#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1035

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Hero_1035_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DeclarativeUnreal_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1035.Config_103521
// 0x0048 (0x00E0 - 0x0098)
class UConfig_103521 final : public UMarvelAbilityConfig
{
public:
	class FName                                   ActivateTentaclePreName;                           // 0x0098(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScopeId;                                           // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceStartSocketName;                              // 0x00A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceEndSocketName;                                // 0x00B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVenomTentacleInfo>             TentacleInfos;                                     // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceDelayTime;                                    // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceDebugDraw;                                   // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFramingUpdateTentacles;                           // 0x00DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103521">();
	}
	static class UConfig_103521* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103521>();
	}
};
static_assert(alignof(UConfig_103521) == 0x000008, "Wrong alignment on UConfig_103521");
static_assert(sizeof(UConfig_103521) == 0x0000E0, "Wrong size on UConfig_103521");
static_assert(offsetof(UConfig_103521, ActivateTentaclePreName) == 0x000098, "Member 'UConfig_103521::ActivateTentaclePreName' has a wrong offset!");
static_assert(offsetof(UConfig_103521, ScopeId) == 0x0000A4, "Member 'UConfig_103521::ScopeId' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceStartSocketName) == 0x0000A8, "Member 'UConfig_103521::TraceStartSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceEndSocketName) == 0x0000B4, "Member 'UConfig_103521::TraceEndSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceDistance) == 0x0000C0, "Member 'UConfig_103521::TraceDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TentacleInfos) == 0x0000C8, "Member 'UConfig_103521::TentacleInfos' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceDelayTime) == 0x0000D8, "Member 'UConfig_103521::TraceDelayTime' has a wrong offset!");
static_assert(offsetof(UConfig_103521, bTraceDebugDraw) == 0x0000DC, "Member 'UConfig_103521::bTraceDebugDraw' has a wrong offset!");
static_assert(offsetof(UConfig_103521, bFramingUpdateTentacles) == 0x0000DD, "Member 'UConfig_103521::bFramingUpdateTentacles' has a wrong offset!");

// Class Hero_1035.Ability_103521
// 0x0020 (0x2578 - 0x2558)
class UAbility_103521 : public UAbility_108
{
public:
	class UConfig_103521*                         AbilityConfig;                                     // 0x2558(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_WaitBindInput*       InputLeftTask;                                     // 0x2560(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CurrentIndex;                                      // 0x2568(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	void OnPressLeft(float TimeWaited);
	void OnReleaseLeft(float TimeWaited);
	void OnSpawnSuccess(class AActor* SpawnActor, const struct FGameplayAbilityTargetDataHandle& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103521">();
	}
	static class UAbility_103521* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103521>();
	}
};
static_assert(alignof(UAbility_103521) == 0x000008, "Wrong alignment on UAbility_103521");
static_assert(sizeof(UAbility_103521) == 0x002578, "Wrong size on UAbility_103521");
static_assert(offsetof(UAbility_103521, AbilityConfig) == 0x002558, "Member 'UAbility_103521::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103521, InputLeftTask) == 0x002560, "Member 'UAbility_103521::InputLeftTask' has a wrong offset!");
static_assert(offsetof(UAbility_103521, CurrentIndex) == 0x002568, "Member 'UAbility_103521::CurrentIndex' has a wrong offset!");

// Class Hero_1035.TentacleAnimInstance
// 0x0050 (0x0470 - 0x0420)
class UTentacleAnimInstance final : public UAnimInstance
{
public:
	TArray<class UAnimSequence*>                  LoopSequences;                                     // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0428(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneScale;                                         // 0x0440(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0444(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseMT;                                          // 0x0450(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_451[0x7];                                      // 0x0451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LoopSequence;                                      // 0x0458(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckPause;                                       // 0x0460(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0xF];                                      // 0x0461(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TentacleAnimInstance">();
	}
	static class UTentacleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTentacleAnimInstance>();
	}
};
static_assert(alignof(UTentacleAnimInstance) == 0x000010, "Wrong alignment on UTentacleAnimInstance");
static_assert(sizeof(UTentacleAnimInstance) == 0x000470, "Wrong size on UTentacleAnimInstance");
static_assert(offsetof(UTentacleAnimInstance, LoopSequences) == 0x000418, "Member 'UTentacleAnimInstance::LoopSequences' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, TargetLocation) == 0x000428, "Member 'UTentacleAnimInstance::TargetLocation' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, BoneScale) == 0x000440, "Member 'UTentacleAnimInstance::BoneScale' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, BoneName) == 0x000444, "Member 'UTentacleAnimInstance::BoneName' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, bPauseMT) == 0x000450, "Member 'UTentacleAnimInstance::bPauseMT' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, LoopSequence) == 0x000458, "Member 'UTentacleAnimInstance::LoopSequence' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, bCheckPause) == 0x000460, "Member 'UTentacleAnimInstance::bCheckPause' has a wrong offset!");

// Class Hero_1035.Scope_10352101
// 0x01B0 (0x1870 - 0x16C0)
class AScope_10352101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	int32                                         ScopeIndex;                                        // 0x16C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C4[0x4];                                     // 0x16C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ClientTraceResult;                                 // 0x16C8(0x0160)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     TracedResults;                                     // 0x1828(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UConfig_103521*                         AbilityConfig;                                     // 0x1838(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1840[0x30];                                    // 0x1840(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeactivateTentacle(int32 TentacleID);
	void ServerSetTraceResult(const struct FHitResult& InTraceResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10352101">();
	}
	static class AScope_10352101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10352101>();
	}
};
static_assert(alignof(AScope_10352101) == 0x000010, "Wrong alignment on AScope_10352101");
static_assert(sizeof(AScope_10352101) == 0x001870, "Wrong size on AScope_10352101");
static_assert(offsetof(AScope_10352101, ScopeIndex) == 0x0016C0, "Member 'AScope_10352101::ScopeIndex' has a wrong offset!");
static_assert(offsetof(AScope_10352101, ClientTraceResult) == 0x0016C8, "Member 'AScope_10352101::ClientTraceResult' has a wrong offset!");
static_assert(offsetof(AScope_10352101, TracedResults) == 0x001828, "Member 'AScope_10352101::TracedResults' has a wrong offset!");
static_assert(offsetof(AScope_10352101, AbilityConfig) == 0x001838, "Member 'AScope_10352101::AbilityConfig' has a wrong offset!");

// Class Hero_1035.MarvelGameplay_SphereTraceType_10352101
// 0x0000 (0x0030 - 0x0030)
class UMarvelGameplay_SphereTraceType_10352101 final : public UMarvelGameplay_SphereTraceType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelGameplay_SphereTraceType_10352101">();
	}
	static class UMarvelGameplay_SphereTraceType_10352101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelGameplay_SphereTraceType_10352101>();
	}
};
static_assert(alignof(UMarvelGameplay_SphereTraceType_10352101) == 0x000008, "Wrong alignment on UMarvelGameplay_SphereTraceType_10352101");
static_assert(sizeof(UMarvelGameplay_SphereTraceType_10352101) == 0x000030, "Wrong size on UMarvelGameplay_SphereTraceType_10352101");

// Class Hero_1035.TraceComponent_10352101
// 0x0020 (0x16D0 - 0x16B0)
class UTraceComponent_10352101 final : public UMarvelAgentTraceComponent
{
public:
	uint8                                         Pad_16A8[0x28];                                    // 0x16A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10352101">();
	}
	static class UTraceComponent_10352101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10352101>();
	}
};
static_assert(alignof(UTraceComponent_10352101) == 0x000010, "Wrong alignment on UTraceComponent_10352101");
static_assert(sizeof(UTraceComponent_10352101) == 0x0016D0, "Wrong size on UTraceComponent_10352101");

// Class Hero_1035.Config_103531
// 0x1B88 (0x1C20 - 0x0098)
class UConfig_103531 final : public UMarvelAbilityConfig
{
public:
	bool                                          bLandedGroundIsWalkable;                           // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumDegreesBetweenDown;                         // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimalDistanceToGround;                           // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToRestrictGroundNormal;                    // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidAngle;                                        // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockTags;                                         // 0x00B0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceAimContext;                                   // 0x0120(0x0F30)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDashAbilityInfo                       DashInfo;                                          // 0x1050(0x0B70)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DashCueTag;                                        // 0x1BC0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CameraCueTag;                                      // 0x1BCC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           IndicateCueTag;                                    // 0x1BD8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AddCueTag;                                         // 0x1BE4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RemoveCueTag;                                      // 0x1BF0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StartCameraInterpTag;                              // 0x1BFC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EndCameraInterpTag;                                // 0x1C08(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C14[0xC];                                     // 0x1C14(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103531">();
	}
	static class UConfig_103531* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103531>();
	}
};
static_assert(alignof(UConfig_103531) == 0x000010, "Wrong alignment on UConfig_103531");
static_assert(sizeof(UConfig_103531) == 0x001C20, "Wrong size on UConfig_103531");
static_assert(offsetof(UConfig_103531, bLandedGroundIsWalkable) == 0x000098, "Member 'UConfig_103531::bLandedGroundIsWalkable' has a wrong offset!");
static_assert(offsetof(UConfig_103531, MaximumDegreesBetweenDown) == 0x00009C, "Member 'UConfig_103531::MaximumDegreesBetweenDown' has a wrong offset!");
static_assert(offsetof(UConfig_103531, MinimalDistanceToGround) == 0x0000A0, "Member 'UConfig_103531::MinimalDistanceToGround' has a wrong offset!");
static_assert(offsetof(UConfig_103531, DistanceToRestrictGroundNormal) == 0x0000A4, "Member 'UConfig_103531::DistanceToRestrictGroundNormal' has a wrong offset!");
static_assert(offsetof(UConfig_103531, ValidAngle) == 0x0000A8, "Member 'UConfig_103531::ValidAngle' has a wrong offset!");
static_assert(offsetof(UConfig_103531, BuffID) == 0x0000AC, "Member 'UConfig_103531::BuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103531, BlockTags) == 0x0000B0, "Member 'UConfig_103531::BlockTags' has a wrong offset!");
static_assert(offsetof(UConfig_103531, TraceAimContext) == 0x000120, "Member 'UConfig_103531::TraceAimContext' has a wrong offset!");
static_assert(offsetof(UConfig_103531, DashInfo) == 0x001050, "Member 'UConfig_103531::DashInfo' has a wrong offset!");
static_assert(offsetof(UConfig_103531, DashCueTag) == 0x001BC0, "Member 'UConfig_103531::DashCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, CameraCueTag) == 0x001BCC, "Member 'UConfig_103531::CameraCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, IndicateCueTag) == 0x001BD8, "Member 'UConfig_103531::IndicateCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, AddCueTag) == 0x001BE4, "Member 'UConfig_103531::AddCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, RemoveCueTag) == 0x001BF0, "Member 'UConfig_103531::RemoveCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, StartCameraInterpTag) == 0x001BFC, "Member 'UConfig_103531::StartCameraInterpTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, EndCameraInterpTag) == 0x001C08, "Member 'UConfig_103531::EndCameraInterpTag' has a wrong offset!");

// Class Hero_1035.Ability_103531
// 0x0478 (0x29C8 - 0x2550)
class UAbility_103531 : public UMarvelGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             CanActivateDelegate;                               // 0x2550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bIsDashing;                                        // 0x2560(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2561[0x7];                                     // 0x2561(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashAimLocation;                                   // 0x2568(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DashAimRotation;                                   // 0x2580(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDashStateChanged;                                // 0x2598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UConfig_103531*                         Config;                                            // 0x25A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   MBCOwner;                                          // 0x25B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_Dash*                DashTask;                                          // 0x25B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* PlayMontageTask;                                   // 0x25C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         AddEffectPredictionKey;                            // 0x25C8(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         RemoveEffectPredictionKey;                         // 0x2668(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         CameraInterpPredictionKey;                         // 0x2708(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         RemoveCameraInterpPredictionKey;                   // 0x27A8(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2848[0x180];                                   // 0x2848(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Explode(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnDashFinish(EDashStopReason Reason);
	void OnRep_IsDashing();
	void PlayMontage(int32 MontageIndex);
	bool TraceGround();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103531">();
	}
	static class UAbility_103531* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103531>();
	}
};
static_assert(alignof(UAbility_103531) == 0x000008, "Wrong alignment on UAbility_103531");
static_assert(sizeof(UAbility_103531) == 0x0029C8, "Wrong size on UAbility_103531");
static_assert(offsetof(UAbility_103531, CanActivateDelegate) == 0x002550, "Member 'UAbility_103531::CanActivateDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_103531, bIsDashing) == 0x002560, "Member 'UAbility_103531::bIsDashing' has a wrong offset!");
static_assert(offsetof(UAbility_103531, DashAimLocation) == 0x002568, "Member 'UAbility_103531::DashAimLocation' has a wrong offset!");
static_assert(offsetof(UAbility_103531, DashAimRotation) == 0x002580, "Member 'UAbility_103531::DashAimRotation' has a wrong offset!");
static_assert(offsetof(UAbility_103531, OnDashStateChanged) == 0x002598, "Member 'UAbility_103531::OnDashStateChanged' has a wrong offset!");
static_assert(offsetof(UAbility_103531, Config) == 0x0025A8, "Member 'UAbility_103531::Config' has a wrong offset!");
static_assert(offsetof(UAbility_103531, MBCOwner) == 0x0025B0, "Member 'UAbility_103531::MBCOwner' has a wrong offset!");
static_assert(offsetof(UAbility_103531, DashTask) == 0x0025B8, "Member 'UAbility_103531::DashTask' has a wrong offset!");
static_assert(offsetof(UAbility_103531, PlayMontageTask) == 0x0025C0, "Member 'UAbility_103531::PlayMontageTask' has a wrong offset!");
static_assert(offsetof(UAbility_103531, AddEffectPredictionKey) == 0x0025C8, "Member 'UAbility_103531::AddEffectPredictionKey' has a wrong offset!");
static_assert(offsetof(UAbility_103531, RemoveEffectPredictionKey) == 0x002668, "Member 'UAbility_103531::RemoveEffectPredictionKey' has a wrong offset!");
static_assert(offsetof(UAbility_103531, CameraInterpPredictionKey) == 0x002708, "Member 'UAbility_103531::CameraInterpPredictionKey' has a wrong offset!");
static_assert(offsetof(UAbility_103531, RemoveCameraInterpPredictionKey) == 0x0027A8, "Member 'UAbility_103531::RemoveCameraInterpPredictionKey' has a wrong offset!");

// Class Hero_1035.Cue_Ability_Loop_10353102
// 0x0030 (0x0E30 - 0x0E00)
class ACue_Ability_Loop_10353102 final : public AMarvelCueNotify_Ability
{
public:
	class UNiagaraComponent*                      NS_Loop;                                           // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityID;                                         // 0x0E08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0C[0x4];                                      // 0x0E0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x0E10(0x0010)(Transient, NativeAccessSpecifierPublic)
	class UAbility_103531*                        Ability;                                           // 0x0E20(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E28[0x8];                                      // 0x0E28(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityCanActivateChanged(bool bCanActivate);
	void OnDashStateChanged(bool bIsDashing);
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10353102">();
	}
	static class ACue_Ability_Loop_10353102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10353102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10353102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10353102");
static_assert(sizeof(ACue_Ability_Loop_10353102) == 0x000E30, "Wrong size on ACue_Ability_Loop_10353102");
static_assert(offsetof(ACue_Ability_Loop_10353102, NS_Loop) == 0x000E00, "Member 'ACue_Ability_Loop_10353102::NS_Loop' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10353102, AbilityID) == 0x000E08, "Member 'ACue_Ability_Loop_10353102::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10353102, DeclarePlayerViewSideHolder) == 0x000E10, "Member 'ACue_Ability_Loop_10353102::DeclarePlayerViewSideHolder' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10353102, Ability) == 0x000E20, "Member 'ACue_Ability_Loop_10353102::Ability' has a wrong offset!");

// Class Hero_1035.Config_103541
// 0x0FA8 (0x1040 - 0x0098)
class UConfig_103541 final : public UMarvelAbilityConfig
{
public:
	int32                                         ScopeId;                                           // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00A0(0x0F30)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         LinkTime;                                          // 0x0FD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x0FD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CancelEffectTags;                                  // 0x0FD8(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103541">();
	}
	static class UConfig_103541* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103541>();
	}
};
static_assert(alignof(UConfig_103541) == 0x000010, "Wrong alignment on UConfig_103541");
static_assert(sizeof(UConfig_103541) == 0x001040, "Wrong size on UConfig_103541");
static_assert(offsetof(UConfig_103541, ScopeId) == 0x000098, "Member 'UConfig_103541::ScopeId' has a wrong offset!");
static_assert(offsetof(UConfig_103541, TraceContext) == 0x0000A0, "Member 'UConfig_103541::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103541, LinkTime) == 0x000FD0, "Member 'UConfig_103541::LinkTime' has a wrong offset!");
static_assert(offsetof(UConfig_103541, Distance) == 0x000FD4, "Member 'UConfig_103541::Distance' has a wrong offset!");
static_assert(offsetof(UConfig_103541, CancelEffectTags) == 0x000FD8, "Member 'UConfig_103541::CancelEffectTags' has a wrong offset!");

// Class Hero_1035.Ability_103541
// 0x0040 (0x2590 - 0x2550)
class UAbility_103541 : public UMarvelGameplayAbility
{
public:
	TArray<struct FHitResult>                     HitResults;                                        // 0x2550(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          TLHasFinished;                                     // 0x2560(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2561[0x3];                                     // 0x2561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x2564(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2568[0x8];                                     // 0x2568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           Timer;                                             // 0x2570(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2588[0x8];                                     // 0x2588(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecordLog();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103541">();
	}
	static class UAbility_103541* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103541>();
	}
};
static_assert(alignof(UAbility_103541) == 0x000008, "Wrong alignment on UAbility_103541");
static_assert(sizeof(UAbility_103541) == 0x002590, "Wrong size on UAbility_103541");
static_assert(offsetof(UAbility_103541, HitResults) == 0x002550, "Member 'UAbility_103541::HitResults' has a wrong offset!");
static_assert(offsetof(UAbility_103541, TLHasFinished) == 0x002560, "Member 'UAbility_103541::TLHasFinished' has a wrong offset!");
static_assert(offsetof(UAbility_103541, Duration) == 0x002564, "Member 'UAbility_103541::Duration' has a wrong offset!");
static_assert(offsetof(UAbility_103541, Timer) == 0x002570, "Member 'UAbility_103541::Timer' has a wrong offset!");

// Class Hero_1035.EffectiveComponent_10354101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10354101 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10354101">();
	}
	static class UEffectiveComponent_10354101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10354101>();
	}
};
static_assert(alignof(UEffectiveComponent_10354101) == 0x000010, "Wrong alignment on UEffectiveComponent_10354101");
static_assert(sizeof(UEffectiveComponent_10354101) == 0x001C00, "Wrong size on UEffectiveComponent_10354101");

// Class Hero_1035.Cue_Buff_10354101
// 0x0560 (0x1548 - 0x0FE8)
class ACue_Buff_10354101 final : public AMarvelCueNotify_Buff
{
public:
	class FName                                   SetLengthName;                                     // 0x0FE8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaxDistanceName;                                   // 0x0FF4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x1000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceScale;                                     // 0x1004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceLerpSpeed;                                 // 0x1008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SplitCenterScaleParam;                             // 0x100C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SplitCenterScaleCurve;                             // 0x1018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBoundsScale;                                   // 0x1020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurDistanceBias;                                   // 0x1024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrowAnimName;                                      // 0x1028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrowNoiseIntensityName;                            // 0x1034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowAnimMax;                                       // 0x1040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1044[0x4];                                     // 0x1044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            GrowAnimValueCurve;                                // 0x1048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GrowNoiseIntensityCurve;                           // 0x1050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherGrowCurves;                                   // 0x1058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         GrowMinR;                                          // 0x10A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowAnimTime;                                      // 0x10AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MinRName;                                          // 0x10B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10BC[0x4];                                     // 0x10BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RecoveryMinRCurve;                                 // 0x10C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherOutOfRangeCurves;                             // 0x10C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherExpiredCurves;                                // 0x1118(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherBlockedCurves;                                // 0x1168(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ForceRecycleTags;                                  // 0x11B8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         RecoverySpeed;                                     // 0x1220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryAnimValue;                                 // 0x1224(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryAnimTime;                                  // 0x1228(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HasObstacleName;                                   // 0x122C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObstacleSplitName;                                 // 0x1238(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObstacleSplitRateName;                             // 0x1244(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitSpeed;                                        // 0x1250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1254[0x4];                                     // 0x1254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         SplitFXAsset;                                      // 0x1258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         TransientFXAsset;                                  // 0x1260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         TargetTransientFXAsset;                            // 0x1268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpValue;                                         // 0x1270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x1274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfRangeLerpSpeed;                               // 0x1278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDelayTime;                                   // 0x127C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpiredDelayTime;                                  // 0x1280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfRangeDelayTime;                               // 0x1284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockedDelayTime;                                  // 0x1288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTransientFXDistance;                            // 0x128C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SymbioteStateOffset;                               // 0x1290(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkeletalMeshName;                                  // 0x12A8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsStartName;                                   // 0x12B4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsEndName;                                     // 0x12C0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetTransientSizeName;                           // 0x12CC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         RestrictFX;                                        // 0x12D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RestrictGrowName;                                  // 0x12E0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12EC[0x4];                                     // 0x12EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RestrictGrowCurve;                                 // 0x12F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RestrictScaleName;                                 // 0x12F8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1304[0x4];                                     // 0x1304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RestrictScaleCurve;                                // 0x1308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ExpiredRestrictScaleCurve;                         // 0x1310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestrictFXDelayTime;                               // 0x1318(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131C[0x4];                                     // 0x131C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         ExpiredHitFX;                                      // 0x1320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TentacleLoopAudioID;                               // 0x1328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuccessAudioID;                                    // 0x132C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailAudioID;                                       // 0x1330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RTPCName;                                          // 0x1334(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOneShotAudioActor*                     TentacleAudioActor;                                // 0x1340(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TransientFXComponent;                              // 0x1348(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TargetTransientFXComponent;                        // 0x1350(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      RestrictFXComponent;                               // 0x1358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransientFXCurrentLerpValue;                       // 0x1360(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTransientFXCurrentLerpValue;                 // 0x1364(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransientDelayRecycleTime;                         // 0x1368(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTransientDelayRecycleTime;                   // 0x136C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x1370(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestrictRecoveryTime;                              // 0x1374(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SplitLocation;                                     // 0x1378(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CacheOwnerLocation;                                // 0x1390(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitPercent;                                      // 0x13A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13AC[0x4];                                     // 0x13AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ObstacleInfo;                                      // 0x13B0(0x0160)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1510[0x4];                                     // 0x1510(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x1514(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x1518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103541*                         AbilityConfig;                                     // 0x1520(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             OwnerCharacter;                                    // 0x1528(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVenomCharacter*                        InstigatorCharacter;                               // 0x1530(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 TickIntervalsOfEachLOD;                            // 0x1538(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void OnInstigatorCharacterEndPlay();
	void OnSymbioteStateChanged(bool InSymbioteState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10354101">();
	}
	static class ACue_Buff_10354101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10354101>();
	}
};
static_assert(alignof(ACue_Buff_10354101) == 0x000008, "Wrong alignment on ACue_Buff_10354101");
static_assert(sizeof(ACue_Buff_10354101) == 0x001548, "Wrong size on ACue_Buff_10354101");
static_assert(offsetof(ACue_Buff_10354101, SetLengthName) == 0x000FE8, "Member 'ACue_Buff_10354101::SetLengthName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MaxDistanceName) == 0x000FF4, "Member 'ACue_Buff_10354101::MaxDistanceName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MaxDistance) == 0x001000, "Member 'ACue_Buff_10354101::MaxDistance' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, DistanceScale) == 0x001004, "Member 'ACue_Buff_10354101::DistanceScale' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, DistanceLerpSpeed) == 0x001008, "Member 'ACue_Buff_10354101::DistanceLerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitCenterScaleParam) == 0x00100C, "Member 'ACue_Buff_10354101::SplitCenterScaleParam' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitCenterScaleCurve) == 0x001018, "Member 'ACue_Buff_10354101::SplitCenterScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MeshBoundsScale) == 0x001020, "Member 'ACue_Buff_10354101::MeshBoundsScale' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, CurDistanceBias) == 0x001024, "Member 'ACue_Buff_10354101::CurDistanceBias' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimName) == 0x001028, "Member 'ACue_Buff_10354101::GrowAnimName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowNoiseIntensityName) == 0x001034, "Member 'ACue_Buff_10354101::GrowNoiseIntensityName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimMax) == 0x001040, "Member 'ACue_Buff_10354101::GrowAnimMax' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimValueCurve) == 0x001048, "Member 'ACue_Buff_10354101::GrowAnimValueCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowNoiseIntensityCurve) == 0x001050, "Member 'ACue_Buff_10354101::GrowNoiseIntensityCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherGrowCurves) == 0x001058, "Member 'ACue_Buff_10354101::OtherGrowCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowMinR) == 0x0010A8, "Member 'ACue_Buff_10354101::GrowMinR' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimTime) == 0x0010AC, "Member 'ACue_Buff_10354101::GrowAnimTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MinRName) == 0x0010B0, "Member 'ACue_Buff_10354101::MinRName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoveryMinRCurve) == 0x0010C0, "Member 'ACue_Buff_10354101::RecoveryMinRCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherOutOfRangeCurves) == 0x0010C8, "Member 'ACue_Buff_10354101::OtherOutOfRangeCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherExpiredCurves) == 0x001118, "Member 'ACue_Buff_10354101::OtherExpiredCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherBlockedCurves) == 0x001168, "Member 'ACue_Buff_10354101::OtherBlockedCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ForceRecycleTags) == 0x0011B8, "Member 'ACue_Buff_10354101::ForceRecycleTags' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoverySpeed) == 0x001220, "Member 'ACue_Buff_10354101::RecoverySpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoveryAnimValue) == 0x001224, "Member 'ACue_Buff_10354101::RecoveryAnimValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoveryAnimTime) == 0x001228, "Member 'ACue_Buff_10354101::RecoveryAnimTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, HasObstacleName) == 0x00122C, "Member 'ACue_Buff_10354101::HasObstacleName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ObstacleSplitName) == 0x001238, "Member 'ACue_Buff_10354101::ObstacleSplitName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ObstacleSplitRateName) == 0x001244, "Member 'ACue_Buff_10354101::ObstacleSplitRateName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitSpeed) == 0x001250, "Member 'ACue_Buff_10354101::SplitSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitFXAsset) == 0x001258, "Member 'ACue_Buff_10354101::SplitFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientFXAsset) == 0x001260, "Member 'ACue_Buff_10354101::TransientFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientFXAsset) == 0x001268, "Member 'ACue_Buff_10354101::TargetTransientFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, LerpValue) == 0x001270, "Member 'ACue_Buff_10354101::LerpValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, LerpSpeed) == 0x001274, "Member 'ACue_Buff_10354101::LerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OutOfRangeLerpSpeed) == 0x001278, "Member 'ACue_Buff_10354101::OutOfRangeLerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetDelayTime) == 0x00127C, "Member 'ACue_Buff_10354101::TargetDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ExpiredDelayTime) == 0x001280, "Member 'ACue_Buff_10354101::ExpiredDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OutOfRangeDelayTime) == 0x001284, "Member 'ACue_Buff_10354101::OutOfRangeDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, BlockedDelayTime) == 0x001288, "Member 'ACue_Buff_10354101::BlockedDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MaxTransientFXDistance) == 0x00128C, "Member 'ACue_Buff_10354101::MaxTransientFXDistance' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SymbioteStateOffset) == 0x001290, "Member 'ACue_Buff_10354101::SymbioteStateOffset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SkeletalMeshName) == 0x0012A8, "Member 'ACue_Buff_10354101::SkeletalMeshName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, PointsStartName) == 0x0012B4, "Member 'ACue_Buff_10354101::PointsStartName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, PointsEndName) == 0x0012C0, "Member 'ACue_Buff_10354101::PointsEndName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientSizeName) == 0x0012CC, "Member 'ACue_Buff_10354101::TargetTransientSizeName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictFX) == 0x0012D8, "Member 'ACue_Buff_10354101::RestrictFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictGrowName) == 0x0012E0, "Member 'ACue_Buff_10354101::RestrictGrowName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictGrowCurve) == 0x0012F0, "Member 'ACue_Buff_10354101::RestrictGrowCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictScaleName) == 0x0012F8, "Member 'ACue_Buff_10354101::RestrictScaleName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictScaleCurve) == 0x001308, "Member 'ACue_Buff_10354101::RestrictScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ExpiredRestrictScaleCurve) == 0x001310, "Member 'ACue_Buff_10354101::ExpiredRestrictScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictFXDelayTime) == 0x001318, "Member 'ACue_Buff_10354101::RestrictFXDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ExpiredHitFX) == 0x001320, "Member 'ACue_Buff_10354101::ExpiredHitFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TentacleLoopAudioID) == 0x001328, "Member 'ACue_Buff_10354101::TentacleLoopAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SuccessAudioID) == 0x00132C, "Member 'ACue_Buff_10354101::SuccessAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, FailAudioID) == 0x001330, "Member 'ACue_Buff_10354101::FailAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RTPCName) == 0x001334, "Member 'ACue_Buff_10354101::RTPCName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TentacleAudioActor) == 0x001340, "Member 'ACue_Buff_10354101::TentacleAudioActor' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientFXComponent) == 0x001348, "Member 'ACue_Buff_10354101::TransientFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientFXComponent) == 0x001350, "Member 'ACue_Buff_10354101::TargetTransientFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictFXComponent) == 0x001358, "Member 'ACue_Buff_10354101::RestrictFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientFXCurrentLerpValue) == 0x001360, "Member 'ACue_Buff_10354101::TransientFXCurrentLerpValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientFXCurrentLerpValue) == 0x001364, "Member 'ACue_Buff_10354101::TargetTransientFXCurrentLerpValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientDelayRecycleTime) == 0x001368, "Member 'ACue_Buff_10354101::TransientDelayRecycleTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientDelayRecycleTime) == 0x00136C, "Member 'ACue_Buff_10354101::TargetTransientDelayRecycleTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, CurrentTime) == 0x001370, "Member 'ACue_Buff_10354101::CurrentTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictRecoveryTime) == 0x001374, "Member 'ACue_Buff_10354101::RestrictRecoveryTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitLocation) == 0x001378, "Member 'ACue_Buff_10354101::SplitLocation' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, CacheOwnerLocation) == 0x001390, "Member 'ACue_Buff_10354101::CacheOwnerLocation' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitPercent) == 0x0013A8, "Member 'ACue_Buff_10354101::SplitPercent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ObstacleInfo) == 0x0013B0, "Member 'ACue_Buff_10354101::ObstacleInfo' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, AbilityID) == 0x001514, "Member 'ACue_Buff_10354101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MeshComponent) == 0x001518, "Member 'ACue_Buff_10354101::MeshComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, AbilityConfig) == 0x001520, "Member 'ACue_Buff_10354101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OwnerCharacter) == 0x001528, "Member 'ACue_Buff_10354101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, InstigatorCharacter) == 0x001530, "Member 'ACue_Buff_10354101::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TickIntervalsOfEachLOD) == 0x001538, "Member 'ACue_Buff_10354101::TickIntervalsOfEachLOD' has a wrong offset!");

// Class Hero_1035.Cue_AbilityLoop_103551
// 0x0258 (0x1058 - 0x0E00)
class ACue_AbilityLoop_103551 : public AMarvelCueNotify_Ability
{
public:
	TArray<struct FArmEffectParam>                ArmEffectParams;                                   // 0x0E00(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SetLengthName;                                     // 0x0E10(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaxDistanceName;                                   // 0x0E1C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         GrowCurveMap;                                      // 0x0E28(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      CurveValueMap_WhenHit;                             // 0x0E78(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   MinRName;                                          // 0x0EC8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowMinR;                                          // 0x0ED4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         RecycleCurveMap;                                   // 0x0ED8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   HasObstacleName;                                   // 0x0F28(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F34[0x4];                                      // 0x0F34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         TransientFXAsset;                                  // 0x0F38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpValue;                                         // 0x0F40(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x0F44(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTransientFXDistance;                            // 0x0F48(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsStartName;                                   // 0x0F4C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsEndName;                                     // 0x0F58(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F64[0x4];                                      // 0x0F64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         HitFxAsset;                                        // 0x0F68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFxScaleValue;                                   // 0x0F70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFxMaxLength;                                    // 0x0F74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFxRecycleDuration;                              // 0x0F78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F7C[0x4];                                      // 0x0F7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   TentacleMeshComponent;                             // 0x0F80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0F88(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETentacleState103551                          TentacleState;                                     // 0x0F90(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F91[0x3];                                      // 0x0F91(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartShootTime;                                    // 0x0F94(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartHandReleaseTime;                              // 0x0F98(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9C[0x24];                                     // 0x0F9C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiagaraComponent*>              ArmFXComponentArray;                               // 0x0FC0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      TransientFXComponent;                              // 0x0FD0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      HitEffectComponent;                                // 0x0FD8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HitEffectCurrentEndPos;                            // 0x0FE0(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitEffectRecycleSpeed;                             // 0x0FF8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FFC[0x4];                                      // 0x0FFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      TentacleStateMap;                                  // 0x1000(0x0050)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     TentacleMaterial;                                  // 0x1050(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddArmFXComponent(class UNiagaraComponent* StartComp);
	struct FVector GetTargetLocationEXT();
	void K2_OnRecycle();
	void ResetDefault();
	void SetTargetLocation(const struct FVector& InTargetLocation);
	void SetTentacleMaterialParamValue(class FName InName, float InValue);

	void SetTransientFXLerpValue(class UNiagaraComponent* StartComp, const struct FVector& InTargetLocation, float InLerpValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_AbilityLoop_103551">();
	}
	static class ACue_AbilityLoop_103551* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_AbilityLoop_103551>();
	}
};
static_assert(alignof(ACue_AbilityLoop_103551) == 0x000008, "Wrong alignment on ACue_AbilityLoop_103551");
static_assert(sizeof(ACue_AbilityLoop_103551) == 0x001058, "Wrong size on ACue_AbilityLoop_103551");
static_assert(offsetof(ACue_AbilityLoop_103551, ArmEffectParams) == 0x000E00, "Member 'ACue_AbilityLoop_103551::ArmEffectParams' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, SetLengthName) == 0x000E10, "Member 'ACue_AbilityLoop_103551::SetLengthName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, MaxDistanceName) == 0x000E1C, "Member 'ACue_AbilityLoop_103551::MaxDistanceName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, GrowCurveMap) == 0x000E28, "Member 'ACue_AbilityLoop_103551::GrowCurveMap' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, CurveValueMap_WhenHit) == 0x000E78, "Member 'ACue_AbilityLoop_103551::CurveValueMap_WhenHit' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, MinRName) == 0x000EC8, "Member 'ACue_AbilityLoop_103551::MinRName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, GrowMinR) == 0x000ED4, "Member 'ACue_AbilityLoop_103551::GrowMinR' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, RecycleCurveMap) == 0x000ED8, "Member 'ACue_AbilityLoop_103551::RecycleCurveMap' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HasObstacleName) == 0x000F28, "Member 'ACue_AbilityLoop_103551::HasObstacleName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TransientFXAsset) == 0x000F38, "Member 'ACue_AbilityLoop_103551::TransientFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, LerpValue) == 0x000F40, "Member 'ACue_AbilityLoop_103551::LerpValue' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, LerpSpeed) == 0x000F44, "Member 'ACue_AbilityLoop_103551::LerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, MaxTransientFXDistance) == 0x000F48, "Member 'ACue_AbilityLoop_103551::MaxTransientFXDistance' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, PointsStartName) == 0x000F4C, "Member 'ACue_AbilityLoop_103551::PointsStartName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, PointsEndName) == 0x000F58, "Member 'ACue_AbilityLoop_103551::PointsEndName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxAsset) == 0x000F68, "Member 'ACue_AbilityLoop_103551::HitFxAsset' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxScaleValue) == 0x000F70, "Member 'ACue_AbilityLoop_103551::HitFxScaleValue' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxMaxLength) == 0x000F74, "Member 'ACue_AbilityLoop_103551::HitFxMaxLength' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxRecycleDuration) == 0x000F78, "Member 'ACue_AbilityLoop_103551::HitFxRecycleDuration' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleMeshComponent) == 0x000F80, "Member 'ACue_AbilityLoop_103551::TentacleMeshComponent' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, OwnerCharacter) == 0x000F88, "Member 'ACue_AbilityLoop_103551::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleState) == 0x000F90, "Member 'ACue_AbilityLoop_103551::TentacleState' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, StartShootTime) == 0x000F94, "Member 'ACue_AbilityLoop_103551::StartShootTime' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, StartHandReleaseTime) == 0x000F98, "Member 'ACue_AbilityLoop_103551::StartHandReleaseTime' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, ArmFXComponentArray) == 0x000FC0, "Member 'ACue_AbilityLoop_103551::ArmFXComponentArray' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TransientFXComponent) == 0x000FD0, "Member 'ACue_AbilityLoop_103551::TransientFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitEffectComponent) == 0x000FD8, "Member 'ACue_AbilityLoop_103551::HitEffectComponent' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitEffectCurrentEndPos) == 0x000FE0, "Member 'ACue_AbilityLoop_103551::HitEffectCurrentEndPos' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitEffectRecycleSpeed) == 0x000FF8, "Member 'ACue_AbilityLoop_103551::HitEffectRecycleSpeed' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleStateMap) == 0x001000, "Member 'ACue_AbilityLoop_103551::TentacleStateMap' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleMaterial) == 0x001050, "Member 'ACue_AbilityLoop_103551::TentacleMaterial' has a wrong offset!");

// Class Hero_1035.Cue_Buff_10356101
// 0x00D8 (0x10C0 - 0x0FE8)
class ACue_Buff_10356101 final : public AMarvelCueNotify_Buff
{
public:
	class UNiagaraComponent*                      NS_Buff;                                           // 0x0FE8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideName;                                          // 0x0FF0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideSpeed;                                         // 0x0FFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x1000(0x0068)(Edit, NativeAccessSpecifierPublic)
	class FName                                   DissolveName;                                      // 0x1068(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1074[0x4];                                     // 0x1074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DissolveCurve;                                     // 0x1078(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SymbiontOpenParameterName;                         // 0x1080(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SymbiontIntensityParameterName;                    // 0x108C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StartSymbiontCurve;                                // 0x1098(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EndSymbiontCurve;                                  // 0x10A0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         RecycleFXAsset;                                    // 0x10A8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B0[0x10];                                    // 0x10B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10356101">();
	}
	static class ACue_Buff_10356101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10356101>();
	}
};
static_assert(alignof(ACue_Buff_10356101) == 0x000008, "Wrong alignment on ACue_Buff_10356101");
static_assert(sizeof(ACue_Buff_10356101) == 0x0010C0, "Wrong size on ACue_Buff_10356101");
static_assert(offsetof(ACue_Buff_10356101, NS_Buff) == 0x000FE8, "Member 'ACue_Buff_10356101::NS_Buff' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, HideName) == 0x000FF0, "Member 'ACue_Buff_10356101::HideName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, HideSpeed) == 0x000FFC, "Member 'ACue_Buff_10356101::HideSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, AbilityTags) == 0x001000, "Member 'ACue_Buff_10356101::AbilityTags' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, DissolveName) == 0x001068, "Member 'ACue_Buff_10356101::DissolveName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, DissolveCurve) == 0x001078, "Member 'ACue_Buff_10356101::DissolveCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, SymbiontOpenParameterName) == 0x001080, "Member 'ACue_Buff_10356101::SymbiontOpenParameterName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, SymbiontIntensityParameterName) == 0x00108C, "Member 'ACue_Buff_10356101::SymbiontIntensityParameterName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, StartSymbiontCurve) == 0x001098, "Member 'ACue_Buff_10356101::StartSymbiontCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, EndSymbiontCurve) == 0x0010A0, "Member 'ACue_Buff_10356101::EndSymbiontCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, RecycleFXAsset) == 0x0010A8, "Member 'ACue_Buff_10356101::RecycleFXAsset' has a wrong offset!");

// Class Hero_1035.Config_103571
// 0x0140 (0x01D8 - 0x0098)
class UConfig_103571 final : public UMarvelAbilityConfig
{
public:
	float                                         ApplyDamageToShieldRatio;                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ApplyDamageToShieldTags;                           // 0x00A0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         ScopeId;                                           // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScopeRadius;                                    // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScopeRadius;                                    // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScopeSpreadDuration;                               // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDragScope;                                  // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DragScopeID;                                       // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableKnockUpScope;                               // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KnockUpScopeID;                                    // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustedCapsuleRadius;                             // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustedCapsuleHalfHeight;                         // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NotTreatShieldBuffID;                              // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SymbioteTag;                                       // 0x0134(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ForceUpdateBoneTag;                                // 0x0140(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpGravityScale;                                  // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZVelocity;                                     // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevouringDuration;                                 // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDelayTime;                                    // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DevouringBlockTags;                                // 0x0160(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         DevouringInvincibleBuffID;                         // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncreaseSpeedBuffID;                               // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevouringOffset;                                   // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103571">();
	}
	static class UConfig_103571* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103571>();
	}
};
static_assert(alignof(UConfig_103571) == 0x000008, "Wrong alignment on UConfig_103571");
static_assert(sizeof(UConfig_103571) == 0x0001D8, "Wrong size on UConfig_103571");
static_assert(offsetof(UConfig_103571, ApplyDamageToShieldRatio) == 0x000098, "Member 'UConfig_103571::ApplyDamageToShieldRatio' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ApplyDamageToShieldTags) == 0x0000A0, "Member 'UConfig_103571::ApplyDamageToShieldTags' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ScopeId) == 0x000108, "Member 'UConfig_103571::ScopeId' has a wrong offset!");
static_assert(offsetof(UConfig_103571, MinScopeRadius) == 0x00010C, "Member 'UConfig_103571::MinScopeRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103571, MaxScopeRadius) == 0x000110, "Member 'UConfig_103571::MaxScopeRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ScopeSpreadDuration) == 0x000114, "Member 'UConfig_103571::ScopeSpreadDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103571, bEnableDragScope) == 0x000118, "Member 'UConfig_103571::bEnableDragScope' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DragScopeID) == 0x00011C, "Member 'UConfig_103571::DragScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, bEnableKnockUpScope) == 0x000120, "Member 'UConfig_103571::bEnableKnockUpScope' has a wrong offset!");
static_assert(offsetof(UConfig_103571, KnockUpScopeID) == 0x000124, "Member 'UConfig_103571::KnockUpScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, AdjustedCapsuleRadius) == 0x000128, "Member 'UConfig_103571::AdjustedCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103571, AdjustedCapsuleHalfHeight) == 0x00012C, "Member 'UConfig_103571::AdjustedCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UConfig_103571, NotTreatShieldBuffID) == 0x000130, "Member 'UConfig_103571::NotTreatShieldBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, SymbioteTag) == 0x000134, "Member 'UConfig_103571::SymbioteTag' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ForceUpdateBoneTag) == 0x000140, "Member 'UConfig_103571::ForceUpdateBoneTag' has a wrong offset!");
static_assert(offsetof(UConfig_103571, JumpGravityScale) == 0x00014C, "Member 'UConfig_103571::JumpGravityScale' has a wrong offset!");
static_assert(offsetof(UConfig_103571, JumpZVelocity) == 0x000150, "Member 'UConfig_103571::JumpZVelocity' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringDuration) == 0x000154, "Member 'UConfig_103571::DevouringDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103571, TraceDelayTime) == 0x000158, "Member 'UConfig_103571::TraceDelayTime' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringBlockTags) == 0x000160, "Member 'UConfig_103571::DevouringBlockTags' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringInvincibleBuffID) == 0x0001C8, "Member 'UConfig_103571::DevouringInvincibleBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, IncreaseSpeedBuffID) == 0x0001CC, "Member 'UConfig_103571::IncreaseSpeedBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringOffset) == 0x0001D0, "Member 'UConfig_103571::DevouringOffset' has a wrong offset!");

// Class Hero_1035.Ability_103571
// 0x0000 (0x2550 - 0x2550)
class UAbility_103571 : public UMarvelGameplayAbility
{
public:
	void ChangeGravity(float InGravityScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103571">();
	}
	static class UAbility_103571* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103571>();
	}
};
static_assert(alignof(UAbility_103571) == 0x000008, "Wrong alignment on UAbility_103571");
static_assert(sizeof(UAbility_103571) == 0x002550, "Wrong size on UAbility_103571");

// Class Hero_1035.Scope_10357101
// 0x0070 (0x1730 - 0x16C0)
class AScope_10357101 : public AMarvelAbilityTargetActor_Scope
{
public:
	float                                         ScopeRadius;                                       // 0x16C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESymbiontScopeState                           ScopeState;                                        // 0x16C4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C5[0x3];                                     // 0x16C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetRotator;                                     // 0x16C8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartDevourDelegate;                               // 0x16E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StopDevourDelegate;                                // 0x16F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UConfig_103571*                         AbilityConfig;                                     // 0x1700(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1708[0x28];                                    // 0x1708(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DevourTrace();
	void OnRep_ScopeRadius();
	void OnRep_ScopeState();
	void SetScopeRadius(float InRadius);
	void SetScopeState(ESymbiontScopeState InScopeState);
	void StartDevour();
	void StartSpread();
	void StopDevour();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10357101">();
	}
	static class AScope_10357101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10357101>();
	}
};
static_assert(alignof(AScope_10357101) == 0x000010, "Wrong alignment on AScope_10357101");
static_assert(sizeof(AScope_10357101) == 0x001730, "Wrong size on AScope_10357101");
static_assert(offsetof(AScope_10357101, ScopeRadius) == 0x0016C0, "Member 'AScope_10357101::ScopeRadius' has a wrong offset!");
static_assert(offsetof(AScope_10357101, ScopeState) == 0x0016C4, "Member 'AScope_10357101::ScopeState' has a wrong offset!");
static_assert(offsetof(AScope_10357101, TargetRotator) == 0x0016C8, "Member 'AScope_10357101::TargetRotator' has a wrong offset!");
static_assert(offsetof(AScope_10357101, StartDevourDelegate) == 0x0016E0, "Member 'AScope_10357101::StartDevourDelegate' has a wrong offset!");
static_assert(offsetof(AScope_10357101, StopDevourDelegate) == 0x0016F0, "Member 'AScope_10357101::StopDevourDelegate' has a wrong offset!");
static_assert(offsetof(AScope_10357101, AbilityConfig) == 0x001700, "Member 'AScope_10357101::AbilityConfig' has a wrong offset!");

// Class Hero_1035.TraceComponent_10357101
// 0x0000 (0x16B0 - 0x16B0)
class UTraceComponent_10357101 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10357101">();
	}
	static class UTraceComponent_10357101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10357101>();
	}
};
static_assert(alignof(UTraceComponent_10357101) == 0x000010, "Wrong alignment on UTraceComponent_10357101");
static_assert(sizeof(UTraceComponent_10357101) == 0x0016B0, "Wrong size on UTraceComponent_10357101");

// Class Hero_1035.TraceComponent_10357102
// 0x0000 (0x16B0 - 0x16B0)
class UTraceComponent_10357102 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10357102">();
	}
	static class UTraceComponent_10357102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10357102>();
	}
};
static_assert(alignof(UTraceComponent_10357102) == 0x000010, "Wrong alignment on UTraceComponent_10357102");
static_assert(sizeof(UTraceComponent_10357102) == 0x0016B0, "Wrong size on UTraceComponent_10357102");

// Class Hero_1035.DragAbility_103571
// 0x0018 (0x1CB8 - 0x1CA0)
class UDragAbility_103571 : public UMarvelDragAbility
{
public:
	struct FVector                                TargetOffset;                                      // 0x1CA0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragAbility_103571">();
	}
	static class UDragAbility_103571* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragAbility_103571>();
	}
};
static_assert(alignof(UDragAbility_103571) == 0x000008, "Wrong alignment on UDragAbility_103571");
static_assert(sizeof(UDragAbility_103571) == 0x001CB8, "Wrong size on UDragAbility_103571");
static_assert(offsetof(UDragAbility_103571, TargetOffset) == 0x001CA0, "Member 'UDragAbility_103571::TargetOffset' has a wrong offset!");

// Class Hero_1035.SymbioteAnimInstance
// 0x0000 (0x0420 - 0x0420)
class USymbioteAnimInstance final : public UAnimInstance
{
public:
	bool                                          bIsRunning;                                        // 0x0418(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SymbioteAnimInstance">();
	}
	static class USymbioteAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USymbioteAnimInstance>();
	}
};
static_assert(alignof(USymbioteAnimInstance) == 0x000010, "Wrong alignment on USymbioteAnimInstance");
static_assert(sizeof(USymbioteAnimInstance) == 0x000420, "Wrong size on USymbioteAnimInstance");
static_assert(offsetof(USymbioteAnimInstance, bIsRunning) == 0x000418, "Member 'USymbioteAnimInstance::bIsRunning' has a wrong offset!");

// Class Hero_1035.Cue_Scope_Loop_10357101
// 0x0220 (0x0F40 - 0x0D20)
class ACue_Scope_Loop_10357101 final : public AMarvelCueNotify_Scope
{
public:
	class USkeletalMeshComponent*                 SymbioteComponent;                                 // 0x0D20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SymbioteTentacleComponent;                         // 0x0D28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Loop;                                           // 0x0D30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Tentacle;                                       // 0x0D38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RegisterHiddenTags;                                // 0x0D40(0x0068)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA8[0x50];                                     // 0x0DA8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x0DF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTraceHeight;                                 // 0x0DFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DevourMontage;                                     // 0x0E00(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachOffset;                                      // 0x0E08(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFXSystemAsset*>                 StartDevourFXAssets;                               // 0x0E20(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   TentacleAlphaName;                                 // 0x0E30(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3C[0x4];                                      // 0x0E3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TentacleAlphaCurve;                                // 0x0E40(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VelocityRatioName;                                 // 0x0E48(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityRatioSpeed;                                // 0x0E54(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IsRotateName;                                      // 0x0E58(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocityRatio;                                  // 0x0E64(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoopFXSizeName;                                    // 0x0E68(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFXSize;                                     // 0x0E74(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TentacleFXOnThrowableName;                         // 0x0E78(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartMoveAudioID;                                  // 0x0E84(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StopMoveAudioID;                                   // 0x0E88(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8C[0x4];                                      // 0x0E8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraInterp*                          DevouringCameraInterp;                             // 0x0E90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103571*                         AbilityConfig;                                     // 0x0E98(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AScope_10357101*                        TargetScope;                                       // 0x0EA0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FSpringArmControlHandler> SpringArmHandlers;                                 // 0x0EA8(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF8[0x48];                                     // 0x0EF8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGenericGameplayTagUpdate(const struct FGameplayTag& InTag, int32 Count);
	void OnMontageEnded(class UAnimMontage* InMontage, bool bIsInterrupted);
	void StartDevour();
	void StopDevour();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10357101">();
	}
	static class ACue_Scope_Loop_10357101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10357101>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10357101) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10357101");
static_assert(sizeof(ACue_Scope_Loop_10357101) == 0x000F40, "Wrong size on ACue_Scope_Loop_10357101");
static_assert(offsetof(ACue_Scope_Loop_10357101, SymbioteComponent) == 0x000D20, "Member 'ACue_Scope_Loop_10357101::SymbioteComponent' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, SymbioteTentacleComponent) == 0x000D28, "Member 'ACue_Scope_Loop_10357101::SymbioteTentacleComponent' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, NS_Loop) == 0x000D30, "Member 'ACue_Scope_Loop_10357101::NS_Loop' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, NS_Tentacle) == 0x000D38, "Member 'ACue_Scope_Loop_10357101::NS_Tentacle' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, RegisterHiddenTags) == 0x000D40, "Member 'ACue_Scope_Loop_10357101::RegisterHiddenTags' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, AbilityID) == 0x000DF8, "Member 'ACue_Scope_Loop_10357101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, GroundTraceHeight) == 0x000DFC, "Member 'ACue_Scope_Loop_10357101::GroundTraceHeight' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, DevourMontage) == 0x000E00, "Member 'ACue_Scope_Loop_10357101::DevourMontage' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, AttachOffset) == 0x000E08, "Member 'ACue_Scope_Loop_10357101::AttachOffset' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, StartDevourFXAssets) == 0x000E20, "Member 'ACue_Scope_Loop_10357101::StartDevourFXAssets' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TentacleAlphaName) == 0x000E30, "Member 'ACue_Scope_Loop_10357101::TentacleAlphaName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TentacleAlphaCurve) == 0x000E40, "Member 'ACue_Scope_Loop_10357101::TentacleAlphaCurve' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, VelocityRatioName) == 0x000E48, "Member 'ACue_Scope_Loop_10357101::VelocityRatioName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, VelocityRatioSpeed) == 0x000E54, "Member 'ACue_Scope_Loop_10357101::VelocityRatioSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, IsRotateName) == 0x000E58, "Member 'ACue_Scope_Loop_10357101::IsRotateName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, MinVelocityRatio) == 0x000E64, "Member 'ACue_Scope_Loop_10357101::MinVelocityRatio' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, LoopFXSizeName) == 0x000E68, "Member 'ACue_Scope_Loop_10357101::LoopFXSizeName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, DefaultFXSize) == 0x000E74, "Member 'ACue_Scope_Loop_10357101::DefaultFXSize' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TentacleFXOnThrowableName) == 0x000E78, "Member 'ACue_Scope_Loop_10357101::TentacleFXOnThrowableName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, StartMoveAudioID) == 0x000E84, "Member 'ACue_Scope_Loop_10357101::StartMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, StopMoveAudioID) == 0x000E88, "Member 'ACue_Scope_Loop_10357101::StopMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, DevouringCameraInterp) == 0x000E90, "Member 'ACue_Scope_Loop_10357101::DevouringCameraInterp' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, AbilityConfig) == 0x000E98, "Member 'ACue_Scope_Loop_10357101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TargetScope) == 0x000EA0, "Member 'ACue_Scope_Loop_10357101::TargetScope' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, SpringArmHandlers) == 0x000EA8, "Member 'ACue_Scope_Loop_10357101::SpringArmHandlers' has a wrong offset!");

// Class Hero_1035.EpicMomentAction_1035
// 0x0040 (0x0160 - 0x0120)
class UEpicMomentAction_1035 : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelGameplayAbility*                 EAbility;                                          // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEpicMomentNodeInfo                    CtrlConfig;                                        // 0x0138(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    EConfig;                                           // 0x0144(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CtrlBuffID;                                        // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CtrlBuffCount;                                     // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EAbilityID;                                        // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EHealthThreshold;                                  // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnEAbilityActivate();
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1035">();
	}
	static class UEpicMomentAction_1035* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1035>();
	}
};
static_assert(alignof(UEpicMomentAction_1035) == 0x000008, "Wrong alignment on UEpicMomentAction_1035");
static_assert(sizeof(UEpicMomentAction_1035) == 0x000160, "Wrong size on UEpicMomentAction_1035");
static_assert(offsetof(UEpicMomentAction_1035, EAbility) == 0x000130, "Member 'UEpicMomentAction_1035::EAbility' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, CtrlConfig) == 0x000138, "Member 'UEpicMomentAction_1035::CtrlConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, EConfig) == 0x000144, "Member 'UEpicMomentAction_1035::EConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, CtrlBuffID) == 0x000150, "Member 'UEpicMomentAction_1035::CtrlBuffID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, CtrlBuffCount) == 0x000154, "Member 'UEpicMomentAction_1035::CtrlBuffCount' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, EAbilityID) == 0x000158, "Member 'UEpicMomentAction_1035::EAbilityID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, EHealthThreshold) == 0x00015C, "Member 'UEpicMomentAction_1035::EHealthThreshold' has a wrong offset!");

// Class Hero_1035.VenomAnimInstance
// 0x00A0 (0x1420 - 0x1380)
class UVenomAnimInstance final : public USpiderManBaseAnimInstance
{
public:
	bool                                          bStartWallIdle_To_OnWallRunning;                   // 0x1380(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndWallIdle_To_OnWallRunning;                     // 0x1381(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1382[0x9E];                                    // 0x1382(0x009E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomAnimInstance">();
	}
	static class UVenomAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVenomAnimInstance>();
	}
};
static_assert(alignof(UVenomAnimInstance) == 0x000010, "Wrong alignment on UVenomAnimInstance");
static_assert(sizeof(UVenomAnimInstance) == 0x001420, "Wrong size on UVenomAnimInstance");
static_assert(offsetof(UVenomAnimInstance, bStartWallIdle_To_OnWallRunning) == 0x001380, "Member 'UVenomAnimInstance::bStartWallIdle_To_OnWallRunning' has a wrong offset!");
static_assert(offsetof(UVenomAnimInstance, bEndWallIdle_To_OnWallRunning) == 0x001381, "Member 'UVenomAnimInstance::bEndWallIdle_To_OnWallRunning' has a wrong offset!");

// Class Hero_1035.VenomCharacter
// 0x0060 (0x1840 - 0x17E0)
class AVenomCharacter : public ASpiderManBaseCharacter
{
public:
	class UCapsuleComponent*                      SymbioteCapsuleComponent;                          // 0x17E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      SymbioteHitShapeComponent;                         // 0x17E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SymbioteInterpSpeed;                               // 0x17F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SymbioteFallingInterpSpeed;                        // 0x17F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerRotateSpeed;                                // 0x17F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17FC[0x4];                                     // 0x17FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVenomMoveLogicBaseComponent*           VenomMoveLogic;                                    // 0x1800(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopAnim;                                         // 0x1808(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableSymbioteCollision;                        // 0x1809(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180A[0x6];                                     // 0x180A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSymbioteStateChanged;                            // 0x1810(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1820[0x20];                                    // 0x1820(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableSymbioteCollision(bool bIsEnable);
	void OnRep_IsEnableSymbioteCollision();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomCharacter">();
	}
	static class AVenomCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVenomCharacter>();
	}
};
static_assert(alignof(AVenomCharacter) == 0x000010, "Wrong alignment on AVenomCharacter");
static_assert(sizeof(AVenomCharacter) == 0x001840, "Wrong size on AVenomCharacter");
static_assert(offsetof(AVenomCharacter, SymbioteCapsuleComponent) == 0x0017E0, "Member 'AVenomCharacter::SymbioteCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, SymbioteHitShapeComponent) == 0x0017E8, "Member 'AVenomCharacter::SymbioteHitShapeComponent' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, SymbioteInterpSpeed) == 0x0017F0, "Member 'AVenomCharacter::SymbioteInterpSpeed' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, SymbioteFallingInterpSpeed) == 0x0017F4, "Member 'AVenomCharacter::SymbioteFallingInterpSpeed' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, TriggerRotateSpeed) == 0x0017F8, "Member 'AVenomCharacter::TriggerRotateSpeed' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, VenomMoveLogic) == 0x001800, "Member 'AVenomCharacter::VenomMoveLogic' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, bLoopAnim) == 0x001808, "Member 'AVenomCharacter::bLoopAnim' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, bIsEnableSymbioteCollision) == 0x001809, "Member 'AVenomCharacter::bIsEnableSymbioteCollision' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, OnSymbioteStateChanged) == 0x001810, "Member 'AVenomCharacter::OnSymbioteStateChanged' has a wrong offset!");

// Class Hero_1035.VenomChildActor
// 0x1260 (0x1CA0 - 0x0A40)
class AVenomChildActor : public AMarvelCharacterChildActor
{
public:
	class USkeletalMeshComponent*                 Tentacle1;                                         // 0x0A40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Tentacle2;                                         // 0x0A48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Tentacle3;                                         // 0x0A50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Tentacle4;                                         // 0x0A58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      BodyFX;                                            // 0x0A60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         TransitionFXAsset;                                 // 0x0A68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTentacleAnimInfo>              TentacleAnimInfos;                                 // 0x0A70(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x0A80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A84[0x4];                                      // 0x0A84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TransitionFXDissolveParameterNames;                // 0x0A88(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DefaultDissolveValue;                              // 0x0A98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TentacleSpeedName;                                 // 0x0A9C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TentacleSpeedDeltaValue;                           // 0x0AA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTentacleSpeed;                                  // 0x0AAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTentacleSpeed;                                  // 0x0AB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideName;                                          // 0x0AB4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideSpeed;                                         // 0x0AC0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC4[0x4];                                      // 0x0AC4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0AC8(0x0068)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  StopFXImmediatelyTags;                             // 0x0B30(0x0068)(Edit, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DeactivateTentacleDelegate;                        // 0x0B98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TransitionFXComponent;                             // 0x0BA8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         Tentacles;                                         // 0x0BB0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<int32>                                 CurrentAnimIndex;                                  // 0x0BC0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         CurTentacleSpeed;                                  // 0x0BD0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD4[0x4];                                      // 0x0BD4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_103521*                         TentacleAbilityConfig;                             // 0x0BD8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x0BE0(0x0010)(Transient, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x0BF0(0x0F30)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             CameraAimResult;                                   // 0x1B20(0x0160)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              BodyNiagaraComponents;                             // 0x1C80(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C90[0x10];                                    // 0x1C90(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideTentacle(class UAnimMontage* AnimMontage, bool bInterrupted);
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomChildActor">();
	}
	static class AVenomChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVenomChildActor>();
	}
};
static_assert(alignof(AVenomChildActor) == 0x000010, "Wrong alignment on AVenomChildActor");
static_assert(sizeof(AVenomChildActor) == 0x001CA0, "Wrong size on AVenomChildActor");
static_assert(offsetof(AVenomChildActor, Tentacle1) == 0x000A40, "Member 'AVenomChildActor::Tentacle1' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacle2) == 0x000A48, "Member 'AVenomChildActor::Tentacle2' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacle3) == 0x000A50, "Member 'AVenomChildActor::Tentacle3' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacle4) == 0x000A58, "Member 'AVenomChildActor::Tentacle4' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, BodyFX) == 0x000A60, "Member 'AVenomChildActor::BodyFX' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TransitionFXAsset) == 0x000A68, "Member 'AVenomChildActor::TransitionFXAsset' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleAnimInfos) == 0x000A70, "Member 'AVenomChildActor::TentacleAnimInfos' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TraceDistance) == 0x000A80, "Member 'AVenomChildActor::TraceDistance' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TransitionFXDissolveParameterNames) == 0x000A88, "Member 'AVenomChildActor::TransitionFXDissolveParameterNames' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, DefaultDissolveValue) == 0x000A98, "Member 'AVenomChildActor::DefaultDissolveValue' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleSpeedName) == 0x000A9C, "Member 'AVenomChildActor::TentacleSpeedName' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleSpeedDeltaValue) == 0x000AA8, "Member 'AVenomChildActor::TentacleSpeedDeltaValue' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, MinTentacleSpeed) == 0x000AAC, "Member 'AVenomChildActor::MinTentacleSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, MaxTentacleSpeed) == 0x000AB0, "Member 'AVenomChildActor::MaxTentacleSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, HideName) == 0x000AB4, "Member 'AVenomChildActor::HideName' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, HideSpeed) == 0x000AC0, "Member 'AVenomChildActor::HideSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, AbilityTags) == 0x000AC8, "Member 'AVenomChildActor::AbilityTags' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, StopFXImmediatelyTags) == 0x000B30, "Member 'AVenomChildActor::StopFXImmediatelyTags' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, DeactivateTentacleDelegate) == 0x000B98, "Member 'AVenomChildActor::DeactivateTentacleDelegate' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TransitionFXComponent) == 0x000BA8, "Member 'AVenomChildActor::TransitionFXComponent' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacles) == 0x000BB0, "Member 'AVenomChildActor::Tentacles' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, CurrentAnimIndex) == 0x000BC0, "Member 'AVenomChildActor::CurrentAnimIndex' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, CurTentacleSpeed) == 0x000BD0, "Member 'AVenomChildActor::CurTentacleSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleAbilityConfig) == 0x000BD8, "Member 'AVenomChildActor::TentacleAbilityConfig' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, DeclarePlayerViewSideHolder) == 0x000BE0, "Member 'AVenomChildActor::DeclarePlayerViewSideHolder' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TraceContext) == 0x000BF0, "Member 'AVenomChildActor::TraceContext' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, CameraAimResult) == 0x001B20, "Member 'AVenomChildActor::CameraAimResult' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, BodyNiagaraComponents) == 0x001C80, "Member 'AVenomChildActor::BodyNiagaraComponents' has a wrong offset!");

// Class Hero_1035.VenomMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UVenomMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomMoveLogicBaseComponent">();
	}
	static class UVenomMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVenomMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UVenomMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UVenomMoveLogicBaseComponent");
static_assert(sizeof(UVenomMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UVenomMoveLogicBaseComponent");

// Class Hero_1035.VenomMovementComponent
// 0x0040 (0x2F20 - 0x2EE0)
class UVenomMovementComponent final : public UCharacterWallRunningComponent
{
public:
	bool                                          bEnableAvoidMeshPenetrationTrace;                  // 0x2ED8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED9[0x3];                                     // 0x2ED9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AwayFromWallScale;                                 // 0x2EDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBetweenAngleToTrace;                            // 0x2EE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE4[0x4];                                     // 0x2EE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HandSocketOffset;                                  // 0x2EE8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleThresholdToForceSlideUpInSwinging;            // 0x2F00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F04[0x4];                                     // 0x2F04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorComponent*>                TraceComponentArray;                               // 0x2F08(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AVenomCharacter*                        VenomCharacter;                                    // 0x2F18(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomMovementComponent">();
	}
	static class UVenomMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVenomMovementComponent>();
	}
};
static_assert(alignof(UVenomMovementComponent) == 0x000010, "Wrong alignment on UVenomMovementComponent");
static_assert(sizeof(UVenomMovementComponent) == 0x002F20, "Wrong size on UVenomMovementComponent");
static_assert(offsetof(UVenomMovementComponent, bEnableAvoidMeshPenetrationTrace) == 0x002ED8, "Member 'UVenomMovementComponent::bEnableAvoidMeshPenetrationTrace' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, AwayFromWallScale) == 0x002EDC, "Member 'UVenomMovementComponent::AwayFromWallScale' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, MinBetweenAngleToTrace) == 0x002EE0, "Member 'UVenomMovementComponent::MinBetweenAngleToTrace' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, HandSocketOffset) == 0x002EE8, "Member 'UVenomMovementComponent::HandSocketOffset' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, AngleThresholdToForceSlideUpInSwinging) == 0x002F00, "Member 'UVenomMovementComponent::AngleThresholdToForceSlideUpInSwinging' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, TraceComponentArray) == 0x002F08, "Member 'UVenomMovementComponent::TraceComponentArray' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, VenomCharacter) == 0x002F18, "Member 'UVenomMovementComponent::VenomCharacter' has a wrong offset!");

}

