#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1034

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "DeclarativeUnreal_structs.hpp"
#include "Hero_1034_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Hero_1034.Config_103401
// 0x00D0 (0x1170 - 0x10A0)
class UConfig_103401 final : public UConfig_AeroBase
{
public:
	struct FGameplayTagContainer                  AscendingCancleAbilityTags;                        // 0x1098(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<int32>                                 AeroStateControlBydAbilityIds;                     // 0x1100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AscendConfigID;                                    // 0x1110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DescendConfigID;                                   // 0x1114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   AchieveRecordFlyDistanceAbilityIDs;                // 0x1118(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_1168[0x8];                                     // 0x1168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103401">();
	}
	static class UConfig_103401* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103401>();
	}
};
static_assert(alignof(UConfig_103401) == 0x000010, "Wrong alignment on UConfig_103401");
static_assert(sizeof(UConfig_103401) == 0x001170, "Wrong size on UConfig_103401");
static_assert(offsetof(UConfig_103401, AscendingCancleAbilityTags) == 0x001098, "Member 'UConfig_103401::AscendingCancleAbilityTags' has a wrong offset!");
static_assert(offsetof(UConfig_103401, AeroStateControlBydAbilityIds) == 0x001100, "Member 'UConfig_103401::AeroStateControlBydAbilityIds' has a wrong offset!");
static_assert(offsetof(UConfig_103401, AscendConfigID) == 0x001110, "Member 'UConfig_103401::AscendConfigID' has a wrong offset!");
static_assert(offsetof(UConfig_103401, DescendConfigID) == 0x001114, "Member 'UConfig_103401::DescendConfigID' has a wrong offset!");
static_assert(offsetof(UConfig_103401, AchieveRecordFlyDistanceAbilityIDs) == 0x001118, "Member 'UConfig_103401::AchieveRecordFlyDistanceAbilityIDs' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Loop_10340101
// 0x0210 (0x1010 - 0x0E00)
class ACue_Ability_Loop_10340101 : public AMarvelCueNotify_Ability
{
public:
	class UNiagaraComponent*                      LoopNS_FootFxL;                                    // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FootFxR;                                    // 0x0E08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandFxL;                                    // 0x0E10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandFxR;                                    // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FootFxL;                          // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FootFxR;                          // 0x0E28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_HandFxL;                          // 0x0E30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_HandFxR;                          // 0x0E38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsBlockHandFX;                                   // 0x0E40(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsBlockFloatingGunFX;                            // 0x0EA8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsNanoWeapons;                                   // 0x0F10(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsLaserAbilities;                                // 0x0F78(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Stationary_SpeedThreshold;                         // 0x0FE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlyLateralInLaserState_StartAudioID;               // 0x0FE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlyLateralInLaserState_LoopAudioID;                // 0x0FE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlyLateralInLaserState_EndAudioID;                 // 0x0FEC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF0[0x20];                                     // 0x0FF0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerTagUpdated(const struct FGameplayTag& TagUpdated, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10340101">();
	}
	static class ACue_Ability_Loop_10340101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10340101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10340101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10340101");
static_assert(sizeof(ACue_Ability_Loop_10340101) == 0x001010, "Wrong size on ACue_Ability_Loop_10340101");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_FootFxL) == 0x000E00, "Member 'ACue_Ability_Loop_10340101::LoopNS_FootFxL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_FootFxR) == 0x000E08, "Member 'ACue_Ability_Loop_10340101::LoopNS_FootFxR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_HandFxL) == 0x000E10, "Member 'ACue_Ability_Loop_10340101::LoopNS_HandFxL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_HandFxR) == 0x000E18, "Member 'ACue_Ability_Loop_10340101::LoopNS_HandFxR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_Ascending_FootFxL) == 0x000E20, "Member 'ACue_Ability_Loop_10340101::LoopNS_Ascending_FootFxL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_Ascending_FootFxR) == 0x000E28, "Member 'ACue_Ability_Loop_10340101::LoopNS_Ascending_FootFxR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_Ascending_HandFxL) == 0x000E30, "Member 'ACue_Ability_Loop_10340101::LoopNS_Ascending_HandFxL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_Ascending_HandFxR) == 0x000E38, "Member 'ACue_Ability_Loop_10340101::LoopNS_Ascending_HandFxR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, TagsBlockHandFX) == 0x000E40, "Member 'ACue_Ability_Loop_10340101::TagsBlockHandFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, TagsBlockFloatingGunFX) == 0x000EA8, "Member 'ACue_Ability_Loop_10340101::TagsBlockFloatingGunFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, TagsNanoWeapons) == 0x000F10, "Member 'ACue_Ability_Loop_10340101::TagsNanoWeapons' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, TagsLaserAbilities) == 0x000F78, "Member 'ACue_Ability_Loop_10340101::TagsLaserAbilities' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, Stationary_SpeedThreshold) == 0x000FE0, "Member 'ACue_Ability_Loop_10340101::Stationary_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, FlyLateralInLaserState_StartAudioID) == 0x000FE4, "Member 'ACue_Ability_Loop_10340101::FlyLateralInLaserState_StartAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, FlyLateralInLaserState_LoopAudioID) == 0x000FE8, "Member 'ACue_Ability_Loop_10340101::FlyLateralInLaserState_LoopAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, FlyLateralInLaserState_EndAudioID) == 0x000FEC, "Member 'ACue_Ability_Loop_10340101::FlyLateralInLaserState_EndAudioID' has a wrong offset!");

// Class Hero_1034.Ability_103401_V2
// 0x0010 (0x5AA0 - 0x5A90)
class UAbility_103401_V2 : public UMarvelAeroBaseAbility
{
public:
	float                                         AchieveFlyDistance;                                // 0x5A90(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A94[0x4];                                     // 0x5A94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AIronManCharacter*                      OwnerIronManCharacter;                             // 0x5A98(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCharacterMovementFlyDistance(float InDistance);
	void OnHoveringAbilityActivate(class UGameplayAbility* ActivatedAbility);
	void OnHoveringAbilityBreak(class UGameplayAbility* Ability);
	void OnHoveringAbilityEnd(class UGameplayAbility* Ability);
	void OnOwnerCharBorn103401(class AActor* TargetActor, const struct FCharacterRebornParam& Param);
	void OnOwnerCharDeath103401(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void UpdateAeroStateByOtherAbility(class UGameplayAbility* Ability, const bool bAbilityActivate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103401_V2">();
	}
	static class UAbility_103401_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103401_V2>();
	}
};
static_assert(alignof(UAbility_103401_V2) == 0x000010, "Wrong alignment on UAbility_103401_V2");
static_assert(sizeof(UAbility_103401_V2) == 0x005AA0, "Wrong size on UAbility_103401_V2");
static_assert(offsetof(UAbility_103401_V2, AchieveFlyDistance) == 0x005A90, "Member 'UAbility_103401_V2::AchieveFlyDistance' has a wrong offset!");
static_assert(offsetof(UAbility_103401_V2, OwnerIronManCharacter) == 0x005A98, "Member 'UAbility_103401_V2::OwnerIronManCharacter' has a wrong offset!");

// Class Hero_1034.Cue_Projectile_Loop_10341101
// 0x0028 (0x0D88 - 0x0D60)
class ACue_Projectile_Loop_10341101 : public AMarvelCueNotify_Projectile
{
public:
	class UNiagaraComponent*                      LoopNS;                                            // 0x0D60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         StartMuzzleFX;                                     // 0x0D68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StartMuzzleScale3D;                                // 0x0D70(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10341101">();
	}
	static class ACue_Projectile_Loop_10341101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10341101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10341101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10341101");
static_assert(sizeof(ACue_Projectile_Loop_10341101) == 0x000D88, "Wrong size on ACue_Projectile_Loop_10341101");
static_assert(offsetof(ACue_Projectile_Loop_10341101, LoopNS) == 0x000D60, "Member 'ACue_Projectile_Loop_10341101::LoopNS' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10341101, StartMuzzleFX) == 0x000D68, "Member 'ACue_Projectile_Loop_10341101::StartMuzzleFX' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10341101, StartMuzzleScale3D) == 0x000D70, "Member 'ACue_Projectile_Loop_10341101::StartMuzzleScale3D' has a wrong offset!");

// Class Hero_1034.Cue_Projectile_Loop_10341901
// 0x0010 (0x0D98 - 0x0D88)
class ACue_Projectile_Loop_10341901 final : public ACue_Projectile_Loop_10341101
{
public:
	class UNiagaraComponent*                      LoopNS_Enhanced;                                   // 0x0D88(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EnhancedAbilityID;                                 // 0x0D90(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D94[0x4];                                      // 0x0D94(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10341901">();
	}
	static class ACue_Projectile_Loop_10341901* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10341901>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10341901) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10341901");
static_assert(sizeof(ACue_Projectile_Loop_10341901) == 0x000D98, "Wrong size on ACue_Projectile_Loop_10341901");
static_assert(offsetof(ACue_Projectile_Loop_10341901, LoopNS_Enhanced) == 0x000D88, "Member 'ACue_Projectile_Loop_10341901::LoopNS_Enhanced' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10341901, EnhancedAbilityID) == 0x000D90, "Member 'ACue_Projectile_Loop_10341901::EnhancedAbilityID' has a wrong offset!");

// Class Hero_1034.Config_103421
// 0x0100 (0x0198 - 0x0098)
class UConfig_103421 : public UMarvelAbilityConfig
{
public:
	int32                                         ScopeId;                                           // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAmmoClipType                                 AmmoType;                                          // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CustomCancelByTags;                                // 0x00A0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CustomBlockByTags;                                 // 0x0108(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FShootModeSensitivityParam             AbilitySensitivityParam;                           // 0x0170(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103421">();
	}
	static class UConfig_103421* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103421>();
	}
};
static_assert(alignof(UConfig_103421) == 0x000008, "Wrong alignment on UConfig_103421");
static_assert(sizeof(UConfig_103421) == 0x000198, "Wrong size on UConfig_103421");
static_assert(offsetof(UConfig_103421, ScopeId) == 0x000098, "Member 'UConfig_103421::ScopeId' has a wrong offset!");
static_assert(offsetof(UConfig_103421, AmmoType) == 0x00009C, "Member 'UConfig_103421::AmmoType' has a wrong offset!");
static_assert(offsetof(UConfig_103421, CustomCancelByTags) == 0x0000A0, "Member 'UConfig_103421::CustomCancelByTags' has a wrong offset!");
static_assert(offsetof(UConfig_103421, CustomBlockByTags) == 0x000108, "Member 'UConfig_103421::CustomBlockByTags' has a wrong offset!");
static_assert(offsetof(UConfig_103421, AbilitySensitivityParam) == 0x000170, "Member 'UConfig_103421::AbilitySensitivityParam' has a wrong offset!");

// Class Hero_1034.Ability_103421
// 0x00F0 (0x2648 - 0x2558)
class UAbility_103421 : public UAbility_108
{
public:
	class UAbilityTask_WaitInputRelease*          InputRightTask;                                    // 0x2558(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_WaitBindInput*       InputSpaceTask;                                    // 0x2560(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLaserFinished;                                  // 0x2568(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2569[0x7];                                     // 0x2569(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelAbilityTargetActor_Scope*        OwnedScope;                                        // 0x2570(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2578[0xD0];                                    // 0x2578(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CommitIronManAmmo();
	void OnPressSpace(float TimeWaited);
	void OnReleaseRight(float TimeWaited);
	void TryCancelOnGameplayEffectAppliedToSelf(class UAbilitySystemComponent* Source, class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& EffectHandle);
	void UpdateAbilitySensitivity();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103421">();
	}
	static class UAbility_103421* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103421>();
	}
};
static_assert(alignof(UAbility_103421) == 0x000008, "Wrong alignment on UAbility_103421");
static_assert(sizeof(UAbility_103421) == 0x002648, "Wrong size on UAbility_103421");
static_assert(offsetof(UAbility_103421, InputRightTask) == 0x002558, "Member 'UAbility_103421::InputRightTask' has a wrong offset!");
static_assert(offsetof(UAbility_103421, InputSpaceTask) == 0x002560, "Member 'UAbility_103421::InputSpaceTask' has a wrong offset!");
static_assert(offsetof(UAbility_103421, bIsLaserFinished) == 0x002568, "Member 'UAbility_103421::bIsLaserFinished' has a wrong offset!");
static_assert(offsetof(UAbility_103421, OwnedScope) == 0x002570, "Member 'UAbility_103421::OwnedScope' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Loop_10342101
// 0x1108 (0x20A0 - 0x0F98)
#pragma pack(push, 0x1)
class alignas(0x10) ACue_Ability_Loop_10342101 : public AMarvelCueNotify_Laser
{
public:
	class UNiagaraComponent*                      LoopNS_Main;                                       // 0x0F98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOneShotAudioActor*                     LaserLoopAudioActor;                               // 0x0FA0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScopeId;                                           // 0x0FA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityID;                                         // 0x0FAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamNameLength;                                   // 0x0FB0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamNameDir;                                      // 0x0FBC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalTranslucencySortPriority;                     // 0x0FC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FCC[0x4];                                      // 0x0FCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AttachPos;                                         // 0x0FD0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimLocation;                                       // 0x0FE8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         AirHitFx;                                          // 0x1000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         MultiCharacterHitFx;                               // 0x1008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ScratchCueTag;                                     // 0x1010(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScratchFXOffset;                                   // 0x101C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     InstanceAirHitFXComponent;                         // 0x1020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1028[0x8];                                     // 0x1028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             ScopeTraceContext;                                 // 0x1030(0x0F30)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class AMarvelBaseCharacter*, class UFXSystemComponent*> CharacterHitsActor2FXMap;                          // 0x1F60(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x1FB0(0x0010)(Transient, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_GenericMain;                                // 0x1FC0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC8[0x8];                                     // 0x1FC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRemoteRotationSInterp                 CameraRotationInterp;                              // 0x1FD0(0x00A0)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2070[0x8];                                     // 0x2070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Loop1PAudioID;                                     // 0x2078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Loop2PAudioID;                                     // 0x207C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmmoRTPCThreshold;                                 // 0x2080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2084[0x4];                                     // 0x2084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CurveAmmoRTPC;                                     // 0x2088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x2090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShorCut;                                       // 0x2094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2095[0x3];                                     // 0x2095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClientPlayerViewSideChange(EClientPlayerViewSide InViewSide);
	void UpdateLaser(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10342101">();
	}
	static class ACue_Ability_Loop_10342101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10342101>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACue_Ability_Loop_10342101) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10342101");
static_assert(sizeof(ACue_Ability_Loop_10342101) == 0x0020A0, "Wrong size on ACue_Ability_Loop_10342101");
static_assert(offsetof(ACue_Ability_Loop_10342101, LoopNS_Main) == 0x000F98, "Member 'ACue_Ability_Loop_10342101::LoopNS_Main' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, LaserLoopAudioActor) == 0x000FA0, "Member 'ACue_Ability_Loop_10342101::LaserLoopAudioActor' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ScopeId) == 0x000FA8, "Member 'ACue_Ability_Loop_10342101::ScopeId' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, AbilityID) == 0x000FAC, "Member 'ACue_Ability_Loop_10342101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ParamNameLength) == 0x000FB0, "Member 'ACue_Ability_Loop_10342101::ParamNameLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ParamNameDir) == 0x000FBC, "Member 'ACue_Ability_Loop_10342101::ParamNameDir' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, DecalTranslucencySortPriority) == 0x000FC8, "Member 'ACue_Ability_Loop_10342101::DecalTranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, AttachPos) == 0x000FD0, "Member 'ACue_Ability_Loop_10342101::AttachPos' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, AimLocation) == 0x000FE8, "Member 'ACue_Ability_Loop_10342101::AimLocation' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, AirHitFx) == 0x001000, "Member 'ACue_Ability_Loop_10342101::AirHitFx' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, MultiCharacterHitFx) == 0x001008, "Member 'ACue_Ability_Loop_10342101::MultiCharacterHitFx' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ScratchCueTag) == 0x001010, "Member 'ACue_Ability_Loop_10342101::ScratchCueTag' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ScratchFXOffset) == 0x00101C, "Member 'ACue_Ability_Loop_10342101::ScratchFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, InstanceAirHitFXComponent) == 0x001020, "Member 'ACue_Ability_Loop_10342101::InstanceAirHitFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ScopeTraceContext) == 0x001030, "Member 'ACue_Ability_Loop_10342101::ScopeTraceContext' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, CharacterHitsActor2FXMap) == 0x001F60, "Member 'ACue_Ability_Loop_10342101::CharacterHitsActor2FXMap' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, DeclarePlayerViewSideHolder) == 0x001FB0, "Member 'ACue_Ability_Loop_10342101::DeclarePlayerViewSideHolder' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, LoopNS_GenericMain) == 0x001FC0, "Member 'ACue_Ability_Loop_10342101::LoopNS_GenericMain' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, CameraRotationInterp) == 0x001FD0, "Member 'ACue_Ability_Loop_10342101::CameraRotationInterp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, Loop1PAudioID) == 0x002078, "Member 'ACue_Ability_Loop_10342101::Loop1PAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, Loop2PAudioID) == 0x00207C, "Member 'ACue_Ability_Loop_10342101::Loop2PAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, AmmoRTPCThreshold) == 0x002080, "Member 'ACue_Ability_Loop_10342101::AmmoRTPCThreshold' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, CurveAmmoRTPC) == 0x002088, "Member 'ACue_Ability_Loop_10342101::CurveAmmoRTPC' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, DrawTime) == 0x002090, "Member 'ACue_Ability_Loop_10342101::DrawTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, bUseShorCut) == 0x002094, "Member 'ACue_Ability_Loop_10342101::bUseShorCut' has a wrong offset!");

// Class Hero_1034.Cue_Scope_Start_10342103
// 0x0010 (0x0378 - 0x0368)
class UCue_Scope_Start_10342103 final : public UMarvelCueNotify_Base
{
public:
	class FName                                   ScaleName;                                         // 0x0368(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleValue;                                        // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Start_10342103">();
	}
	static class UCue_Scope_Start_10342103* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Scope_Start_10342103>();
	}
};
static_assert(alignof(UCue_Scope_Start_10342103) == 0x000008, "Wrong alignment on UCue_Scope_Start_10342103");
static_assert(sizeof(UCue_Scope_Start_10342103) == 0x000378, "Wrong size on UCue_Scope_Start_10342103");
static_assert(offsetof(UCue_Scope_Start_10342103, ScaleName) == 0x000368, "Member 'UCue_Scope_Start_10342103::ScaleName' has a wrong offset!");
static_assert(offsetof(UCue_Scope_Start_10342103, ScaleValue) == 0x000374, "Member 'UCue_Scope_Start_10342103::ScaleValue' has a wrong offset!");

// Class Hero_1034.Config_103429
// 0x0000 (0x0198 - 0x0198)
class UConfig_103429 final : public UConfig_103421
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103429">();
	}
	static class UConfig_103429* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103429>();
	}
};
static_assert(alignof(UConfig_103429) == 0x000008, "Wrong alignment on UConfig_103429");
static_assert(sizeof(UConfig_103429) == 0x000198, "Wrong size on UConfig_103429");

// Class Hero_1034.Ability_103429
// 0x0000 (0x2648 - 0x2648)
class UAbility_103429 : public UAbility_103421
{
public:
	void OnNanoStateTimeout();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103429">();
	}
	static class UAbility_103429* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103429>();
	}
};
static_assert(alignof(UAbility_103429) == 0x000008, "Wrong alignment on UAbility_103429");
static_assert(sizeof(UAbility_103429) == 0x002648, "Wrong size on UAbility_103429");

// Class Hero_1034.Cue_Ability_Loop_10342901
// 0x0070 (0x2110 - 0x20A0)
class ACue_Ability_Loop_10342901 final : public ACue_Ability_Loop_10342101
{
public:
	class USkeletalMeshComponent*                 FloatingMeshComp;                                  // 0x2098(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Junction;                                   // 0x20A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_SmallLasers;                                // 0x20A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_EnhancedMain;                               // 0x20B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_EnhancedJunction;                           // 0x20B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamNameEndPos;                                   // 0x20C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamNameTargetSkelMesh;                           // 0x20CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnhancedAbilityID;                                 // 0x20D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JunctionDistance;                                  // 0x20DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JunctionLocation;                                  // 0x20E0(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPortableMaterialSlotName>      WeaponMeshDissolveSlots;                           // 0x20F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasShowWeaponMesh;                                // 0x2108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2109[0x7];                                     // 0x2109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateNanoLaser(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10342901">();
	}
	static class ACue_Ability_Loop_10342901* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10342901>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10342901) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10342901");
static_assert(sizeof(ACue_Ability_Loop_10342901) == 0x002110, "Wrong size on ACue_Ability_Loop_10342901");
static_assert(offsetof(ACue_Ability_Loop_10342901, FloatingMeshComp) == 0x002098, "Member 'ACue_Ability_Loop_10342901::FloatingMeshComp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, LoopNS_Junction) == 0x0020A0, "Member 'ACue_Ability_Loop_10342901::LoopNS_Junction' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, LoopNS_SmallLasers) == 0x0020A8, "Member 'ACue_Ability_Loop_10342901::LoopNS_SmallLasers' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, LoopNS_EnhancedMain) == 0x0020B0, "Member 'ACue_Ability_Loop_10342901::LoopNS_EnhancedMain' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, LoopNS_EnhancedJunction) == 0x0020B8, "Member 'ACue_Ability_Loop_10342901::LoopNS_EnhancedJunction' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, ParamNameEndPos) == 0x0020C0, "Member 'ACue_Ability_Loop_10342901::ParamNameEndPos' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, ParamNameTargetSkelMesh) == 0x0020CC, "Member 'ACue_Ability_Loop_10342901::ParamNameTargetSkelMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, EnhancedAbilityID) == 0x0020D8, "Member 'ACue_Ability_Loop_10342901::EnhancedAbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, JunctionDistance) == 0x0020DC, "Member 'ACue_Ability_Loop_10342901::JunctionDistance' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, JunctionLocation) == 0x0020E0, "Member 'ACue_Ability_Loop_10342901::JunctionLocation' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, WeaponMeshDissolveSlots) == 0x0020F8, "Member 'ACue_Ability_Loop_10342901::WeaponMeshDissolveSlots' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, bHasShowWeaponMesh) == 0x002108, "Member 'ACue_Ability_Loop_10342901::bHasShowWeaponMesh' has a wrong offset!");

// Class Hero_1034.Config_103431
// 0x0068 (0x0100 - 0x0098)
class UConfig_103431 : public UMarvelAbilityConfig
{
public:
	struct FVector2D                              CapsuleSize;                                       // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADControlFactor;                                   // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SocketOffsetTargetY;                               // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMin;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMax;                                      // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyArrivedMaxHeightInterpSpeed;                    // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxEnterength;                                     // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxExitLength;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlySpeedBuffId;                                    // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EndFlyCueTag;                                      // 0x00C8(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateChangedTaskParam                 ActiveUserSetting;                                 // 0x00D4(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103431">();
	}
	static class UConfig_103431* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103431>();
	}
};
static_assert(alignof(UConfig_103431) == 0x000008, "Wrong alignment on UConfig_103431");
static_assert(sizeof(UConfig_103431) == 0x000100, "Wrong size on UConfig_103431");
static_assert(offsetof(UConfig_103431, CapsuleSize) == 0x000098, "Member 'UConfig_103431::CapsuleSize' has a wrong offset!");
static_assert(offsetof(UConfig_103431, ADControlFactor) == 0x0000A8, "Member 'UConfig_103431::ADControlFactor' has a wrong offset!");
static_assert(offsetof(UConfig_103431, SocketOffsetTargetY) == 0x0000AC, "Member 'UConfig_103431::SocketOffsetTargetY' has a wrong offset!");
static_assert(offsetof(UConfig_103431, ViewPitchMin) == 0x0000B0, "Member 'UConfig_103431::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(UConfig_103431, ViewPitchMax) == 0x0000B4, "Member 'UConfig_103431::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(UConfig_103431, FlyArrivedMaxHeightInterpSpeed) == 0x0000B8, "Member 'UConfig_103431::FlyArrivedMaxHeightInterpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_103431, BoxEnterength) == 0x0000BC, "Member 'UConfig_103431::BoxEnterength' has a wrong offset!");
static_assert(offsetof(UConfig_103431, BoxExitLength) == 0x0000C0, "Member 'UConfig_103431::BoxExitLength' has a wrong offset!");
static_assert(offsetof(UConfig_103431, FlySpeedBuffId) == 0x0000C4, "Member 'UConfig_103431::FlySpeedBuffId' has a wrong offset!");
static_assert(offsetof(UConfig_103431, EndFlyCueTag) == 0x0000C8, "Member 'UConfig_103431::EndFlyCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103431, ActiveUserSetting) == 0x0000D4, "Member 'UConfig_103431::ActiveUserSetting' has a wrong offset!");

// Class Hero_1034.Ability_103431
// 0x0240 (0x2798 - 0x2558)
class UAbility_103431 : public UAbility_108
{
public:
	class UCapsuleComponent*                      AvatarCapsule;                                     // 0x2558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitCancel*                CancelInputTask;                                   // 0x2560(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputLeftTask;                                     // 0x2568(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputRightTask;                                    // 0x2570(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitInputStateChanged* InputStateChangedTask;                             // 0x2578(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103431*                         Config103431;                                      // 0x2580(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      PlayerController;                                  // 0x2588(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2590[0x208];                                   // 0x2590(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelInput(float Time);
	bool GetLastTestResult();
	void OnMoveRightReceive(float RightInput);
	void OnPressA(float TimeWaited);
	void OnPressD(float TimeWaited);
	void OnReleaseA(float TimeWaited);
	void OnReleaseD(float TimeWaited);
	void RefreshADControllTag();
	void ServerSetADState(int32 PredictionSerial, int8 ADState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103431">();
	}
	static class UAbility_103431* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103431>();
	}
};
static_assert(alignof(UAbility_103431) == 0x000008, "Wrong alignment on UAbility_103431");
static_assert(sizeof(UAbility_103431) == 0x002798, "Wrong size on UAbility_103431");
static_assert(offsetof(UAbility_103431, AvatarCapsule) == 0x002558, "Member 'UAbility_103431::AvatarCapsule' has a wrong offset!");
static_assert(offsetof(UAbility_103431, CancelInputTask) == 0x002560, "Member 'UAbility_103431::CancelInputTask' has a wrong offset!");
static_assert(offsetof(UAbility_103431, InputLeftTask) == 0x002568, "Member 'UAbility_103431::InputLeftTask' has a wrong offset!");
static_assert(offsetof(UAbility_103431, InputRightTask) == 0x002570, "Member 'UAbility_103431::InputRightTask' has a wrong offset!");
static_assert(offsetof(UAbility_103431, InputStateChangedTask) == 0x002578, "Member 'UAbility_103431::InputStateChangedTask' has a wrong offset!");
static_assert(offsetof(UAbility_103431, Config103431) == 0x002580, "Member 'UAbility_103431::Config103431' has a wrong offset!");
static_assert(offsetof(UAbility_103431, PlayerController) == 0x002588, "Member 'UAbility_103431::PlayerController' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Loop_10343101
// 0x00B8 (0x0EB8 - 0x0E00)
class ACue_Ability_Loop_10343101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E00[0x18];                                     // 0x0E00(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      LoopBody;                                          // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandL;                                      // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandR;                                      // 0x0E28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FootL;                                      // 0x0E30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FootR;                                      // 0x0E38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_GunL;                                       // 0x0E40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_GunR;                                       // 0x0E48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTagUpdateDispatcher;                             // 0x0E50(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FloatingGunSizeScaleCurve;                         // 0x0E60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FlameSizeScaleCurve;                               // 0x0E68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SoundCurveHeight;                                  // 0x0E70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SoundThresholdUpDown;                              // 0x0E78(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundThresholdLeftRight;                           // 0x0E88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8C[0x4];                                      // 0x0E8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SoundCurveRight;                                   // 0x0E90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SoundCurveRightWhenUpDown;                         // 0x0E98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SoundCurveUp;                                      // 0x0EA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SoundCurveUpWhenLeftRight;                         // 0x0EA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkComponent*                           AudioComp;                                         // 0x0EB0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnOwnedTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10343101">();
	}
	static class ACue_Ability_Loop_10343101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10343101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10343101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10343101");
static_assert(sizeof(ACue_Ability_Loop_10343101) == 0x000EB8, "Wrong size on ACue_Ability_Loop_10343101");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopBody) == 0x000E18, "Member 'ACue_Ability_Loop_10343101::LoopBody' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_HandL) == 0x000E20, "Member 'ACue_Ability_Loop_10343101::LoopNS_HandL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_HandR) == 0x000E28, "Member 'ACue_Ability_Loop_10343101::LoopNS_HandR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_FootL) == 0x000E30, "Member 'ACue_Ability_Loop_10343101::LoopNS_FootL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_FootR) == 0x000E38, "Member 'ACue_Ability_Loop_10343101::LoopNS_FootR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_GunL) == 0x000E40, "Member 'ACue_Ability_Loop_10343101::LoopNS_GunL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_GunR) == 0x000E48, "Member 'ACue_Ability_Loop_10343101::LoopNS_GunR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, OnTagUpdateDispatcher) == 0x000E50, "Member 'ACue_Ability_Loop_10343101::OnTagUpdateDispatcher' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, FloatingGunSizeScaleCurve) == 0x000E60, "Member 'ACue_Ability_Loop_10343101::FloatingGunSizeScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, FlameSizeScaleCurve) == 0x000E68, "Member 'ACue_Ability_Loop_10343101::FlameSizeScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundCurveHeight) == 0x000E70, "Member 'ACue_Ability_Loop_10343101::SoundCurveHeight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundThresholdUpDown) == 0x000E78, "Member 'ACue_Ability_Loop_10343101::SoundThresholdUpDown' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundThresholdLeftRight) == 0x000E88, "Member 'ACue_Ability_Loop_10343101::SoundThresholdLeftRight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundCurveRight) == 0x000E90, "Member 'ACue_Ability_Loop_10343101::SoundCurveRight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundCurveRightWhenUpDown) == 0x000E98, "Member 'ACue_Ability_Loop_10343101::SoundCurveRightWhenUpDown' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundCurveUp) == 0x000EA0, "Member 'ACue_Ability_Loop_10343101::SoundCurveUp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundCurveUpWhenLeftRight) == 0x000EA8, "Member 'ACue_Ability_Loop_10343101::SoundCurveUpWhenLeftRight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, AudioComp) == 0x000EB0, "Member 'ACue_Ability_Loop_10343101::AudioComp' has a wrong offset!");

// Class Hero_1034.Config_103439
// 0x0000 (0x0100 - 0x0100)
class UConfig_103439 final : public UConfig_103431
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103439">();
	}
	static class UConfig_103439* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103439>();
	}
};
static_assert(alignof(UConfig_103439) == 0x000008, "Wrong alignment on UConfig_103439");
static_assert(sizeof(UConfig_103439) == 0x000100, "Wrong size on UConfig_103439");

// Class Hero_1034.Ability_103439
// 0x0000 (0x2798 - 0x2798)
class UAbility_103439 : public UAbility_103431
{
public:
	void OnNanoStateTimeout();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103439">();
	}
	static class UAbility_103439* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103439>();
	}
};
static_assert(alignof(UAbility_103439) == 0x000008, "Wrong alignment on UAbility_103439");
static_assert(sizeof(UAbility_103439) == 0x002798, "Wrong size on UAbility_103439");

// Class Hero_1034.SplineConfigActor_103441
// 0x0010 (0x0480 - 0x0470)
class ASplineConfigActor_103441 final : public AActor
{
public:
	TArray<class USplineComponent*>               SplineCompArray;                                   // 0x0470(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineConfigActor_103441">();
	}
	static class ASplineConfigActor_103441* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineConfigActor_103441>();
	}
};
static_assert(alignof(ASplineConfigActor_103441) == 0x000008, "Wrong alignment on ASplineConfigActor_103441");
static_assert(sizeof(ASplineConfigActor_103441) == 0x000480, "Wrong size on ASplineConfigActor_103441");
static_assert(offsetof(ASplineConfigActor_103441, SplineCompArray) == 0x000470, "Member 'ASplineConfigActor_103441::SplineCompArray' has a wrong offset!");

// Class Hero_1034.Config_103441
// 0x0090 (0x0128 - 0x0098)
class UConfig_103441 final : public UMarvelAbilityConfig
{
public:
	float                                         MaxCurvesTime;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SplineLocationScale;                               // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FIronManSpline>                 SplineDatas;                                       // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SplineConfigActor;                                 // 0x00C8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TestIndex;                                         // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineFixedVelocityX;                              // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGroundDist;                                     // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepDistByEachIndex;                               // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepDistByEvenIndex;                               // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFireCount;                                      // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireInterval;                                      // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FIronManMissileSpec>            MissileSpecs;                                      // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103441">();
	}
	static class UConfig_103441* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103441>();
	}
};
static_assert(alignof(UConfig_103441) == 0x000008, "Wrong alignment on UConfig_103441");
static_assert(sizeof(UConfig_103441) == 0x000128, "Wrong size on UConfig_103441");
static_assert(offsetof(UConfig_103441, MaxCurvesTime) == 0x000098, "Member 'UConfig_103441::MaxCurvesTime' has a wrong offset!");
static_assert(offsetof(UConfig_103441, SplineLocationScale) == 0x0000A0, "Member 'UConfig_103441::SplineLocationScale' has a wrong offset!");
static_assert(offsetof(UConfig_103441, SplineDatas) == 0x0000B8, "Member 'UConfig_103441::SplineDatas' has a wrong offset!");
static_assert(offsetof(UConfig_103441, SplineConfigActor) == 0x0000C8, "Member 'UConfig_103441::SplineConfigActor' has a wrong offset!");
static_assert(offsetof(UConfig_103441, TestIndex) == 0x0000F8, "Member 'UConfig_103441::TestIndex' has a wrong offset!");
static_assert(offsetof(UConfig_103441, SplineFixedVelocityX) == 0x0000FC, "Member 'UConfig_103441::SplineFixedVelocityX' has a wrong offset!");
static_assert(offsetof(UConfig_103441, MaxGroundDist) == 0x000100, "Member 'UConfig_103441::MaxGroundDist' has a wrong offset!");
static_assert(offsetof(UConfig_103441, StepDistByEachIndex) == 0x000104, "Member 'UConfig_103441::StepDistByEachIndex' has a wrong offset!");
static_assert(offsetof(UConfig_103441, StepDistByEvenIndex) == 0x000108, "Member 'UConfig_103441::StepDistByEvenIndex' has a wrong offset!");
static_assert(offsetof(UConfig_103441, MaxFireCount) == 0x00010C, "Member 'UConfig_103441::MaxFireCount' has a wrong offset!");
static_assert(offsetof(UConfig_103441, FireInterval) == 0x000110, "Member 'UConfig_103441::FireInterval' has a wrong offset!");
static_assert(offsetof(UConfig_103441, MissileSpecs) == 0x000118, "Member 'UConfig_103441::MissileSpecs' has a wrong offset!");

// Class Hero_1034.Ability_103441
// 0x0008 (0x2560 - 0x2558)
class UAbility_103441 : public UAbility_108
{
public:
	int32                                         ProjectileIndex;                                   // 0x2558(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255C[0x4];                                     // 0x255C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103441">();
	}
	static class UAbility_103441* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103441>();
	}
};
static_assert(alignof(UAbility_103441) == 0x000008, "Wrong alignment on UAbility_103441");
static_assert(sizeof(UAbility_103441) == 0x002560, "Wrong size on UAbility_103441");
static_assert(offsetof(UAbility_103441, ProjectileIndex) == 0x002558, "Member 'UAbility_103441::ProjectileIndex' has a wrong offset!");

// Class Hero_1034.MarvelProjectileSplineComponent
// 0x0020 (0x1F90 - 0x1F70)
class UMarvelProjectileSplineComponent final : public UMarvelProjectileComponent
{
public:
	class USplineComponent*                       RelativeSplineComponent;                           // 0x1F68(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F70[0x20];                                    // 0x1F70(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelProjectileSplineComponent">();
	}
	static class UMarvelProjectileSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelProjectileSplineComponent>();
	}
};
static_assert(alignof(UMarvelProjectileSplineComponent) == 0x000010, "Wrong alignment on UMarvelProjectileSplineComponent");
static_assert(sizeof(UMarvelProjectileSplineComponent) == 0x001F90, "Wrong size on UMarvelProjectileSplineComponent");
static_assert(offsetof(UMarvelProjectileSplineComponent, RelativeSplineComponent) == 0x001F68, "Member 'UMarvelProjectileSplineComponent::RelativeSplineComponent' has a wrong offset!");

// Class Hero_1034.Projectile_10344101
// 0x0030 (0x2F90 - 0x2F60)
class AProjectile_10344101 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x2F60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileIndex;                                   // 0x2F68(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F6C[0x4];                                     // 0x2F6C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialTargetLocation;                             // 0x2F70(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F88[0x8];                                     // 0x2F88(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ProjectileIndex();
	void SetDataByProjectileIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10344101">();
	}
	static class AProjectile_10344101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10344101>();
	}
};
static_assert(alignof(AProjectile_10344101) == 0x000010, "Wrong alignment on AProjectile_10344101");
static_assert(sizeof(AProjectile_10344101) == 0x002F90, "Wrong size on AProjectile_10344101");
static_assert(offsetof(AProjectile_10344101, SplineComponent) == 0x002F60, "Member 'AProjectile_10344101::SplineComponent' has a wrong offset!");
static_assert(offsetof(AProjectile_10344101, ProjectileIndex) == 0x002F68, "Member 'AProjectile_10344101::ProjectileIndex' has a wrong offset!");
static_assert(offsetof(AProjectile_10344101, InitialTargetLocation) == 0x002F70, "Member 'AProjectile_10344101::InitialTargetLocation' has a wrong offset!");

// Class Hero_1034.Config_103449
// 0x0F98 (0x1030 - 0x0098)
class UConfig_103449 final : public UMarvelAbilityConfig
{
public:
	int32                                         MissileNumber;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnInterval;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFXSocketName;                                  // 0x00A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFXSocketName;                                 // 0x00AC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeMax;                                         // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngelDegreeRandom;                                 // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDistance;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRadius;                                      // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceParam;                                        // 0x00D0(0x0F30)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector2D                              ArcTime;                                           // 0x1000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ArcRadius;                                         // 0x1010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetPosRandomRange;                              // 0x1020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1024[0xC];                                     // 0x1024(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103449">();
	}
	static class UConfig_103449* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103449>();
	}
};
static_assert(alignof(UConfig_103449) == 0x000010, "Wrong alignment on UConfig_103449");
static_assert(sizeof(UConfig_103449) == 0x001030, "Wrong size on UConfig_103449");
static_assert(offsetof(UConfig_103449, MissileNumber) == 0x000098, "Member 'UConfig_103449::MissileNumber' has a wrong offset!");
static_assert(offsetof(UConfig_103449, SpawnInterval) == 0x00009C, "Member 'UConfig_103449::SpawnInterval' has a wrong offset!");
static_assert(offsetof(UConfig_103449, LeftFXSocketName) == 0x0000A0, "Member 'UConfig_103449::LeftFXSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_103449, RightFXSocketName) == 0x0000AC, "Member 'UConfig_103449::RightFXSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_103449, DegreeMax) == 0x0000B8, "Member 'UConfig_103449::DegreeMax' has a wrong offset!");
static_assert(offsetof(UConfig_103449, AngelDegreeRandom) == 0x0000BC, "Member 'UConfig_103449::AngelDegreeRandom' has a wrong offset!");
static_assert(offsetof(UConfig_103449, TargetDistance) == 0x0000C0, "Member 'UConfig_103449::TargetDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103449, TargetRadius) == 0x0000C4, "Member 'UConfig_103449::TargetRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103449, TraceParam) == 0x0000D0, "Member 'UConfig_103449::TraceParam' has a wrong offset!");
static_assert(offsetof(UConfig_103449, ArcTime) == 0x001000, "Member 'UConfig_103449::ArcTime' has a wrong offset!");
static_assert(offsetof(UConfig_103449, ArcRadius) == 0x001010, "Member 'UConfig_103449::ArcRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103449, TargetPosRandomRange) == 0x001020, "Member 'UConfig_103449::TargetPosRandomRange' has a wrong offset!");

// Class Hero_1034.ProjectileMovementComponent_103449
// 0x0040 (0x1FB0 - 0x1F70)
class UProjectileMovementComponent_103449 final : public UMarvelProjectileComponent
{
public:
	class AProjectile_10344901*                   OwnerProjectile;                                   // 0x1F68(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F70[0x40];                                    // 0x1F70(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileMovementComponent_103449">();
	}
	static class UProjectileMovementComponent_103449* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileMovementComponent_103449>();
	}
};
static_assert(alignof(UProjectileMovementComponent_103449) == 0x000010, "Wrong alignment on UProjectileMovementComponent_103449");
static_assert(sizeof(UProjectileMovementComponent_103449) == 0x001FB0, "Wrong size on UProjectileMovementComponent_103449");
static_assert(offsetof(UProjectileMovementComponent_103449, OwnerProjectile) == 0x001F68, "Member 'UProjectileMovementComponent_103449::OwnerProjectile' has a wrong offset!");

// Class Hero_1034.Projectile_10344901
// 0x00C0 (0x3020 - 0x2F60)
class AProjectile_10344901 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	bool                                          bStraight;                                         // 0x2F60(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F61[0x7];                                     // 0x2F61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Target;                                            // 0x2F68(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneNormal;                                       // 0x2F80(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArcEnd;                                            // 0x2F98(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArcCenter;                                         // 0x2FB0(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArcBeginDir;                                       // 0x2FC8(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArcEndDir;                                         // 0x2FE0(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArcMiddleDir;                                      // 0x2FF8(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcRadius;                                         // 0x3010(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcTime;                                           // 0x3014(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3018[0x8];                                     // 0x3018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Straight();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10344901">();
	}
	static class AProjectile_10344901* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10344901>();
	}
};
static_assert(alignof(AProjectile_10344901) == 0x000010, "Wrong alignment on AProjectile_10344901");
static_assert(sizeof(AProjectile_10344901) == 0x003020, "Wrong size on AProjectile_10344901");
static_assert(offsetof(AProjectile_10344901, bStraight) == 0x002F60, "Member 'AProjectile_10344901::bStraight' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, Target) == 0x002F68, "Member 'AProjectile_10344901::Target' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, PlaneNormal) == 0x002F80, "Member 'AProjectile_10344901::PlaneNormal' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcEnd) == 0x002F98, "Member 'AProjectile_10344901::ArcEnd' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcCenter) == 0x002FB0, "Member 'AProjectile_10344901::ArcCenter' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcBeginDir) == 0x002FC8, "Member 'AProjectile_10344901::ArcBeginDir' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcEndDir) == 0x002FE0, "Member 'AProjectile_10344901::ArcEndDir' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcMiddleDir) == 0x002FF8, "Member 'AProjectile_10344901::ArcMiddleDir' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcRadius) == 0x003010, "Member 'AProjectile_10344901::ArcRadius' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcTime) == 0x003014, "Member 'AProjectile_10344901::ArcTime' has a wrong offset!");

// Class Hero_1034.Ability_103449
// 0x0130 (0x2688 - 0x2558)
class UAbility_103449 : public UAbility_108
{
public:
	TArray<struct FVector>                        TargetDirctions;                                   // 0x2558(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UConfig_103449*                         Config103449;                                      // 0x2568(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDistance;                                    // 0x2570(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2574[0x4];                                     // 0x2574(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MainTargetPos;                                     // 0x2578(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MainTargetDir;                                     // 0x2590(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A8[0xE0];                                    // 0x25A8(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFireSucceed(class AActor* SpawnActor, const struct FGameplayAbilityTargetDataHandle& Data);
	void OnNeedSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103449">();
	}
	static class UAbility_103449* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103449>();
	}
};
static_assert(alignof(UAbility_103449) == 0x000008, "Wrong alignment on UAbility_103449");
static_assert(sizeof(UAbility_103449) == 0x002688, "Wrong size on UAbility_103449");
static_assert(offsetof(UAbility_103449, TargetDirctions) == 0x002558, "Member 'UAbility_103449::TargetDirctions' has a wrong offset!");
static_assert(offsetof(UAbility_103449, Config103449) == 0x002568, "Member 'UAbility_103449::Config103449' has a wrong offset!");
static_assert(offsetof(UAbility_103449, TargetDistance) == 0x002570, "Member 'UAbility_103449::TargetDistance' has a wrong offset!");
static_assert(offsetof(UAbility_103449, MainTargetPos) == 0x002578, "Member 'UAbility_103449::MainTargetPos' has a wrong offset!");
static_assert(offsetof(UAbility_103449, MainTargetDir) == 0x002590, "Member 'UAbility_103449::MainTargetDir' has a wrong offset!");

// Class Hero_1034.Config_103451
// 0x0070 (0x11A0 - 0x1130)
class UConfig_103451 : public UConfig_113
{
public:
	struct FGameplayTagContainer                  MissileToAddTags;                                  // 0x1130(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         EnhancedAbilityDuration;                           // 0x1198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119C[0x4];                                     // 0x119C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103451">();
	}
	static class UConfig_103451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103451>();
	}
};
static_assert(alignof(UConfig_103451) == 0x000010, "Wrong alignment on UConfig_103451");
static_assert(sizeof(UConfig_103451) == 0x0011A0, "Wrong size on UConfig_103451");
static_assert(offsetof(UConfig_103451, MissileToAddTags) == 0x001130, "Member 'UConfig_103451::MissileToAddTags' has a wrong offset!");
static_assert(offsetof(UConfig_103451, EnhancedAbilityDuration) == 0x001198, "Member 'UConfig_103451::EnhancedAbilityDuration' has a wrong offset!");

// Class Hero_1034.Ability_103451
// 0x0010 (0x27C0 - 0x27B0)
class UAbility_103451 : public UAbility_113
{
public:
	uint8                                         Pad_27B0[0x8];                                     // 0x27B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_WaitAbilityActivate*       WaitUltimateActivateTask;                          // 0x27B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnExitNanoState(const struct FGameplayEventData& Payload);
	void OnUltimateAbilityActivate(class UGameplayAbility* Ability);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103451">();
	}
	static class UAbility_103451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103451>();
	}
};
static_assert(alignof(UAbility_103451) == 0x000008, "Wrong alignment on UAbility_103451");
static_assert(sizeof(UAbility_103451) == 0x0027C0, "Wrong size on UAbility_103451");
static_assert(offsetof(UAbility_103451, WaitUltimateActivateTask) == 0x0027B8, "Member 'UAbility_103451::WaitUltimateActivateTask' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Loop_10345101
// 0x00A0 (0x0EA0 - 0x0E00)
class ACue_Ability_Loop_10345101 final : public AMarvelCueNotify_Ability
{
public:
	int32                                         AbilityID;                                         // 0x0E00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E04[0x4];                                      // 0x0E04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCueHintData                           HintData;                                          // 0x0E08(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10345101">();
	}
	static class ACue_Ability_Loop_10345101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10345101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10345101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10345101");
static_assert(sizeof(ACue_Ability_Loop_10345101) == 0x000EA0, "Wrong size on ACue_Ability_Loop_10345101");
static_assert(offsetof(ACue_Ability_Loop_10345101, AbilityID) == 0x000E00, "Member 'ACue_Ability_Loop_10345101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345101, HintData) == 0x000E08, "Member 'ACue_Ability_Loop_10345101::HintData' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Loop_10345103
// 0x0060 (0x1070 - 0x1010)
class ACue_Ability_Loop_10345103 final : public ACue_Ability_Loop_10340101
{
public:
	class UNiagaraComponent*                      LoopNS_FootFxNanoL;                                // 0x1010(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FootFxNanoR;                                // 0x1018(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandFxNanoL;                                // 0x1020(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandFxNanoR;                                // 0x1028(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FloatFxNanoL;                               // 0x1030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FloatFxNanoR;                               // 0x1038(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FootFxNanoL;                      // 0x1040(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FootFxNanoR;                      // 0x1048(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_HandFxNanoL;                      // 0x1050(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_HandFxNanoR;                      // 0x1058(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FloatFxNanoL;                     // 0x1060(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FloatFxNanoR;                     // 0x1068(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10345103">();
	}
	static class ACue_Ability_Loop_10345103* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10345103>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10345103) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10345103");
static_assert(sizeof(ACue_Ability_Loop_10345103) == 0x001070, "Wrong size on ACue_Ability_Loop_10345103");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_FootFxNanoL) == 0x001010, "Member 'ACue_Ability_Loop_10345103::LoopNS_FootFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_FootFxNanoR) == 0x001018, "Member 'ACue_Ability_Loop_10345103::LoopNS_FootFxNanoR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_HandFxNanoL) == 0x001020, "Member 'ACue_Ability_Loop_10345103::LoopNS_HandFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_HandFxNanoR) == 0x001028, "Member 'ACue_Ability_Loop_10345103::LoopNS_HandFxNanoR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_FloatFxNanoL) == 0x001030, "Member 'ACue_Ability_Loop_10345103::LoopNS_FloatFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_FloatFxNanoR) == 0x001038, "Member 'ACue_Ability_Loop_10345103::LoopNS_FloatFxNanoR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_FootFxNanoL) == 0x001040, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_FootFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_FootFxNanoR) == 0x001048, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_FootFxNanoR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_HandFxNanoL) == 0x001050, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_HandFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_HandFxNanoR) == 0x001058, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_HandFxNanoR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_FloatFxNanoL) == 0x001060, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_FloatFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_FloatFxNanoR) == 0x001068, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_FloatFxNanoR' has a wrong offset!");

// Class Hero_1034.Config_103452
// 0x0010 (0x00A8 - 0x0098)
class UConfig_103452 final : public UMarvelAbilityConfig
{
public:
	TArray<struct FStateBasedTimelineSpec>        StateBasedTimelineSpecs;                           // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103452">();
	}
	static class UConfig_103452* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103452>();
	}
};
static_assert(alignof(UConfig_103452) == 0x000008, "Wrong alignment on UConfig_103452");
static_assert(sizeof(UConfig_103452) == 0x0000A8, "Wrong size on UConfig_103452");
static_assert(offsetof(UConfig_103452, StateBasedTimelineSpecs) == 0x000098, "Member 'UConfig_103452::StateBasedTimelineSpecs' has a wrong offset!");

// Class Hero_1034.Ability_103452
// 0x0000 (0x2558 - 0x2558)
class UAbility_103452 : public UAbility_108
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103452">();
	}
	static class UAbility_103452* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103452>();
	}
};
static_assert(alignof(UAbility_103452) == 0x000008, "Wrong alignment on UAbility_103452");
static_assert(sizeof(UAbility_103452) == 0x002558, "Wrong size on UAbility_103452");

// Class Hero_1034.Config_103454
// 0x0010 (0x11B0 - 0x11A0)
class UConfig_103454 final : public UConfig_103451
{
public:
	int32                                         ConsumeBuffWhenEndAbility;                         // 0x11A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A4[0xC];                                     // 0x11A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103454">();
	}
	static class UConfig_103454* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103454>();
	}
};
static_assert(alignof(UConfig_103454) == 0x000010, "Wrong alignment on UConfig_103454");
static_assert(sizeof(UConfig_103454) == 0x0011B0, "Wrong size on UConfig_103454");
static_assert(offsetof(UConfig_103454, ConsumeBuffWhenEndAbility) == 0x0011A0, "Member 'UConfig_103454::ConsumeBuffWhenEndAbility' has a wrong offset!");

// Class Hero_1034.Ability_103454
// 0x0000 (0x27C0 - 0x27C0)
class UAbility_103454 : public UAbility_103451
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103454">();
	}
	static class UAbility_103454* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103454>();
	}
};
static_assert(alignof(UAbility_103454) == 0x000008, "Wrong alignment on UAbility_103454");
static_assert(sizeof(UAbility_103454) == 0x0027C0, "Wrong size on UAbility_103454");

// Class Hero_1034.Config_103461
// 0x0000 (0x0098 - 0x0098)
class UConfig_103461 final : public UMarvelAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103461">();
	}
	static class UConfig_103461* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103461>();
	}
};
static_assert(alignof(UConfig_103461) == 0x000008, "Wrong alignment on UConfig_103461");
static_assert(sizeof(UConfig_103461) == 0x000098, "Wrong size on UConfig_103461");

// Class Hero_1034.Ability_103461
// 0x0000 (0x2558 - 0x2558)
class UAbility_103461 : public UAbility_108
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103461">();
	}
	static class UAbility_103461* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103461>();
	}
};
static_assert(alignof(UAbility_103461) == 0x000008, "Wrong alignment on UAbility_103461");
static_assert(sizeof(UAbility_103461) == 0x002558, "Wrong size on UAbility_103461");

// Class Hero_1034.TraceComponent_10346101
// 0x0000 (0x16B0 - 0x16B0)
class UTraceComponent_10346101 final : public UMarvelAgentTraceComponent
{
public:
	void OnApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10346101">();
	}
	static class UTraceComponent_10346101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10346101>();
	}
};
static_assert(alignof(UTraceComponent_10346101) == 0x000010, "Wrong alignment on UTraceComponent_10346101");
static_assert(sizeof(UTraceComponent_10346101) == 0x0016B0, "Wrong size on UTraceComponent_10346101");

// Class Hero_1034.Projectile_10346101
// 0x0000 (0x2F60 - 0x2F60)
class AProjectile_10346101 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10346101">();
	}
	static class AProjectile_10346101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10346101>();
	}
};
static_assert(alignof(AProjectile_10346101) == 0x000010, "Wrong alignment on AProjectile_10346101");
static_assert(sizeof(AProjectile_10346101) == 0x002F60, "Wrong size on AProjectile_10346101");

// Class Hero_1034.Cue_Ability_Loop_10346101
// 0x0008 (0x0E08 - 0x0E00)
class ACue_Ability_Loop_10346101 final : public AMarvelCueNotify_Ability
{
public:
	class USkeletalMeshComponent*                 WeaponMesh;                                        // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10346101">();
	}
	static class ACue_Ability_Loop_10346101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10346101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10346101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10346101");
static_assert(sizeof(ACue_Ability_Loop_10346101) == 0x000E08, "Wrong size on ACue_Ability_Loop_10346101");
static_assert(offsetof(ACue_Ability_Loop_10346101, WeaponMesh) == 0x000E00, "Member 'ACue_Ability_Loop_10346101::WeaponMesh' has a wrong offset!");

// Class Hero_1034.Cue_Instant_HitImpact_10346101
// 0x0050 (0x0520 - 0x04D0)
class UCue_Instant_HitImpact_10346101 final : public UMarvelCueNotify_HitImpact
{
public:
	struct FCueNiagaraInfo_Custom                 CustomHitNiagaraInfo;                              // 0x04D0(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         GroundHiddenZThreshold;                            // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomHitNiagaraSpawned(class UNiagaraComponent* InNiagaraComponent, class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Instant_HitImpact_10346101">();
	}
	static class UCue_Instant_HitImpact_10346101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Instant_HitImpact_10346101>();
	}
};
static_assert(alignof(UCue_Instant_HitImpact_10346101) == 0x000008, "Wrong alignment on UCue_Instant_HitImpact_10346101");
static_assert(sizeof(UCue_Instant_HitImpact_10346101) == 0x000520, "Wrong size on UCue_Instant_HitImpact_10346101");
static_assert(offsetof(UCue_Instant_HitImpact_10346101, CustomHitNiagaraInfo) == 0x0004D0, "Member 'UCue_Instant_HitImpact_10346101::CustomHitNiagaraInfo' has a wrong offset!");
static_assert(offsetof(UCue_Instant_HitImpact_10346101, GroundHiddenZThreshold) == 0x000518, "Member 'UCue_Instant_HitImpact_10346101::GroundHiddenZThreshold' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Instant_10346101
// 0x0008 (0x0370 - 0x0368)
class UCue_Ability_Instant_10346101 final : public UMarvelCueNotify_Base
{
public:
	int32                                         NanoAudioID;                                       // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalAudioID;                                     // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Instant_10346101">();
	}
	static class UCue_Ability_Instant_10346101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Ability_Instant_10346101>();
	}
};
static_assert(alignof(UCue_Ability_Instant_10346101) == 0x000008, "Wrong alignment on UCue_Ability_Instant_10346101");
static_assert(sizeof(UCue_Ability_Instant_10346101) == 0x000370, "Wrong size on UCue_Ability_Instant_10346101");
static_assert(offsetof(UCue_Ability_Instant_10346101, NanoAudioID) == 0x000368, "Member 'UCue_Ability_Instant_10346101::NanoAudioID' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10346101, NormalAudioID) == 0x00036C, "Member 'UCue_Ability_Instant_10346101::NormalAudioID' has a wrong offset!");

// Class Hero_1034.IronManAnimInstance
// 0x00C0 (0x09C0 - 0x0900)
class UIronManAnimInstance final : public UMarvelAnimInstance
{
public:
	float                                         FlyTransitionTime;                                 // 0x0900(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ADControlAnimFactor;                               // 0x0904(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DirAnimCurveX;                                     // 0x0908(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DirAnimCurveY;                                     // 0x0910(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AccCurveY;                                         // 0x0918(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AccCurveZ;                                         // 0x0920(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AbilityTag103431;                                  // 0x0928(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AbilityTag103439;                                  // 0x0934(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CustomLandAbilityTag;                              // 0x0940(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94C[0x4];                                      // 0x094C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LandSequence;                                      // 0x0950(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          LandSequenceAbility;                               // 0x0958(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            LandLean2D;                                        // 0x0960(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomLand;                                    // 0x0968(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFly;                                              // 0x0969(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndFlyComplete;                                   // 0x096A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_96B[0x1];                                      // 0x096B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraForwardPitch;                                // 0x096C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFlyStartTransition;                               // 0x0970(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsNanoWeapon;                                     // 0x0971(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_972[0x6];                                      // 0x0972(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpringArmSocketOffset;                             // 0x0978(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_990[0x30];                                     // 0x0990(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManAnimInstance">();
	}
	static class UIronManAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIronManAnimInstance>();
	}
};
static_assert(alignof(UIronManAnimInstance) == 0x000010, "Wrong alignment on UIronManAnimInstance");
static_assert(sizeof(UIronManAnimInstance) == 0x0009C0, "Wrong size on UIronManAnimInstance");
static_assert(offsetof(UIronManAnimInstance, FlyTransitionTime) == 0x000900, "Member 'UIronManAnimInstance::FlyTransitionTime' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, ADControlAnimFactor) == 0x000904, "Member 'UIronManAnimInstance::ADControlAnimFactor' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, DirAnimCurveX) == 0x000908, "Member 'UIronManAnimInstance::DirAnimCurveX' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, DirAnimCurveY) == 0x000910, "Member 'UIronManAnimInstance::DirAnimCurveY' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, AccCurveY) == 0x000918, "Member 'UIronManAnimInstance::AccCurveY' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, AccCurveZ) == 0x000920, "Member 'UIronManAnimInstance::AccCurveZ' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, AbilityTag103431) == 0x000928, "Member 'UIronManAnimInstance::AbilityTag103431' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, AbilityTag103439) == 0x000934, "Member 'UIronManAnimInstance::AbilityTag103439' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, CustomLandAbilityTag) == 0x000940, "Member 'UIronManAnimInstance::CustomLandAbilityTag' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, LandSequence) == 0x000950, "Member 'UIronManAnimInstance::LandSequence' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, LandSequenceAbility) == 0x000958, "Member 'UIronManAnimInstance::LandSequenceAbility' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, LandLean2D) == 0x000960, "Member 'UIronManAnimInstance::LandLean2D' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, bUseCustomLand) == 0x000968, "Member 'UIronManAnimInstance::bUseCustomLand' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, bFly) == 0x000969, "Member 'UIronManAnimInstance::bFly' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, bEndFlyComplete) == 0x00096A, "Member 'UIronManAnimInstance::bEndFlyComplete' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, CameraForwardPitch) == 0x00096C, "Member 'UIronManAnimInstance::CameraForwardPitch' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, bFlyStartTransition) == 0x000970, "Member 'UIronManAnimInstance::bFlyStartTransition' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, bIsNanoWeapon) == 0x000971, "Member 'UIronManAnimInstance::bIsNanoWeapon' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, SpringArmSocketOffset) == 0x000978, "Member 'UIronManAnimInstance::SpringArmSocketOffset' has a wrong offset!");

// Class Hero_1034.IronManFlyMotionAnimInstance
// 0x0030 (0x0450 - 0x0420)
class UIronManFlyMotionAnimInstance final : public UAnimInstance
{
public:
	bool                                          bFly;                                              // 0x0418(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartFly;                                         // 0x0419(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41A[0x6];                                      // 0x041A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InterpAirVeloctiy;                                 // 0x0420(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraForwardRot;                                  // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyTransitionStartAlpha;                           // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            FlyBS2D;                                           // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FlyStopAnimSequence;                               // 0x0448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManFlyMotionAnimInstance">();
	}
	static class UIronManFlyMotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIronManFlyMotionAnimInstance>();
	}
};
static_assert(alignof(UIronManFlyMotionAnimInstance) == 0x000010, "Wrong alignment on UIronManFlyMotionAnimInstance");
static_assert(sizeof(UIronManFlyMotionAnimInstance) == 0x000450, "Wrong size on UIronManFlyMotionAnimInstance");
static_assert(offsetof(UIronManFlyMotionAnimInstance, bFly) == 0x000418, "Member 'UIronManFlyMotionAnimInstance::bFly' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, bStartFly) == 0x000419, "Member 'UIronManFlyMotionAnimInstance::bStartFly' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, InterpAirVeloctiy) == 0x000420, "Member 'UIronManFlyMotionAnimInstance::InterpAirVeloctiy' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, CameraForwardRot) == 0x000438, "Member 'UIronManFlyMotionAnimInstance::CameraForwardRot' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, FlyTransitionStartAlpha) == 0x00043C, "Member 'UIronManFlyMotionAnimInstance::FlyTransitionStartAlpha' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, FlyBS2D) == 0x000440, "Member 'UIronManFlyMotionAnimInstance::FlyBS2D' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, FlyStopAnimSequence) == 0x000448, "Member 'UIronManFlyMotionAnimInstance::FlyStopAnimSequence' has a wrong offset!");

// Class Hero_1034.IronManCharacter
// 0x0030 (0x17F0 - 0x17C0)
class AIronManCharacter : public AMarvelBaseCharacter
{
public:
	class USceneCaptureComponent2D*               SceneCapComponent2D;                               // 0x17B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelMultiCapsuleComponent*           BodyLeanCollision;                                 // 0x17C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             NanoStateTimeoutDispatcher;                        // 0x17C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIronManShiftFlyDistanceDispatcher;               // 0x17D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UIronManMoveLogicBaseComponent*         IronManMoveLogic;                                  // 0x17E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManCharacter">();
	}
	static class AIronManCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIronManCharacter>();
	}
};
static_assert(alignof(AIronManCharacter) == 0x000010, "Wrong alignment on AIronManCharacter");
static_assert(sizeof(AIronManCharacter) == 0x0017F0, "Wrong size on AIronManCharacter");
static_assert(offsetof(AIronManCharacter, SceneCapComponent2D) == 0x0017B8, "Member 'AIronManCharacter::SceneCapComponent2D' has a wrong offset!");
static_assert(offsetof(AIronManCharacter, BodyLeanCollision) == 0x0017C0, "Member 'AIronManCharacter::BodyLeanCollision' has a wrong offset!");
static_assert(offsetof(AIronManCharacter, NanoStateTimeoutDispatcher) == 0x0017C8, "Member 'AIronManCharacter::NanoStateTimeoutDispatcher' has a wrong offset!");
static_assert(offsetof(AIronManCharacter, OnIronManShiftFlyDistanceDispatcher) == 0x0017D8, "Member 'AIronManCharacter::OnIronManShiftFlyDistanceDispatcher' has a wrong offset!");
static_assert(offsetof(AIronManCharacter, IronManMoveLogic) == 0x0017E8, "Member 'AIronManCharacter::IronManMoveLogic' has a wrong offset!");

// Class Hero_1034.IronManChildActor
// 0x0040 (0x0A80 - 0x0A40)
class AIronManChildActor : public AMarvelCharacterChildActor
{
public:
	bool                                          bFly;                                              // 0x0A40(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A41[0x7];                                      // 0x0A41(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpringArmSocketOffsetForShift;                     // 0x0A48(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshSlotGroupAssetUserData*            MeshSlotGroup;                                     // 0x0A60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A68[0x18];                                     // 0x0A68(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManChildActor">();
	}
	static class AIronManChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIronManChildActor>();
	}
};
static_assert(alignof(AIronManChildActor) == 0x000008, "Wrong alignment on AIronManChildActor");
static_assert(sizeof(AIronManChildActor) == 0x000A80, "Wrong size on AIronManChildActor");
static_assert(offsetof(AIronManChildActor, bFly) == 0x000A40, "Member 'AIronManChildActor::bFly' has a wrong offset!");
static_assert(offsetof(AIronManChildActor, SpringArmSocketOffsetForShift) == 0x000A48, "Member 'AIronManChildActor::SpringArmSocketOffsetForShift' has a wrong offset!");
static_assert(offsetof(AIronManChildActor, MeshSlotGroup) == 0x000A60, "Member 'AIronManChildActor::MeshSlotGroup' has a wrong offset!");

// Class Hero_1034.IronManSpringArmComponent
// 0x00A0 (0x1180 - 0x10E0)
class UIronManSpringArmComponent final : public UMarvelComposerSpringArmComponent
{
public:
	struct FVector2D                              RotFactor;                                         // 0x10D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SocketOffsetTargetY;                               // 0x10E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10EC[0x4];                                     // 0x10EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MouseRecoverSpeed;                                 // 0x10F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseOffsetFactor;                                 // 0x1100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputToOffsetScale;                                // 0x1110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOffset;                                           // 0x1114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DOffset;                                           // 0x1118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseInterpSpeed;                                  // 0x111C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShiftFlySocketOffsetInterpSpeed;                   // 0x1120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringBackDelay;                                   // 0x1124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InputCameraThreshold;                              // 0x1128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1138[0x20];                                    // 0x1138(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TargetMouseInput;                                  // 0x1158(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1168[0x18];                                    // 0x1168(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManSpringArmComponent">();
	}
	static class UIronManSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIronManSpringArmComponent>();
	}
};
static_assert(alignof(UIronManSpringArmComponent) == 0x000010, "Wrong alignment on UIronManSpringArmComponent");
static_assert(sizeof(UIronManSpringArmComponent) == 0x001180, "Wrong size on UIronManSpringArmComponent");
static_assert(offsetof(UIronManSpringArmComponent, RotFactor) == 0x0010D8, "Member 'UIronManSpringArmComponent::RotFactor' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, SocketOffsetTargetY) == 0x0010E8, "Member 'UIronManSpringArmComponent::SocketOffsetTargetY' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, MouseRecoverSpeed) == 0x0010F0, "Member 'UIronManSpringArmComponent::MouseRecoverSpeed' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, MouseOffsetFactor) == 0x001100, "Member 'UIronManSpringArmComponent::MouseOffsetFactor' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, InputToOffsetScale) == 0x001110, "Member 'UIronManSpringArmComponent::InputToOffsetScale' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, AOffset) == 0x001114, "Member 'UIronManSpringArmComponent::AOffset' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, DOffset) == 0x001118, "Member 'UIronManSpringArmComponent::DOffset' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, MouseInterpSpeed) == 0x00111C, "Member 'UIronManSpringArmComponent::MouseInterpSpeed' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, ShiftFlySocketOffsetInterpSpeed) == 0x001120, "Member 'UIronManSpringArmComponent::ShiftFlySocketOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, SpringBackDelay) == 0x001124, "Member 'UIronManSpringArmComponent::SpringBackDelay' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, InputCameraThreshold) == 0x001128, "Member 'UIronManSpringArmComponent::InputCameraThreshold' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, TargetMouseInput) == 0x001158, "Member 'UIronManSpringArmComponent::TargetMouseInput' has a wrong offset!");

// Class Hero_1034.IronManMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UIronManMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManMoveLogicBaseComponent">();
	}
	static class UIronManMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIronManMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UIronManMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UIronManMoveLogicBaseComponent");
static_assert(sizeof(UIronManMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UIronManMoveLogicBaseComponent");

// Class Hero_1034.IronManMovementComponent
// 0x0010 (0x1B00 - 0x1AF0)
class UIronManMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	uint8                                         Pad_1AF0[0x10];                                    // 0x1AF0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManMovementComponent">();
	}
	static class UIronManMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIronManMovementComponent>();
	}
};
static_assert(alignof(UIronManMovementComponent) == 0x000010, "Wrong alignment on UIronManMovementComponent");
static_assert(sizeof(UIronManMovementComponent) == 0x001B00, "Wrong size on UIronManMovementComponent");

// Class Hero_1034.NanoAbilityStatics
// 0x0000 (0x0030 - 0x0030)
class UNanoAbilityStatics final : public UBlueprintFunctionLibrary
{
public:
	static struct FGameplayTagContainer GetNanoCanActivateTags();
	static struct FGameplayTagContainer GetNanoWeaponTags();
	static bool HasAnyNanoCanActivateTags(const class UAbilitySystemComponent* ASC);
	static bool HasAnyNanoWeaponTags(const class UAbilitySystemComponent* ASC);
	static bool IsNanoWeaponTags(const struct FGameplayTag& InTag);
	static bool RemoveAllNanoCanActivateTags(class UAbilitySystemComponent* ASC);
	static bool RemoveAllNanoWeaponTags(class UAbilitySystemComponent* ASC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NanoAbilityStatics">();
	}
	static class UNanoAbilityStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNanoAbilityStatics>();
	}
};
static_assert(alignof(UNanoAbilityStatics) == 0x000008, "Wrong alignment on UNanoAbilityStatics");
static_assert(sizeof(UNanoAbilityStatics) == 0x000030, "Wrong size on UNanoAbilityStatics");

}

