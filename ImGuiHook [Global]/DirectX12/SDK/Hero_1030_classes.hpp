#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1030

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Hero_1030_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "Hero_1026_structs.hpp"


namespace SDK
{

// Class Hero_1030.Config_103021
// 0x0FE8 (0x10B0 - 0x00C8)
class UConfig_103021 final : public UConfig_106
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProjectileConductInfo                 ConductInfo;                                       // 0x00D0(0x0FD0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         TargetBuffID;                                      // 0x10A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnkaSummonerID;                                    // 0x10A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnhancedAnkaSummonedID;                            // 0x10A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10AC[0x4];                                     // 0x10AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103021">();
	}
	static class UConfig_103021* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103021>();
	}
};
static_assert(alignof(UConfig_103021) == 0x000010, "Wrong alignment on UConfig_103021");
static_assert(sizeof(UConfig_103021) == 0x0010B0, "Wrong size on UConfig_103021");
static_assert(offsetof(UConfig_103021, ConductInfo) == 0x0000D0, "Member 'UConfig_103021::ConductInfo' has a wrong offset!");
static_assert(offsetof(UConfig_103021, TargetBuffID) == 0x0010A0, "Member 'UConfig_103021::TargetBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103021, AnkaSummonerID) == 0x0010A4, "Member 'UConfig_103021::AnkaSummonerID' has a wrong offset!");
static_assert(offsetof(UConfig_103021, EnhancedAnkaSummonedID) == 0x0010A8, "Member 'UConfig_103021::EnhancedAnkaSummonedID' has a wrong offset!");

// Class Hero_1030.ProjectileConductBase
// 0x0FF0 (0x3F50 - 0x2F60)
class AProjectileConductBase : public AMarvelAbilityTargetActor_Projectile
{
public:
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x2F60(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103021*                         AbilityConfig;                                     // 0x2F68(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F70[0x10];                                    // 0x2F70(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class AActor>, int32>     ConductedTargets;                                  // 0x2F80(0x0050)(Transient, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  LastTarget;                                        // 0x2FD0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HomingTarget;                                      // 0x2FD8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HomingSource;                                      // 0x2FE0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       AbsorbedMovingComponent;                           // 0x2FE8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FF0[0x18];                                    // 0x2FF0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PendingAbsorbedAnka;                               // 0x3008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3010[0xF40];                                   // 0x3010(0x0F40)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void RemoteProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileConductBase">();
	}
	static class AProjectileConductBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileConductBase>();
	}
};
static_assert(alignof(AProjectileConductBase) == 0x000010, "Wrong alignment on AProjectileConductBase");
static_assert(sizeof(AProjectileConductBase) == 0x003F50, "Wrong size on AProjectileConductBase");
static_assert(offsetof(AProjectileConductBase, OwnerCharacter) == 0x002F60, "Member 'AProjectileConductBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, AbilityConfig) == 0x002F68, "Member 'AProjectileConductBase::AbilityConfig' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, ConductedTargets) == 0x002F80, "Member 'AProjectileConductBase::ConductedTargets' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, LastTarget) == 0x002FD0, "Member 'AProjectileConductBase::LastTarget' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, HomingTarget) == 0x002FD8, "Member 'AProjectileConductBase::HomingTarget' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, HomingSource) == 0x002FE0, "Member 'AProjectileConductBase::HomingSource' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, AbsorbedMovingComponent) == 0x002FE8, "Member 'AProjectileConductBase::AbsorbedMovingComponent' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, PendingAbsorbedAnka) == 0x003008, "Member 'AProjectileConductBase::PendingAbsorbedAnka' has a wrong offset!");

// Class Hero_1030.Projectile_10302101
// 0x0000 (0x3F50 - 0x3F50)
class AProjectile_10302101 : public AProjectileConductBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10302101">();
	}
	static class AProjectile_10302101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10302101>();
	}
};
static_assert(alignof(AProjectile_10302101) == 0x000010, "Wrong alignment on AProjectile_10302101");
static_assert(sizeof(AProjectile_10302101) == 0x003F50, "Wrong size on AProjectile_10302101");

// Class Hero_1030.ConductProjectileMovement
// 0x0000 (0x1F70 - 0x1F70)
class UConductProjectileMovement final : public UMarvelProjectileComponent
{
public:
	float                                         DeltaRadius;                                       // 0x1F68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncTargetPoint;                                  // 0x1F6C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F6D[0x3];                                     // 0x1F6D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConductProjectileMovement">();
	}
	static class UConductProjectileMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConductProjectileMovement>();
	}
};
static_assert(alignof(UConductProjectileMovement) == 0x000010, "Wrong alignment on UConductProjectileMovement");
static_assert(sizeof(UConductProjectileMovement) == 0x001F70, "Wrong size on UConductProjectileMovement");
static_assert(offsetof(UConductProjectileMovement, DeltaRadius) == 0x001F68, "Member 'UConductProjectileMovement::DeltaRadius' has a wrong offset!");
static_assert(offsetof(UConductProjectileMovement, bSyncTargetPoint) == 0x001F6C, "Member 'UConductProjectileMovement::bSyncTargetPoint' has a wrong offset!");

// Class Hero_1030.Ability_103031
// 0x0000 (0x2550 - 0x2550)
class UAbility_103031 final : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103031">();
	}
	static class UAbility_103031* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103031>();
	}
};
static_assert(alignof(UAbility_103031) == 0x000008, "Wrong alignment on UAbility_103031");
static_assert(sizeof(UAbility_103031) == 0x002550, "Wrong size on UAbility_103031");

// Class Hero_1030.Cue_Ability_Loop_10303101
// 0x0008 (0x0E08 - 0x0E00)
class ACue_Ability_Loop_10303101 final : public AMarvelCueNotify_Ability
{
public:
	class USkeletalMeshComponent*                 MoonWeaponMesh;                                    // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10303101">();
	}
	static class ACue_Ability_Loop_10303101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10303101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10303101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10303101");
static_assert(sizeof(ACue_Ability_Loop_10303101) == 0x000E08, "Wrong size on ACue_Ability_Loop_10303101");
static_assert(offsetof(ACue_Ability_Loop_10303101, MoonWeaponMesh) == 0x000E00, "Member 'ACue_Ability_Loop_10303101::MoonWeaponMesh' has a wrong offset!");

// Class Hero_1030.Config_103041
// 0x0FD8 (0x1070 - 0x0098)
class UConfig_103041 final : public UMarvelAbilityConfig
{
public:
	TArray<int32>                                 SummonerDontSpawnAnka;                             // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         WallTraceDepth;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetOutsideWall;                                 // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetInsideWall;                                  // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00C0(0x0F30)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         AnkaSummonerID;                                    // 0x0FF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageScopeID;                                     // 0x0FF4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldBuffID;                                      // 0x0FF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorPerTarget;                                    // 0x0FFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AddShieldTags;                                     // 0x1000(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1068[0x8];                                     // 0x1068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103041">();
	}
	static class UConfig_103041* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103041>();
	}
};
static_assert(alignof(UConfig_103041) == 0x000010, "Wrong alignment on UConfig_103041");
static_assert(sizeof(UConfig_103041) == 0x001070, "Wrong size on UConfig_103041");
static_assert(offsetof(UConfig_103041, SummonerDontSpawnAnka) == 0x000098, "Member 'UConfig_103041::SummonerDontSpawnAnka' has a wrong offset!");
static_assert(offsetof(UConfig_103041, WallTraceDepth) == 0x0000A8, "Member 'UConfig_103041::WallTraceDepth' has a wrong offset!");
static_assert(offsetof(UConfig_103041, OffsetOutsideWall) == 0x0000AC, "Member 'UConfig_103041::OffsetOutsideWall' has a wrong offset!");
static_assert(offsetof(UConfig_103041, OffsetInsideWall) == 0x0000B0, "Member 'UConfig_103041::OffsetInsideWall' has a wrong offset!");
static_assert(offsetof(UConfig_103041, TraceContext) == 0x0000C0, "Member 'UConfig_103041::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103041, AnkaSummonerID) == 0x000FF0, "Member 'UConfig_103041::AnkaSummonerID' has a wrong offset!");
static_assert(offsetof(UConfig_103041, DamageScopeID) == 0x000FF4, "Member 'UConfig_103041::DamageScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103041, ShieldBuffID) == 0x000FF8, "Member 'UConfig_103041::ShieldBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103041, ArmorPerTarget) == 0x000FFC, "Member 'UConfig_103041::ArmorPerTarget' has a wrong offset!");
static_assert(offsetof(UConfig_103041, AddShieldTags) == 0x001000, "Member 'UConfig_103041::AddShieldTags' has a wrong offset!");

// Class Hero_1030.Projectile_10304101
// 0x0170 (0x30D0 - 0x2F60)
class AProjectile_10304101 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	class UConfig_103041*                         AbilityConfig;                                     // 0x2F60(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F68[0x168];                                   // 0x2F68(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10304101">();
	}
	static class AProjectile_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10304101>();
	}
};
static_assert(alignof(AProjectile_10304101) == 0x000010, "Wrong alignment on AProjectile_10304101");
static_assert(sizeof(AProjectile_10304101) == 0x0030D0, "Wrong size on AProjectile_10304101");
static_assert(offsetof(AProjectile_10304101, AbilityConfig) == 0x002F60, "Member 'AProjectile_10304101::AbilityConfig' has a wrong offset!");

// Class Hero_1030.NotTreatFallAbility_10304101
// 0x0008 (0x1268 - 0x1260)
class UNotTreatFallAbility_10304101 : public UMarvelNotTreatFallAbility
{
public:
	class UConfig_103041*                         AbilityConfig;                                     // 0x1260(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotTreatFallAbility_10304101">();
	}
	static class UNotTreatFallAbility_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotTreatFallAbility_10304101>();
	}
};
static_assert(alignof(UNotTreatFallAbility_10304101) == 0x000008, "Wrong alignment on UNotTreatFallAbility_10304101");
static_assert(sizeof(UNotTreatFallAbility_10304101) == 0x001268, "Wrong size on UNotTreatFallAbility_10304101");
static_assert(offsetof(UNotTreatFallAbility_10304101, AbilityConfig) == 0x001260, "Member 'UNotTreatFallAbility_10304101::AbilityConfig' has a wrong offset!");

// Class Hero_1030.Summoned_10304101
// 0x0000 (0x0800 - 0x0800)
class ASummoned_10304101 : public AMarvelSummonerBase
{
public:
	class UMeshHiddenComponent*                   HiddenComponent;                                   // 0x07F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10304101">();
	}
	static class ASummoned_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10304101>();
	}
};
static_assert(alignof(ASummoned_10304101) == 0x000010, "Wrong alignment on ASummoned_10304101");
static_assert(sizeof(ASummoned_10304101) == 0x000800, "Wrong size on ASummoned_10304101");
static_assert(offsetof(ASummoned_10304101, HiddenComponent) == 0x0007F8, "Member 'ASummoned_10304101::HiddenComponent' has a wrong offset!");

// Class Hero_1030.SummonedComp_10304101
// 0x0010 (0x0CA0 - 0x0C90)
class USummonedComp_10304101 final : public UMarvelSummonedComponent
{
public:
	uint8                                         Pad_C88[0x18];                                     // 0x0C88(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10304101">();
	}
	static class USummonedComp_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10304101>();
	}
};
static_assert(alignof(USummonedComp_10304101) == 0x000010, "Wrong alignment on USummonedComp_10304101");
static_assert(sizeof(USummonedComp_10304101) == 0x000CA0, "Wrong size on USummonedComp_10304101");

// Class Hero_1030.Scope_10304102
// 0x0010 (0x16D0 - 0x16C0)
class AScope_10304102 final : public AMarvelAbilityTargetActor_Scope
{
public:
	uint8                                         Pad_16C0[0x10];                                    // 0x16C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void OnCharacterDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10304102">();
	}
	static class AScope_10304102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10304102>();
	}
};
static_assert(alignof(AScope_10304102) == 0x000010, "Wrong alignment on AScope_10304102");
static_assert(sizeof(AScope_10304102) == 0x0016D0, "Wrong size on AScope_10304102");

// Class Hero_1030.ScopeManager_10304102
// 0x0050 (0x0080 - 0x0030)
class UScopeManager_10304102 final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector DoCondition(class AActor* InActor, const struct FVector& Delta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScopeManager_10304102">();
	}
	static class UScopeManager_10304102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScopeManager_10304102>();
	}
};
static_assert(alignof(UScopeManager_10304102) == 0x000008, "Wrong alignment on UScopeManager_10304102");
static_assert(sizeof(UScopeManager_10304102) == 0x000080, "Wrong size on UScopeManager_10304102");

// Class Hero_1030.Cue_Buff_10304101
// 0x00A0 (0x1088 - 0x0FE8)
class ACue_Buff_10304101 final : public AMarvelCueNotify_Buff
{
public:
	class UFXSystemAsset*                         LineEffectPartOne;                                 // 0x0FE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         LineEffectPartTwo;                                 // 0x0FF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFxMaterialsCurve                      ColorMaterial;                                     // 0x0FF8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFxMaterialsCurve                      GoldColorMaterial;                                 // 0x1030(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         LightDuration;                                     // 0x1068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_106C[0x4];                                     // 0x106C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x1070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1078[0x10];                                    // 0x1078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10304101">();
	}
	static class ACue_Buff_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10304101>();
	}
};
static_assert(alignof(ACue_Buff_10304101) == 0x000008, "Wrong alignment on ACue_Buff_10304101");
static_assert(sizeof(ACue_Buff_10304101) == 0x001088, "Wrong size on ACue_Buff_10304101");
static_assert(offsetof(ACue_Buff_10304101, LineEffectPartOne) == 0x000FE8, "Member 'ACue_Buff_10304101::LineEffectPartOne' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, LineEffectPartTwo) == 0x000FF0, "Member 'ACue_Buff_10304101::LineEffectPartTwo' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, ColorMaterial) == 0x000FF8, "Member 'ACue_Buff_10304101::ColorMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, GoldColorMaterial) == 0x001030, "Member 'ACue_Buff_10304101::GoldColorMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, LightDuration) == 0x001068, "Member 'ACue_Buff_10304101::LightDuration' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, OwnerCharacter) == 0x001070, "Member 'ACue_Buff_10304101::OwnerCharacter' has a wrong offset!");

// Class Hero_1030.Cue_Summoner_Loop_10304101
// 0x0018 (0x0E48 - 0x0E30)
class ACue_Summoner_Loop_10304101 final : public AMarvelCueNotify_Summoned
{
public:
	class AMarvelSummonerBase*                    OwnerSummoner;                                     // 0x0E30(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwnerInstigator;                                   // 0x0E38(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Anka;                                           // 0x0E40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnOwnerSummonerDeath(class AActor* InSource, class AActor* InSourceAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10304101">();
	}
	static class ACue_Summoner_Loop_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10304101>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10304101) == 0x000008, "Wrong alignment on ACue_Summoner_Loop_10304101");
static_assert(sizeof(ACue_Summoner_Loop_10304101) == 0x000E48, "Wrong size on ACue_Summoner_Loop_10304101");
static_assert(offsetof(ACue_Summoner_Loop_10304101, OwnerSummoner) == 0x000E30, "Member 'ACue_Summoner_Loop_10304101::OwnerSummoner' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10304101, OwnerInstigator) == 0x000E38, "Member 'ACue_Summoner_Loop_10304101::OwnerInstigator' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10304101, NS_Anka) == 0x000E40, "Member 'ACue_Summoner_Loop_10304101::NS_Anka' has a wrong offset!");

// Class Hero_1030.Config_103051
// 0x0B90 (0x0C28 - 0x0098)
class UConfig_103051 final : public UMarvelAbilityConfig
{
public:
	struct FDashAbilityInfo                       DashInfo;                                          // 0x0098(0x0B70)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bEnableOffsetZ;                                    // 0x0C08(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C09[0x3];                                      // 0x0C09(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashOffsetZ;                                       // 0x0C0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDashDistance;                                   // 0x0C10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFlyDistance;                                    // 0x0C14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableLaunchV;                                      // 0x0C18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableRecoverA;                                     // 0x0C1C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndMontageWhenDashFinish;                         // 0x0C20(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C21[0x7];                                      // 0x0C21(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103051">();
	}
	static class UConfig_103051* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103051>();
	}
};
static_assert(alignof(UConfig_103051) == 0x000008, "Wrong alignment on UConfig_103051");
static_assert(sizeof(UConfig_103051) == 0x000C28, "Wrong size on UConfig_103051");
static_assert(offsetof(UConfig_103051, DashInfo) == 0x000098, "Member 'UConfig_103051::DashInfo' has a wrong offset!");
static_assert(offsetof(UConfig_103051, bEnableOffsetZ) == 0x000C08, "Member 'UConfig_103051::bEnableOffsetZ' has a wrong offset!");
static_assert(offsetof(UConfig_103051, DashOffsetZ) == 0x000C0C, "Member 'UConfig_103051::DashOffsetZ' has a wrong offset!");
static_assert(offsetof(UConfig_103051, MaxDashDistance) == 0x000C10, "Member 'UConfig_103051::MaxDashDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103051, MaxFlyDistance) == 0x000C14, "Member 'UConfig_103051::MaxFlyDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103051, CableLaunchV) == 0x000C18, "Member 'UConfig_103051::CableLaunchV' has a wrong offset!");
static_assert(offsetof(UConfig_103051, CableRecoverA) == 0x000C1C, "Member 'UConfig_103051::CableRecoverA' has a wrong offset!");
static_assert(offsetof(UConfig_103051, bEndMontageWhenDashFinish) == 0x000C20, "Member 'UConfig_103051::bEndMontageWhenDashFinish' has a wrong offset!");

// Class Hero_1030.Ability_103051
// 0x0198 (0x26F0 - 0x2558)
class UAbility_103051 : public UAbility_108
{
public:
	class UConfig_103051*                         AbilityConfig;                                     // 0x2558(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitMovementModeChange*    MoveModeTask;                                      // 0x2560(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2568[0x188];                                   // 0x2568(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDashFinish(EDashStopReason Reason);
	void OnOwnerLanding(EMovementMode Mode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103051">();
	}
	static class UAbility_103051* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103051>();
	}
};
static_assert(alignof(UAbility_103051) == 0x000008, "Wrong alignment on UAbility_103051");
static_assert(sizeof(UAbility_103051) == 0x0026F0, "Wrong size on UAbility_103051");
static_assert(offsetof(UAbility_103051, AbilityConfig) == 0x002558, "Member 'UAbility_103051::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103051, MoveModeTask) == 0x002560, "Member 'UAbility_103051::MoveModeTask' has a wrong offset!");

// Class Hero_1030.Projectile_10305101
// 0x0000 (0x2F60 - 0x2F60)
class AProjectile_10305101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10305101">();
	}
	static class AProjectile_10305101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10305101>();
	}
};
static_assert(alignof(AProjectile_10305101) == 0x000010, "Wrong alignment on AProjectile_10305101");
static_assert(sizeof(AProjectile_10305101) == 0x002F60, "Wrong size on AProjectile_10305101");

// Class Hero_1030.Cue_Projectile_Loop_10305101
// 0x0120 (0x0E80 - 0x0D60)
class ACue_Projectile_Loop_10305101 final : public AMarvelCueNotify_Projectile
{
public:
	class FName                                   CableAttachedSocket;                               // 0x0D60(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayFromHit;                                      // 0x0D6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayFromDistance;                                 // 0x0D70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartParticleScale;                                // 0x0D74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0D78(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MinNumOfSegments;                                  // 0x0DE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE4[0x4];                                      // 0x0DE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ControlPointCurve;                                 // 0x0DE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCableComponent*                  CableComponent;                                    // 0x0DF0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   HookComponent;                                     // 0x0DF8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0E00(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AProjectile_10305101*                   OwnerProjectile;                                   // 0x0E08(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelGameplayAbility*                 OwningAbility;                                     // 0x0E10(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E18[0x68];                                     // 0x0E18(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGenericGameplayTagUpdate(const struct FGameplayTag& InTag, int32 Count);
	void PostCableUpdate(float DeltaSeconds);
	void PreCableUpdate(float DeltaSeconds);
	void SetCableVisibility(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10305101">();
	}
	static class ACue_Projectile_Loop_10305101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10305101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10305101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10305101");
static_assert(sizeof(ACue_Projectile_Loop_10305101) == 0x000E80, "Wrong size on ACue_Projectile_Loop_10305101");
static_assert(offsetof(ACue_Projectile_Loop_10305101, CableAttachedSocket) == 0x000D60, "Member 'ACue_Projectile_Loop_10305101::CableAttachedSocket' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, DelayFromHit) == 0x000D6C, "Member 'ACue_Projectile_Loop_10305101::DelayFromHit' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, DelayFromDistance) == 0x000D70, "Member 'ACue_Projectile_Loop_10305101::DelayFromDistance' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, StartParticleScale) == 0x000D74, "Member 'ACue_Projectile_Loop_10305101::StartParticleScale' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, TagContainer) == 0x000D78, "Member 'ACue_Projectile_Loop_10305101::TagContainer' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, MinNumOfSegments) == 0x000DE0, "Member 'ACue_Projectile_Loop_10305101::MinNumOfSegments' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, ControlPointCurve) == 0x000DE8, "Member 'ACue_Projectile_Loop_10305101::ControlPointCurve' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, CableComponent) == 0x000DF0, "Member 'ACue_Projectile_Loop_10305101::CableComponent' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, HookComponent) == 0x000DF8, "Member 'ACue_Projectile_Loop_10305101::HookComponent' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, OwnerCharacter) == 0x000E00, "Member 'ACue_Projectile_Loop_10305101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, OwnerProjectile) == 0x000E08, "Member 'ACue_Projectile_Loop_10305101::OwnerProjectile' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, OwningAbility) == 0x000E10, "Member 'ACue_Projectile_Loop_10305101::OwningAbility' has a wrong offset!");

// Class Hero_1030.Config_103052
// 0x0020 (0x10C0 - 0x10A0)
class UConfig_103052 final : public UConfig_AeroBase
{
public:
	float                                         DefaultGlidingV;                                   // 0x1098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CueTag;                                            // 0x109C(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CloakOneTag;                                       // 0x10A8(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CloakTwoTag;                                       // 0x10B4(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103052">();
	}
	static class UConfig_103052* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103052>();
	}
};
static_assert(alignof(UConfig_103052) == 0x000010, "Wrong alignment on UConfig_103052");
static_assert(sizeof(UConfig_103052) == 0x0010C0, "Wrong size on UConfig_103052");
static_assert(offsetof(UConfig_103052, DefaultGlidingV) == 0x001098, "Member 'UConfig_103052::DefaultGlidingV' has a wrong offset!");
static_assert(offsetof(UConfig_103052, CueTag) == 0x00109C, "Member 'UConfig_103052::CueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103052, CloakOneTag) == 0x0010A8, "Member 'UConfig_103052::CloakOneTag' has a wrong offset!");
static_assert(offsetof(UConfig_103052, CloakTwoTag) == 0x0010B4, "Member 'UConfig_103052::CloakTwoTag' has a wrong offset!");

// Class Hero_1030.Ability_103052
// 0x0130 (0x5BC0 - 0x5A90)
class UAbility_103052 : public UMarvelAeroBaseAbility
{
public:
	class UConfig_103052*                         AbilityConfig;                                     // 0x5A90(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputTask;                                         // 0x5A98(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                                      // 0x5AA0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AA8[0x118];                                   // 0x5AA8(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanActivateForUI();
	void LeaveGlide(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103052">();
	}
	static class UAbility_103052* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103052>();
	}
};
static_assert(alignof(UAbility_103052) == 0x000010, "Wrong alignment on UAbility_103052");
static_assert(sizeof(UAbility_103052) == 0x005BC0, "Wrong size on UAbility_103052");
static_assert(offsetof(UAbility_103052, AbilityConfig) == 0x005A90, "Member 'UAbility_103052::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103052, InputTask) == 0x005A98, "Member 'UAbility_103052::InputTask' has a wrong offset!");
static_assert(offsetof(UAbility_103052, TimelineTask) == 0x005AA0, "Member 'UAbility_103052::TimelineTask' has a wrong offset!");

// Class Hero_1030.Ability_103053
// 0x0038 (0x2588 - 0x2550)
class UAbility_103053 : public UMarvelGameplayAbility
{
public:
	class UAbility_103052*                        Ability_Glide;                                     // 0x2550(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelGameplayAbility*                 Ability_DoubleJump;                                // 0x2558(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x2560(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103052*                         GlideConfig;                                       // 0x2568(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputTask;                                         // 0x2570(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2578[0x10];                                    // 0x2578(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103053">();
	}
	static class UAbility_103053* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103053>();
	}
};
static_assert(alignof(UAbility_103053) == 0x000008, "Wrong alignment on UAbility_103053");
static_assert(sizeof(UAbility_103053) == 0x002588, "Wrong size on UAbility_103053");
static_assert(offsetof(UAbility_103053, Ability_Glide) == 0x002550, "Member 'UAbility_103053::Ability_Glide' has a wrong offset!");
static_assert(offsetof(UAbility_103053, Ability_DoubleJump) == 0x002558, "Member 'UAbility_103053::Ability_DoubleJump' has a wrong offset!");
static_assert(offsetof(UAbility_103053, OwnerCharacter) == 0x002560, "Member 'UAbility_103053::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_103053, GlideConfig) == 0x002568, "Member 'UAbility_103053::GlideConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103053, InputTask) == 0x002570, "Member 'UAbility_103053::InputTask' has a wrong offset!");

// Class Hero_1030.Config_103061
// 0x0020 (0x00B8 - 0x0098)
class UConfig_103061 : public UMarvelAbilityConfig
{
public:
	int32                                         ProjectileID;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileNum;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileDelay;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileInterval;                                // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageScopeID_HitPoint;                            // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageScopeID_Summoner;                            // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnergyForbidBuffID;                                // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103061">();
	}
	static class UConfig_103061* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103061>();
	}
};
static_assert(alignof(UConfig_103061) == 0x000008, "Wrong alignment on UConfig_103061");
static_assert(sizeof(UConfig_103061) == 0x0000B8, "Wrong size on UConfig_103061");
static_assert(offsetof(UConfig_103061, ProjectileID) == 0x000098, "Member 'UConfig_103061::ProjectileID' has a wrong offset!");
static_assert(offsetof(UConfig_103061, ProjectileNum) == 0x00009C, "Member 'UConfig_103061::ProjectileNum' has a wrong offset!");
static_assert(offsetof(UConfig_103061, ProjectileDelay) == 0x0000A0, "Member 'UConfig_103061::ProjectileDelay' has a wrong offset!");
static_assert(offsetof(UConfig_103061, ProjectileInterval) == 0x0000A4, "Member 'UConfig_103061::ProjectileInterval' has a wrong offset!");
static_assert(offsetof(UConfig_103061, DamageScopeID_HitPoint) == 0x0000A8, "Member 'UConfig_103061::DamageScopeID_HitPoint' has a wrong offset!");
static_assert(offsetof(UConfig_103061, DamageScopeID_Summoner) == 0x0000AC, "Member 'UConfig_103061::DamageScopeID_Summoner' has a wrong offset!");
static_assert(offsetof(UConfig_103061, EnergyForbidBuffID) == 0x0000B0, "Member 'UConfig_103061::EnergyForbidBuffID' has a wrong offset!");

// Class Hero_1030.Ability_103061
// 0x0008 (0x2560 - 0x2558)
class UAbility_103061 : public UAbility_108
{
public:
	class AMarvelAbilityTargetActor_Projectile*   CurrentProjectile;                                 // 0x2558(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103061">();
	}
	static class UAbility_103061* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103061>();
	}
};
static_assert(alignof(UAbility_103061) == 0x000008, "Wrong alignment on UAbility_103061");
static_assert(sizeof(UAbility_103061) == 0x002560, "Wrong size on UAbility_103061");
static_assert(offsetof(UAbility_103061, CurrentProjectile) == 0x002558, "Member 'UAbility_103061::CurrentProjectile' has a wrong offset!");

// Class Hero_1030.ProjectileMovementComponent_Parabola
// 0x0010 (0x1F80 - 0x1F70)
class UProjectileMovementComponent_Parabola final : public UMarvelProjectileComponent
{
public:
	struct FVector                                ParabolaEndPoint;                                  // 0x1F68(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileMovementComponent_Parabola">();
	}
	static class UProjectileMovementComponent_Parabola* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileMovementComponent_Parabola>();
	}
};
static_assert(alignof(UProjectileMovementComponent_Parabola) == 0x000010, "Wrong alignment on UProjectileMovementComponent_Parabola");
static_assert(sizeof(UProjectileMovementComponent_Parabola) == 0x001F80, "Wrong size on UProjectileMovementComponent_Parabola");
static_assert(offsetof(UProjectileMovementComponent_Parabola, ParabolaEndPoint) == 0x001F68, "Member 'UProjectileMovementComponent_Parabola::ParabolaEndPoint' has a wrong offset!");

// Class Hero_1030.Projectile_10306101
// 0x00C0 (0x3020 - 0x2F60)
class AProjectile_10306101 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	int32                                         ProjectileIndex;                                   // 0x2F60(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F64[0x4];                                     // 0x2F64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EndPoint;                                          // 0x2F68(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             ProjectileTransform;                               // 0x2F80(0x0060)(Net, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SummonerLocation;                                  // 0x2FE0(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FF8[0x28];                                    // 0x2FF8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProjectileEndPoint(const struct FVector& InLocation);
	void SetProjectileIndex(const int32 InValue);
	void SetProjectileTransform(const struct FTransform& InTransform);
	void SetSummonerLocation(const struct FVector& InLocation);

	struct FVector GetSummonerLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10306101">();
	}
	static class AProjectile_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10306101>();
	}
};
static_assert(alignof(AProjectile_10306101) == 0x000010, "Wrong alignment on AProjectile_10306101");
static_assert(sizeof(AProjectile_10306101) == 0x003020, "Wrong size on AProjectile_10306101");
static_assert(offsetof(AProjectile_10306101, ProjectileIndex) == 0x002F60, "Member 'AProjectile_10306101::ProjectileIndex' has a wrong offset!");
static_assert(offsetof(AProjectile_10306101, EndPoint) == 0x002F68, "Member 'AProjectile_10306101::EndPoint' has a wrong offset!");
static_assert(offsetof(AProjectile_10306101, ProjectileTransform) == 0x002F80, "Member 'AProjectile_10306101::ProjectileTransform' has a wrong offset!");
static_assert(offsetof(AProjectile_10306101, SummonerLocation) == 0x002FE0, "Member 'AProjectile_10306101::SummonerLocation' has a wrong offset!");

// Class Hero_1030.Summoned_10306101
// 0x01F0 (0x09F0 - 0x0800)
class ASummoned_10306101 : public AMarvelSummonerBase
{
public:
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x07F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103061*                         AbilityConfig;                                     // 0x0800(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_808[0x1A8];                                    // 0x0808(0x01A8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProjectileNum;                                     // 0x09B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonRightOffset;                                   // 0x09B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonUpOffset;                                      // 0x09B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonScaleOverride;                                 // 0x09BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkyHeight;                                         // 0x09C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonRadius;                                        // 0x09C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ProjectileStartOffset;                             // 0x09C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndPointRadius;                                    // 0x09E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndPointAngle;                                     // 0x09E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E8[0x8];                                      // 0x09E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTransform CalcMoonTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10306101">();
	}
	static class ASummoned_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10306101>();
	}
};
static_assert(alignof(ASummoned_10306101) == 0x000010, "Wrong alignment on ASummoned_10306101");
static_assert(sizeof(ASummoned_10306101) == 0x0009F0, "Wrong size on ASummoned_10306101");
static_assert(offsetof(ASummoned_10306101, OwnerCharacter) == 0x0007F8, "Member 'ASummoned_10306101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, AbilityConfig) == 0x000800, "Member 'ASummoned_10306101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, ProjectileNum) == 0x0009B0, "Member 'ASummoned_10306101::ProjectileNum' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonRightOffset) == 0x0009B4, "Member 'ASummoned_10306101::MoonRightOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonUpOffset) == 0x0009B8, "Member 'ASummoned_10306101::MoonUpOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonScaleOverride) == 0x0009BC, "Member 'ASummoned_10306101::MoonScaleOverride' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, SkyHeight) == 0x0009C0, "Member 'ASummoned_10306101::SkyHeight' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonRadius) == 0x0009C4, "Member 'ASummoned_10306101::MoonRadius' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, ProjectileStartOffset) == 0x0009C8, "Member 'ASummoned_10306101::ProjectileStartOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, EndPointRadius) == 0x0009E0, "Member 'ASummoned_10306101::EndPointRadius' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, EndPointAngle) == 0x0009E4, "Member 'ASummoned_10306101::EndPointAngle' has a wrong offset!");

// Class Hero_1030.Cue_Ability_Loop_10306102
// 0x0008 (0x0E08 - 0x0E00)
class ACue_Ability_Loop_10306102 : public AMarvelCueNotify_Ability
{
public:
	class USkeletalMeshComponent*                 AnkaWeaponMesh;                                    // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10306102">();
	}
	static class ACue_Ability_Loop_10306102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10306102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10306102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10306102");
static_assert(sizeof(ACue_Ability_Loop_10306102) == 0x000E08, "Wrong size on ACue_Ability_Loop_10306102");
static_assert(offsetof(ACue_Ability_Loop_10306102, AnkaWeaponMesh) == 0x000E00, "Member 'ACue_Ability_Loop_10306102::AnkaWeaponMesh' has a wrong offset!");

// Class Hero_1030.Cue_Summoned_Loop_10306101
// 0x0018 (0x0E48 - 0x0E30)
class ACue_Summoned_Loop_10306101 : public AMarvelCueNotify_Summoned
{
public:
	class ASummoned_10306101*                     OwnerSummoner;                                     // 0x0E30(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Moon;                                              // 0x0E38(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     SkyFX;                                             // 0x0E40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoned_Loop_10306101">();
	}
	static class ACue_Summoned_Loop_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoned_Loop_10306101>();
	}
};
static_assert(alignof(ACue_Summoned_Loop_10306101) == 0x000008, "Wrong alignment on ACue_Summoned_Loop_10306101");
static_assert(sizeof(ACue_Summoned_Loop_10306101) == 0x000E48, "Wrong size on ACue_Summoned_Loop_10306101");
static_assert(offsetof(ACue_Summoned_Loop_10306101, OwnerSummoner) == 0x000E30, "Member 'ACue_Summoned_Loop_10306101::OwnerSummoner' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10306101, Moon) == 0x000E38, "Member 'ACue_Summoned_Loop_10306101::Moon' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10306101, SkyFX) == 0x000E40, "Member 'ACue_Summoned_Loop_10306101::SkyFX' has a wrong offset!");

// Class Hero_1030.Cue_TraceActor_10306101
// 0x0020 (0x0CD0 - 0x0CB0)
class ACue_TraceActor_10306101 final : public AMarvelCueNotify_TraceActor
{
public:
	struct FVector                                DecalSize;                                         // 0x0CB0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComponent;                                    // 0x0CC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_TraceActor_10306101">();
	}
	static class ACue_TraceActor_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_TraceActor_10306101>();
	}
};
static_assert(alignof(ACue_TraceActor_10306101) == 0x000008, "Wrong alignment on ACue_TraceActor_10306101");
static_assert(sizeof(ACue_TraceActor_10306101) == 0x000CD0, "Wrong size on ACue_TraceActor_10306101");
static_assert(offsetof(ACue_TraceActor_10306101, DecalSize) == 0x000CB0, "Member 'ACue_TraceActor_10306101::DecalSize' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10306101, DecalComponent) == 0x000CC8, "Member 'ACue_TraceActor_10306101::DecalComponent' has a wrong offset!");

// Class Hero_1030.Cue_Projectile_HitImpact_10306101
// 0x0000 (0x04D0 - 0x04D0)
class UCue_Projectile_HitImpact_10306101 final : public UMarvelCueNotify_HitImpact
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_HitImpact_10306101">();
	}
	static class UCue_Projectile_HitImpact_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Projectile_HitImpact_10306101>();
	}
};
static_assert(alignof(UCue_Projectile_HitImpact_10306101) == 0x000008, "Wrong alignment on UCue_Projectile_HitImpact_10306101");
static_assert(sizeof(UCue_Projectile_HitImpact_10306101) == 0x0004D0, "Wrong size on UCue_Projectile_HitImpact_10306101");

// Class Hero_1030.Config_103071
// 0x0000 (0x00C0 - 0x00C0)
class UConfig_103071 final : public UMarvelAbilityConfig_DoubleJump
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103071">();
	}
	static class UConfig_103071* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103071>();
	}
};
static_assert(alignof(UConfig_103071) == 0x000008, "Wrong alignment on UConfig_103071");
static_assert(sizeof(UConfig_103071) == 0x0000C0, "Wrong size on UConfig_103071");

// Class Hero_1030.Ability_103071
// 0x0000 (0x2648 - 0x2648)
class UAbility_103071 : public UMarvelAbility_DoubleJump
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103071">();
	}
	static class UAbility_103071* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103071>();
	}
};
static_assert(alignof(UAbility_103071) == 0x000008, "Wrong alignment on UAbility_103071");
static_assert(sizeof(UAbility_103071) == 0x002648, "Wrong size on UAbility_103071");

// Class Hero_1030.EpicMomentAction_1030
// 0x0000 (0x0120 - 0x0120)
class UEpicMomentAction_1030 final : public UEpicMomentBaseAction
{
public:
	void OnSummonerBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Summoned, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnSummonerEnd(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1030">();
	}
	static class UEpicMomentAction_1030* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1030>();
	}
};
static_assert(alignof(UEpicMomentAction_1030) == 0x000008, "Wrong alignment on UEpicMomentAction_1030");
static_assert(sizeof(UEpicMomentAction_1030) == 0x000120, "Wrong size on UEpicMomentAction_1030");

// Class Hero_1030.MoonKnightAnimInstance
// 0x00E0 (0x09E0 - 0x0900)
class UMoonKnightAnimInstance final : public UMarvelAnimInstance
{
public:
	class UAnimSequence*                          FallingAnimAsset;                                  // 0x0900(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLayeredBoneBlendExternalSetting       PelvisBlendSettings;                               // 0x0908(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   PelvisModifyCurveName_103051;                      // 0x0918(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MeleeAbilityTag;                                   // 0x0924(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PevisLoc;                                          // 0x0930(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StartVelocity;                                     // 0x0948(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDoubleJumpingForAnim;                            // 0x0960(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseAO;                                      // 0x0961(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedModifyBone;                                   // 0x0962(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_963[0x1];                                      // 0x0963(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PelvisModifyCurveValue_103051;                     // 0x0964(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_968[0x78];                                     // 0x0968(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGenericGameplayTagUpdate(const struct FGameplayTag& InTag, int32 Count);

	void GetLinkedAeroAnimInstances(TArray<class UAnimInstance*>* OutLinkedInstances) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightAnimInstance">();
	}
	static class UMoonKnightAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonKnightAnimInstance>();
	}
};
static_assert(alignof(UMoonKnightAnimInstance) == 0x000010, "Wrong alignment on UMoonKnightAnimInstance");
static_assert(sizeof(UMoonKnightAnimInstance) == 0x0009E0, "Wrong size on UMoonKnightAnimInstance");
static_assert(offsetof(UMoonKnightAnimInstance, FallingAnimAsset) == 0x000900, "Member 'UMoonKnightAnimInstance::FallingAnimAsset' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PelvisBlendSettings) == 0x000908, "Member 'UMoonKnightAnimInstance::PelvisBlendSettings' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PelvisModifyCurveName_103051) == 0x000918, "Member 'UMoonKnightAnimInstance::PelvisModifyCurveName_103051' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, MeleeAbilityTag) == 0x000924, "Member 'UMoonKnightAnimInstance::MeleeAbilityTag' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PevisLoc) == 0x000930, "Member 'UMoonKnightAnimInstance::PevisLoc' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, StartVelocity) == 0x000948, "Member 'UMoonKnightAnimInstance::StartVelocity' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, IsDoubleJumpingForAnim) == 0x000960, "Member 'UMoonKnightAnimInstance::IsDoubleJumpingForAnim' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, bShouldUseAO) == 0x000961, "Member 'UMoonKnightAnimInstance::bShouldUseAO' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, bNeedModifyBone) == 0x000962, "Member 'UMoonKnightAnimInstance::bNeedModifyBone' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PelvisModifyCurveValue_103051) == 0x000964, "Member 'UMoonKnightAnimInstance::PelvisModifyCurveValue_103051' has a wrong offset!");

// Class Hero_1030.MoonKnightCharacter
// 0x0000 (0x17C0 - 0x17C0)
class AMoonKnightCharacter : public AMarvelBaseCharacter
{
public:
	class UMoonKnightMoveLogicBaseComponent*      MoonKnightMoveLogic;                               // 0x17B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightCharacter">();
	}
	static class AMoonKnightCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoonKnightCharacter>();
	}
};
static_assert(alignof(AMoonKnightCharacter) == 0x000010, "Wrong alignment on AMoonKnightCharacter");
static_assert(sizeof(AMoonKnightCharacter) == 0x0017C0, "Wrong size on AMoonKnightCharacter");
static_assert(offsetof(AMoonKnightCharacter, MoonKnightMoveLogic) == 0x0017B8, "Member 'AMoonKnightCharacter::MoonKnightMoveLogic' has a wrong offset!");

// Class Hero_1030.MoonKnightChildActor
// 0x0060 (0x0AA0 - 0x0A40)
class AMoonKnightChildActor : public AMarvelCharacterChildActor
{
public:
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0A40(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MoonMesh;                                          // 0x0A48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A50[0x30];                                     // 0x0A50(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResetCloakDelay;                                   // 0x0A80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalCloakSlot;                                   // 0x0A84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlideCloakSlot;                                    // 0x0A88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8C[0x4];                                      // 0x0A8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ExtraMoonSkinIDs;                                  // 0x0A90(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void OnOwnerReborn(class AActor* Target, const struct FCharacterRebornParam& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightChildActor">();
	}
	static class AMoonKnightChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoonKnightChildActor>();
	}
};
static_assert(alignof(AMoonKnightChildActor) == 0x000008, "Wrong alignment on AMoonKnightChildActor");
static_assert(sizeof(AMoonKnightChildActor) == 0x000AA0, "Wrong size on AMoonKnightChildActor");
static_assert(offsetof(AMoonKnightChildActor, OwnerCharacter) == 0x000A40, "Member 'AMoonKnightChildActor::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, MoonMesh) == 0x000A48, "Member 'AMoonKnightChildActor::MoonMesh' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, ResetCloakDelay) == 0x000A80, "Member 'AMoonKnightChildActor::ResetCloakDelay' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, NormalCloakSlot) == 0x000A84, "Member 'AMoonKnightChildActor::NormalCloakSlot' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, GlideCloakSlot) == 0x000A88, "Member 'AMoonKnightChildActor::GlideCloakSlot' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, ExtraMoonSkinIDs) == 0x000A90, "Member 'AMoonKnightChildActor::ExtraMoonSkinIDs' has a wrong offset!");

// Class Hero_1030.MoonKnightMoveLogicBaseComponent
// 0x0008 (0x03F8 - 0x03F0)
class UMoonKnightMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockASDInputMovment(uint8 BlockInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightMoveLogicBaseComponent">();
	}
	static class UMoonKnightMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonKnightMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UMoonKnightMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UMoonKnightMoveLogicBaseComponent");
static_assert(sizeof(UMoonKnightMoveLogicBaseComponent) == 0x0003F8, "Wrong size on UMoonKnightMoveLogicBaseComponent");

// Class Hero_1030.MoonKnightMovementComponent
// 0x0000 (0x1AF0 - 0x1AF0)
class UMoonKnightMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightMovementComponent">();
	}
	static class UMoonKnightMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonKnightMovementComponent>();
	}
};
static_assert(alignof(UMoonKnightMovementComponent) == 0x000010, "Wrong alignment on UMoonKnightMovementComponent");
static_assert(sizeof(UMoonKnightMovementComponent) == 0x001AF0, "Wrong size on UMoonKnightMovementComponent");

}

