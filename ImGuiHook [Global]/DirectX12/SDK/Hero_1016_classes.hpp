#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1016

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Hero_1016_structs.hpp"
#include "DeclarativeUnreal_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1016.Config_101611
// 0x0078 (0x0110 - 0x0098)
class UConfig_101611 final : public UMarvelAbilityConfig
{
public:
	struct FGameplayTagContainer                  BackstabRequireTags;                               // 0x0098(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BackstabCheckAngle;                                // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackstabDamageRatio;                               // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceDeviation;                              // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101611">();
	}
	static class UConfig_101611* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101611>();
	}
};
static_assert(alignof(UConfig_101611) == 0x000008, "Wrong alignment on UConfig_101611");
static_assert(sizeof(UConfig_101611) == 0x000110, "Wrong size on UConfig_101611");
static_assert(offsetof(UConfig_101611, BackstabRequireTags) == 0x000098, "Member 'UConfig_101611::BackstabRequireTags' has a wrong offset!");
static_assert(offsetof(UConfig_101611, BackstabCheckAngle) == 0x000100, "Member 'UConfig_101611::BackstabCheckAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101611, BackstabDamageRatio) == 0x000104, "Member 'UConfig_101611::BackstabDamageRatio' has a wrong offset!");
static_assert(offsetof(UConfig_101611, MaxDistanceDeviation) == 0x000108, "Member 'UConfig_101611::MaxDistanceDeviation' has a wrong offset!");

// Class Hero_1016.EffectiveComponent_Loki
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_Loki : public UMarvelAgentEffectiveComponent
{
public:
	class UConfig_101651* GetConfig_101651();
	void ReplaceProjectileAgentApplyBuff();
	void ReplaceScopeAgentApplyBuff();
	void SetProjectileAgentDamageValue();
	void SetScopeAgentDamageValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_Loki">();
	}
	static class UEffectiveComponent_Loki* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_Loki>();
	}
};
static_assert(alignof(UEffectiveComponent_Loki) == 0x000010, "Wrong alignment on UEffectiveComponent_Loki");
static_assert(sizeof(UEffectiveComponent_Loki) == 0x001C00, "Wrong size on UEffectiveComponent_Loki");

// Class Hero_1016.EffectiveComponent_10161101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10161101 : public UEffectiveComponent_Loki
{
public:
	void JudgeBackstabAndSetEffect(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10161101">();
	}
	static class UEffectiveComponent_10161101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10161101>();
	}
};
static_assert(alignof(UEffectiveComponent_10161101) == 0x000010, "Wrong alignment on UEffectiveComponent_10161101");
static_assert(sizeof(UEffectiveComponent_10161101) == 0x001C00, "Wrong size on UEffectiveComponent_10161101");

// Class Hero_1016.Ability_101621
// 0x0000 (0x2550 - 0x2550)
class UAbility_101621 : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101621">();
	}
	static class UAbility_101621* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101621>();
	}
};
static_assert(alignof(UAbility_101621) == 0x000008, "Wrong alignment on UAbility_101621");
static_assert(sizeof(UAbility_101621) == 0x002550, "Wrong size on UAbility_101621");

// Class Hero_1016.Projectile_Loki
// 0x0010 (0x2F70 - 0x2F60)
class AProjectile_Loki : public AMarvelAbilityTargetActor_Projectile
{
public:
	uint8                                         Pad_2F60[0x8];                                     // 0x2F60(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPhantomOwned;                                     // 0x2F68(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F69[0x7];                                     // 0x2F69(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPhantomOwned();
	void SetPhantomOwned(bool bOwned);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_Loki">();
	}
	static class AProjectile_Loki* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_Loki>();
	}
};
static_assert(alignof(AProjectile_Loki) == 0x000010, "Wrong alignment on AProjectile_Loki");
static_assert(sizeof(AProjectile_Loki) == 0x002F70, "Wrong size on AProjectile_Loki");
static_assert(offsetof(AProjectile_Loki, bPhantomOwned) == 0x002F68, "Member 'AProjectile_Loki::bPhantomOwned' has a wrong offset!");

// Class Hero_1016.Projectile_10162101
// 0x0010 (0x2F80 - 0x2F70)
class AProjectile_10162101 : public AProjectile_Loki
{
public:
	uint8                                         Pad_2F70[0x10];                                    // 0x2F70(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10162101">();
	}
	static class AProjectile_10162101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10162101>();
	}
};
static_assert(alignof(AProjectile_10162101) == 0x000010, "Wrong alignment on AProjectile_10162101");
static_assert(sizeof(AProjectile_10162101) == 0x002F80, "Wrong size on AProjectile_10162101");

// Class Hero_1016.Config_101631
// 0x0020 (0x00B8 - 0x0098)
class UConfig_101631 : public UMarvelAbilityConfig
{
public:
	float                                         ScopeCenterHeight;                                 // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultHeight;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckSceneBlock;                            // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SummonerId;                                        // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScopeId;                                           // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SummonerGravityScale;                              // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101631">();
	}
	static class UConfig_101631* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101631>();
	}
};
static_assert(alignof(UConfig_101631) == 0x000008, "Wrong alignment on UConfig_101631");
static_assert(sizeof(UConfig_101631) == 0x0000B8, "Wrong size on UConfig_101631");
static_assert(offsetof(UConfig_101631, ScopeCenterHeight) == 0x000098, "Member 'UConfig_101631::ScopeCenterHeight' has a wrong offset!");
static_assert(offsetof(UConfig_101631, DefaultHeight) == 0x00009C, "Member 'UConfig_101631::DefaultHeight' has a wrong offset!");
static_assert(offsetof(UConfig_101631, OuterRadius) == 0x0000A0, "Member 'UConfig_101631::OuterRadius' has a wrong offset!");
static_assert(offsetof(UConfig_101631, bShouldCheckSceneBlock) == 0x0000A4, "Member 'UConfig_101631::bShouldCheckSceneBlock' has a wrong offset!");
static_assert(offsetof(UConfig_101631, SummonerId) == 0x0000A8, "Member 'UConfig_101631::SummonerId' has a wrong offset!");
static_assert(offsetof(UConfig_101631, ScopeId) == 0x0000AC, "Member 'UConfig_101631::ScopeId' has a wrong offset!");
static_assert(offsetof(UConfig_101631, SummonerGravityScale) == 0x0000B0, "Member 'UConfig_101631::SummonerGravityScale' has a wrong offset!");

// Class Hero_1016.Summoned_10163101
// 0x0010 (0x0810 - 0x0800)
class ASummoned_10163101 : public AMarvelSummonerBase
{
public:
	uint8                                         Pad_7F8[0x8];                                      // 0x07F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_101631*                         CachedConfig;                                      // 0x0800(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USummonedComp_10163101*                 SummonedComp_10163101;                             // 0x0808(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class USummonedComp_10163101* GetOwningComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10163101">();
	}
	static class ASummoned_10163101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10163101>();
	}
};
static_assert(alignof(ASummoned_10163101) == 0x000010, "Wrong alignment on ASummoned_10163101");
static_assert(sizeof(ASummoned_10163101) == 0x000810, "Wrong size on ASummoned_10163101");
static_assert(offsetof(ASummoned_10163101, CachedConfig) == 0x000800, "Member 'ASummoned_10163101::CachedConfig' has a wrong offset!");
static_assert(offsetof(ASummoned_10163101, SummonedComp_10163101) == 0x000808, "Member 'ASummoned_10163101::SummonedComp_10163101' has a wrong offset!");

// Class Hero_1016.SummonedComp_10163101
// 0x0FE0 (0x1C70 - 0x0C90)
class USummonedComp_10163101 : public UMarvelSummonedComponent
{
public:
	uint8                                         Pad_C88[0x8];                                      // 0x0C88(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             GroundTraceContext;                                // 0x0C90(0x0F30)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPositionReady;                                   // 0x1BC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      BlockingTypes;                                     // 0x1BD0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bPositionReady;                                    // 0x1BE0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BE1[0x7];                                     // 0x1BE1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScopeLocation;                                     // 0x1BE8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalScopeLocation;                                // 0x1C00(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RealHeight;                                        // 0x1C18(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1C[0x4];                                     // 0x1C1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_101631*                         Config_101631;                                     // 0x1C20(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASummoned_10163101*                     Summoned_101631;                                   // 0x1C28(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C30[0x38];                                    // 0x1C30(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereCollision;                                   // 0x1C68(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	TArray<struct FVector> CalSurroundSphereCenters(const struct FVector& CenterPoint, int32 SurroundNum, float SurroundRadius);
	class UConfig_101631* GetOwnerAbilityConfig();
	class ASummoned_10163101* GetOwnerSummoned();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10163101">();
	}
	static class USummonedComp_10163101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10163101>();
	}
};
static_assert(alignof(USummonedComp_10163101) == 0x000010, "Wrong alignment on USummonedComp_10163101");
static_assert(sizeof(USummonedComp_10163101) == 0x001C70, "Wrong size on USummonedComp_10163101");
static_assert(offsetof(USummonedComp_10163101, GroundTraceContext) == 0x000C90, "Member 'USummonedComp_10163101::GroundTraceContext' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, OnPositionReady) == 0x001BC0, "Member 'USummonedComp_10163101::OnPositionReady' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, BlockingTypes) == 0x001BD0, "Member 'USummonedComp_10163101::BlockingTypes' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, bPositionReady) == 0x001BE0, "Member 'USummonedComp_10163101::bPositionReady' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, ScopeLocation) == 0x001BE8, "Member 'USummonedComp_10163101::ScopeLocation' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, FinalScopeLocation) == 0x001C00, "Member 'USummonedComp_10163101::FinalScopeLocation' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, RealHeight) == 0x001C18, "Member 'USummonedComp_10163101::RealHeight' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, Config_101631) == 0x001C20, "Member 'USummonedComp_10163101::Config_101631' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, Summoned_101631) == 0x001C28, "Member 'USummonedComp_10163101::Summoned_101631' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, SphereCollision) == 0x001C68, "Member 'USummonedComp_10163101::SphereCollision' has a wrong offset!");

// Class Hero_1016.Ability_101631
// 0x0018 (0x2568 - 0x2550)
class UAbility_101631 : public UMarvelGameplayAbility
{
public:
	class UConfig_101631*                         Config_101631;                                     // 0x2550(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbility_101631*                        Instigator_Ability_101631;                         // 0x2558(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASummoned_10163101*                     CurSummoned;                                       // 0x2560(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UAbility_101631* GetInstigatorAbility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101631">();
	}
	static class UAbility_101631* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101631>();
	}
};
static_assert(alignof(UAbility_101631) == 0x000008, "Wrong alignment on UAbility_101631");
static_assert(sizeof(UAbility_101631) == 0x002568, "Wrong size on UAbility_101631");
static_assert(offsetof(UAbility_101631, Config_101631) == 0x002550, "Member 'UAbility_101631::Config_101631' has a wrong offset!");
static_assert(offsetof(UAbility_101631, Instigator_Ability_101631) == 0x002558, "Member 'UAbility_101631::Instigator_Ability_101631' has a wrong offset!");
static_assert(offsetof(UAbility_101631, CurSummoned) == 0x002560, "Member 'UAbility_101631::CurSummoned' has a wrong offset!");

// Class Hero_1016.UMarvelTreatOverflowConvAbility_10163101
// 0x0000 (0x1198 - 0x1198)
class UUMarvelTreatOverflowConvAbility_10163101 : public UMarvelTreatOverflowConvAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMarvelTreatOverflowConvAbility_10163101">();
	}
	static class UUMarvelTreatOverflowConvAbility_10163101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMarvelTreatOverflowConvAbility_10163101>();
	}
};
static_assert(alignof(UUMarvelTreatOverflowConvAbility_10163101) == 0x000008, "Wrong alignment on UUMarvelTreatOverflowConvAbility_10163101");
static_assert(sizeof(UUMarvelTreatOverflowConvAbility_10163101) == 0x001198, "Wrong size on UUMarvelTreatOverflowConvAbility_10163101");

// Class Hero_1016.Cue_Summoner_Loop_10163101
// 0x0038 (0x0E68 - 0x0E30)
class ACue_Summoner_Loop_10163101 : public AMarvelCueNotify_Summoned
{
public:
	class UNiagaraComponent*                      LoopScopeNiagara;                                  // 0x0E30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E38[0x8];                                      // 0x0E38(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0E40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComponent;                                    // 0x0E48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           DecalScaleCurve;                                   // 0x0E50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0E58(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASummoned_10163101*                     OwnerSummoned;                                     // 0x0E60(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10163101">();
	}
	static class ACue_Summoner_Loop_10163101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10163101>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10163101) == 0x000008, "Wrong alignment on ACue_Summoner_Loop_10163101");
static_assert(sizeof(ACue_Summoner_Loop_10163101) == 0x000E68, "Wrong size on ACue_Summoner_Loop_10163101");
static_assert(offsetof(ACue_Summoner_Loop_10163101, LoopScopeNiagara) == 0x000E30, "Member 'ACue_Summoner_Loop_10163101::LoopScopeNiagara' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10163101, DecalMaterial) == 0x000E40, "Member 'ACue_Summoner_Loop_10163101::DecalMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10163101, DecalComponent) == 0x000E48, "Member 'ACue_Summoner_Loop_10163101::DecalComponent' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10163101, DecalScaleCurve) == 0x000E50, "Member 'ACue_Summoner_Loop_10163101::DecalScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10163101, Mid) == 0x000E58, "Member 'ACue_Summoner_Loop_10163101::Mid' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10163101, OwnerSummoned) == 0x000E60, "Member 'ACue_Summoner_Loop_10163101::OwnerSummoned' has a wrong offset!");

// Class Hero_1016.Stealth_101641
// 0x0068 (0x12D0 - 0x1268)
class UStealth_101641 : public UMarvelStealthAbility
{
public:
	struct FGameplayTagContainer                  BlockInputAbilities;                               // 0x1268(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Stealth_101641">();
	}
	static class UStealth_101641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStealth_101641>();
	}
};
static_assert(alignof(UStealth_101641) == 0x000008, "Wrong alignment on UStealth_101641");
static_assert(sizeof(UStealth_101641) == 0x0012D0, "Wrong size on UStealth_101641");
static_assert(offsetof(UStealth_101641, BlockInputAbilities) == 0x001268, "Member 'UStealth_101641::BlockInputAbilities' has a wrong offset!");

// Class Hero_1016.Cue_Buff_10164101
// 0x0028 (0x1010 - 0x0FE8)
class ACue_Buff_10164101 final : public AMarvelCueNotify_Buff
{
public:
	class UFXSystemComponent*                     NiagaraSystem;                                     // 0x0FE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         DisappearFX;                                       // 0x0FF0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DisappearLocation;                                 // 0x0FF8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SpawnDisappearFX(class ACharacter* Character);
	void UpdateDisappearFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10164101">();
	}
	static class ACue_Buff_10164101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10164101>();
	}
};
static_assert(alignof(ACue_Buff_10164101) == 0x000008, "Wrong alignment on ACue_Buff_10164101");
static_assert(sizeof(ACue_Buff_10164101) == 0x001010, "Wrong size on ACue_Buff_10164101");
static_assert(offsetof(ACue_Buff_10164101, NiagaraSystem) == 0x000FE8, "Member 'ACue_Buff_10164101::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10164101, DisappearFX) == 0x000FF0, "Member 'ACue_Buff_10164101::DisappearFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10164101, DisappearLocation) == 0x000FF8, "Member 'ACue_Buff_10164101::DisappearLocation' has a wrong offset!");

// Class Hero_1016.Ability_101651
// 0x00B8 (0x2608 - 0x2550)
class UAbility_101651 : public UMarvelGameplayAbility
{
public:
	EAbilityState_101651                          CurrentAbilityState;                               // 0x2550(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityState_101651                          LastAbilityState;                                  // 0x2551(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2552[0x6];                                     // 0x2552(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                                      // 0x2558(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALokiCharacter*                         OwnerChar;                                         // 0x2560(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         TimelineKey;                                       // 0x2568(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector GetOriginCharacterAimedLocation();
	void SwitchTimelineTask(const class FName& SectionName, bool bWithAbilityEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101651">();
	}
	static class UAbility_101651* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101651>();
	}
};
static_assert(alignof(UAbility_101651) == 0x000008, "Wrong alignment on UAbility_101651");
static_assert(sizeof(UAbility_101651) == 0x002608, "Wrong size on UAbility_101651");
static_assert(offsetof(UAbility_101651, CurrentAbilityState) == 0x002550, "Member 'UAbility_101651::CurrentAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_101651, LastAbilityState) == 0x002551, "Member 'UAbility_101651::LastAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_101651, TimelineTask) == 0x002558, "Member 'UAbility_101651::TimelineTask' has a wrong offset!");
static_assert(offsetof(UAbility_101651, OwnerChar) == 0x002560, "Member 'UAbility_101651::OwnerChar' has a wrong offset!");
static_assert(offsetof(UAbility_101651, TimelineKey) == 0x002568, "Member 'UAbility_101651::TimelineKey' has a wrong offset!");

// Class Hero_1016.SummonedController_10165101
// 0x0F68 (0x1530 - 0x05C8)
class ASummonedController_10165101 : public ASummonedAIController
{
public:
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             AimPointTraceParam;                                // 0x05D0(0x0F30)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1500[0x18];                                    // 0x1500(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_101651*                         PhantomConfig;                                     // 0x1518(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x1520(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASummoned_10165101*                     ControlledCharacter;                               // 0x1528(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector GetOriginCharacterAimedLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedController_10165101">();
	}
	static class ASummonedController_10165101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummonedController_10165101>();
	}
};
static_assert(alignof(ASummonedController_10165101) == 0x000010, "Wrong alignment on ASummonedController_10165101");
static_assert(sizeof(ASummonedController_10165101) == 0x001530, "Wrong size on ASummonedController_10165101");
static_assert(offsetof(ASummonedController_10165101, AimPointTraceParam) == 0x0005D0, "Member 'ASummonedController_10165101::AimPointTraceParam' has a wrong offset!");
static_assert(offsetof(ASummonedController_10165101, PhantomConfig) == 0x001518, "Member 'ASummonedController_10165101::PhantomConfig' has a wrong offset!");
static_assert(offsetof(ASummonedController_10165101, InstigatorCharacter) == 0x001520, "Member 'ASummonedController_10165101::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(ASummonedController_10165101, ControlledCharacter) == 0x001528, "Member 'ASummonedController_10165101::ControlledCharacter' has a wrong offset!");

// Class Hero_1016.Summoned_10165101
// 0x0140 (0x0F60 - 0x0E20)
class ASummoned_10165101 : public ASummonedCharacterBase
{
public:
	uint8                                         Pad_E20[0x108];                                    // 0x0E20(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	class ULokiMoveLogicBaseComponent*            LokiMoveLogicComponent;                            // 0x0F28(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelSolvePenetrationComponent*       SolvePenetrationComponent;                         // 0x0F30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshHiddenComponent*                   HiddenComponent;                                   // 0x0F38(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInVisible;                                        // 0x0F40(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F41[0x7];                                      // 0x0F41(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x0F48(0x0010)(Protected, NativeAccessSpecifierProtected)
	bool                                          bForceMovementCompActive;                          // 0x0F58(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F59[0x7];                                      // 0x0F59(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);

	EHeroRole GetHeroRole() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10165101">();
	}
	static class ASummoned_10165101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10165101>();
	}
};
static_assert(alignof(ASummoned_10165101) == 0x000010, "Wrong alignment on ASummoned_10165101");
static_assert(sizeof(ASummoned_10165101) == 0x000F60, "Wrong size on ASummoned_10165101");
static_assert(offsetof(ASummoned_10165101, LokiMoveLogicComponent) == 0x000F28, "Member 'ASummoned_10165101::LokiMoveLogicComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10165101, SolvePenetrationComponent) == 0x000F30, "Member 'ASummoned_10165101::SolvePenetrationComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10165101, HiddenComponent) == 0x000F38, "Member 'ASummoned_10165101::HiddenComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10165101, bInVisible) == 0x000F40, "Member 'ASummoned_10165101::bInVisible' has a wrong offset!");
static_assert(offsetof(ASummoned_10165101, DeclarePlayerViewSideHolder) == 0x000F48, "Member 'ASummoned_10165101::DeclarePlayerViewSideHolder' has a wrong offset!");
static_assert(offsetof(ASummoned_10165101, bForceMovementCompActive) == 0x000F58, "Member 'ASummoned_10165101::bForceMovementCompActive' has a wrong offset!");

// Class Hero_1016.SummonedComp_V2_10165101
// 0x00A0 (0x0D30 - 0x0C90)
class USummonedComp_V2_10165101 : public UMarvelSummonedComponent
{
public:
	class ASummoned_10165101*                     OwnerCharacter;                                    // 0x0C88(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALokiCharacter*                         SourceCharacter;                                   // 0x0C90(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelPlayerState*                     SourcePlayerState;                                 // 0x0C98(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourcePlayerUID;                                   // 0x0CA0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA4[0x4];                                      // 0x0CA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLifetimeControlParam                  LifetimeParam;                                     // 0x0CA8(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UConfig_101651*                         PhantomConfig;                                     // 0x0D28(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnInstigatorActivateAbility(int32 InAbilityId);
	void OnInstigatorEndAbility(int32 InAbilityId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_V2_10165101">();
	}
	static class USummonedComp_V2_10165101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_V2_10165101>();
	}
};
static_assert(alignof(USummonedComp_V2_10165101) == 0x000010, "Wrong alignment on USummonedComp_V2_10165101");
static_assert(sizeof(USummonedComp_V2_10165101) == 0x000D30, "Wrong size on USummonedComp_V2_10165101");
static_assert(offsetof(USummonedComp_V2_10165101, OwnerCharacter) == 0x000C88, "Member 'USummonedComp_V2_10165101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USummonedComp_V2_10165101, SourceCharacter) == 0x000C90, "Member 'USummonedComp_V2_10165101::SourceCharacter' has a wrong offset!");
static_assert(offsetof(USummonedComp_V2_10165101, SourcePlayerState) == 0x000C98, "Member 'USummonedComp_V2_10165101::SourcePlayerState' has a wrong offset!");
static_assert(offsetof(USummonedComp_V2_10165101, SourcePlayerUID) == 0x000CA0, "Member 'USummonedComp_V2_10165101::SourcePlayerUID' has a wrong offset!");
static_assert(offsetof(USummonedComp_V2_10165101, LifetimeParam) == 0x000CA8, "Member 'USummonedComp_V2_10165101::LifetimeParam' has a wrong offset!");
static_assert(offsetof(USummonedComp_V2_10165101, PhantomConfig) == 0x000D28, "Member 'USummonedComp_V2_10165101::PhantomConfig' has a wrong offset!");

// Class Hero_1016.Cue_TraceActor_10165101
// 0x0078 (0x0D28 - 0x0CB0)
class ACue_TraceActor_10165101 : public AMarvelCueNotify_TraceActor
{
public:
	class UNiagaraComponent*                      GroundShowNiagara;                                 // 0x0CB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNiagara;                                       // 0x0CB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTimelineComponent*                     YawControl;                                        // 0x0CC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0CC8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            YawCurve;                                          // 0x0CD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD8[0x18];                                     // 0x0CD8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 LokiMirrorMesh;                                    // 0x0CF0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayShowLokiMirrorMeshTime;                       // 0x0CF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CFC[0x4];                                      // 0x0CFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPortableMaterialSlotName>      LokiHiddenSlots;                                   // 0x0D00(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           DelayShowMirrorMeshHandle;                         // 0x0D10(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFloatChange(class FName TrackName, class FName PropertyName, float OutValue);
	void UpdateRotation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_TraceActor_10165101">();
	}
	static class ACue_TraceActor_10165101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_TraceActor_10165101>();
	}
};
static_assert(alignof(ACue_TraceActor_10165101) == 0x000008, "Wrong alignment on ACue_TraceActor_10165101");
static_assert(sizeof(ACue_TraceActor_10165101) == 0x000D28, "Wrong size on ACue_TraceActor_10165101");
static_assert(offsetof(ACue_TraceActor_10165101, GroundShowNiagara) == 0x000CB0, "Member 'ACue_TraceActor_10165101::GroundShowNiagara' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, LoopNiagara) == 0x000CB8, "Member 'ACue_TraceActor_10165101::LoopNiagara' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, YawControl) == 0x000CC0, "Member 'ACue_TraceActor_10165101::YawControl' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, OwnerCharacter) == 0x000CC8, "Member 'ACue_TraceActor_10165101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, YawCurve) == 0x000CD0, "Member 'ACue_TraceActor_10165101::YawCurve' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, LokiMirrorMesh) == 0x000CF0, "Member 'ACue_TraceActor_10165101::LokiMirrorMesh' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, DelayShowLokiMirrorMeshTime) == 0x000CF8, "Member 'ACue_TraceActor_10165101::DelayShowLokiMirrorMeshTime' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, LokiHiddenSlots) == 0x000D00, "Member 'ACue_TraceActor_10165101::LokiHiddenSlots' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, DelayShowMirrorMeshHandle) == 0x000D10, "Member 'ACue_TraceActor_10165101::DelayShowMirrorMeshHandle' has a wrong offset!");

// Class Hero_1016.LokiSpaceActor
// 0x0018 (0x0488 - 0x0470)
class ALokiSpaceActor : public AActor
{
public:
	class USceneCaptureComponent2D*               SceneCapComponent2D;                               // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        LokiRotationPivot;                                 // 0x0478(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVDelta;                                          // 0x0480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiSpaceActor">();
	}
	static class ALokiSpaceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALokiSpaceActor>();
	}
};
static_assert(alignof(ALokiSpaceActor) == 0x000008, "Wrong alignment on ALokiSpaceActor");
static_assert(sizeof(ALokiSpaceActor) == 0x000488, "Wrong size on ALokiSpaceActor");
static_assert(offsetof(ALokiSpaceActor, SceneCapComponent2D) == 0x000470, "Member 'ALokiSpaceActor::SceneCapComponent2D' has a wrong offset!");
static_assert(offsetof(ALokiSpaceActor, LokiRotationPivot) == 0x000478, "Member 'ALokiSpaceActor::LokiRotationPivot' has a wrong offset!");
static_assert(offsetof(ALokiSpaceActor, FOVDelta) == 0x000480, "Member 'ALokiSpaceActor::FOVDelta' has a wrong offset!");

// Class Hero_1016.Summoned_10165102
// 0x0030 (0x0830 - 0x0800)
class ASummoned_10165102 final : public AMarvelSummonerBase
{
public:
	class USphereComponent*                       OverlapCollisionComponent;                         // 0x07F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlapHandlerComponent*               OverlapHandleComponent;                            // 0x0800(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OverlapActorDelegate;                              // 0x0808(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 OverlappedActor;                                   // 0x0818(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_820[0x8];                                      // 0x0820(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasExecuteCue;                                    // 0x0828(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_829[0x7];                                      // 0x0829(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NetMulticastCharacterOverlap(class AActor* InActor);
	void OnValidCharacterOverlap(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10165102">();
	}
	static class ASummoned_10165102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10165102>();
	}
};
static_assert(alignof(ASummoned_10165102) == 0x000010, "Wrong alignment on ASummoned_10165102");
static_assert(sizeof(ASummoned_10165102) == 0x000830, "Wrong size on ASummoned_10165102");
static_assert(offsetof(ASummoned_10165102, OverlapCollisionComponent) == 0x0007F8, "Member 'ASummoned_10165102::OverlapCollisionComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10165102, OverlapHandleComponent) == 0x000800, "Member 'ASummoned_10165102::OverlapHandleComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10165102, OverlapActorDelegate) == 0x000808, "Member 'ASummoned_10165102::OverlapActorDelegate' has a wrong offset!");
static_assert(offsetof(ASummoned_10165102, OverlappedActor) == 0x000818, "Member 'ASummoned_10165102::OverlappedActor' has a wrong offset!");
static_assert(offsetof(ASummoned_10165102, bHasExecuteCue) == 0x000828, "Member 'ASummoned_10165102::bHasExecuteCue' has a wrong offset!");

// Class Hero_1016.Cue_Summoner_Loop_10165101
// 0x0098 (0x0EC8 - 0x0E30)
class ACue_Summoner_Loop_10165101 : public AMarvelCueNotify_Summoned
{
public:
	class UNiagaraComponent*                      TeammateEffectFX;                                  // 0x0E30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeammateEffectSocket;                              // 0x0E38(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E44[0x4];                                      // 0x0E44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             FX_MaterialSlotName_Set;                           // 0x0E48(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           FX_InColor_Param;                                  // 0x0E98(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FX_Fresnel_Param;                                  // 0x0EA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FX_InExponentln_Param;                             // 0x0EAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FX_InIntensity_Param;                              // 0x0EB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EB4[0x4];                                      // 0x0EB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeclarationHolder                     DeclareViewSideHolder;                             // 0x0EB8(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);
	void SetTeammateMaterialParams(bool bSet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10165101">();
	}
	static class ACue_Summoner_Loop_10165101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10165101>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10165101) == 0x000008, "Wrong alignment on ACue_Summoner_Loop_10165101");
static_assert(sizeof(ACue_Summoner_Loop_10165101) == 0x000EC8, "Wrong size on ACue_Summoner_Loop_10165101");
static_assert(offsetof(ACue_Summoner_Loop_10165101, TeammateEffectFX) == 0x000E30, "Member 'ACue_Summoner_Loop_10165101::TeammateEffectFX' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, TeammateEffectSocket) == 0x000E38, "Member 'ACue_Summoner_Loop_10165101::TeammateEffectSocket' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, FX_MaterialSlotName_Set) == 0x000E48, "Member 'ACue_Summoner_Loop_10165101::FX_MaterialSlotName_Set' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, FX_InColor_Param) == 0x000E98, "Member 'ACue_Summoner_Loop_10165101::FX_InColor_Param' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, FX_Fresnel_Param) == 0x000EA8, "Member 'ACue_Summoner_Loop_10165101::FX_Fresnel_Param' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, FX_InExponentln_Param) == 0x000EAC, "Member 'ACue_Summoner_Loop_10165101::FX_InExponentln_Param' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, FX_InIntensity_Param) == 0x000EB0, "Member 'ACue_Summoner_Loop_10165101::FX_InIntensity_Param' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, DeclareViewSideHolder) == 0x000EB8, "Member 'ACue_Summoner_Loop_10165101::DeclareViewSideHolder' has a wrong offset!");

// Class Hero_1016.Config_101651
// 0x1098 (0x1130 - 0x0098)
class UConfig_101651 final : public UMarvelAbilityConfig
{
public:
	float                                         AbilityDamageDecayRatio;                           // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            PhantomBuffMap;                                    // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFindGroundParam                       FindGroundParam;                                   // 0x00F0(0x0F70)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Aim_MaxDistance;                                   // 0x1060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swap_MaxDistance;                                  // 0x1064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 FowardAbilities;                                   // 0x1068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BuffTable;                                         // 0x1078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockTurnTagContainer;                             // 0x1088(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         AimDistanceTraceForNoCircle;                       // 0x10F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckDegreeAngle;                                  // 0x10F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLokiPhantomSpec>               LokiPhantomSpecs;                                  // 0x10F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocationOffset;                               // 0x1108(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CueTag;                                            // 0x1120(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhantomFollowInstigatorVisibility;                // 0x112C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112D[0x3];                                     // 0x112D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UConfig_101651* GetLokiPhantomConfig();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101651">();
	}
	static class UConfig_101651* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101651>();
	}
};
static_assert(alignof(UConfig_101651) == 0x000010, "Wrong alignment on UConfig_101651");
static_assert(sizeof(UConfig_101651) == 0x001130, "Wrong size on UConfig_101651");
static_assert(offsetof(UConfig_101651, AbilityDamageDecayRatio) == 0x000098, "Member 'UConfig_101651::AbilityDamageDecayRatio' has a wrong offset!");
static_assert(offsetof(UConfig_101651, PhantomBuffMap) == 0x0000A0, "Member 'UConfig_101651::PhantomBuffMap' has a wrong offset!");
static_assert(offsetof(UConfig_101651, FindGroundParam) == 0x0000F0, "Member 'UConfig_101651::FindGroundParam' has a wrong offset!");
static_assert(offsetof(UConfig_101651, Aim_MaxDistance) == 0x001060, "Member 'UConfig_101651::Aim_MaxDistance' has a wrong offset!");
static_assert(offsetof(UConfig_101651, Swap_MaxDistance) == 0x001064, "Member 'UConfig_101651::Swap_MaxDistance' has a wrong offset!");
static_assert(offsetof(UConfig_101651, FowardAbilities) == 0x001068, "Member 'UConfig_101651::FowardAbilities' has a wrong offset!");
static_assert(offsetof(UConfig_101651, BuffTable) == 0x001078, "Member 'UConfig_101651::BuffTable' has a wrong offset!");
static_assert(offsetof(UConfig_101651, BlockTurnTagContainer) == 0x001088, "Member 'UConfig_101651::BlockTurnTagContainer' has a wrong offset!");
static_assert(offsetof(UConfig_101651, AimDistanceTraceForNoCircle) == 0x0010F0, "Member 'UConfig_101651::AimDistanceTraceForNoCircle' has a wrong offset!");
static_assert(offsetof(UConfig_101651, CheckDegreeAngle) == 0x0010F4, "Member 'UConfig_101651::CheckDegreeAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101651, LokiPhantomSpecs) == 0x0010F8, "Member 'UConfig_101651::LokiPhantomSpecs' has a wrong offset!");
static_assert(offsetof(UConfig_101651, SpawnLocationOffset) == 0x001108, "Member 'UConfig_101651::SpawnLocationOffset' has a wrong offset!");
static_assert(offsetof(UConfig_101651, CueTag) == 0x001120, "Member 'UConfig_101651::CueTag' has a wrong offset!");
static_assert(offsetof(UConfig_101651, bPhantomFollowInstigatorVisibility) == 0x00112C, "Member 'UConfig_101651::bPhantomFollowInstigatorVisibility' has a wrong offset!");

// Class Hero_1016.Scope_Loki
// 0x0010 (0x16D0 - 0x16C0)
class AScope_Loki final : public AMarvelAbilityTargetActor_Scope
{
public:
	uint8                                         Pad_16C0[0x8];                                     // 0x16C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPhantomOwned;                                     // 0x16C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C9[0x7];                                     // 0x16C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPhantomOwned();
	void SetPhantomOwned(bool bOwned);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_Loki">();
	}
	static class AScope_Loki* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_Loki>();
	}
};
static_assert(alignof(AScope_Loki) == 0x000010, "Wrong alignment on AScope_Loki");
static_assert(sizeof(AScope_Loki) == 0x0016D0, "Wrong size on AScope_Loki");
static_assert(offsetof(AScope_Loki, bPhantomOwned) == 0x0016C8, "Member 'AScope_Loki::bPhantomOwned' has a wrong offset!");

// Class Hero_1016.LokiPhantomStatics
// 0x0000 (0x0030 - 0x0030)
class ULokiPhantomStatics final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class AActor*> GetLokiPhantoms(class AMarvelBaseCharacter* InSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiPhantomStatics">();
	}
	static class ULokiPhantomStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiPhantomStatics>();
	}
};
static_assert(alignof(ULokiPhantomStatics) == 0x000008, "Wrong alignment on ULokiPhantomStatics");
static_assert(sizeof(ULokiPhantomStatics) == 0x000030, "Wrong size on ULokiPhantomStatics");

// Class Hero_1016.LokiPhantomManagementComponent
// 0x0F70 (0x1060 - 0x00F0)
class ULokiPhantomManagementComponent final : public UActorComponent
{
public:
	class UConfig_101651*                         PhantomConfig;                                     // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMarvelAbilityTraceContext             AimPointTraceParam;                                // 0x0100(0x0F30)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TickPhantomTurnInterval;                           // 0x1030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickPhantomTickInterval;                           // 0x1034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1038[0x18];                                    // 0x1038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickPhantomTurnCounter;                            // 0x1050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickPhantomTickCounter;                            // 0x1054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1058[0x8];                                     // 0x1058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetOriginCharacterAimedLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiPhantomManagementComponent">();
	}
	static class ULokiPhantomManagementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiPhantomManagementComponent>();
	}
};
static_assert(alignof(ULokiPhantomManagementComponent) == 0x000010, "Wrong alignment on ULokiPhantomManagementComponent");
static_assert(sizeof(ULokiPhantomManagementComponent) == 0x001060, "Wrong size on ULokiPhantomManagementComponent");
static_assert(offsetof(ULokiPhantomManagementComponent, PhantomConfig) == 0x0000F0, "Member 'ULokiPhantomManagementComponent::PhantomConfig' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, InstigatorCharacter) == 0x0000F8, "Member 'ULokiPhantomManagementComponent::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, AimPointTraceParam) == 0x000100, "Member 'ULokiPhantomManagementComponent::AimPointTraceParam' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, TickPhantomTurnInterval) == 0x001030, "Member 'ULokiPhantomManagementComponent::TickPhantomTurnInterval' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, TickPhantomTickInterval) == 0x001034, "Member 'ULokiPhantomManagementComponent::TickPhantomTickInterval' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, TickPhantomTurnCounter) == 0x001050, "Member 'ULokiPhantomManagementComponent::TickPhantomTurnCounter' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, TickPhantomTickCounter) == 0x001054, "Member 'ULokiPhantomManagementComponent::TickPhantomTickCounter' has a wrong offset!");

// Class Hero_1016.LokiAnimTimelineComponent
// 0x0010 (0x0228 - 0x0218)
class ULokiAnimTimelineComponent final : public UAnimTimelineComponent
{
public:
	class UConfig_101651*                         PhantomConfig;                                     // 0x0218(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x0220(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiAnimTimelineComponent">();
	}
	static class ULokiAnimTimelineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiAnimTimelineComponent>();
	}
};
static_assert(alignof(ULokiAnimTimelineComponent) == 0x000008, "Wrong alignment on ULokiAnimTimelineComponent");
static_assert(sizeof(ULokiAnimTimelineComponent) == 0x000228, "Wrong size on ULokiAnimTimelineComponent");
static_assert(offsetof(ULokiAnimTimelineComponent, PhantomConfig) == 0x000218, "Member 'ULokiAnimTimelineComponent::PhantomConfig' has a wrong offset!");
static_assert(offsetof(ULokiAnimTimelineComponent, InstigatorCharacter) == 0x000220, "Member 'ULokiAnimTimelineComponent::InstigatorCharacter' has a wrong offset!");

// Class Hero_1016.Config_101652
// 0x0078 (0x0110 - 0x0098)
class UConfig_101652 final : public UMarvelAbilityConfig
{
public:
	struct FVector2D                              LockRange;                                         // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockTagContainer;                                 // 0x00A8(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101652">();
	}
	static class UConfig_101652* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101652>();
	}
};
static_assert(alignof(UConfig_101652) == 0x000008, "Wrong alignment on UConfig_101652");
static_assert(sizeof(UConfig_101652) == 0x000110, "Wrong size on UConfig_101652");
static_assert(offsetof(UConfig_101652, LockRange) == 0x000098, "Member 'UConfig_101652::LockRange' has a wrong offset!");
static_assert(offsetof(UConfig_101652, BlockTagContainer) == 0x0000A8, "Member 'UConfig_101652::BlockTagContainer' has a wrong offset!");

// Class Hero_1016.Ability_101652
// 0x0018 (0x2568 - 0x2550)
class UAbility_101652 : public UMarvelGameplayAbility
{
public:
	class ASummoned_10165101*                     TargetPhantom;                                     // 0x2550(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  ViewportTarget;                                    // 0x2558(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_101652*                         Config;                                            // 0x2560(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float AnglesToPoint(const struct FTransform& Transform, const struct FVector& Point);
	class AActor* GetProperPhantoms();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101652">();
	}
	static class UAbility_101652* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101652>();
	}
};
static_assert(alignof(UAbility_101652) == 0x000008, "Wrong alignment on UAbility_101652");
static_assert(sizeof(UAbility_101652) == 0x002568, "Wrong size on UAbility_101652");
static_assert(offsetof(UAbility_101652, TargetPhantom) == 0x002550, "Member 'UAbility_101652::TargetPhantom' has a wrong offset!");
static_assert(offsetof(UAbility_101652, ViewportTarget) == 0x002558, "Member 'UAbility_101652::ViewportTarget' has a wrong offset!");
static_assert(offsetof(UAbility_101652, Config) == 0x002560, "Member 'UAbility_101652::Config' has a wrong offset!");

// Class Hero_1016.UIC_SelectTarget_101652
// 0x0008 (0x0160 - 0x0158)
class UUIC_SelectTarget_101652 final : public UUIC_SelectTarget
{
public:
	class UAbility_101652*                        Ability_101652;                                    // 0x0158(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIC_SelectTarget_101652">();
	}
	static class UUIC_SelectTarget_101652* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIC_SelectTarget_101652>();
	}
};
static_assert(alignof(UUIC_SelectTarget_101652) == 0x000008, "Wrong alignment on UUIC_SelectTarget_101652");
static_assert(sizeof(UUIC_SelectTarget_101652) == 0x000160, "Wrong size on UUIC_SelectTarget_101652");
static_assert(offsetof(UUIC_SelectTarget_101652, Ability_101652) == 0x000158, "Member 'UUIC_SelectTarget_101652::Ability_101652' has a wrong offset!");

// Class Hero_1016.Config_101661
// 0x1308 (0x13A0 - 0x0098)
class UConfig_101661 final : public UMarvelAbilityConfig
{
public:
	int32                                         TargetDeceptionBuffID;                             // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetDuplicateBuffID;                             // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetStopDisguiseBuffID;                          // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetStopDisguiseRetentionTime;                   // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourcePrepDisguiseBuffID;                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourcePostDisguiseBuffID;                          // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               SourcePostDisguiseRemoveBuffTagRequirements;       // 0x00B0(0x0118)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetFXCueTag;                                    // 0x01C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetFXCueDuration;                               // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSelectTaskParam                       SelectTaskParam;                                   // 0x01E0(0x1040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AlwaysExcludedAbilities;                           // 0x1220(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExposeIfAbilityActivated;                          // 0x1288(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExposeTagContainer;                                // 0x12F0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag_InterruptDisguise;                             // 0x1358(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExposeWhenHitOrReceiveBuff;                       // 0x1364(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1365[0x3];                                     // 0x1365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraTransitionSpeed;                             // 0x1368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTransitionMaxSpeed;                          // 0x136C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTransitionAcceleration;                      // 0x1370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTransitionMinStep;                           // 0x1374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrantedUltimateEnergyPercent;                      // 0x1378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAbilityDuration;                                // 0x137C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraUltimateAbilityDuration;                      // 0x1380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MRFantasyEachJumpTime;                             // 0x1384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UserSettingConfirmationKeyName;                    // 0x1388(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfirmationIntervals;                             // 0x1394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1398[0x8];                                     // 0x1398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101661">();
	}
	static class UConfig_101661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101661>();
	}
};
static_assert(alignof(UConfig_101661) == 0x000010, "Wrong alignment on UConfig_101661");
static_assert(sizeof(UConfig_101661) == 0x0013A0, "Wrong size on UConfig_101661");
static_assert(offsetof(UConfig_101661, TargetDeceptionBuffID) == 0x000098, "Member 'UConfig_101661::TargetDeceptionBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101661, TargetDuplicateBuffID) == 0x00009C, "Member 'UConfig_101661::TargetDuplicateBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101661, TargetStopDisguiseBuffID) == 0x0000A0, "Member 'UConfig_101661::TargetStopDisguiseBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101661, TargetStopDisguiseRetentionTime) == 0x0000A4, "Member 'UConfig_101661::TargetStopDisguiseRetentionTime' has a wrong offset!");
static_assert(offsetof(UConfig_101661, SourcePrepDisguiseBuffID) == 0x0000A8, "Member 'UConfig_101661::SourcePrepDisguiseBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101661, SourcePostDisguiseBuffID) == 0x0000AC, "Member 'UConfig_101661::SourcePostDisguiseBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101661, SourcePostDisguiseRemoveBuffTagRequirements) == 0x0000B0, "Member 'UConfig_101661::SourcePostDisguiseRemoveBuffTagRequirements' has a wrong offset!");
static_assert(offsetof(UConfig_101661, TargetFXCueTag) == 0x0001C8, "Member 'UConfig_101661::TargetFXCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_101661, TargetFXCueDuration) == 0x0001D4, "Member 'UConfig_101661::TargetFXCueDuration' has a wrong offset!");
static_assert(offsetof(UConfig_101661, SelectTaskParam) == 0x0001E0, "Member 'UConfig_101661::SelectTaskParam' has a wrong offset!");
static_assert(offsetof(UConfig_101661, AlwaysExcludedAbilities) == 0x001220, "Member 'UConfig_101661::AlwaysExcludedAbilities' has a wrong offset!");
static_assert(offsetof(UConfig_101661, ExposeIfAbilityActivated) == 0x001288, "Member 'UConfig_101661::ExposeIfAbilityActivated' has a wrong offset!");
static_assert(offsetof(UConfig_101661, ExposeTagContainer) == 0x0012F0, "Member 'UConfig_101661::ExposeTagContainer' has a wrong offset!");
static_assert(offsetof(UConfig_101661, Tag_InterruptDisguise) == 0x001358, "Member 'UConfig_101661::Tag_InterruptDisguise' has a wrong offset!");
static_assert(offsetof(UConfig_101661, bExposeWhenHitOrReceiveBuff) == 0x001364, "Member 'UConfig_101661::bExposeWhenHitOrReceiveBuff' has a wrong offset!");
static_assert(offsetof(UConfig_101661, CameraTransitionSpeed) == 0x001368, "Member 'UConfig_101661::CameraTransitionSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101661, CameraTransitionMaxSpeed) == 0x00136C, "Member 'UConfig_101661::CameraTransitionMaxSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101661, CameraTransitionAcceleration) == 0x001370, "Member 'UConfig_101661::CameraTransitionAcceleration' has a wrong offset!");
static_assert(offsetof(UConfig_101661, CameraTransitionMinStep) == 0x001374, "Member 'UConfig_101661::CameraTransitionMinStep' has a wrong offset!");
static_assert(offsetof(UConfig_101661, GrantedUltimateEnergyPercent) == 0x001378, "Member 'UConfig_101661::GrantedUltimateEnergyPercent' has a wrong offset!");
static_assert(offsetof(UConfig_101661, MaxAbilityDuration) == 0x00137C, "Member 'UConfig_101661::MaxAbilityDuration' has a wrong offset!");
static_assert(offsetof(UConfig_101661, ExtraUltimateAbilityDuration) == 0x001380, "Member 'UConfig_101661::ExtraUltimateAbilityDuration' has a wrong offset!");
static_assert(offsetof(UConfig_101661, MRFantasyEachJumpTime) == 0x001384, "Member 'UConfig_101661::MRFantasyEachJumpTime' has a wrong offset!");
static_assert(offsetof(UConfig_101661, UserSettingConfirmationKeyName) == 0x001388, "Member 'UConfig_101661::UserSettingConfirmationKeyName' has a wrong offset!");
static_assert(offsetof(UConfig_101661, ConfirmationIntervals) == 0x001394, "Member 'UConfig_101661::ConfirmationIntervals' has a wrong offset!");

// Class Hero_1016.Ability_101661
// 0x01C0 (0x2710 - 0x2550)
class UAbility_101661 : public UMarvelGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             OnTryActivateWithoutTarget;                        // 0x2550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPrimaryTargetUpdate;                             // 0x2560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActingCharacterKillActor;                        // 0x2570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2580[0x18];                                    // 0x2580(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_101661*                         MyConfig;                                          // 0x2598(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtraUltimateTime;                                 // 0x25A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DisguiseStateUltimateUseCount;                     // 0x25A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         DisguiseStateEndedKey;                             // 0x25A8(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  ViewportTarget;                                    // 0x2648(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SavedTargetHeroID;                                 // 0x2650(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SavedTargetSkinID;                                 // 0x2654(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SavedTargetIsEnemy;                                // 0x2658(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBattleSide                                   SavedTargetBattleSide;                             // 0x2659(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265A[0x6];                                     // 0x265A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SavedTargetPlayerName;                             // 0x2660(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerState*                           SavedTargetPlayerState;                            // 0x2670(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SavedTargetCollisionRadius;                        // 0x2678(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SavedTargetCollisionHalfHeight;                    // 0x267C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   ActingCharacter;                                   // 0x2680(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AController*                            ActingController;                                  // 0x2688(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelPlayerState*                     ActingPlayerState;                                 // 0x2690(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetDuplicateEffectStartTime;                    // 0x2698(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            TargetDuplicateEffectHandle;                       // 0x269C(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            TargetDeceptionEffectHandle;                       // 0x26A4(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26AC[0x4];                                     // 0x26AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffectHandle>    SourceDisguiseEffectHandles;                       // 0x26B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitGameplayEffectRemoved* WaitEffectRemovedTask;                             // 0x26C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_SelectTarget*        SelectTask;                                        // 0x26C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitGameplayEvent*         WaitGameplayEvent;                                 // 0x26D0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26D8[0x38];                                    // 0x26D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddActingCharacterEnergyValue(class AActor* SourceActor);
	struct FTransform AdjustPawnTransform(const class APawn* NewPawn, const class APawn* OldPawn, const struct FTransform& OldTransform);
	bool CheckViewportTarget(const class AMarvelBaseCharacter* SourceCharacter, const class AActor* InTarget);
	void On104061JumpAgain(class UMarvelGameplayAbility* InAbility);
	void OnActingCharacterAbilityFinishedInit(class AActor* SourceActor);
	void OnActingCharacterKillActor__DelegateSignature(class AActor* KillTarget);
	void OnActingCharacterTagUpdated(const struct FGameplayTag& InTag, bool bInExists);
	void OnActorDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnBannerTagAdded();
	void OnDisguiseEffectRemoved(const struct FGameplayEffectRemovalInfo& InGameplayEffectRemovalInfo);
	void OnDisguiseInterruptedTagEvent(const struct FGameplayEventData& Payload);
	void OnDisguiseStateChanged(class AMarvelPlayerState* InPlayerState, class APawn* InNewPawn, class APawn* InOldPawn);
	void OnDisguiseStateEnded_CameraTransition(class AMarvelPlayerState* InPlayerState);
	void OnDisguiseStateEnded_PlayEndTimeline();
	void OnHeroHulkAbilitiesFinishInit(class AActor* SourceActor);
	void OnMrFantasyAbilityEnd(const struct FAbilityEndedData& InAbilityEndedData);
	void OnMySelfPlayerStateChange(class AMarvelPlayerState* InPlayerState);
	void OnPrimaryTargetUpdate__DelegateSignature(class AActor* InTarget);
	void OnServerControllerPostNewPawn(class APawn* InPawn);
	void OnServerControllerPostPawnSpawn(class APawn* InPawn, ESpawnMethod InMethod);
	void OnServerControllerPreNewPawn(class APawn* InPawn);
	void OnTargetPlayerAbilityActivated(class UGameplayAbility* InAbility);
	void OnTargetPlayerAbilityCommitted(class UGameplayAbility* InAbility);
	void OnTargetPlayerControllerSet();
	void OnTargetPlayerPreDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnTargetPlayerReceiveEffect(class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& EffectHandle);
	void OnTryActivateWithoutTarget__DelegateSignature();
	void PrepDisguiseEffect();
	void ReCalculateAbilityRemainTime(class UMarvelGameplayAbility* InAbility);
	void ResetSelectTask();
	bool StartDisguiseEffect();
	void StopDisguiseEffect(bool bIsAvatarAlive, class AActor* InSourceAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	bool VerifyAndSaveTarget(const class AActor* InTarget);

	bool IsDisguiseActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101661">();
	}
	static class UAbility_101661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101661>();
	}
};
static_assert(alignof(UAbility_101661) == 0x000008, "Wrong alignment on UAbility_101661");
static_assert(sizeof(UAbility_101661) == 0x002710, "Wrong size on UAbility_101661");
static_assert(offsetof(UAbility_101661, OnTryActivateWithoutTarget) == 0x002550, "Member 'UAbility_101661::OnTryActivateWithoutTarget' has a wrong offset!");
static_assert(offsetof(UAbility_101661, OnPrimaryTargetUpdate) == 0x002560, "Member 'UAbility_101661::OnPrimaryTargetUpdate' has a wrong offset!");
static_assert(offsetof(UAbility_101661, OnActingCharacterKillActor) == 0x002570, "Member 'UAbility_101661::OnActingCharacterKillActor' has a wrong offset!");
static_assert(offsetof(UAbility_101661, MyConfig) == 0x002598, "Member 'UAbility_101661::MyConfig' has a wrong offset!");
static_assert(offsetof(UAbility_101661, ExtraUltimateTime) == 0x0025A0, "Member 'UAbility_101661::ExtraUltimateTime' has a wrong offset!");
static_assert(offsetof(UAbility_101661, DisguiseStateUltimateUseCount) == 0x0025A4, "Member 'UAbility_101661::DisguiseStateUltimateUseCount' has a wrong offset!");
static_assert(offsetof(UAbility_101661, DisguiseStateEndedKey) == 0x0025A8, "Member 'UAbility_101661::DisguiseStateEndedKey' has a wrong offset!");
static_assert(offsetof(UAbility_101661, ViewportTarget) == 0x002648, "Member 'UAbility_101661::ViewportTarget' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetHeroID) == 0x002650, "Member 'UAbility_101661::SavedTargetHeroID' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetSkinID) == 0x002654, "Member 'UAbility_101661::SavedTargetSkinID' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetIsEnemy) == 0x002658, "Member 'UAbility_101661::SavedTargetIsEnemy' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetBattleSide) == 0x002659, "Member 'UAbility_101661::SavedTargetBattleSide' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetPlayerName) == 0x002660, "Member 'UAbility_101661::SavedTargetPlayerName' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetPlayerState) == 0x002670, "Member 'UAbility_101661::SavedTargetPlayerState' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetCollisionRadius) == 0x002678, "Member 'UAbility_101661::SavedTargetCollisionRadius' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetCollisionHalfHeight) == 0x00267C, "Member 'UAbility_101661::SavedTargetCollisionHalfHeight' has a wrong offset!");
static_assert(offsetof(UAbility_101661, ActingCharacter) == 0x002680, "Member 'UAbility_101661::ActingCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_101661, ActingController) == 0x002688, "Member 'UAbility_101661::ActingController' has a wrong offset!");
static_assert(offsetof(UAbility_101661, ActingPlayerState) == 0x002690, "Member 'UAbility_101661::ActingPlayerState' has a wrong offset!");
static_assert(offsetof(UAbility_101661, TargetDuplicateEffectStartTime) == 0x002698, "Member 'UAbility_101661::TargetDuplicateEffectStartTime' has a wrong offset!");
static_assert(offsetof(UAbility_101661, TargetDuplicateEffectHandle) == 0x00269C, "Member 'UAbility_101661::TargetDuplicateEffectHandle' has a wrong offset!");
static_assert(offsetof(UAbility_101661, TargetDeceptionEffectHandle) == 0x0026A4, "Member 'UAbility_101661::TargetDeceptionEffectHandle' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SourceDisguiseEffectHandles) == 0x0026B0, "Member 'UAbility_101661::SourceDisguiseEffectHandles' has a wrong offset!");
static_assert(offsetof(UAbility_101661, WaitEffectRemovedTask) == 0x0026C0, "Member 'UAbility_101661::WaitEffectRemovedTask' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SelectTask) == 0x0026C8, "Member 'UAbility_101661::SelectTask' has a wrong offset!");
static_assert(offsetof(UAbility_101661, WaitGameplayEvent) == 0x0026D0, "Member 'UAbility_101661::WaitGameplayEvent' has a wrong offset!");

// Class Hero_1016.CharacterSpawnPipeline_101661
// 0x0000 (0x0030 - 0x0030)
class UCharacterSpawnPipeline_101661 final : public UMarvelCharacterSpawnPipeline
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSpawnPipeline_101661">();
	}
	static class UCharacterSpawnPipeline_101661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSpawnPipeline_101661>();
	}
};
static_assert(alignof(UCharacterSpawnPipeline_101661) == 0x000008, "Wrong alignment on UCharacterSpawnPipeline_101661");
static_assert(sizeof(UCharacterSpawnPipeline_101661) == 0x000030, "Wrong size on UCharacterSpawnPipeline_101661");

// Class Hero_1016.ExtraWidget_101661
// 0x0000 (0x07A0 - 0x07A0)
class UExtraWidget_101661 final : public UWidget_AbilityStatus_Normal
{
public:
	void SetDurationAndStartCountDown(float Duration, float TimeRemaining);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtraWidget_101661">();
	}
	static class UExtraWidget_101661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtraWidget_101661>();
	}
};
static_assert(alignof(UExtraWidget_101661) == 0x000008, "Wrong alignment on UExtraWidget_101661");
static_assert(sizeof(UExtraWidget_101661) == 0x0007A0, "Wrong size on UExtraWidget_101661");

// Class Hero_1016.CueNotify_10166102
// 0x0088 (0x1070 - 0x0FE8)
class ACueNotify_10166102 final : public AMarvelCueNotify_Buff
{
public:
	struct FGameplayTag                           DisguiseEffectGameplayTag;                         // 0x0FE8(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF4[0x4];                                      // 0x0FF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   Character;                                         // 0x0FF8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           SetDyeingStateTimerHandle;                         // 0x1000(0x0018)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           SetTickEnabledTimerHandle;                         // 0x1018(0x0018)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x1030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1034[0x4];                                     // 0x1034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RecoveryCurve;                                     // 0x1038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryTime;                                      // 0x1040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x1044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1048[0x18];                                    // 0x1048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      InStableNiagara;                                   // 0x1060(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBuffDuration;                                   // 0x1068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastTimeBuffRemainTime;                            // 0x106C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EnableSelfTick();
	void MyOnRemoveFX(class AActor* MyTarget);
	void OnTagUpdate(const struct FGameplayTag& Tag, bool bTagExists);
	void SetChildMeshMaterials(class AMarvelCharacterChildActor* InChildActor, const TArray<class FName>& SocketNames, float Value);
	void SetDuplicateEffect(bool bEnabled, bool bDisguise, class AMarvelBaseCharacter* MyOwner);
	void SetDyeingStateDisabled();
	void SetDyeingStateEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueNotify_10166102">();
	}
	static class ACueNotify_10166102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueNotify_10166102>();
	}
};
static_assert(alignof(ACueNotify_10166102) == 0x000008, "Wrong alignment on ACueNotify_10166102");
static_assert(sizeof(ACueNotify_10166102) == 0x001070, "Wrong size on ACueNotify_10166102");
static_assert(offsetof(ACueNotify_10166102, DisguiseEffectGameplayTag) == 0x000FE8, "Member 'ACueNotify_10166102::DisguiseEffectGameplayTag' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, Character) == 0x000FF8, "Member 'ACueNotify_10166102::Character' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, SetDyeingStateTimerHandle) == 0x001000, "Member 'ACueNotify_10166102::SetDyeingStateTimerHandle' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, SetTickEnabledTimerHandle) == 0x001018, "Member 'ACueNotify_10166102::SetTickEnabledTimerHandle' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, DelayTime) == 0x001030, "Member 'ACueNotify_10166102::DelayTime' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, RecoveryCurve) == 0x001038, "Member 'ACueNotify_10166102::RecoveryCurve' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, RecoveryTime) == 0x001040, "Member 'ACueNotify_10166102::RecoveryTime' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, CurrentTime) == 0x001044, "Member 'ACueNotify_10166102::CurrentTime' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, InStableNiagara) == 0x001060, "Member 'ACueNotify_10166102::InStableNiagara' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, MaxBuffDuration) == 0x001068, "Member 'ACueNotify_10166102::MaxBuffDuration' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, LastTimeBuffRemainTime) == 0x00106C, "Member 'ACueNotify_10166102::LastTimeBuffRemainTime' has a wrong offset!");

// Class Hero_1016.CueNotify_10166104
// 0x0028 (0x0EA0 - 0x0E78)
class ACueNotify_10166104 final : public AMarvelCueNotify_Loop
{
public:
	class UFXSystemComponent*                     EffectComponent;                                   // 0x0E78(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         FXConnection;                                      // 0x0E80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PositionSocket;                                    // 0x0E88(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E94[0x4];                                      // 0x0E94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   SourceCharacter;                                   // 0x0E98(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueNotify_10166104">();
	}
	static class ACueNotify_10166104* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueNotify_10166104>();
	}
};
static_assert(alignof(ACueNotify_10166104) == 0x000008, "Wrong alignment on ACueNotify_10166104");
static_assert(sizeof(ACueNotify_10166104) == 0x000EA0, "Wrong size on ACueNotify_10166104");
static_assert(offsetof(ACueNotify_10166104, EffectComponent) == 0x000E78, "Member 'ACueNotify_10166104::EffectComponent' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166104, FXConnection) == 0x000E80, "Member 'ACueNotify_10166104::FXConnection' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166104, PositionSocket) == 0x000E88, "Member 'ACueNotify_10166104::PositionSocket' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166104, SourceCharacter) == 0x000E98, "Member 'ACueNotify_10166104::SourceCharacter' has a wrong offset!");

// Class Hero_1016.EpicMomentAction_1016
// 0x0028 (0x0198 - 0x0170)
class UEpicMomentAction_1016 : public UEpicMomentAction_Treat
{
public:
	class UMarvelGameplayAbility*                 DisguiseAbility;                                   // 0x0170(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelGameplayAbility*                 ShiftAbility;                                      // 0x0178(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x4];                                      // 0x0180(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    ShiftConfig;                                       // 0x0184(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ShiftDamageThreshold;                              // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorDamageToCure(class AActor* InSource, class AActor* InTarget, int32 AbilityID, float Value, float DamageValue);
	void OnShiftAbilityEnd();
	void OnSummonedBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Summoned, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnSummonedEnd(class AActor* InSummoner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1016">();
	}
	static class UEpicMomentAction_1016* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1016>();
	}
};
static_assert(alignof(UEpicMomentAction_1016) == 0x000008, "Wrong alignment on UEpicMomentAction_1016");
static_assert(sizeof(UEpicMomentAction_1016) == 0x000198, "Wrong size on UEpicMomentAction_1016");
static_assert(offsetof(UEpicMomentAction_1016, DisguiseAbility) == 0x000170, "Member 'UEpicMomentAction_1016::DisguiseAbility' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1016, ShiftAbility) == 0x000178, "Member 'UEpicMomentAction_1016::ShiftAbility' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1016, ShiftConfig) == 0x000184, "Member 'UEpicMomentAction_1016::ShiftConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1016, ShiftDamageThreshold) == 0x000190, "Member 'UEpicMomentAction_1016::ShiftDamageThreshold' has a wrong offset!");

// Class Hero_1016.LokiAnimInstance
// 0x0010 (0x0910 - 0x0900)
class ULokiAnimInstance : public UMarvelAnimInstance
{
public:
	int32                                         AimOffsetAnimIndex;                                // 0x0900(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_904[0xC];                                      // 0x0904(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiAnimInstance">();
	}
	static class ULokiAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiAnimInstance>();
	}
};
static_assert(alignof(ULokiAnimInstance) == 0x000010, "Wrong alignment on ULokiAnimInstance");
static_assert(sizeof(ULokiAnimInstance) == 0x000910, "Wrong size on ULokiAnimInstance");
static_assert(offsetof(ULokiAnimInstance, AimOffsetAnimIndex) == 0x000900, "Member 'ULokiAnimInstance::AimOffsetAnimIndex' has a wrong offset!");

// Class Hero_1016.LokiPhantomAnimInstance
// 0x0000 (0x0910 - 0x0910)
class ULokiPhantomAnimInstance final : public ULokiAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiPhantomAnimInstance">();
	}
	static class ULokiPhantomAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiPhantomAnimInstance>();
	}
};
static_assert(alignof(ULokiPhantomAnimInstance) == 0x000010, "Wrong alignment on ULokiPhantomAnimInstance");
static_assert(sizeof(ULokiPhantomAnimInstance) == 0x000910, "Wrong size on ULokiPhantomAnimInstance");

// Class Hero_1016.LokiPhantomGroundMotionSubAnimInstance
// 0x0030 (0x1330 - 0x1300)
class ULokiPhantomGroundMotionSubAnimInstance final : public UGroundMotionSubAnimInstanceV2
{
public:
	bool                                          bLokiPhantomIsInAir;                               // 0x12F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F9[0x7];                                     // 0x12F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             SummonedChracter;                                  // 0x1300(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1308[0x28];                                    // 0x1308(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiPhantomGroundMotionSubAnimInstance">();
	}
	static class ULokiPhantomGroundMotionSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiPhantomGroundMotionSubAnimInstance>();
	}
};
static_assert(alignof(ULokiPhantomGroundMotionSubAnimInstance) == 0x000010, "Wrong alignment on ULokiPhantomGroundMotionSubAnimInstance");
static_assert(sizeof(ULokiPhantomGroundMotionSubAnimInstance) == 0x001330, "Wrong size on ULokiPhantomGroundMotionSubAnimInstance");
static_assert(offsetof(ULokiPhantomGroundMotionSubAnimInstance, bLokiPhantomIsInAir) == 0x0012F8, "Member 'ULokiPhantomGroundMotionSubAnimInstance::bLokiPhantomIsInAir' has a wrong offset!");
static_assert(offsetof(ULokiPhantomGroundMotionSubAnimInstance, SummonedChracter) == 0x001300, "Member 'ULokiPhantomGroundMotionSubAnimInstance::SummonedChracter' has a wrong offset!");

// Class Hero_1016.LokiChildActor
// 0x0010 (0x0A50 - 0x0A40)
class ALokiChildActor : public AMarvelCharacterChildActor
{
public:
	class USkeletalMeshComponent*                 DaggerMesh;                                        // 0x0A40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      WeaponNiagara;                                     // 0x0A48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiChildActor">();
	}
	static class ALokiChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALokiChildActor>();
	}
};
static_assert(alignof(ALokiChildActor) == 0x000008, "Wrong alignment on ALokiChildActor");
static_assert(sizeof(ALokiChildActor) == 0x000A50, "Wrong size on ALokiChildActor");
static_assert(offsetof(ALokiChildActor, DaggerMesh) == 0x000A40, "Member 'ALokiChildActor::DaggerMesh' has a wrong offset!");
static_assert(offsetof(ALokiChildActor, WeaponNiagara) == 0x000A48, "Member 'ALokiChildActor::WeaponNiagara' has a wrong offset!");

// Class Hero_1016.LokiCharacter
// 0x0030 (0x17F0 - 0x17C0)
class ALokiCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bInVisible;                                        // 0x17B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B9[0x7];                                     // 0x17B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULokiPhantomManagementComponent*        PhantomManagementComponent;                        // 0x17C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULokiMoveLogicBaseComponent*            LokiMoveLogic;                                     // 0x17C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetPhantomCache;                                // 0x17D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17D1[0x7];                                     // 0x17D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActivePhantoms;                                    // 0x17D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_17E8[0x8];                                     // 0x17E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SpawnLokiPhantom(const struct FTransform& InTransform, const class UMarvelGameplayAbility* InAbility);
	void UpdatePhantomManagementComponentTick(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiCharacter">();
	}
	static class ALokiCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALokiCharacter>();
	}
};
static_assert(alignof(ALokiCharacter) == 0x000010, "Wrong alignment on ALokiCharacter");
static_assert(sizeof(ALokiCharacter) == 0x0017F0, "Wrong size on ALokiCharacter");
static_assert(offsetof(ALokiCharacter, bInVisible) == 0x0017B8, "Member 'ALokiCharacter::bInVisible' has a wrong offset!");
static_assert(offsetof(ALokiCharacter, PhantomManagementComponent) == 0x0017C0, "Member 'ALokiCharacter::PhantomManagementComponent' has a wrong offset!");
static_assert(offsetof(ALokiCharacter, LokiMoveLogic) == 0x0017C8, "Member 'ALokiCharacter::LokiMoveLogic' has a wrong offset!");
static_assert(offsetof(ALokiCharacter, bResetPhantomCache) == 0x0017D0, "Member 'ALokiCharacter::bResetPhantomCache' has a wrong offset!");
static_assert(offsetof(ALokiCharacter, ActivePhantoms) == 0x0017D8, "Member 'ALokiCharacter::ActivePhantoms' has a wrong offset!");

// Class Hero_1016.LokiMoveLogicBaseComponent
// 0x0018 (0x0408 - 0x03F0)
class ULokiMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	float                                         FortStyleTurninPlaceLimitMinOffset_Invisible;      // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PhantomDistanceThreshold;                          // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALokiCharacter*                         Loki;                                              // 0x03F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiMoveLogicBaseComponent">();
	}
	static class ULokiMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiMoveLogicBaseComponent>();
	}
};
static_assert(alignof(ULokiMoveLogicBaseComponent) == 0x000008, "Wrong alignment on ULokiMoveLogicBaseComponent");
static_assert(sizeof(ULokiMoveLogicBaseComponent) == 0x000408, "Wrong size on ULokiMoveLogicBaseComponent");
static_assert(offsetof(ULokiMoveLogicBaseComponent, FortStyleTurninPlaceLimitMinOffset_Invisible) == 0x0003F0, "Member 'ULokiMoveLogicBaseComponent::FortStyleTurninPlaceLimitMinOffset_Invisible' has a wrong offset!");
static_assert(offsetof(ULokiMoveLogicBaseComponent, PhantomDistanceThreshold) == 0x0003F4, "Member 'ULokiMoveLogicBaseComponent::PhantomDistanceThreshold' has a wrong offset!");
static_assert(offsetof(ULokiMoveLogicBaseComponent, Loki) == 0x0003F8, "Member 'ULokiMoveLogicBaseComponent::Loki' has a wrong offset!");

// Class Hero_1016.LokiMovementComponent
// 0x0000 (0x1AF0 - 0x1AF0)
class ULokiMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiMovementComponent">();
	}
	static class ULokiMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiMovementComponent>();
	}
};
static_assert(alignof(ULokiMovementComponent) == 0x000010, "Wrong alignment on ULokiMovementComponent");
static_assert(sizeof(ULokiMovementComponent) == 0x001AF0, "Wrong size on ULokiMovementComponent");

// Class Hero_1016.TabData_1016
// 0x0000 (0x0050 - 0x0050)
class UTabData_1016 : public UHeroTabDataBase
{
public:
	void OnActorDamageToCure(class AActor* InSource, class AActor* InTarget, int32 AbilityID, float Value, float DamageValue);
	void OnActorTakeHealth(class AActor* InInstigator, class AActor* InTarget, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1016">();
	}
	static class UTabData_1016* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1016>();
	}
};
static_assert(alignof(UTabData_1016) == 0x000008, "Wrong alignment on UTabData_1016");
static_assert(sizeof(UTabData_1016) == 0x000050, "Wrong size on UTabData_1016");

}

