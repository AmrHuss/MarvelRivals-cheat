#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1047

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Hero_1047_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"


namespace SDK
{

// Class Hero_1047.Config_104701
// 0x0008 (0x00A0 - 0x0098)
class UConfig_104701 final : public UMarvelAbilityConfig
{
public:
	float                                         CriticalStrikeReductionPercentage;                 // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104701">();
	}
	static class UConfig_104701* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104701>();
	}
};
static_assert(alignof(UConfig_104701) == 0x000008, "Wrong alignment on UConfig_104701");
static_assert(sizeof(UConfig_104701) == 0x0000A0, "Wrong size on UConfig_104701");
static_assert(offsetof(UConfig_104701, CriticalStrikeReductionPercentage) == 0x000098, "Member 'UConfig_104701::CriticalStrikeReductionPercentage' has a wrong offset!");

// Class Hero_1047.Ability_104701
// 0x0000 (0x2550 - 0x2550)
class UAbility_104701 : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104701">();
	}
	static class UAbility_104701* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104701>();
	}
};
static_assert(alignof(UAbility_104701) == 0x000008, "Wrong alignment on UAbility_104701");
static_assert(sizeof(UAbility_104701) == 0x002550, "Wrong size on UAbility_104701");

// Class Hero_1047.Config_104711
// 0x0070 (0x0128 - 0x00B8)
class UConfig_104711 : public UConfig_105
{
public:
	class UCurveFloat*                            ProjectileRadiusCurveByTime;                       // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProjectileGravityCurveByTime;                      // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProjectileVelocityCurveByTime;                     // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayEnterSectionEndTime;                          // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHapplyBubbleDebug;                                // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsiderCutCosAngle;                              // 0x00D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CutAngle;                                          // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DynamicInterpRotationSpeedCurve;                   // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicInterpRotationMaxAngle;                     // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlowDelayTime;                                     // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFlowSpeed;                                      // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSegmentsSpline                        SegmentsSpline;                                    // 0x00F4(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104711">();
	}
	static class UConfig_104711* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104711>();
	}
};
static_assert(alignof(UConfig_104711) == 0x000008, "Wrong alignment on UConfig_104711");
static_assert(sizeof(UConfig_104711) == 0x000128, "Wrong size on UConfig_104711");
static_assert(offsetof(UConfig_104711, ProjectileRadiusCurveByTime) == 0x0000B8, "Member 'UConfig_104711::ProjectileRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(UConfig_104711, ProjectileGravityCurveByTime) == 0x0000C0, "Member 'UConfig_104711::ProjectileGravityCurveByTime' has a wrong offset!");
static_assert(offsetof(UConfig_104711, ProjectileVelocityCurveByTime) == 0x0000C8, "Member 'UConfig_104711::ProjectileVelocityCurveByTime' has a wrong offset!");
static_assert(offsetof(UConfig_104711, DelayEnterSectionEndTime) == 0x0000D0, "Member 'UConfig_104711::DelayEnterSectionEndTime' has a wrong offset!");
static_assert(offsetof(UConfig_104711, bHapplyBubbleDebug) == 0x0000D4, "Member 'UConfig_104711::bHapplyBubbleDebug' has a wrong offset!");
static_assert(offsetof(UConfig_104711, bConsiderCutCosAngle) == 0x0000D5, "Member 'UConfig_104711::bConsiderCutCosAngle' has a wrong offset!");
static_assert(offsetof(UConfig_104711, CutAngle) == 0x0000D8, "Member 'UConfig_104711::CutAngle' has a wrong offset!");
static_assert(offsetof(UConfig_104711, DynamicInterpRotationSpeedCurve) == 0x0000E0, "Member 'UConfig_104711::DynamicInterpRotationSpeedCurve' has a wrong offset!");
static_assert(offsetof(UConfig_104711, DynamicInterpRotationMaxAngle) == 0x0000E8, "Member 'UConfig_104711::DynamicInterpRotationMaxAngle' has a wrong offset!");
static_assert(offsetof(UConfig_104711, FlowDelayTime) == 0x0000EC, "Member 'UConfig_104711::FlowDelayTime' has a wrong offset!");
static_assert(offsetof(UConfig_104711, MaxFlowSpeed) == 0x0000F0, "Member 'UConfig_104711::MaxFlowSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104711, SegmentsSpline) == 0x0000F4, "Member 'UConfig_104711::SegmentsSpline' has a wrong offset!");

// Class Hero_1047.Projectile_10471101
// 0x0090 (0x2FF0 - 0x2F60)
class AProjectile_10471101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	class UConfig_104711*                         Config104711;                                      // 0x2F60(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProjectileRadiusCurveByTime;                       // 0x2F68(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProjectileGravityCurveByTime;                      // 0x2F70(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProjectileVelocityCurveByTime;                     // 0x2F78(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlowDelayTime;                                     // 0x2F80(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlowEscapeTime;                                    // 0x2F84(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OldVelocity;                                       // 0x2F88(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FA0[0x50];                                    // 0x2FA0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetProjectileFlyingTime();
	void OnJeffProjectileStop(const struct FHitResult& ImpactResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10471101">();
	}
	static class AProjectile_10471101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10471101>();
	}
};
static_assert(alignof(AProjectile_10471101) == 0x000010, "Wrong alignment on AProjectile_10471101");
static_assert(sizeof(AProjectile_10471101) == 0x002FF0, "Wrong size on AProjectile_10471101");
static_assert(offsetof(AProjectile_10471101, Config104711) == 0x002F60, "Member 'AProjectile_10471101::Config104711' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, ProjectileRadiusCurveByTime) == 0x002F68, "Member 'AProjectile_10471101::ProjectileRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, ProjectileGravityCurveByTime) == 0x002F70, "Member 'AProjectile_10471101::ProjectileGravityCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, ProjectileVelocityCurveByTime) == 0x002F78, "Member 'AProjectile_10471101::ProjectileVelocityCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, FlowDelayTime) == 0x002F80, "Member 'AProjectile_10471101::FlowDelayTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, FlowEscapeTime) == 0x002F84, "Member 'AProjectile_10471101::FlowEscapeTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, OldVelocity) == 0x002F88, "Member 'AProjectile_10471101::OldVelocity' has a wrong offset!");

// Class Hero_1047.Ability_104711
// 0x0008 (0x25A0 - 0x2598)
class UAbility_104711 : public UAbility_105
{
public:
	uint8                                         Pad_2598[0x8];                                     // 0x2598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104711">();
	}
	static class UAbility_104711* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104711>();
	}
};
static_assert(alignof(UAbility_104711) == 0x000008, "Wrong alignment on UAbility_104711");
static_assert(sizeof(UAbility_104711) == 0x0025A0, "Wrong size on UAbility_104711");

// Class Hero_1047.Cue_Projectile_Loop_10471101
// 0x0030 (0x0D90 - 0x0D60)
class ACue_Projectile_Loop_10471101 final : public AMarvelCueNotify_Projectile
{
public:
	class UNiagaraComponent*                      LoopNX;                                            // 0x0D60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      SingleFlowLoopNX;                                  // 0x0D68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConeAngleName;                                     // 0x0D70(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7C[0x4];                                      // 0x0D7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CurveConeAngle;                                    // 0x0D80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AProjectile_10471101*                   Projectile10471101;                                // 0x0D88(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10471101">();
	}
	static class ACue_Projectile_Loop_10471101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10471101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10471101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10471101");
static_assert(sizeof(ACue_Projectile_Loop_10471101) == 0x000D90, "Wrong size on ACue_Projectile_Loop_10471101");
static_assert(offsetof(ACue_Projectile_Loop_10471101, LoopNX) == 0x000D60, "Member 'ACue_Projectile_Loop_10471101::LoopNX' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10471101, SingleFlowLoopNX) == 0x000D68, "Member 'ACue_Projectile_Loop_10471101::SingleFlowLoopNX' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10471101, ConeAngleName) == 0x000D70, "Member 'ACue_Projectile_Loop_10471101::ConeAngleName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10471101, CurveConeAngle) == 0x000D80, "Member 'ACue_Projectile_Loop_10471101::CurveConeAngle' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10471101, Projectile10471101) == 0x000D88, "Member 'ACue_Projectile_Loop_10471101::Projectile10471101' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10471101
// 0x0018 (0x0E18 - 0x0E00)
class ACue_Ability_Loop_10471101 final : public AMarvelCueNotify_Ability
{
public:
	int32                                         OwningAbilityID;                                   // 0x0E00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E04[0x14];                                     // 0x0E04(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10471101">();
	}
	static class ACue_Ability_Loop_10471101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10471101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10471101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10471101");
static_assert(sizeof(ACue_Ability_Loop_10471101) == 0x000E18, "Wrong size on ACue_Ability_Loop_10471101");
static_assert(offsetof(ACue_Ability_Loop_10471101, OwningAbilityID) == 0x000E00, "Member 'ACue_Ability_Loop_10471101::OwningAbilityID' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10471102
// 0x0060 (0x0E60 - 0x0E00)
class ACue_Ability_Loop_10471102 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E00[0x8];                                      // 0x0E00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         SystemTemplate;                                    // 0x0E08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineComponent*>               LoopNXSpines;                                      // 0x0E10(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              LoopNXs;                                           // 0x0E20(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_E30[0x10];                                     // 0x0E30(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebug;                                            // 0x0E40(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugSpineComopnent;                              // 0x0E41(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E42[0x2];                                      // 0x0E42(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OwningAbilityID;                                   // 0x0E44(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDebugHapplyDebugSpline>        DebugHapplyBubblesGroup;                           // 0x0E48(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E58[0x8];                                      // 0x0E58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyDebugHapplyBubbles(int32 FrameIndex);
	void ApplyDebugHapplyBubblesSpline(int32 FrameIndex, class USplineComponent* Spline);
	void GetDebugHapplyMinAndMaxFrame(int32* Min, int32* Max);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10471102">();
	}
	static class ACue_Ability_Loop_10471102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10471102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10471102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10471102");
static_assert(sizeof(ACue_Ability_Loop_10471102) == 0x000E60, "Wrong size on ACue_Ability_Loop_10471102");
static_assert(offsetof(ACue_Ability_Loop_10471102, SystemTemplate) == 0x000E08, "Member 'ACue_Ability_Loop_10471102::SystemTemplate' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, LoopNXSpines) == 0x000E10, "Member 'ACue_Ability_Loop_10471102::LoopNXSpines' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, LoopNXs) == 0x000E20, "Member 'ACue_Ability_Loop_10471102::LoopNXs' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, bDebug) == 0x000E40, "Member 'ACue_Ability_Loop_10471102::bDebug' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, bDebugSpineComopnent) == 0x000E41, "Member 'ACue_Ability_Loop_10471102::bDebugSpineComopnent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, OwningAbilityID) == 0x000E44, "Member 'ACue_Ability_Loop_10471102::OwningAbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, DebugHapplyBubblesGroup) == 0x000E48, "Member 'ACue_Ability_Loop_10471102::DebugHapplyBubblesGroup' has a wrong offset!");

// Class Hero_1047.Cue_Projectile_HitImpact_10471101
// 0x0000 (0x04D0 - 0x04D0)
class UCue_Projectile_HitImpact_10471101 final : public UMarvelCueNotify_HitImpact
{
public:
	void OnPostExecuteAudioCreateShotActor(class AOneShotAudioActor* OneShotActor, class AActor* MyTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_HitImpact_10471101">();
	}
	static class UCue_Projectile_HitImpact_10471101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Projectile_HitImpact_10471101>();
	}
};
static_assert(alignof(UCue_Projectile_HitImpact_10471101) == 0x000008, "Wrong alignment on UCue_Projectile_HitImpact_10471101");
static_assert(sizeof(UCue_Projectile_HitImpact_10471101) == 0x0004D0, "Wrong size on UCue_Projectile_HitImpact_10471101");

// Class Hero_1047.Ability_104712
// 0x2068 (0x4600 - 0x2598)
class UAbility_104712 : public UAbility_105
{
public:
	class UCurveFloat*                            ProjectileCollisionRadiusCurveByTime;              // 0x2598(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFlowManagerTickFunction               FlowManagerTickFunction;                           // 0x25A0(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint64                                        CurrentActiveFlowUID;                              // 0x25D8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E0[0xF0];                                    // 0x25E0(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectile_10471201*                   LatestSpawnedProjectile;                           // 0x26D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26D8[0x8];                                     // 0x26D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             CachedTraceContext;                                // 0x26E0(0x0F30)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FMarvelProjectileAgentTable            CachedProjectileAgentTable;                        // 0x3610(0x0FD8)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_45E8[0x18];                                    // 0x45E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104712">();
	}
	static class UAbility_104712* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104712>();
	}
};
static_assert(alignof(UAbility_104712) == 0x000010, "Wrong alignment on UAbility_104712");
static_assert(sizeof(UAbility_104712) == 0x004600, "Wrong size on UAbility_104712");
static_assert(offsetof(UAbility_104712, ProjectileCollisionRadiusCurveByTime) == 0x002598, "Member 'UAbility_104712::ProjectileCollisionRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(UAbility_104712, FlowManagerTickFunction) == 0x0025A0, "Member 'UAbility_104712::FlowManagerTickFunction' has a wrong offset!");
static_assert(offsetof(UAbility_104712, CurrentActiveFlowUID) == 0x0025D8, "Member 'UAbility_104712::CurrentActiveFlowUID' has a wrong offset!");
static_assert(offsetof(UAbility_104712, LatestSpawnedProjectile) == 0x0026D0, "Member 'UAbility_104712::LatestSpawnedProjectile' has a wrong offset!");
static_assert(offsetof(UAbility_104712, CachedTraceContext) == 0x0026E0, "Member 'UAbility_104712::CachedTraceContext' has a wrong offset!");
static_assert(offsetof(UAbility_104712, CachedProjectileAgentTable) == 0x003610, "Member 'UAbility_104712::CachedProjectileAgentTable' has a wrong offset!");

// Class Hero_1047.Projectile_10471201
// 0x0030 (0x2F90 - 0x2F60)
class AProjectile_10471201 : public AMarvelAbilityTargetActor_Projectile
{
public:
	uint8                                         Pad_2F60[0x10];                                    // 0x2F60(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ProjectileCollisionRadiusCurveByTime;              // 0x2F70(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F78[0x8];                                     // 0x2F78(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        InitialFlowUID;                                    // 0x2F80(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F88[0x8];                                     // 0x2F88(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10471201">();
	}
	static class AProjectile_10471201* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10471201>();
	}
};
static_assert(alignof(AProjectile_10471201) == 0x000010, "Wrong alignment on AProjectile_10471201");
static_assert(sizeof(AProjectile_10471201) == 0x002F90, "Wrong size on AProjectile_10471201");
static_assert(offsetof(AProjectile_10471201, ProjectileCollisionRadiusCurveByTime) == 0x002F70, "Member 'AProjectile_10471201::ProjectileCollisionRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471201, InitialFlowUID) == 0x002F80, "Member 'AProjectile_10471201::InitialFlowUID' has a wrong offset!");

// Class Hero_1047.VisualWaterFlow
// 0x0010 (0x0040 - 0x0030)
class UVisualWaterFlow final : public UObject
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualWaterFlow">();
	}
	static class UVisualWaterFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisualWaterFlow>();
	}
};
static_assert(alignof(UVisualWaterFlow) == 0x000008, "Wrong alignment on UVisualWaterFlow");
static_assert(sizeof(UVisualWaterFlow) == 0x000040, "Wrong size on UVisualWaterFlow");
static_assert(offsetof(UVisualWaterFlow, NiagaraComponent) == 0x000030, "Member 'UVisualWaterFlow::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(UVisualWaterFlow, SplineComponent) == 0x000038, "Member 'UVisualWaterFlow::SplineComponent' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10471201
// 0x0080 (0x0E80 - 0x0E00)
class ACue_Ability_Loop_10471201 final : public AMarvelCueNotify_Ability
{
public:
	class UNiagaraComponent*                      NS_WaterFlow;                                      // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       SplineComponent;                                   // 0x0E08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         NS_WaterFlowSystem;                                // 0x0E10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<uint64, class UVisualWaterFlow*>         WaterFlowVisuals;                                  // 0x0E18(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UVisualWaterFlow*>               VisualWaterFlowPool;                               // 0x0E68(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UAbility_104712*                        Ability_104712;                                    // 0x0E78(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10471201">();
	}
	static class ACue_Ability_Loop_10471201* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10471201>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10471201) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10471201");
static_assert(sizeof(ACue_Ability_Loop_10471201) == 0x000E80, "Wrong size on ACue_Ability_Loop_10471201");
static_assert(offsetof(ACue_Ability_Loop_10471201, NS_WaterFlow) == 0x000E00, "Member 'ACue_Ability_Loop_10471201::NS_WaterFlow' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471201, SplineComponent) == 0x000E08, "Member 'ACue_Ability_Loop_10471201::SplineComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471201, NS_WaterFlowSystem) == 0x000E10, "Member 'ACue_Ability_Loop_10471201::NS_WaterFlowSystem' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471201, WaterFlowVisuals) == 0x000E18, "Member 'ACue_Ability_Loop_10471201::WaterFlowVisuals' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471201, VisualWaterFlowPool) == 0x000E68, "Member 'ACue_Ability_Loop_10471201::VisualWaterFlowPool' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471201, Ability_104712) == 0x000E78, "Member 'ACue_Ability_Loop_10471201::Ability_104712' has a wrong offset!");

// Class Hero_1047.WaterProjectileMovementComponent
// 0x0010 (0x1F80 - 0x1F70)
class UWaterProjectileMovementComponent final : public UMarvelProjectileComponent
{
public:
	class UCurveFloat*                            ProjectileVelocityCurveByTime;                     // 0x1F68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F70[0x10];                                    // 0x1F70(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterProjectileMovementComponent">();
	}
	static class UWaterProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterProjectileMovementComponent>();
	}
};
static_assert(alignof(UWaterProjectileMovementComponent) == 0x000010, "Wrong alignment on UWaterProjectileMovementComponent");
static_assert(sizeof(UWaterProjectileMovementComponent) == 0x001F80, "Wrong size on UWaterProjectileMovementComponent");
static_assert(offsetof(UWaterProjectileMovementComponent, ProjectileVelocityCurveByTime) == 0x001F68, "Member 'UWaterProjectileMovementComponent::ProjectileVelocityCurveByTime' has a wrong offset!");

// Class Hero_1047.Config_104713
// 0x0020 (0x0148 - 0x0128)
class UConfig_104713 final : public UConfig_104711
{
public:
	float                                         PaintRadius;                                       // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaintIneral;                                       // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PaintRadiusSize;                                   // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     PigmentActor;                                      // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104713">();
	}
	static class UConfig_104713* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104713>();
	}
};
static_assert(alignof(UConfig_104713) == 0x000008, "Wrong alignment on UConfig_104713");
static_assert(sizeof(UConfig_104713) == 0x000148, "Wrong size on UConfig_104713");
static_assert(offsetof(UConfig_104713, PaintRadius) == 0x000128, "Member 'UConfig_104713::PaintRadius' has a wrong offset!");
static_assert(offsetof(UConfig_104713, PaintIneral) == 0x00012C, "Member 'UConfig_104713::PaintIneral' has a wrong offset!");
static_assert(offsetof(UConfig_104713, PaintRadiusSize) == 0x000130, "Member 'UConfig_104713::PaintRadiusSize' has a wrong offset!");
static_assert(offsetof(UConfig_104713, PigmentActor) == 0x000140, "Member 'UConfig_104713::PigmentActor' has a wrong offset!");

// Class Hero_1047.Projectile_10471301
// 0x0000 (0x2FF0 - 0x2FF0)
class AProjectile_10471301 final : public AProjectile_10471101
{
public:
	void K2_JeffPaintOnLocation(const struct FJeffPaintParams& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10471301">();
	}
	static class AProjectile_10471301* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10471301>();
	}
};
static_assert(alignof(AProjectile_10471301) == 0x000010, "Wrong alignment on AProjectile_10471301");
static_assert(sizeof(AProjectile_10471301) == 0x002FF0, "Wrong size on AProjectile_10471301");

// Class Hero_1047.JeffWinterFestivalLibrary
// 0x0000 (0x0030 - 0x0030)
class UJeffWinterFestivalLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void JeffPaintOnLocation(const struct FJeffPaintParams& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffWinterFestivalLibrary">();
	}
	static class UJeffWinterFestivalLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffWinterFestivalLibrary>();
	}
};
static_assert(alignof(UJeffWinterFestivalLibrary) == 0x000008, "Wrong alignment on UJeffWinterFestivalLibrary");
static_assert(sizeof(UJeffWinterFestivalLibrary) == 0x000030, "Wrong size on UJeffWinterFestivalLibrary");

// Class Hero_1047.Cue_Ability_Loop_10473101
// 0x0078 (0x0E78 - 0x0E00)
class ACue_Ability_Loop_10473101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E00[0x10];                                     // 0x0E00(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BlockTags;                                         // 0x0E10(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void CheckMovementModeByState(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnSystemFinished(class UNiagaraComponent* PSystem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10473101">();
	}
	static class ACue_Ability_Loop_10473101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10473101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10473101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10473101");
static_assert(sizeof(ACue_Ability_Loop_10473101) == 0x000E78, "Wrong size on ACue_Ability_Loop_10473101");
static_assert(offsetof(ACue_Ability_Loop_10473101, BlockTags) == 0x000E10, "Member 'ACue_Ability_Loop_10473101::BlockTags' has a wrong offset!");

// Class Hero_1047.Config_104751
// 0x0008 (0x00A0 - 0x0098)
class UConfig_104751 final : public UMarvelAbilityConfig
{
public:
	float                                         SphereRadius;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104751">();
	}
	static class UConfig_104751* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104751>();
	}
};
static_assert(alignof(UConfig_104751) == 0x000008, "Wrong alignment on UConfig_104751");
static_assert(sizeof(UConfig_104751) == 0x0000A0, "Wrong size on UConfig_104751");
static_assert(offsetof(UConfig_104751, SphereRadius) == 0x000098, "Member 'UConfig_104751::SphereRadius' has a wrong offset!");

// Class Hero_1047.Summoned_10475101
// 0x0020 (0x0820 - 0x0800)
class ASummoned_10475101 : public AMarvelSummonerBase
{
public:
	class USphereComponent*                       OverlapCollisionComponent;                         // 0x07F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlapHandlerComponent*               OverlapHandleComponent;                            // 0x0800(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_808[0x8];                                      // 0x0808(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InstigatorUID;                                     // 0x0810(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_814[0xC];                                      // 0x0814(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorOverlap(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10475101">();
	}
	static class ASummoned_10475101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10475101>();
	}
};
static_assert(alignof(ASummoned_10475101) == 0x000010, "Wrong alignment on ASummoned_10475101");
static_assert(sizeof(ASummoned_10475101) == 0x000820, "Wrong size on ASummoned_10475101");
static_assert(offsetof(ASummoned_10475101, OverlapCollisionComponent) == 0x0007F8, "Member 'ASummoned_10475101::OverlapCollisionComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10475101, OverlapHandleComponent) == 0x000800, "Member 'ASummoned_10475101::OverlapHandleComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10475101, InstigatorUID) == 0x000810, "Member 'ASummoned_10475101::InstigatorUID' has a wrong offset!");

// Class Hero_1047.Projectile_10475101
// 0x0000 (0x2F60 - 0x2F60)
class AProjectile_10475101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	bool CheckBubblePlacingSpace(struct FVector* BubbleLocation, const struct FHitResult& InHitResult, float BubbleRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10475101">();
	}
	static class AProjectile_10475101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10475101>();
	}
};
static_assert(alignof(AProjectile_10475101) == 0x000010, "Wrong alignment on AProjectile_10475101");
static_assert(sizeof(AProjectile_10475101) == 0x002F60, "Wrong size on AProjectile_10475101");

// Class Hero_1047.Config_104761
// 0x0100 (0x0198 - 0x0098)
class UConfig_104761 : public UMarvelAbilityConfig
{
public:
	struct FGameplayTag                           DivingGameplayTag;                                 // 0x0098(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     IgnoreCollisionChannels;                           // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class FName>                             DivingHideMaterialSlots;                           // 0x00B8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<class FName>                             DivingParamMaterialSlots;                          // 0x0108(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         DivingOrientRotationLerpSpeed;                     // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChildActorMeshLerpSpeed;                           // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRelativeRotator;                             // 0x0160(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         EnterDivingCameraShake;                            // 0x0178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         ExitDivingCameraShake;                             // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraInterp*                          DivingCameraInterp;                                // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocal;                                           // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104761">();
	}
	static class UConfig_104761* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104761>();
	}
};
static_assert(alignof(UConfig_104761) == 0x000008, "Wrong alignment on UConfig_104761");
static_assert(sizeof(UConfig_104761) == 0x000198, "Wrong size on UConfig_104761");
static_assert(offsetof(UConfig_104761, DivingGameplayTag) == 0x000098, "Member 'UConfig_104761::DivingGameplayTag' has a wrong offset!");
static_assert(offsetof(UConfig_104761, IgnoreCollisionChannels) == 0x0000A8, "Member 'UConfig_104761::IgnoreCollisionChannels' has a wrong offset!");
static_assert(offsetof(UConfig_104761, DivingHideMaterialSlots) == 0x0000B8, "Member 'UConfig_104761::DivingHideMaterialSlots' has a wrong offset!");
static_assert(offsetof(UConfig_104761, DivingParamMaterialSlots) == 0x000108, "Member 'UConfig_104761::DivingParamMaterialSlots' has a wrong offset!");
static_assert(offsetof(UConfig_104761, DivingOrientRotationLerpSpeed) == 0x000158, "Member 'UConfig_104761::DivingOrientRotationLerpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104761, ChildActorMeshLerpSpeed) == 0x00015C, "Member 'UConfig_104761::ChildActorMeshLerpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104761, TargetRelativeRotator) == 0x000160, "Member 'UConfig_104761::TargetRelativeRotator' has a wrong offset!");
static_assert(offsetof(UConfig_104761, EnterDivingCameraShake) == 0x000178, "Member 'UConfig_104761::EnterDivingCameraShake' has a wrong offset!");
static_assert(offsetof(UConfig_104761, ExitDivingCameraShake) == 0x000180, "Member 'UConfig_104761::ExitDivingCameraShake' has a wrong offset!");
static_assert(offsetof(UConfig_104761, DivingCameraInterp) == 0x000188, "Member 'UConfig_104761::DivingCameraInterp' has a wrong offset!");
static_assert(offsetof(UConfig_104761, IsLocal) == 0x000190, "Member 'UConfig_104761::IsLocal' has a wrong offset!");

// Class Hero_1047.Ability_104761
// 0x00A0 (0x25F0 - 0x2550)
class UAbility_104761 : public UMarvelGameplayAbility
{
public:
	struct FPredictionKey                         GravityRestoreKey;                                 // 0x2550(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104761">();
	}
	static class UAbility_104761* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104761>();
	}
};
static_assert(alignof(UAbility_104761) == 0x000008, "Wrong alignment on UAbility_104761");
static_assert(sizeof(UAbility_104761) == 0x0025F0, "Wrong size on UAbility_104761");
static_assert(offsetof(UAbility_104761, GravityRestoreKey) == 0x002550, "Member 'UAbility_104761::GravityRestoreKey' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10476101
// 0x00B8 (0x0EB8 - 0x0E00)
class ACue_Ability_Loop_10476101 final : public AMarvelCueNotify_Ability
{
public:
	int32                                         DivingLoopAudioID;                                 // 0x0E00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartMoveAudioID;                                  // 0x0E04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopMoveAudioID;                                   // 0x0E08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMoveAudioProtectTime;                         // 0x0E0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopMoveAudioDelayTime;                            // 0x0E10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E14[0x4];                                      // 0x0E14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      LoopNX_1;                                          // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNX_2;                                          // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceDirectionParamName;                           // 0x0E28(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E34[0x4];                                      // 0x0E34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AJeffCharacter*                         JeffCharacter;                                     // 0x0E38(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJeffMovementComponent*                 JeffCharacterMovement;                             // 0x0E40(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104761*                         DivingConfig;                                      // 0x0E48(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FSpringArmControlHandler> SpringArmHandlers;                                 // 0x0E50(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UCameraShakeBase*                       EnterDivingShakeHandle;                            // 0x0EA0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA8[0x10];                                     // 0x0EA8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnJeffStateUpdate(EJeffState InState);
	void OnOwnerTagUpdate(const struct FGameplayTag& Tag, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10476101">();
	}
	static class ACue_Ability_Loop_10476101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10476101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10476101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10476101");
static_assert(sizeof(ACue_Ability_Loop_10476101) == 0x000EB8, "Wrong size on ACue_Ability_Loop_10476101");
static_assert(offsetof(ACue_Ability_Loop_10476101, DivingLoopAudioID) == 0x000E00, "Member 'ACue_Ability_Loop_10476101::DivingLoopAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, StartMoveAudioID) == 0x000E04, "Member 'ACue_Ability_Loop_10476101::StartMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, LoopMoveAudioID) == 0x000E08, "Member 'ACue_Ability_Loop_10476101::LoopMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, StartMoveAudioProtectTime) == 0x000E0C, "Member 'ACue_Ability_Loop_10476101::StartMoveAudioProtectTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, LoopMoveAudioDelayTime) == 0x000E10, "Member 'ACue_Ability_Loop_10476101::LoopMoveAudioDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, LoopNX_1) == 0x000E18, "Member 'ACue_Ability_Loop_10476101::LoopNX_1' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, LoopNX_2) == 0x000E20, "Member 'ACue_Ability_Loop_10476101::LoopNX_2' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, TraceDirectionParamName) == 0x000E28, "Member 'ACue_Ability_Loop_10476101::TraceDirectionParamName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, JeffCharacter) == 0x000E38, "Member 'ACue_Ability_Loop_10476101::JeffCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, JeffCharacterMovement) == 0x000E40, "Member 'ACue_Ability_Loop_10476101::JeffCharacterMovement' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, DivingConfig) == 0x000E48, "Member 'ACue_Ability_Loop_10476101::DivingConfig' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, SpringArmHandlers) == 0x000E50, "Member 'ACue_Ability_Loop_10476101::SpringArmHandlers' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, EnterDivingShakeHandle) == 0x000EA0, "Member 'ACue_Ability_Loop_10476101::EnterDivingShakeHandle' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_Jeff_Diving
// 0x0038 (0x0E38 - 0x0E00)
class ACue_Ability_Loop_Jeff_Diving final : public AMarvelCueNotify_Ability
{
public:
	int32                                         DivingEnvAudioID;                                  // 0x0E00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DivingMovementAudioID;                             // 0x0E04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DivingStartMoveAudioID;                            // 0x0E08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DivingStartMoveAudioProtectTime;                   // 0x0E0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DivingMovementAudioDelayTime;                      // 0x0E10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E14[0x4];                                      // 0x0E14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AJeffCharacter*                         JeffCharacter;                                     // 0x0E18(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelCharacterMovementComponent*      CharacterMovementComp;                             // 0x0E20(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E28[0x10];                                     // 0x0E28(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnJeffStateUpdate(EJeffState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_Jeff_Diving">();
	}
	static class ACue_Ability_Loop_Jeff_Diving* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_Jeff_Diving>();
	}
};
static_assert(alignof(ACue_Ability_Loop_Jeff_Diving) == 0x000008, "Wrong alignment on ACue_Ability_Loop_Jeff_Diving");
static_assert(sizeof(ACue_Ability_Loop_Jeff_Diving) == 0x000E38, "Wrong size on ACue_Ability_Loop_Jeff_Diving");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, DivingEnvAudioID) == 0x000E00, "Member 'ACue_Ability_Loop_Jeff_Diving::DivingEnvAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, DivingMovementAudioID) == 0x000E04, "Member 'ACue_Ability_Loop_Jeff_Diving::DivingMovementAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, DivingStartMoveAudioID) == 0x000E08, "Member 'ACue_Ability_Loop_Jeff_Diving::DivingStartMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, DivingStartMoveAudioProtectTime) == 0x000E0C, "Member 'ACue_Ability_Loop_Jeff_Diving::DivingStartMoveAudioProtectTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, DivingMovementAudioDelayTime) == 0x000E10, "Member 'ACue_Ability_Loop_Jeff_Diving::DivingMovementAudioDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, JeffCharacter) == 0x000E18, "Member 'ACue_Ability_Loop_Jeff_Diving::JeffCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, CharacterMovementComp) == 0x000E20, "Member 'ACue_Ability_Loop_Jeff_Diving::CharacterMovementComp' has a wrong offset!");

// Class Hero_1047.AnimNotify_JeffExitDivingPlayNiagaraEffect
// 0x0000 (0x0360 - 0x0360)
class UAnimNotify_JeffExitDivingPlayNiagaraEffect final : public UAnimNotify_PlayNiagaraEffectEx
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_JeffExitDivingPlayNiagaraEffect">();
	}
	static class UAnimNotify_JeffExitDivingPlayNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_JeffExitDivingPlayNiagaraEffect>();
	}
};
static_assert(alignof(UAnimNotify_JeffExitDivingPlayNiagaraEffect) == 0x000010, "Wrong alignment on UAnimNotify_JeffExitDivingPlayNiagaraEffect");
static_assert(sizeof(UAnimNotify_JeffExitDivingPlayNiagaraEffect) == 0x000360, "Wrong size on UAnimNotify_JeffExitDivingPlayNiagaraEffect");

// Class Hero_1047.Config_104762_New
// 0x0000 (0x00E0 - 0x00E0)
class UConfig_104762_New final : public UWallRunningPassiveAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104762_New">();
	}
	static class UConfig_104762_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104762_New>();
	}
};
static_assert(alignof(UConfig_104762_New) == 0x000008, "Wrong alignment on UConfig_104762_New");
static_assert(sizeof(UConfig_104762_New) == 0x0000E0, "Wrong size on UConfig_104762_New");

// Class Hero_1047.Ability_104762_New
// 0x0008 (0x2570 - 0x2568)
class UAbility_104762_New : public UWallRunningPassiveAbility
{
public:
	uint8                                         Pad_2568[0x8];                                     // 0x2568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104762_New">();
	}
	static class UAbility_104762_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104762_New>();
	}
};
static_assert(alignof(UAbility_104762_New) == 0x000008, "Wrong alignment on UAbility_104762_New");
static_assert(sizeof(UAbility_104762_New) == 0x002570, "Wrong size on UAbility_104762_New");

// Class Hero_1047.Config_104763_New
// 0x0000 (0x0118 - 0x0118)
class UConfig_104763_New : public UWallRunningAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104763_New">();
	}
	static class UConfig_104763_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104763_New>();
	}
};
static_assert(alignof(UConfig_104763_New) == 0x000008, "Wrong alignment on UConfig_104763_New");
static_assert(sizeof(UConfig_104763_New) == 0x000118, "Wrong size on UConfig_104763_New");

// Class Hero_1047.Ability_104763_New
// 0x0000 (0x25D8 - 0x25D8)
class UAbility_104763_New : public UWallRunningAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104763_New">();
	}
	static class UAbility_104763_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104763_New>();
	}
};
static_assert(alignof(UAbility_104763_New) == 0x000008, "Wrong alignment on UAbility_104763_New");
static_assert(sizeof(UAbility_104763_New) == 0x0025D8, "Wrong size on UAbility_104763_New");

// Class Hero_1047.Config_104771
// 0x0140 (0x01D8 - 0x0098)
class UConfig_104771 : public UMarvelAbilityConfig
{
public:
	struct FSelectRegionConfig                    SelectRegionConfig;                                // 0x0098(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EnterLocatorCameraTranslation;                     // 0x00B8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EnterLocatorCameraRotation;                        // 0x00D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EnterLocatorCameraInterpSpeed;                     // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocatorTopViewCameraZ;                             // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AltitudeUpperLimit;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AltitudeLowerLimit;                                // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTopViewPushUpSpeed;                          // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTopViewPushDownSpeed;                        // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EnterWarningCameraTranslation;                     // 0x0100(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EnterWarningCameraRotation;                        // 0x0118(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EnterWarningCameraInterpSpeed;                     // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevourCharacterLagSpeed;                           // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevourCharacterLagMaxDistance;                     // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DirectKnockUpBuffID;                               // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomKnockUpBuffID;                               // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyDirectKnockUpBuffID;                          // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyRandomKnockUpBuffID;                          // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DispelBuffsBeforeSpitOut;                          // 0x0150(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                SpitOutDir;                                        // 0x01B8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DevourBuffID;                                      // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104771">();
	}
	static class UConfig_104771* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104771>();
	}
};
static_assert(alignof(UConfig_104771) == 0x000008, "Wrong alignment on UConfig_104771");
static_assert(sizeof(UConfig_104771) == 0x0001D8, "Wrong size on UConfig_104771");
static_assert(offsetof(UConfig_104771, SelectRegionConfig) == 0x000098, "Member 'UConfig_104771::SelectRegionConfig' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterLocatorCameraTranslation) == 0x0000B8, "Member 'UConfig_104771::EnterLocatorCameraTranslation' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterLocatorCameraRotation) == 0x0000D0, "Member 'UConfig_104771::EnterLocatorCameraRotation' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterLocatorCameraInterpSpeed) == 0x0000E8, "Member 'UConfig_104771::EnterLocatorCameraInterpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104771, LocatorTopViewCameraZ) == 0x0000EC, "Member 'UConfig_104771::LocatorTopViewCameraZ' has a wrong offset!");
static_assert(offsetof(UConfig_104771, AltitudeUpperLimit) == 0x0000F0, "Member 'UConfig_104771::AltitudeUpperLimit' has a wrong offset!");
static_assert(offsetof(UConfig_104771, AltitudeLowerLimit) == 0x0000F4, "Member 'UConfig_104771::AltitudeLowerLimit' has a wrong offset!");
static_assert(offsetof(UConfig_104771, CameraTopViewPushUpSpeed) == 0x0000F8, "Member 'UConfig_104771::CameraTopViewPushUpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104771, CameraTopViewPushDownSpeed) == 0x0000FC, "Member 'UConfig_104771::CameraTopViewPushDownSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterWarningCameraTranslation) == 0x000100, "Member 'UConfig_104771::EnterWarningCameraTranslation' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterWarningCameraRotation) == 0x000118, "Member 'UConfig_104771::EnterWarningCameraRotation' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterWarningCameraInterpSpeed) == 0x000130, "Member 'UConfig_104771::EnterWarningCameraInterpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104771, DevourCharacterLagSpeed) == 0x000134, "Member 'UConfig_104771::DevourCharacterLagSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104771, DevourCharacterLagMaxDistance) == 0x000138, "Member 'UConfig_104771::DevourCharacterLagMaxDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104771, DirectKnockUpBuffID) == 0x00013C, "Member 'UConfig_104771::DirectKnockUpBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104771, RandomKnockUpBuffID) == 0x000140, "Member 'UConfig_104771::RandomKnockUpBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnemyDirectKnockUpBuffID) == 0x000144, "Member 'UConfig_104771::EnemyDirectKnockUpBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnemyRandomKnockUpBuffID) == 0x000148, "Member 'UConfig_104771::EnemyRandomKnockUpBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104771, DispelBuffsBeforeSpitOut) == 0x000150, "Member 'UConfig_104771::DispelBuffsBeforeSpitOut' has a wrong offset!");
static_assert(offsetof(UConfig_104771, SpitOutDir) == 0x0001B8, "Member 'UConfig_104771::SpitOutDir' has a wrong offset!");
static_assert(offsetof(UConfig_104771, DevourBuffID) == 0x0001D0, "Member 'UConfig_104771::DevourBuffID' has a wrong offset!");

// Class Hero_1047.Ability_104771
// 0x04A8 (0x29F8 - 0x2550)
class UAbility_104771 : public UMarvelGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             OnStateChanged;                                    // 0x2550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectRegionFinishDelegate;                      // 0x2560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDevouredCharacterChanged;                        // 0x2570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSelectRegionConfig                    MoveConfigCache;                                   // 0x2580(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_259C[0x4];                                     // 0x259C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_104771*                         Config;                                            // 0x25A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         Selection_StartKey;                                // 0x25A8(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         Selection_EnterTopViewKey;                         // 0x2648(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         Selection_ExitTopViewKey;                          // 0x26E8(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         Selection_WarningKey;                              // 0x2788(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         Selection_ClearKey;                                // 0x2828(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         AbilityEnd_ClearKey;                               // 0x28C8(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_SelectRegionAttack*  SelectRegionAttack;                                // 0x2968(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDevouredCharactersData                DevouredCharactersData;                            // 0x2970(0x0058)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C8[0x8];                                     // 0x29C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDevouredCharactersDataWasSet;                     // 0x29D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSelectionRegionTopView;                         // 0x29D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29D2[0x2];                                     // 0x29D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedSpringArmLength;                             // 0x29D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CachedSpringArmSocketOffset;                       // 0x29D8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilityState_104771                          CurrentAbilityState;                               // 0x29F0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FWarningNotify                         WarningNotify;                                     // 0x29F1(0x0002)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29F3[0x5];                                     // 0x29F3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AfterSetDevourCharacters();
	void DevourCharactersWhenStartSwimming();
	bool ExpandCapsuleSize();
	TArray<class AActor*> GetAliveDevouredCharacter();
	void HandleOwnerBuff(int32 BuffID, bool bNeedApply);
	void OnDevouredCharacterChanged__DelegateSignature();
	void OnDevouredCharacterDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnDevouredCharacterDisguiseEnd(class AMarvelBaseCharacter* InDisguiseCharacter, class AMarvelBaseCharacter* InOriginCharacter, bool bIsAvatorAlive);
	void OnDevourSummonedEndAgentTask(class AActor* InSummoned);
	void OnRep_ReplicatedCurrentAbilityState();
	void OnRep_ReplicatedDevourCharactersData();
	void OnRep_ReplicatedWarningNotify();
	void OnSelectRegionFinish(bool bActivateByTimerOrMT);
	void OnStateChanged__DelegateSignature();
	void OnUpdateDevouredCharactersData();
	void ReStartDivingBuff(float RemainDuration);
	bool RestoreCapsuleSize();
	void SetCurrentAbilityState(const EAbilityState_104771 CurrentAbilityState_0);
	void SetDevourCharactersFromScope(const TArray<TWeakObjectPtr<class AActor>>& InDevourCharactersList);
	void SetMoveLogicFrame_AbilityEndClear();
	void SetMoveLogicFrame_EnterTopView();
	void SetMoveLogicFrame_ExitTopView();
	void SetMoveLogicFrame_SelectionClear();
	void SetMoveLogicFrame_SelectionStart();
	void SetMoveLogicFrame_SelectionWarning();
	void SpitOutImpl(bool bSpitOutAll, bool bSpitOutEnemy, bool bKnockUp);
	float StopDivingBuff();
	void SwitchSelectionRegionTopView(bool bToTopView, bool bButtonSwitch);

	EAbilityState_104771 GetCurrentAbilityState() const;
	TArray<class AActor*> GetDevouredAlly() const;
	TArray<class AActor*> GetDevouredEnemy() const;
	bool HaveDevouredAlly() const;
	bool HaveDevouredEnemy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104771">();
	}
	static class UAbility_104771* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104771>();
	}
};
static_assert(alignof(UAbility_104771) == 0x000008, "Wrong alignment on UAbility_104771");
static_assert(sizeof(UAbility_104771) == 0x0029F8, "Wrong size on UAbility_104771");
static_assert(offsetof(UAbility_104771, OnStateChanged) == 0x002550, "Member 'UAbility_104771::OnStateChanged' has a wrong offset!");
static_assert(offsetof(UAbility_104771, OnSelectRegionFinishDelegate) == 0x002560, "Member 'UAbility_104771::OnSelectRegionFinishDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_104771, OnDevouredCharacterChanged) == 0x002570, "Member 'UAbility_104771::OnDevouredCharacterChanged' has a wrong offset!");
static_assert(offsetof(UAbility_104771, MoveConfigCache) == 0x002580, "Member 'UAbility_104771::MoveConfigCache' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Config) == 0x0025A0, "Member 'UAbility_104771::Config' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Selection_StartKey) == 0x0025A8, "Member 'UAbility_104771::Selection_StartKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Selection_EnterTopViewKey) == 0x002648, "Member 'UAbility_104771::Selection_EnterTopViewKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Selection_ExitTopViewKey) == 0x0026E8, "Member 'UAbility_104771::Selection_ExitTopViewKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Selection_WarningKey) == 0x002788, "Member 'UAbility_104771::Selection_WarningKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Selection_ClearKey) == 0x002828, "Member 'UAbility_104771::Selection_ClearKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, AbilityEnd_ClearKey) == 0x0028C8, "Member 'UAbility_104771::AbilityEnd_ClearKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, SelectRegionAttack) == 0x002968, "Member 'UAbility_104771::SelectRegionAttack' has a wrong offset!");
static_assert(offsetof(UAbility_104771, DevouredCharactersData) == 0x002970, "Member 'UAbility_104771::DevouredCharactersData' has a wrong offset!");
static_assert(offsetof(UAbility_104771, bDevouredCharactersDataWasSet) == 0x0029D0, "Member 'UAbility_104771::bDevouredCharactersDataWasSet' has a wrong offset!");
static_assert(offsetof(UAbility_104771, bIsSelectionRegionTopView) == 0x0029D1, "Member 'UAbility_104771::bIsSelectionRegionTopView' has a wrong offset!");
static_assert(offsetof(UAbility_104771, CachedSpringArmLength) == 0x0029D4, "Member 'UAbility_104771::CachedSpringArmLength' has a wrong offset!");
static_assert(offsetof(UAbility_104771, CachedSpringArmSocketOffset) == 0x0029D8, "Member 'UAbility_104771::CachedSpringArmSocketOffset' has a wrong offset!");
static_assert(offsetof(UAbility_104771, CurrentAbilityState) == 0x0029F0, "Member 'UAbility_104771::CurrentAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_104771, WarningNotify) == 0x0029F1, "Member 'UAbility_104771::WarningNotify' has a wrong offset!");

// Class Hero_1047.JeffPassengerContainerComponent
// 0x0010 (0x0480 - 0x0470)
class UJeffPassengerContainerComponent final : public USceneComponent
{
public:
	TArray<TWeakObjectPtr<class AActor>>          DevouredCharList;                                  // 0x0470(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void Client_AttachPassengerAndUpdateComponentTickPrerequisite(class AActor* InAttachPassenger);
	void Client_DetachPassengerAndUpdateComponentTickPrerequisite(class AActor* InDetachPassenger);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffPassengerContainerComponent">();
	}
	static class UJeffPassengerContainerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffPassengerContainerComponent>();
	}
};
static_assert(alignof(UJeffPassengerContainerComponent) == 0x000010, "Wrong alignment on UJeffPassengerContainerComponent");
static_assert(sizeof(UJeffPassengerContainerComponent) == 0x000480, "Wrong size on UJeffPassengerContainerComponent");
static_assert(offsetof(UJeffPassengerContainerComponent, DevouredCharList) == 0x000470, "Member 'UJeffPassengerContainerComponent::DevouredCharList' has a wrong offset!");

// Class Hero_1047.EffectiveComponent_10477101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10477101 : public UMarvelAgentEffectiveComponent
{
public:
	TArray<struct FHitResult> K2_OnPreApplyContainer(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10477101">();
	}
	static class UEffectiveComponent_10477101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10477101>();
	}
};
static_assert(alignof(UEffectiveComponent_10477101) == 0x000010, "Wrong alignment on UEffectiveComponent_10477101");
static_assert(sizeof(UEffectiveComponent_10477101) == 0x001C00, "Wrong size on UEffectiveComponent_10477101");

// Class Hero_1047.EffectiveComponent_10477103
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10477103 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10477103">();
	}
	static class UEffectiveComponent_10477103* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10477103>();
	}
};
static_assert(alignof(UEffectiveComponent_10477103) == 0x000010, "Wrong alignment on UEffectiveComponent_10477103");
static_assert(sizeof(UEffectiveComponent_10477103) == 0x001C00, "Wrong size on UEffectiveComponent_10477103");

// Class Hero_1047.TestMarvelAbilityTask
// 0x0018 (0x01F0 - 0x01D8)
class UTestMarvelAbilityTask : public UAbilityTask
{
public:
	TArray<class UGameplayTask*>                  SubTasks;                                          // 0x01D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsEnding;                                         // 0x01E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestMarvelAbilityTask">();
	}
	static class UTestMarvelAbilityTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestMarvelAbilityTask>();
	}
};
static_assert(alignof(UTestMarvelAbilityTask) == 0x000008, "Wrong alignment on UTestMarvelAbilityTask");
static_assert(sizeof(UTestMarvelAbilityTask) == 0x0001F0, "Wrong size on UTestMarvelAbilityTask");
static_assert(offsetof(UTestMarvelAbilityTask, SubTasks) == 0x0001D8, "Member 'UTestMarvelAbilityTask::SubTasks' has a wrong offset!");
static_assert(offsetof(UTestMarvelAbilityTask, bIsEnding) == 0x0001E8, "Member 'UTestMarvelAbilityTask::bIsEnding' has a wrong offset!");

// Class Hero_1047.MarvelAbilityTask_SelectRegionAttack
// 0x01B0 (0x03A0 - 0x01F0)
class UMarvelAbilityTask_SelectRegionAttack final : public UTestMarvelAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnSelectRegionFinish;                              // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectRegionWarningFinish;                       // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_WaitBindInput*       ConfirmInputTask;                                  // 0x0210(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           SelectionRegionTimer;                              // 0x0218(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           WarningScopeTimer;                                 // 0x0230(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPredictionKey                         SelectionKeySeed;                                  // 0x0248(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPredictionKey                         WarningKeySeed;                                    // 0x02E8(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelAbilityTask_WaitDelay*           SelectingDelayTask;                                // 0x0388(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelGameplayAbility*                 SourceAbility;                                     // 0x0398(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UMarvelAbilityTask_SelectRegionAttack* SelectRegionAttack(class UMarvelGameplayAbility* OwningAbility, class FName ConfirmMethodName);

	void OnLocateFinish(bool bActiveByTimerOrMT);
	void OnPressActivateHurricaneKey(float TimeWaited);
	void OnPressCameraAnimationKey(float TimeWaited);
	void OnReleaseCameraAnimationKey(float TimeWaited);
	void OnTimeOverFinish();
	void OnWarningFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAbilityTask_SelectRegionAttack">();
	}
	static class UMarvelAbilityTask_SelectRegionAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAbilityTask_SelectRegionAttack>();
	}
};
static_assert(alignof(UMarvelAbilityTask_SelectRegionAttack) == 0x000008, "Wrong alignment on UMarvelAbilityTask_SelectRegionAttack");
static_assert(sizeof(UMarvelAbilityTask_SelectRegionAttack) == 0x0003A0, "Wrong size on UMarvelAbilityTask_SelectRegionAttack");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, OnSelectRegionFinish) == 0x0001F0, "Member 'UMarvelAbilityTask_SelectRegionAttack::OnSelectRegionFinish' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, OnSelectRegionWarningFinish) == 0x000200, "Member 'UMarvelAbilityTask_SelectRegionAttack::OnSelectRegionWarningFinish' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, ConfirmInputTask) == 0x000210, "Member 'UMarvelAbilityTask_SelectRegionAttack::ConfirmInputTask' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, SelectionRegionTimer) == 0x000218, "Member 'UMarvelAbilityTask_SelectRegionAttack::SelectionRegionTimer' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, WarningScopeTimer) == 0x000230, "Member 'UMarvelAbilityTask_SelectRegionAttack::WarningScopeTimer' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, SelectionKeySeed) == 0x000248, "Member 'UMarvelAbilityTask_SelectRegionAttack::SelectionKeySeed' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, WarningKeySeed) == 0x0002E8, "Member 'UMarvelAbilityTask_SelectRegionAttack::WarningKeySeed' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, SelectingDelayTask) == 0x000388, "Member 'UMarvelAbilityTask_SelectRegionAttack::SelectingDelayTask' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, SourceAbility) == 0x000398, "Member 'UMarvelAbilityTask_SelectRegionAttack::SourceAbility' has a wrong offset!");

// Class Hero_1047.KnockUp_10477109
// 0x0020 (0x1D70 - 0x1D50)
class UKnockUp_10477109 : public UMarvelKnockUpAbility
{
public:
	float                                         RandomSpreadAngle;                                 // 0x1D50(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D54[0x4];                                     // 0x1D54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantizeNormal              ReplicatedKnockUpDir;                              // 0x1D58(0x0018)(Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnockUp_10477109">();
	}
	static class UKnockUp_10477109* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnockUp_10477109>();
	}
};
static_assert(alignof(UKnockUp_10477109) == 0x000008, "Wrong alignment on UKnockUp_10477109");
static_assert(sizeof(UKnockUp_10477109) == 0x001D70, "Wrong size on UKnockUp_10477109");
static_assert(offsetof(UKnockUp_10477109, RandomSpreadAngle) == 0x001D50, "Member 'UKnockUp_10477109::RandomSpreadAngle' has a wrong offset!");
static_assert(offsetof(UKnockUp_10477109, ReplicatedKnockUpDir) == 0x001D58, "Member 'UKnockUp_10477109::ReplicatedKnockUpDir' has a wrong offset!");

// Class Hero_1047.EffectAbility_10477110
// 0x0000 (0x10E8 - 0x10E8)
class UEffectAbility_10477110 final : public UMarvelEffectGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectAbility_10477110">();
	}
	static class UEffectAbility_10477110* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectAbility_10477110>();
	}
};
static_assert(alignof(UEffectAbility_10477110) == 0x000008, "Wrong alignment on UEffectAbility_10477110");
static_assert(sizeof(UEffectAbility_10477110) == 0x0010E8, "Wrong size on UEffectAbility_10477110");

// Class Hero_1047.Cue_Ability_Loop_10477101
// 0x0040 (0x0E40 - 0x0E00)
class ACue_Ability_Loop_10477101 final : public AMarvelCueNotify_Ability
{
public:
	class UNiagaraComponent*                      SelectRegionFxComp;                                // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      WarnFxComp;                                        // 0x0E08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        SelectRegionDecal;                                 // 0x0E10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityID;                                         // 0x0E18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectPreGenerateFXOffset;                         // 0x0E1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectionAudioID;                                  // 0x0E20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectRegionConfirmAudioID;                        // 0x0E24(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FallingDevourAudioID;                              // 0x0E28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DevourCharacterSuccessAudioID;                     // 0x0E2C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E30[0x10];                                     // 0x0E30(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDevourCharacterSuccess();
	void OnSelectRegionFinish(bool bActivateByTimerOrMT);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10477101">();
	}
	static class ACue_Ability_Loop_10477101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10477101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10477101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10477101");
static_assert(sizeof(ACue_Ability_Loop_10477101) == 0x000E40, "Wrong size on ACue_Ability_Loop_10477101");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectRegionFxComp) == 0x000E00, "Member 'ACue_Ability_Loop_10477101::SelectRegionFxComp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, WarnFxComp) == 0x000E08, "Member 'ACue_Ability_Loop_10477101::WarnFxComp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectRegionDecal) == 0x000E10, "Member 'ACue_Ability_Loop_10477101::SelectRegionDecal' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, AbilityID) == 0x000E18, "Member 'ACue_Ability_Loop_10477101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectPreGenerateFXOffset) == 0x000E1C, "Member 'ACue_Ability_Loop_10477101::SelectPreGenerateFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectionAudioID) == 0x000E20, "Member 'ACue_Ability_Loop_10477101::SelectionAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectRegionConfirmAudioID) == 0x000E24, "Member 'ACue_Ability_Loop_10477101::SelectRegionConfirmAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, FallingDevourAudioID) == 0x000E28, "Member 'ACue_Ability_Loop_10477101::FallingDevourAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, DevourCharacterSuccessAudioID) == 0x000E2C, "Member 'ACue_Ability_Loop_10477101::DevourCharacterSuccessAudioID' has a wrong offset!");

// Class Hero_1047.Config_104781
// 0x0E00 (0x1FD0 - 0x11D0)
class UConfig_104781 : public UMarvelSelectTargetConfig
{
public:
	int32                                         BondID;                                            // 0x11C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOptimizeGameStateFindGroot;                       // 0x11CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CD[0x3];                                     // 0x11CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrootFilterDistance;                               // 0x11D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D4[0x4];                                     // 0x11D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDashAbilityInfo                       DashToGrootInfo;                                   // 0x11D8(0x0B70)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockAbilityTagsWhenFlying;                        // 0x1D48(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   GrootSocketName;                                   // 0x1DB0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitShapeScale;                                     // 0x1DBC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GrootDetachTagContainer;                           // 0x1DC0(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  JeffDetachTagContainer;                            // 0x1E28(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UCameraInterp*                          RidingCameraInterp;                                // 0x1E90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateChangedTaskParam                 ExitRideInputSetting;                              // 0x1E98(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExitRideWhenJeffTakeDamage;                       // 0x1EC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC1[0x7];                                     // 0x1EC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   SameBuffSet;                                       // 0x1EC8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RemoveEffectWithTagsWhileAttach;                   // 0x1F18(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                AttachCylinderOffset;                              // 0x1F80(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachMeshOffset;                                  // 0x1F98(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DettachLaunchVelocity;                             // 0x1FB0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC8[0x8];                                     // 0x1FC8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104781">();
	}
	static class UConfig_104781* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104781>();
	}
};
static_assert(alignof(UConfig_104781) == 0x000010, "Wrong alignment on UConfig_104781");
static_assert(sizeof(UConfig_104781) == 0x001FD0, "Wrong size on UConfig_104781");
static_assert(offsetof(UConfig_104781, BondID) == 0x0011C8, "Member 'UConfig_104781::BondID' has a wrong offset!");
static_assert(offsetof(UConfig_104781, bOptimizeGameStateFindGroot) == 0x0011CC, "Member 'UConfig_104781::bOptimizeGameStateFindGroot' has a wrong offset!");
static_assert(offsetof(UConfig_104781, GrootFilterDistance) == 0x0011D0, "Member 'UConfig_104781::GrootFilterDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104781, DashToGrootInfo) == 0x0011D8, "Member 'UConfig_104781::DashToGrootInfo' has a wrong offset!");
static_assert(offsetof(UConfig_104781, BlockAbilityTagsWhenFlying) == 0x001D48, "Member 'UConfig_104781::BlockAbilityTagsWhenFlying' has a wrong offset!");
static_assert(offsetof(UConfig_104781, GrootSocketName) == 0x001DB0, "Member 'UConfig_104781::GrootSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_104781, HitShapeScale) == 0x001DBC, "Member 'UConfig_104781::HitShapeScale' has a wrong offset!");
static_assert(offsetof(UConfig_104781, GrootDetachTagContainer) == 0x001DC0, "Member 'UConfig_104781::GrootDetachTagContainer' has a wrong offset!");
static_assert(offsetof(UConfig_104781, JeffDetachTagContainer) == 0x001E28, "Member 'UConfig_104781::JeffDetachTagContainer' has a wrong offset!");
static_assert(offsetof(UConfig_104781, RidingCameraInterp) == 0x001E90, "Member 'UConfig_104781::RidingCameraInterp' has a wrong offset!");
static_assert(offsetof(UConfig_104781, ExitRideInputSetting) == 0x001E98, "Member 'UConfig_104781::ExitRideInputSetting' has a wrong offset!");
static_assert(offsetof(UConfig_104781, bExitRideWhenJeffTakeDamage) == 0x001EC0, "Member 'UConfig_104781::bExitRideWhenJeffTakeDamage' has a wrong offset!");
static_assert(offsetof(UConfig_104781, SameBuffSet) == 0x001EC8, "Member 'UConfig_104781::SameBuffSet' has a wrong offset!");
static_assert(offsetof(UConfig_104781, RemoveEffectWithTagsWhileAttach) == 0x001F18, "Member 'UConfig_104781::RemoveEffectWithTagsWhileAttach' has a wrong offset!");
static_assert(offsetof(UConfig_104781, AttachCylinderOffset) == 0x001F80, "Member 'UConfig_104781::AttachCylinderOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104781, AttachMeshOffset) == 0x001F98, "Member 'UConfig_104781::AttachMeshOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104781, DettachLaunchVelocity) == 0x001FB0, "Member 'UConfig_104781::DettachLaunchVelocity' has a wrong offset!");

// Class Hero_1047.Ability_104781
// 0x0138 (0x2848 - 0x2710)
class UAbility_104781 : public UMarvelSelectTargetAbility
{
public:
	struct FGameplayTag                           MarkOnGrootTag;                                    // 0x2710(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271C[0x4];                                     // 0x271C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnJeffGrootCoopStateChangeDispatcher;              // 0x2720(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EJeffGrootAbilityState                        CurrentState;                                      // 0x2730(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2731[0x7];                                     // 0x2731(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   Groot;                                             // 0x2738(0x0008)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class USceneComponent*, struct FVector>  CachedComponentScaleMap;                           // 0x2740(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2790[0x90];                                    // 0x2790(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelGameState*                       CurrentGameState;                                  // 0x2820(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwningCharacter;                                   // 0x2828(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJeffChildActor*                        JeffChildActor;                                    // 0x2830(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_104781*                         CoopConfig;                                        // 0x2838(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitInputStateChanged* RideCancelTask;                                    // 0x2840(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BindCancelRideInput();
	void BindDettachDelegates(class AActor* InGroot);
	void MarkOnGroot(bool bOnGroot);
	void OnCoopAbilityTickStateChanged(bool bShouldAbilityTick);
	void OnGrootDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnGrootRepToSimulatedRole();
	void OnGrootTagUpdated(const struct FGameplayTag& TagUpdated, bool bTagExists);
	void OnJeffDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnJeffTagUpdated(const struct FGameplayTag& TagUpdated, bool bTagExists);
	void OnJeffTakeDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnRep_CurrentState();
	void OnRep_Groot();
	void OnRideCancel(float StateIntervalTime);
	void Python_AttachToGroot();
	void Python_DetachFromGroot();
	void Python_FailedFlyingToGroot();
	void Python_OnRideCancel();
	void Python_StartFlyingToGroot();
	void ScaleRidingHitShapeSize(bool bEnable);
	void ServerOnRideCancel(float StateIntervalTime);
	void SetJeffState(EJeffGrootAbilityState InState);
	void SetSpringArmIgnore(class AMarvelBaseCharacter* InGroot, class AMarvelBaseCharacter* OwnChar, bool bIgnore);
	void UnBindDettachDelegates(class AActor* InGroot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104781">();
	}
	static class UAbility_104781* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104781>();
	}
};
static_assert(alignof(UAbility_104781) == 0x000008, "Wrong alignment on UAbility_104781");
static_assert(sizeof(UAbility_104781) == 0x002848, "Wrong size on UAbility_104781");
static_assert(offsetof(UAbility_104781, MarkOnGrootTag) == 0x002710, "Member 'UAbility_104781::MarkOnGrootTag' has a wrong offset!");
static_assert(offsetof(UAbility_104781, OnJeffGrootCoopStateChangeDispatcher) == 0x002720, "Member 'UAbility_104781::OnJeffGrootCoopStateChangeDispatcher' has a wrong offset!");
static_assert(offsetof(UAbility_104781, CurrentState) == 0x002730, "Member 'UAbility_104781::CurrentState' has a wrong offset!");
static_assert(offsetof(UAbility_104781, Groot) == 0x002738, "Member 'UAbility_104781::Groot' has a wrong offset!");
static_assert(offsetof(UAbility_104781, CachedComponentScaleMap) == 0x002740, "Member 'UAbility_104781::CachedComponentScaleMap' has a wrong offset!");
static_assert(offsetof(UAbility_104781, CurrentGameState) == 0x002820, "Member 'UAbility_104781::CurrentGameState' has a wrong offset!");
static_assert(offsetof(UAbility_104781, OwningCharacter) == 0x002828, "Member 'UAbility_104781::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_104781, JeffChildActor) == 0x002830, "Member 'UAbility_104781::JeffChildActor' has a wrong offset!");
static_assert(offsetof(UAbility_104781, CoopConfig) == 0x002838, "Member 'UAbility_104781::CoopConfig' has a wrong offset!");
static_assert(offsetof(UAbility_104781, RideCancelTask) == 0x002840, "Member 'UAbility_104781::RideCancelTask' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10478101
// 0x0078 (0x0E78 - 0x0E00)
class ACue_Ability_Loop_10478101 final : public AMarvelCueNotify_Ability
{
public:
	float                                         StartRideSoundID;                                  // 0x0E00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuccessRideSoundID;                                // 0x0E04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopRideSoundID;                                   // 0x0E08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0C[0x4];                                      // 0x0E0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwningCharacter;                                   // 0x0E10(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbility_104781*                        CoopAbility;                                       // 0x0E18(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraInterp*                          RidingCameraInterp;                                // 0x0E20(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FSpringArmControlHandler> SpringArmHandlers;                                 // 0x0E28(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void OnJeffGrootCoopStateChange(EJeffGrootAbilityState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10478101">();
	}
	static class ACue_Ability_Loop_10478101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10478101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10478101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10478101");
static_assert(sizeof(ACue_Ability_Loop_10478101) == 0x000E78, "Wrong size on ACue_Ability_Loop_10478101");
static_assert(offsetof(ACue_Ability_Loop_10478101, StartRideSoundID) == 0x000E00, "Member 'ACue_Ability_Loop_10478101::StartRideSoundID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, SuccessRideSoundID) == 0x000E04, "Member 'ACue_Ability_Loop_10478101::SuccessRideSoundID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, StopRideSoundID) == 0x000E08, "Member 'ACue_Ability_Loop_10478101::StopRideSoundID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, OwningCharacter) == 0x000E10, "Member 'ACue_Ability_Loop_10478101::OwningCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, CoopAbility) == 0x000E18, "Member 'ACue_Ability_Loop_10478101::CoopAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, RidingCameraInterp) == 0x000E20, "Member 'ACue_Ability_Loop_10478101::RidingCameraInterp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, SpringArmHandlers) == 0x000E28, "Member 'ACue_Ability_Loop_10478101::SpringArmHandlers' has a wrong offset!");

// Class Hero_1047.JeffAnimInstance
// 0x0250 (0x0B50 - 0x0900)
class UJeffAnimInstance final : public UMarvelAnimInstance
{
public:
	uint8                                         Pad_900[0x8];                                      // 0x0900(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendSpaceYawAngle;                                // 0x0908(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendSpaceYawAngleSpeed;                           // 0x090C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OnGrootPlayTurnMontageAngleThreshold;              // 0x0910(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RefreshOnGrootMovingStateThreshold;                // 0x0914(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SpineRigDirection;                                 // 0x0918(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ControlRigUpPoint;                                 // 0x0930(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ControlRigForwardPoint;                            // 0x0948(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAdjustControlRigAngle;                      // 0x0960(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_961[0x3];                                      // 0x0961(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrootControlRigAngleThreshold;                     // 0x0964(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendSpaceYawAngleThreshold;                       // 0x0968(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JeffOffsetSizeOnGroot;                             // 0x096C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JeffOffsetSpeedOnGroot;                            // 0x0970(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JeffGrootIKHandAlphaSpeed;                         // 0x0974(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebugJeffGrootIK : 1;                             // 0x0978(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          bDiving;                                           // 0x0979(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDiving_To_Default;                                // 0x097A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_97B[0x5];                                      // 0x097B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Diving_To_DefaultTags;                             // 0x0980(0x0068)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DivingTag;                                         // 0x09E8(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFullyHidden;                                      // 0x09F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnGroot;                                          // 0x09F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9F6[0x2];                                      // 0x09F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendSpaceYaw;                                     // 0x09F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendSpaceAimAOYaw;                                // 0x09FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJeffOnGrootMovingState                       OnGrootMovingState;                                // 0x0A00(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A01[0x7];                                      // 0x0A01(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               NewJeffRotationOnGrootWS;                          // 0x0A08(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                NewJeffLocatioOnGrootnWS;                          // 0x0A20(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JeffTurnAlphaOnGroot;                              // 0x0A38(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A3C[0x4];                                      // 0x0A3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                JeffGrootIKHandLLocationCS;                        // 0x0A40(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                JeffGrootIKHandRLocationCS;                        // 0x0A58(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                JeffGrootIKlLowerArmLLocationCS;                   // 0x0A70(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                JeffGrootIKlLowerArmRLocationCS;                   // 0x0A88(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JeffGrootIKHandAlpha;                              // 0x0AA0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDivingAcceleratingBase;                          // 0x0AA4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA5[0xB];                                      // 0x0AA5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class AJeffCharacter*                         JeffCharacter;                                     // 0x0AB0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AB8[0x98];                                     // 0x0AB8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalucateJeffGrootIK(const struct FAnimComponentSpacePoseContext& PoseContext);
	void GetGroundMotionForwardState(const struct FAnimPoseContext& PoseContext);
	void RelevantJeffOnGrootStateNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateJeffOnGrootMotionNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateJeffOnGrootStateNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffAnimInstance">();
	}
	static class UJeffAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffAnimInstance>();
	}
};
static_assert(alignof(UJeffAnimInstance) == 0x000010, "Wrong alignment on UJeffAnimInstance");
static_assert(sizeof(UJeffAnimInstance) == 0x000B50, "Wrong size on UJeffAnimInstance");
static_assert(offsetof(UJeffAnimInstance, BlendSpaceYawAngle) == 0x000908, "Member 'UJeffAnimInstance::BlendSpaceYawAngle' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, BlendSpaceYawAngleSpeed) == 0x00090C, "Member 'UJeffAnimInstance::BlendSpaceYawAngleSpeed' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, OnGrootPlayTurnMontageAngleThreshold) == 0x000910, "Member 'UJeffAnimInstance::OnGrootPlayTurnMontageAngleThreshold' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, RefreshOnGrootMovingStateThreshold) == 0x000914, "Member 'UJeffAnimInstance::RefreshOnGrootMovingStateThreshold' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, SpineRigDirection) == 0x000918, "Member 'UJeffAnimInstance::SpineRigDirection' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, ControlRigUpPoint) == 0x000930, "Member 'UJeffAnimInstance::ControlRigUpPoint' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, ControlRigForwardPoint) == 0x000948, "Member 'UJeffAnimInstance::ControlRigForwardPoint' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, bEnableAdjustControlRigAngle) == 0x000960, "Member 'UJeffAnimInstance::bEnableAdjustControlRigAngle' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, GrootControlRigAngleThreshold) == 0x000964, "Member 'UJeffAnimInstance::GrootControlRigAngleThreshold' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, BlendSpaceYawAngleThreshold) == 0x000968, "Member 'UJeffAnimInstance::BlendSpaceYawAngleThreshold' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffOffsetSizeOnGroot) == 0x00096C, "Member 'UJeffAnimInstance::JeffOffsetSizeOnGroot' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffOffsetSpeedOnGroot) == 0x000970, "Member 'UJeffAnimInstance::JeffOffsetSpeedOnGroot' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKHandAlphaSpeed) == 0x000974, "Member 'UJeffAnimInstance::JeffGrootIKHandAlphaSpeed' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, bDiving) == 0x000979, "Member 'UJeffAnimInstance::bDiving' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, bDiving_To_Default) == 0x00097A, "Member 'UJeffAnimInstance::bDiving_To_Default' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, Diving_To_DefaultTags) == 0x000980, "Member 'UJeffAnimInstance::Diving_To_DefaultTags' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, DivingTag) == 0x0009E8, "Member 'UJeffAnimInstance::DivingTag' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, bFullyHidden) == 0x0009F4, "Member 'UJeffAnimInstance::bFullyHidden' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, bOnGroot) == 0x0009F5, "Member 'UJeffAnimInstance::bOnGroot' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, BlendSpaceYaw) == 0x0009F8, "Member 'UJeffAnimInstance::BlendSpaceYaw' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, BlendSpaceAimAOYaw) == 0x0009FC, "Member 'UJeffAnimInstance::BlendSpaceAimAOYaw' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, OnGrootMovingState) == 0x000A00, "Member 'UJeffAnimInstance::OnGrootMovingState' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, NewJeffRotationOnGrootWS) == 0x000A08, "Member 'UJeffAnimInstance::NewJeffRotationOnGrootWS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, NewJeffLocatioOnGrootnWS) == 0x000A20, "Member 'UJeffAnimInstance::NewJeffLocatioOnGrootnWS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffTurnAlphaOnGroot) == 0x000A38, "Member 'UJeffAnimInstance::JeffTurnAlphaOnGroot' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKHandLLocationCS) == 0x000A40, "Member 'UJeffAnimInstance::JeffGrootIKHandLLocationCS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKHandRLocationCS) == 0x000A58, "Member 'UJeffAnimInstance::JeffGrootIKHandRLocationCS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKlLowerArmLLocationCS) == 0x000A70, "Member 'UJeffAnimInstance::JeffGrootIKlLowerArmLLocationCS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKlLowerArmRLocationCS) == 0x000A88, "Member 'UJeffAnimInstance::JeffGrootIKlLowerArmRLocationCS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKHandAlpha) == 0x000AA0, "Member 'UJeffAnimInstance::JeffGrootIKHandAlpha' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, IsDivingAcceleratingBase) == 0x000AA4, "Member 'UJeffAnimInstance::IsDivingAcceleratingBase' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffCharacter) == 0x000AB0, "Member 'UJeffAnimInstance::JeffCharacter' has a wrong offset!");

// Class Hero_1047.JeffCharacter
// 0x0180 (0x1940 - 0x17C0)
class AJeffCharacter : public AMarvelBaseCharacter
{
public:
	class URideOnCharacterManagementComponent*    RideOnGrootManagementComponent;                    // 0x17B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DivingGameplayTag;                                 // 0x17C0(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17CC[0x4];                                     // 0x17CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     IgnoreCollisionChannels;                           // 0x17D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJeffStateChangeDelegate;                         // 0x17E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             JeffDivingUIWindowStateChangedDispatcher;          // 0x17F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UJeffPassengerContainerComponent*       JeffPassengerContainerComponent;                   // 0x1800(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnimMovingForward;                              // 0x1808(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1809[0x7];                                     // 0x1809(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECollisionChannel, ECollisionResponse>   CollisionCachedMap;                                // 0x1810(0x0050)(Protected, NativeAccessSpecifierProtected)
	EJeffState                                    CurrentState;                                      // 0x1860(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1861[0x3];                                     // 0x1861(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bHapplyBubbleButtonPressed : 1;                    // 0x1864(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1865[0xB];                                     // 0x1865(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USplineComponent*>               LoopNXSpines;                                      // 0x1870(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1880[0xA8];                                    // 0x1880(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerOnGrootBlendSpaceYaw;                        // 0x1928(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192C[0x4];                                     // 0x192C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsOnWallWheDivingEnd : 1;                         // 0x1930(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1931[0xF];                                     // 0x1931(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DivingBlockAbility(const struct FGameplayTagContainer& InContainer, bool bBlock);
	EJeffState GetJeffState();
	bool IsJeffDiving();
	bool IsJeffMovingForward();
	void JeffCharacterEnterDiving();
	void JeffCharacterExitDiving();
	void OnCharacterSwimAbilityStart();
	void RecoverCollisionResponse();
	void SafeMove(const struct FVector& Delta);
	void SetIgnoreCollisionResponse();
	void SetJeffState(EJeffState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffCharacter">();
	}
	static class AJeffCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJeffCharacter>();
	}
};
static_assert(alignof(AJeffCharacter) == 0x000010, "Wrong alignment on AJeffCharacter");
static_assert(sizeof(AJeffCharacter) == 0x001940, "Wrong size on AJeffCharacter");
static_assert(offsetof(AJeffCharacter, RideOnGrootManagementComponent) == 0x0017B8, "Member 'AJeffCharacter::RideOnGrootManagementComponent' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, DivingGameplayTag) == 0x0017C0, "Member 'AJeffCharacter::DivingGameplayTag' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, IgnoreCollisionChannels) == 0x0017D0, "Member 'AJeffCharacter::IgnoreCollisionChannels' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, OnJeffStateChangeDelegate) == 0x0017E0, "Member 'AJeffCharacter::OnJeffStateChangeDelegate' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, JeffDivingUIWindowStateChangedDispatcher) == 0x0017F0, "Member 'AJeffCharacter::JeffDivingUIWindowStateChangedDispatcher' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, JeffPassengerContainerComponent) == 0x001800, "Member 'AJeffCharacter::JeffPassengerContainerComponent' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, bIsAnimMovingForward) == 0x001808, "Member 'AJeffCharacter::bIsAnimMovingForward' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, CollisionCachedMap) == 0x001810, "Member 'AJeffCharacter::CollisionCachedMap' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, CurrentState) == 0x001860, "Member 'AJeffCharacter::CurrentState' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, LoopNXSpines) == 0x001870, "Member 'AJeffCharacter::LoopNXSpines' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, ServerOnGrootBlendSpaceYaw) == 0x001928, "Member 'AJeffCharacter::ServerOnGrootBlendSpaceYaw' has a wrong offset!");

// Class Hero_1047.JeffChildActor
// 0x0160 (0x0BA0 - 0x0A40)
class AJeffChildActor : public AMarvelCharacterChildActor
{
public:
	uint8                                         Pad_A40[0x30];                                     // 0x0A40(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DivingAbilityID;                                   // 0x0A70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A74[0x4];                                      // 0x0A74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             DivingHideMaterialSlotNames;                       // 0x0A78(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<class FName>                             DivingParamMaterialSlotNames;                      // 0x0AC8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           CheckScaledBoneNames;                              // 0x0B18(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AliveCueTagsContainer;                             // 0x0B28(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class AJeffCharacter*                         JeffOwner;                                         // 0x0B90(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJeffState                                    CurrentState;                                      // 0x0B98(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B99[0x7];                                      // 0x0B99(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JeffChildActorEnterDiving();
	void JeffChildActorExitDiving();
	void OnCharacterDeath(class AActor* OutSourceAvatar, class AActor* OutTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnCharacterReborn(class AActor* OutTargetActor, const struct FCharacterRebornParam& Param);
	void OnCharacterSwimEnd(class FName Tag);
	void OnJeffStateChange(EJeffState InState);
	void OnTagUpdate(const struct FGameplayTag& Tag, bool bTagExists);
	void SetDivingMarteialSectionHidden(bool bDiving);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffChildActor">();
	}
	static class AJeffChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJeffChildActor>();
	}
};
static_assert(alignof(AJeffChildActor) == 0x000008, "Wrong alignment on AJeffChildActor");
static_assert(sizeof(AJeffChildActor) == 0x000BA0, "Wrong size on AJeffChildActor");
static_assert(offsetof(AJeffChildActor, DivingAbilityID) == 0x000A70, "Member 'AJeffChildActor::DivingAbilityID' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, DivingHideMaterialSlotNames) == 0x000A78, "Member 'AJeffChildActor::DivingHideMaterialSlotNames' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, DivingParamMaterialSlotNames) == 0x000AC8, "Member 'AJeffChildActor::DivingParamMaterialSlotNames' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, CheckScaledBoneNames) == 0x000B18, "Member 'AJeffChildActor::CheckScaledBoneNames' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, AliveCueTagsContainer) == 0x000B28, "Member 'AJeffChildActor::AliveCueTagsContainer' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, JeffOwner) == 0x000B90, "Member 'AJeffChildActor::JeffOwner' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, CurrentState) == 0x000B98, "Member 'AJeffChildActor::CurrentState' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10470101
// 0x0130 (0x0F30 - 0x0E00)
class ACue_Ability_Loop_10470101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E00[0x20];                                     // 0x0E00(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NormalLoopNX;                                      // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      HoverLoopNX;                                       // 0x0E28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsRequired;                                      // 0x0E30(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsBlocked;                                       // 0x0E98(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         VelocitySizeSquaredThreshold;                      // 0x0F00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FXHideDelay;                                       // 0x0F04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverFXRotationInterpSpeed;                        // 0x0F08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0C[0x24];                                     // 0x0F0C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoShowHide();
	void OnTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10470101">();
	}
	static class ACue_Ability_Loop_10470101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10470101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10470101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10470101");
static_assert(sizeof(ACue_Ability_Loop_10470101) == 0x000F30, "Wrong size on ACue_Ability_Loop_10470101");
static_assert(offsetof(ACue_Ability_Loop_10470101, NormalLoopNX) == 0x000E20, "Member 'ACue_Ability_Loop_10470101::NormalLoopNX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, HoverLoopNX) == 0x000E28, "Member 'ACue_Ability_Loop_10470101::HoverLoopNX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, TagsRequired) == 0x000E30, "Member 'ACue_Ability_Loop_10470101::TagsRequired' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, TagsBlocked) == 0x000E98, "Member 'ACue_Ability_Loop_10470101::TagsBlocked' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, VelocitySizeSquaredThreshold) == 0x000F00, "Member 'ACue_Ability_Loop_10470101::VelocitySizeSquaredThreshold' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, FXHideDelay) == 0x000F04, "Member 'ACue_Ability_Loop_10470101::FXHideDelay' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, HoverFXRotationInterpSpeed) == 0x000F08, "Member 'ACue_Ability_Loop_10470101::HoverFXRotationInterpSpeed' has a wrong offset!");

// Class Hero_1047.FlowSimluateSplineActor
// 0x0020 (0x0490 - 0x0470)
class AFlowSimluateSplineActor final : public AActor
{
public:
	int32                                         SplinePointCount;                                  // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlowHorizontalHalfRadius;                          // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        SplinePoints;                                      // 0x0478(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FlowLerpCurve;                                     // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BuildCurrentSplinePoints(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowSimluateSplineActor">();
	}
	static class AFlowSimluateSplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlowSimluateSplineActor>();
	}
};
static_assert(alignof(AFlowSimluateSplineActor) == 0x000008, "Wrong alignment on AFlowSimluateSplineActor");
static_assert(sizeof(AFlowSimluateSplineActor) == 0x000490, "Wrong size on AFlowSimluateSplineActor");
static_assert(offsetof(AFlowSimluateSplineActor, SplinePointCount) == 0x000470, "Member 'AFlowSimluateSplineActor::SplinePointCount' has a wrong offset!");
static_assert(offsetof(AFlowSimluateSplineActor, FlowHorizontalHalfRadius) == 0x000474, "Member 'AFlowSimluateSplineActor::FlowHorizontalHalfRadius' has a wrong offset!");
static_assert(offsetof(AFlowSimluateSplineActor, SplinePoints) == 0x000478, "Member 'AFlowSimluateSplineActor::SplinePoints' has a wrong offset!");
static_assert(offsetof(AFlowSimluateSplineActor, FlowLerpCurve) == 0x000488, "Member 'AFlowSimluateSplineActor::FlowLerpCurve' has a wrong offset!");

// Class Hero_1047.JeffGroundMotionSubAnimInstance
// 0x01A0 (0x0AA0 - 0x0900)
class UJeffGroundMotionSubAnimInstance final : public UMarvelAnimInstance
{
public:
	float                                         WorldTimeSeconds;                                  // 0x0900(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreBackwardTime;                                   // 0x0904(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreForwardTime;                                    // 0x0908(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreLeftForwardTime;                                // 0x090C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreRightForwardTime;                               // 0x0910(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftForwardRelevantTime;                           // 0x0914(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightForwardRelevantTime;                          // 0x0918(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopStartTime;                                     // 0x091C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopDirection;                                     // 0x0920(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMoveForward : 1;                                  // 0x0924(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsForwardStop : 1;                                 // 0x0924(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_925[0x3];                                      // 0x0925(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StateBufferTime;                                   // 0x0928(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LRBToLRFTime;                                      // 0x092C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LRFToLRBTime;                                      // 0x0930(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopStartTimeOffset;                               // 0x0934(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnterBToFAnimationStartPosition;                   // 0x0938(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CyclesBlendTime;                                   // 0x093C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJeffGroundMotionTransitionFlags       JeffGroundMotionTransitionFlags;                   // 0x0940(0x001C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FGroundMotionTransitionFlags           GroundMotionTransitionFlags;                       // 0x095C(0x0025)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_981[0x3];                                      // 0x0981(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVelocityBlend                         VelocityBlendFactor;                               // 0x0984(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FVelocityBlend                         OrientationBlendFactor;                            // 0x09A4(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	EJeffEightDirection                           EightDirection;                                    // 0x09C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C5[0x3];                                      // 0x09C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSpeed;                                         // 0x09C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedRate;                                     // 0x09CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedRateLowerLimit;                           // 0x09D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumpForward;                                    // 0x09D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D5[0x3];                                      // 0x09D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpDirection;                                     // 0x09D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpDirectionFwd;                                  // 0x09DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpDirectionBwd;                                  // 0x09E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingIdleBlendTime;                              // 0x09E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpStartToFallingBlendTime;                       // 0x09E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandBlendFactor;                                   // 0x09EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SubIsAccelerating;                                 // 0x09F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F1[0x3];                                      // 0x09F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LandMovementToGround;                              // 0x09F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlackforwardTransitionAplha;                       // 0x09F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9FC[0x24];                                     // 0x09FC(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class AJeffCharacter*                         JeffCharacter;                                     // 0x0A20(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGroundMotionSubAnimInstanceV1*         MainGroundMotion;                                  // 0x0A28(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A30[0x70];                                     // 0x0A30(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterBToF(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantBlackforwadTransitionNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantCycleNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantJumpStartNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantLeftForwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantRightForwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantStopNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateAllBackforwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateBlackforwadTransitionNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateForwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateJumpLandNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateJumpLoopNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateJumpStartNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateLeftForwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateRightForwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffGroundMotionSubAnimInstance">();
	}
	static class UJeffGroundMotionSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffGroundMotionSubAnimInstance>();
	}
};
static_assert(alignof(UJeffGroundMotionSubAnimInstance) == 0x000010, "Wrong alignment on UJeffGroundMotionSubAnimInstance");
static_assert(sizeof(UJeffGroundMotionSubAnimInstance) == 0x000AA0, "Wrong size on UJeffGroundMotionSubAnimInstance");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, WorldTimeSeconds) == 0x000900, "Member 'UJeffGroundMotionSubAnimInstance::WorldTimeSeconds' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, PreBackwardTime) == 0x000904, "Member 'UJeffGroundMotionSubAnimInstance::PreBackwardTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, PreForwardTime) == 0x000908, "Member 'UJeffGroundMotionSubAnimInstance::PreForwardTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, PreLeftForwardTime) == 0x00090C, "Member 'UJeffGroundMotionSubAnimInstance::PreLeftForwardTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, PreRightForwardTime) == 0x000910, "Member 'UJeffGroundMotionSubAnimInstance::PreRightForwardTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, LeftForwardRelevantTime) == 0x000914, "Member 'UJeffGroundMotionSubAnimInstance::LeftForwardRelevantTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, RightForwardRelevantTime) == 0x000918, "Member 'UJeffGroundMotionSubAnimInstance::RightForwardRelevantTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, StopStartTime) == 0x00091C, "Member 'UJeffGroundMotionSubAnimInstance::StopStartTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, StopDirection) == 0x000920, "Member 'UJeffGroundMotionSubAnimInstance::StopDirection' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, StateBufferTime) == 0x000928, "Member 'UJeffGroundMotionSubAnimInstance::StateBufferTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, LRBToLRFTime) == 0x00092C, "Member 'UJeffGroundMotionSubAnimInstance::LRBToLRFTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, LRFToLRBTime) == 0x000930, "Member 'UJeffGroundMotionSubAnimInstance::LRFToLRBTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, StopStartTimeOffset) == 0x000934, "Member 'UJeffGroundMotionSubAnimInstance::StopStartTimeOffset' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, EnterBToFAnimationStartPosition) == 0x000938, "Member 'UJeffGroundMotionSubAnimInstance::EnterBToFAnimationStartPosition' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, CyclesBlendTime) == 0x00093C, "Member 'UJeffGroundMotionSubAnimInstance::CyclesBlendTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JeffGroundMotionTransitionFlags) == 0x000940, "Member 'UJeffGroundMotionSubAnimInstance::JeffGroundMotionTransitionFlags' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, GroundMotionTransitionFlags) == 0x00095C, "Member 'UJeffGroundMotionSubAnimInstance::GroundMotionTransitionFlags' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, VelocityBlendFactor) == 0x000984, "Member 'UJeffGroundMotionSubAnimInstance::VelocityBlendFactor' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, OrientationBlendFactor) == 0x0009A4, "Member 'UJeffGroundMotionSubAnimInstance::OrientationBlendFactor' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, EightDirection) == 0x0009C4, "Member 'UJeffGroundMotionSubAnimInstance::EightDirection' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, WalkSpeed) == 0x0009C8, "Member 'UJeffGroundMotionSubAnimInstance::WalkSpeed' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, WalkSpeedRate) == 0x0009CC, "Member 'UJeffGroundMotionSubAnimInstance::WalkSpeedRate' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, WalkSpeedRateLowerLimit) == 0x0009D0, "Member 'UJeffGroundMotionSubAnimInstance::WalkSpeedRateLowerLimit' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, bIsJumpForward) == 0x0009D4, "Member 'UJeffGroundMotionSubAnimInstance::bIsJumpForward' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JumpDirection) == 0x0009D8, "Member 'UJeffGroundMotionSubAnimInstance::JumpDirection' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JumpDirectionFwd) == 0x0009DC, "Member 'UJeffGroundMotionSubAnimInstance::JumpDirectionFwd' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JumpDirectionBwd) == 0x0009E0, "Member 'UJeffGroundMotionSubAnimInstance::JumpDirectionBwd' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, FallingIdleBlendTime) == 0x0009E4, "Member 'UJeffGroundMotionSubAnimInstance::FallingIdleBlendTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JumpStartToFallingBlendTime) == 0x0009E8, "Member 'UJeffGroundMotionSubAnimInstance::JumpStartToFallingBlendTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, LandBlendFactor) == 0x0009EC, "Member 'UJeffGroundMotionSubAnimInstance::LandBlendFactor' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, SubIsAccelerating) == 0x0009F0, "Member 'UJeffGroundMotionSubAnimInstance::SubIsAccelerating' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, LandMovementToGround) == 0x0009F4, "Member 'UJeffGroundMotionSubAnimInstance::LandMovementToGround' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, BlackforwardTransitionAplha) == 0x0009F8, "Member 'UJeffGroundMotionSubAnimInstance::BlackforwardTransitionAplha' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JeffCharacter) == 0x000A20, "Member 'UJeffGroundMotionSubAnimInstance::JeffCharacter' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, MainGroundMotion) == 0x000A28, "Member 'UJeffGroundMotionSubAnimInstance::MainGroundMotion' has a wrong offset!");

// Class Hero_1047.JeffMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UJeffMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffMoveLogicBaseComponent">();
	}
	static class UJeffMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UJeffMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UJeffMoveLogicBaseComponent");
static_assert(sizeof(UJeffMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UJeffMoveLogicBaseComponent");

// Class Hero_1047.JeffMovementComponent
// 0x0060 (0x2F40 - 0x2EE0)
class UJeffMovementComponent final : public UCharacterWallRunningComponent
{
public:
	class AJeffCharacter*                         JeffCharacter;                                     // 0x2ED8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDivingWantToClimb;                                // 0x2EE0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDivingInClimbRadius;                              // 0x2EE1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE2[0x2];                                     // 0x2EE2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DivingOrientRotationLerpSpeed;                     // 0x2EE4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChildActorMeshLerpSpeed;                           // 0x2EE8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EEC[0x4];                                     // 0x2EEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetRelativeRotator;                             // 0x2EF0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJeffFallingWhenDiveDispatcher_ThreadSafe;        // 0x2F08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         StepDownOnceHeight;                                // 0x2F18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepDownHeight;                                 // 0x2F1C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TryRiseSpeed;                                      // 0x2F20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFixZCeilMode;                                   // 0x2F24(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F25[0x3];                                     // 0x2F25(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CeilingZ;                                          // 0x2F28(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F2C[0x14];                                    // 0x2F2C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FJeffMoveForwardCheckResult CheckMoveForward(const struct FVector& MoveDelta);
	void OnJeffGetOffWall(const struct FWallRunningEndInfo& InWallRunningEndInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffMovementComponent">();
	}
	static class UJeffMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffMovementComponent>();
	}
};
static_assert(alignof(UJeffMovementComponent) == 0x000010, "Wrong alignment on UJeffMovementComponent");
static_assert(sizeof(UJeffMovementComponent) == 0x002F40, "Wrong size on UJeffMovementComponent");
static_assert(offsetof(UJeffMovementComponent, JeffCharacter) == 0x002ED8, "Member 'UJeffMovementComponent::JeffCharacter' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, bDivingWantToClimb) == 0x002EE0, "Member 'UJeffMovementComponent::bDivingWantToClimb' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, bDivingInClimbRadius) == 0x002EE1, "Member 'UJeffMovementComponent::bDivingInClimbRadius' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, DivingOrientRotationLerpSpeed) == 0x002EE4, "Member 'UJeffMovementComponent::DivingOrientRotationLerpSpeed' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, ChildActorMeshLerpSpeed) == 0x002EE8, "Member 'UJeffMovementComponent::ChildActorMeshLerpSpeed' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, TargetRelativeRotator) == 0x002EF0, "Member 'UJeffMovementComponent::TargetRelativeRotator' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, OnJeffFallingWhenDiveDispatcher_ThreadSafe) == 0x002F08, "Member 'UJeffMovementComponent::OnJeffFallingWhenDiveDispatcher_ThreadSafe' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, StepDownOnceHeight) == 0x002F18, "Member 'UJeffMovementComponent::StepDownOnceHeight' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, MaxStepDownHeight) == 0x002F1C, "Member 'UJeffMovementComponent::MaxStepDownHeight' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, TryRiseSpeed) == 0x002F20, "Member 'UJeffMovementComponent::TryRiseSpeed' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, bIsFixZCeilMode) == 0x002F24, "Member 'UJeffMovementComponent::bIsFixZCeilMode' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, CeilingZ) == 0x002F28, "Member 'UJeffMovementComponent::CeilingZ' has a wrong offset!");

// Class Hero_1047.ShootingLogic_104712
// 0x0008 (0x15D0 - 0x15C8)
class UShootingLogic_104712 final : public UShootingLogic_AbilityProjectile
{
public:
	int32                                         SimpleWaterEntityNum;                              // 0x15C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15CC[0x4];                                     // 0x15CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShootingLogic_104712">();
	}
	static class UShootingLogic_104712* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShootingLogic_104712>();
	}
};
static_assert(alignof(UShootingLogic_104712) == 0x000008, "Wrong alignment on UShootingLogic_104712");
static_assert(sizeof(UShootingLogic_104712) == 0x0015D0, "Wrong size on UShootingLogic_104712");
static_assert(offsetof(UShootingLogic_104712, SimpleWaterEntityNum) == 0x0015C8, "Member 'UShootingLogic_104712::SimpleWaterEntityNum' has a wrong offset!");

}

