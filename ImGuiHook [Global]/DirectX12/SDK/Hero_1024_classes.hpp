#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1024

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Hero_1024_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Hero_1024.ResurrectionAbility_10240201
// 0x0008 (0x1188 - 0x1180)
class UResurrectionAbility_10240201 : public UMarvelBaseResurrectionAbility
{
public:
	float                                         LokiResurrectionHPPercent;                         // 0x1180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThorResurrectionHPPercent;                         // 0x1184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResurrectionAbility_10240201">();
	}
	static class UResurrectionAbility_10240201* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResurrectionAbility_10240201>();
	}
};
static_assert(alignof(UResurrectionAbility_10240201) == 0x000008, "Wrong alignment on UResurrectionAbility_10240201");
static_assert(sizeof(UResurrectionAbility_10240201) == 0x001188, "Wrong size on UResurrectionAbility_10240201");
static_assert(offsetof(UResurrectionAbility_10240201, LokiResurrectionHPPercent) == 0x001180, "Member 'UResurrectionAbility_10240201::LokiResurrectionHPPercent' has a wrong offset!");
static_assert(offsetof(UResurrectionAbility_10240201, ThorResurrectionHPPercent) == 0x001184, "Member 'UResurrectionAbility_10240201::ThorResurrectionHPPercent' has a wrong offset!");

// Class Hero_1024.SummonedComp_10247101
// 0x0000 (0x0C90 - 0x0C90)
class USummonedComp_10247101 : public UMarvelSummonedComponent
{
public:
	bool                                          IsFiring;                                          // 0x0C88(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEndPlay;                                         // 0x0C89(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCameraFinish;                                    // 0x0C8A(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8B[0x1];                                      // 0x0C8B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityStatusNum;                                  // 0x0C8C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10247101">();
	}
	static class USummonedComp_10247101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10247101>();
	}
};
static_assert(alignof(USummonedComp_10247101) == 0x000010, "Wrong alignment on USummonedComp_10247101");
static_assert(sizeof(USummonedComp_10247101) == 0x000C90, "Wrong size on USummonedComp_10247101");
static_assert(offsetof(USummonedComp_10247101, IsFiring) == 0x000C88, "Member 'USummonedComp_10247101::IsFiring' has a wrong offset!");
static_assert(offsetof(USummonedComp_10247101, IsEndPlay) == 0x000C89, "Member 'USummonedComp_10247101::IsEndPlay' has a wrong offset!");
static_assert(offsetof(USummonedComp_10247101, IsCameraFinish) == 0x000C8A, "Member 'USummonedComp_10247101::IsCameraFinish' has a wrong offset!");
static_assert(offsetof(USummonedComp_10247101, AbilityStatusNum) == 0x000C8C, "Member 'USummonedComp_10247101::AbilityStatusNum' has a wrong offset!");

// Class Hero_1024.Cue_Buff_10240201
// 0x0170 (0x1170 - 0x1000)
class ACue_Buff_10240201 final : public ACue_Buff_Resurrection
{
public:
	class UFXSystemAsset*                         GroundFX;                                          // 0x1000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         ResurrectLoopFX;                                   // 0x1008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         ResurrectExplodeFX;                                // 0x1010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1018[0x8];                                     // 0x1018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ExplodeFXOffset;                                   // 0x1020(0x0060)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             LoopFXOffset;                                      // 0x1080(0x0060)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTraceDist;                                   // 0x10E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E4[0x4];                                     // 0x10E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWidgetStyle_BattleTransientTip        ResurrectionTip;                                   // 0x10E8(0x0048)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MaterialCurve;                                     // 0x1130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName1;                                        // 0x1138(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName2;                                        // 0x1144(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1150[0x4];                                     // 0x1150(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeshOverlayMaterialHandle             TargetMaterialHandle;                              // 0x1154(0x001C)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10240201">();
	}
	static class ACue_Buff_10240201* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10240201>();
	}
};
static_assert(alignof(ACue_Buff_10240201) == 0x000010, "Wrong alignment on ACue_Buff_10240201");
static_assert(sizeof(ACue_Buff_10240201) == 0x001170, "Wrong size on ACue_Buff_10240201");
static_assert(offsetof(ACue_Buff_10240201, GroundFX) == 0x001000, "Member 'ACue_Buff_10240201::GroundFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ResurrectLoopFX) == 0x001008, "Member 'ACue_Buff_10240201::ResurrectLoopFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ResurrectExplodeFX) == 0x001010, "Member 'ACue_Buff_10240201::ResurrectExplodeFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ExplodeFXOffset) == 0x001020, "Member 'ACue_Buff_10240201::ExplodeFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, LoopFXOffset) == 0x001080, "Member 'ACue_Buff_10240201::LoopFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, GroundTraceDist) == 0x0010E0, "Member 'ACue_Buff_10240201::GroundTraceDist' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ResurrectionTip) == 0x0010E8, "Member 'ACue_Buff_10240201::ResurrectionTip' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, MaterialCurve) == 0x001130, "Member 'ACue_Buff_10240201::MaterialCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ParamName1) == 0x001138, "Member 'ACue_Buff_10240201::ParamName1' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ParamName2) == 0x001144, "Member 'ACue_Buff_10240201::ParamName2' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, TargetMaterialHandle) == 0x001154, "Member 'ACue_Buff_10240201::TargetMaterialHandle' has a wrong offset!");

// Class Hero_1024.Config_102411
// 0x0078 (0x0110 - 0x0098)
class UConfig_102411 final : public UMarvelAbilityConfig
{
public:
	int32                                         ScopeDamageID;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScopeDelay;                                  // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScopeWarningID;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreDeathTag;                                    // 0x00A8(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102411">();
	}
	static class UConfig_102411* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102411>();
	}
};
static_assert(alignof(UConfig_102411) == 0x000008, "Wrong alignment on UConfig_102411");
static_assert(sizeof(UConfig_102411) == 0x000110, "Wrong size on UConfig_102411");
static_assert(offsetof(UConfig_102411, ScopeDamageID) == 0x000098, "Member 'UConfig_102411::ScopeDamageID' has a wrong offset!");
static_assert(offsetof(UConfig_102411, DamageScopeDelay) == 0x00009C, "Member 'UConfig_102411::DamageScopeDelay' has a wrong offset!");
static_assert(offsetof(UConfig_102411, ScopeWarningID) == 0x0000A0, "Member 'UConfig_102411::ScopeWarningID' has a wrong offset!");
static_assert(offsetof(UConfig_102411, IgnoreDeathTag) == 0x0000A8, "Member 'UConfig_102411::IgnoreDeathTag' has a wrong offset!");

// Class Hero_1024.ProjectileMovementComponent_102451
// 0x0030 (0x1FA0 - 0x1F70)
class UProjectileMovementComponent_102451 final : public UMarvelProjectileComponent
{
public:
	class UProjectileCollisionComponent_102451*   CollisionComponent;                                // 0x1F68(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleControl;                                      // 0x1F70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepVelocityDirection;                            // 0x1F74(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F75[0x1B];                                    // 0x1F75(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastDiffLocationLength;                            // 0x1F90(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AMarvelAbilityTargetActor_Projectile> TargetActor;                                       // 0x1F94(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F9C[0x4];                                     // 0x1F9C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileMovementComponent_102451">();
	}
	static class UProjectileMovementComponent_102451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileMovementComponent_102451>();
	}
};
static_assert(alignof(UProjectileMovementComponent_102451) == 0x000010, "Wrong alignment on UProjectileMovementComponent_102451");
static_assert(sizeof(UProjectileMovementComponent_102451) == 0x001FA0, "Wrong size on UProjectileMovementComponent_102451");
static_assert(offsetof(UProjectileMovementComponent_102451, CollisionComponent) == 0x001F68, "Member 'UProjectileMovementComponent_102451::CollisionComponent' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent_102451, AngleControl) == 0x001F70, "Member 'UProjectileMovementComponent_102451::AngleControl' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent_102451, bKeepVelocityDirection) == 0x001F74, "Member 'UProjectileMovementComponent_102451::bKeepVelocityDirection' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent_102451, LastDiffLocationLength) == 0x001F90, "Member 'UProjectileMovementComponent_102451::LastDiffLocationLength' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent_102451, TargetActor) == 0x001F94, "Member 'UProjectileMovementComponent_102451::TargetActor' has a wrong offset!");

// Class Hero_1024.Ability_102411
// 0x0000 (0x2550 - 0x2550)
class UAbility_102411 : public UMarvelGameplayAbility
{
public:
	void OnActorDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnAssistKill(const struct FUIKillInfo& KillInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102411">();
	}
	static class UAbility_102411* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102411>();
	}
};
static_assert(alignof(UAbility_102411) == 0x000008, "Wrong alignment on UAbility_102411");
static_assert(sizeof(UAbility_102411) == 0x002550, "Wrong size on UAbility_102411");

// Class Hero_1024.Scope_10241102
// 0x0010 (0x16D0 - 0x16C0)
class AScope_10241102 final : public AMarvelAbilityTargetActor_Scope
{
public:
	struct FGameplayTag                           WarningCueTag;                                     // 0x16C0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16CC[0x4];                                     // 0x16CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10241102">();
	}
	static class AScope_10241102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10241102>();
	}
};
static_assert(alignof(AScope_10241102) == 0x000010, "Wrong alignment on AScope_10241102");
static_assert(sizeof(AScope_10241102) == 0x0016D0, "Wrong size on AScope_10241102");
static_assert(offsetof(AScope_10241102, WarningCueTag) == 0x0016C0, "Member 'AScope_10241102::WarningCueTag' has a wrong offset!");

// Class Hero_1024.Projectile_10244101
// 0x0000 (0x2F60 - 0x2F60)
class AProjectile_10244101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	void ListenHitComponentCollisionChanged(class UPrimitiveComponent* InComponent, bool bListen);
	void OnHitComponentCollisionChanged(class UPrimitiveComponent* InPrimitiveComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10244101">();
	}
	static class AProjectile_10244101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10244101>();
	}
};
static_assert(alignof(AProjectile_10244101) == 0x000010, "Wrong alignment on AProjectile_10244101");
static_assert(sizeof(AProjectile_10244101) == 0x002F60, "Wrong size on AProjectile_10244101");

// Class Hero_1024.Cue_Ability_Loop_10244101
// 0x0038 (0x0E38 - 0x0E00)
class ACue_Ability_Loop_10244101 : public AMarvelCueNotify_Ability
{
public:
	TArray<struct FHelaFXInfo>                    HelaFXInfos;                                       // 0x0E00(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         InterpSpeedP;                                      // 0x0E10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeedY;                                      // 0x0E14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS1;                                               // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS2;                                               // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS3;                                               // 0x0E28(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS4;                                               // 0x0E30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FRotator GetFXRotation(class UNiagaraComponent* FXComponent, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10244101">();
	}
	static class ACue_Ability_Loop_10244101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10244101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10244101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10244101");
static_assert(sizeof(ACue_Ability_Loop_10244101) == 0x000E38, "Wrong size on ACue_Ability_Loop_10244101");
static_assert(offsetof(ACue_Ability_Loop_10244101, HelaFXInfos) == 0x000E00, "Member 'ACue_Ability_Loop_10244101::HelaFXInfos' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, InterpSpeedP) == 0x000E10, "Member 'ACue_Ability_Loop_10244101::InterpSpeedP' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, InterpSpeedY) == 0x000E14, "Member 'ACue_Ability_Loop_10244101::InterpSpeedY' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, NS1) == 0x000E18, "Member 'ACue_Ability_Loop_10244101::NS1' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, NS2) == 0x000E20, "Member 'ACue_Ability_Loop_10244101::NS2' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, NS3) == 0x000E28, "Member 'ACue_Ability_Loop_10244101::NS3' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, NS4) == 0x000E30, "Member 'ACue_Ability_Loop_10244101::NS4' has a wrong offset!");

// Class Hero_1024.ForceMoveToAbility_102461
// 0x0008 (0x10F0 - 0x10E8)
class UForceMoveToAbility_102461 : public UMarvelEffectGameplayAbility
{
public:
	class UMarvelAbilityTask_Dash*                MoveTask;                                          // 0x10E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDashFinish(EDashStopReason InReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceMoveToAbility_102461">();
	}
	static class UForceMoveToAbility_102461* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceMoveToAbility_102461>();
	}
};
static_assert(alignof(UForceMoveToAbility_102461) == 0x000008, "Wrong alignment on UForceMoveToAbility_102461");
static_assert(sizeof(UForceMoveToAbility_102461) == 0x0010F0, "Wrong size on UForceMoveToAbility_102461");
static_assert(offsetof(UForceMoveToAbility_102461, MoveTask) == 0x0010E8, "Member 'UForceMoveToAbility_102461::MoveTask' has a wrong offset!");

// Class Hero_1024.Config_102451
// 0x0010 (0x00A8 - 0x0098)
class UConfig_102451 : public UMarvelAbilityConfig
{
public:
	float                                         PhantomCapsuleHalfHeight;                          // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhantomCapsuleRadius;                              // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectActorCheckDistance;                          // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNewAbility;                                 // 0x00A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102451">();
	}
	static class UConfig_102451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102451>();
	}
};
static_assert(alignof(UConfig_102451) == 0x000008, "Wrong alignment on UConfig_102451");
static_assert(sizeof(UConfig_102451) == 0x0000A8, "Wrong size on UConfig_102451");
static_assert(offsetof(UConfig_102451, PhantomCapsuleHalfHeight) == 0x000098, "Member 'UConfig_102451::PhantomCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UConfig_102451, PhantomCapsuleRadius) == 0x00009C, "Member 'UConfig_102451::PhantomCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UConfig_102451, EffectActorCheckDistance) == 0x0000A0, "Member 'UConfig_102451::EffectActorCheckDistance' has a wrong offset!");
static_assert(offsetof(UConfig_102451, bEnableNewAbility) == 0x0000A4, "Member 'UConfig_102451::bEnableNewAbility' has a wrong offset!");

// Class Hero_1024.Ability_102451
// 0x0000 (0x2550 - 0x2550)
class UAbility_102451 : public UMarvelGameplayAbility
{
public:
	bool InBirthRoom();
	void PreTeleport();
	void Teleport();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102451">();
	}
	static class UAbility_102451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102451>();
	}
};
static_assert(alignof(UAbility_102451) == 0x000008, "Wrong alignment on UAbility_102451");
static_assert(sizeof(UAbility_102451) == 0x002550, "Wrong size on UAbility_102451");

// Class Hero_1024.ProjectileCollisionComponent_102451
// 0x0010 (0x08C0 - 0x08B0)
class UProjectileCollisionComponent_102451 final : public UProjectileCollisionComponent
{
public:
	bool                                          bOverridePawnSweep;                                // 0x08B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B1[0x7];                                      // 0x08B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      OwnerCapsule;                                      // 0x08B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileCollisionComponent_102451">();
	}
	static class UProjectileCollisionComponent_102451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileCollisionComponent_102451>();
	}
};
static_assert(alignof(UProjectileCollisionComponent_102451) == 0x000010, "Wrong alignment on UProjectileCollisionComponent_102451");
static_assert(sizeof(UProjectileCollisionComponent_102451) == 0x0008C0, "Wrong size on UProjectileCollisionComponent_102451");
static_assert(offsetof(UProjectileCollisionComponent_102451, bOverridePawnSweep) == 0x0008B0, "Member 'UProjectileCollisionComponent_102451::bOverridePawnSweep' has a wrong offset!");
static_assert(offsetof(UProjectileCollisionComponent_102451, OwnerCapsule) == 0x0008B8, "Member 'UProjectileCollisionComponent_102451::OwnerCapsule' has a wrong offset!");

// Class Hero_1024.Projectile_10245101
// 0x0040 (0x2FA0 - 0x2F60)
class AProjectile_10245101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	class UCapsuleComponent*                      PhantomCapsuleComponent;                           // 0x2F60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelSpringArmComponent*              SpringArm;                                         // 0x2F68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       Camera;                                            // 0x2F70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x2F78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F7C[0x24];                                    // 0x2F7C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10245101">();
	}
	static class AProjectile_10245101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10245101>();
	}
};
static_assert(alignof(AProjectile_10245101) == 0x000010, "Wrong alignment on AProjectile_10245101");
static_assert(sizeof(AProjectile_10245101) == 0x002FA0, "Wrong size on AProjectile_10245101");
static_assert(offsetof(AProjectile_10245101, PhantomCapsuleComponent) == 0x002F60, "Member 'AProjectile_10245101::PhantomCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AProjectile_10245101, SpringArm) == 0x002F68, "Member 'AProjectile_10245101::SpringArm' has a wrong offset!");
static_assert(offsetof(AProjectile_10245101, Camera) == 0x002F70, "Member 'AProjectile_10245101::Camera' has a wrong offset!");
static_assert(offsetof(AProjectile_10245101, InterpSpeed) == 0x002F78, "Member 'AProjectile_10245101::InterpSpeed' has a wrong offset!");

// Class Hero_1024.Cue_Projectile_Loop_10245101
// 0x0018 (0x0D78 - 0x0D60)
class ACue_Projectile_Loop_10245101 final : public AMarvelCueNotify_Projectile
{
public:
	float                                         CheckDistance;                                     // 0x0D60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D64[0x4];                                      // 0x0D64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectile_10245101*                   ProjectileTarget;                                  // 0x0D68(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_102451*                         OwnerAbilityConfig;                                // 0x0D70(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitializeSummonedSceneIndicator(float TotalTime);
	void OnViewingCharacterChanged(class AMarvelBaseCharacter* InCharacter);
	void UpdateStencilValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10245101">();
	}
	static class ACue_Projectile_Loop_10245101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10245101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10245101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10245101");
static_assert(sizeof(ACue_Projectile_Loop_10245101) == 0x000D78, "Wrong size on ACue_Projectile_Loop_10245101");
static_assert(offsetof(ACue_Projectile_Loop_10245101, CheckDistance) == 0x000D60, "Member 'ACue_Projectile_Loop_10245101::CheckDistance' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10245101, ProjectileTarget) == 0x000D68, "Member 'ACue_Projectile_Loop_10245101::ProjectileTarget' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10245101, OwnerAbilityConfig) == 0x000D70, "Member 'ACue_Projectile_Loop_10245101::OwnerAbilityConfig' has a wrong offset!");

// Class Hero_1024.Config_102461
// 0x0B70 (0x0C08 - 0x0098)
class UConfig_102461 : public UMarvelAbilityConfig
{
public:
	struct FDashAbilityInfo                       DashInfo;                                          // 0x0098(0x0B70)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102461">();
	}
	static class UConfig_102461* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102461>();
	}
};
static_assert(alignof(UConfig_102461) == 0x000008, "Wrong alignment on UConfig_102461");
static_assert(sizeof(UConfig_102461) == 0x000C08, "Wrong size on UConfig_102461");
static_assert(offsetof(UConfig_102461, DashInfo) == 0x000098, "Member 'UConfig_102461::DashInfo' has a wrong offset!");

// Class Hero_1024.Summoned_10247101
// 0x0050 (0x0850 - 0x0800)
class ASummoned_10247101 : public AMarvelSummonerBase
{
public:
	class UMarvelChildActorComponent*             ChildActorComponent;                               // 0x07F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    SpringArm;                                         // 0x0800(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       Camera;                                            // 0x0808(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      Capsule;                                           // 0x0810(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonMaxPitchLimit;                          // 0x0818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x081C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFirstPerson;                                     // 0x0820(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_821[0x7];                                      // 0x0821(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LastRotation;                                      // 0x0828(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PenetrationExtraRadiusScale;                       // 0x0840(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_844[0xC];                                      // 0x0844(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustCapsuleLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10247101">();
	}
	static class ASummoned_10247101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10247101>();
	}
};
static_assert(alignof(ASummoned_10247101) == 0x000010, "Wrong alignment on ASummoned_10247101");
static_assert(sizeof(ASummoned_10247101) == 0x000850, "Wrong size on ASummoned_10247101");
static_assert(offsetof(ASummoned_10247101, ChildActorComponent) == 0x0007F8, "Member 'ASummoned_10247101::ChildActorComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, SpringArm) == 0x000800, "Member 'ASummoned_10247101::SpringArm' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, Camera) == 0x000808, "Member 'ASummoned_10247101::Camera' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, Capsule) == 0x000810, "Member 'ASummoned_10247101::Capsule' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, ThirdPersonMaxPitchLimit) == 0x000818, "Member 'ASummoned_10247101::ThirdPersonMaxPitchLimit' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, InterpSpeed) == 0x00081C, "Member 'ASummoned_10247101::InterpSpeed' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, IsFirstPerson) == 0x000820, "Member 'ASummoned_10247101::IsFirstPerson' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, LastRotation) == 0x000828, "Member 'ASummoned_10247101::LastRotation' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, PenetrationExtraRadiusScale) == 0x000840, "Member 'ASummoned_10247101::PenetrationExtraRadiusScale' has a wrong offset!");

// Class Hero_1024.Ability_102471
// 0x0018 (0x2568 - 0x2550)
class UAbility_102471 : public UMarvelGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             ActiveFailedDueToHeight;                           // 0x2550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2560[0x8];                                     // 0x2560(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeGravityScale(float NewGravityScale);
	bool CheckHeightAboveGround();

	float GetOriginGravityScale() const;
	void OnAbilityActiveFailed(const class UGameplayAbility* InAbility, const struct FGameplayTagContainer& Tags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102471">();
	}
	static class UAbility_102471* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102471>();
	}
};
static_assert(alignof(UAbility_102471) == 0x000008, "Wrong alignment on UAbility_102471");
static_assert(sizeof(UAbility_102471) == 0x002568, "Wrong size on UAbility_102471");
static_assert(offsetof(UAbility_102471, ActiveFailedDueToHeight) == 0x002550, "Member 'UAbility_102471::ActiveFailedDueToHeight' has a wrong offset!");

// Class Hero_1024.Cue_Ability_Loop_102491
// 0x0010 (0x0E10 - 0x0E00)
class ACue_Ability_Loop_102491 final : public AMarvelCueNotify_Ability
{
public:
	class UNiagaraComponent*                      NS_Link;                                           // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHelaCharacter*                         OwnerCharacter;                                    // 0x0E08(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class APhysicsSummoner* GetWeaponSummoner();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_102491">();
	}
	static class ACue_Ability_Loop_102491* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_102491>();
	}
};
static_assert(alignof(ACue_Ability_Loop_102491) == 0x000008, "Wrong alignment on ACue_Ability_Loop_102491");
static_assert(sizeof(ACue_Ability_Loop_102491) == 0x000E10, "Wrong size on ACue_Ability_Loop_102491");
static_assert(offsetof(ACue_Ability_Loop_102491, NS_Link) == 0x000E00, "Member 'ACue_Ability_Loop_102491::NS_Link' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102491, OwnerCharacter) == 0x000E08, "Member 'ACue_Ability_Loop_102491::OwnerCharacter' has a wrong offset!");

// Class Hero_1024.CrownStormAnimInstance
// 0x0000 (0x0900 - 0x0900)
class UCrownStormAnimInstance final : public UMarvelAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrownStormAnimInstance">();
	}
	static class UCrownStormAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrownStormAnimInstance>();
	}
};
static_assert(alignof(UCrownStormAnimInstance) == 0x000010, "Wrong alignment on UCrownStormAnimInstance");
static_assert(sizeof(UCrownStormAnimInstance) == 0x000900, "Wrong size on UCrownStormAnimInstance");

// Class Hero_1024.CrownStormCharacter
// 0x0010 (0x17D0 - 0x17C0)
class ACrownStormCharacter final : public AMarvelBaseCharacter
{
public:
	int32                                         FromHeroID;                                        // 0x17B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17BC[0x4];                                     // 0x17BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrownStormMoveLogicBaseComponent*      CrownStormMoveLogic;                               // 0x17C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17C8[0x8];                                     // 0x17C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastTransitionToHela();
	void TransitionToHela();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrownStormCharacter">();
	}
	static class ACrownStormCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrownStormCharacter>();
	}
};
static_assert(alignof(ACrownStormCharacter) == 0x000010, "Wrong alignment on ACrownStormCharacter");
static_assert(sizeof(ACrownStormCharacter) == 0x0017D0, "Wrong size on ACrownStormCharacter");
static_assert(offsetof(ACrownStormCharacter, FromHeroID) == 0x0017B8, "Member 'ACrownStormCharacter::FromHeroID' has a wrong offset!");
static_assert(offsetof(ACrownStormCharacter, CrownStormMoveLogic) == 0x0017C0, "Member 'ACrownStormCharacter::CrownStormMoveLogic' has a wrong offset!");

// Class Hero_1024.CrownStormMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UCrownStormMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrownStormMoveLogicBaseComponent">();
	}
	static class UCrownStormMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrownStormMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UCrownStormMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UCrownStormMoveLogicBaseComponent");
static_assert(sizeof(UCrownStormMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UCrownStormMoveLogicBaseComponent");

// Class Hero_1024.HelaAnimInstance
// 0x0050 (0x0950 - 0x0900)
class UHelaAnimInstance : public UMarvelAnimInstance
{
public:
	float                                         HoverMaxSpeed;                                     // 0x0900(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FlyTag;                                            // 0x0904(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovingVelocityNormalInterpSpeed;                   // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDescending;                                     // 0x0914(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_915[0x3];                                      // 0x0915(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MovingVelocityNormal;                              // 0x0918(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHovering;                                       // 0x0930(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCrowState;                                      // 0x0931(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCrowFiring;                                     // 0x0932(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_933[0x1D];                                     // 0x0933(0x001D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFlyTagUpdated(const struct FGameplayTag& TagUpdated, bool TagExists);
	void SetAutoDescend(bool bInOpenAutoDescend);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaAnimInstance">();
	}
	static class UHelaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaAnimInstance>();
	}
};
static_assert(alignof(UHelaAnimInstance) == 0x000010, "Wrong alignment on UHelaAnimInstance");
static_assert(sizeof(UHelaAnimInstance) == 0x000950, "Wrong size on UHelaAnimInstance");
static_assert(offsetof(UHelaAnimInstance, HoverMaxSpeed) == 0x000900, "Member 'UHelaAnimInstance::HoverMaxSpeed' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, FlyTag) == 0x000904, "Member 'UHelaAnimInstance::FlyTag' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, MovingVelocityNormalInterpSpeed) == 0x000910, "Member 'UHelaAnimInstance::MovingVelocityNormalInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, bIsDescending) == 0x000914, "Member 'UHelaAnimInstance::bIsDescending' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, MovingVelocityNormal) == 0x000918, "Member 'UHelaAnimInstance::MovingVelocityNormal' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, bIsHovering) == 0x000930, "Member 'UHelaAnimInstance::bIsHovering' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, bIsCrowState) == 0x000931, "Member 'UHelaAnimInstance::bIsCrowState' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, bIsCrowFiring) == 0x000932, "Member 'UHelaAnimInstance::bIsCrowFiring' has a wrong offset!");

// Class Hero_1024.HelaCrowCloakAnimInstance
// 0x0010 (0x0430 - 0x0420)
class UHelaCrowCloakAnimInstance final : public UAnimInstance
{
public:
	bool                                          bShouldTransIdle;                                  // 0x0418(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x3];                                      // 0x0419(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StateSeconds;                                      // 0x041C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaCrowCloakAnimInstance">();
	}
	static class UHelaCrowCloakAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaCrowCloakAnimInstance>();
	}
};
static_assert(alignof(UHelaCrowCloakAnimInstance) == 0x000010, "Wrong alignment on UHelaCrowCloakAnimInstance");
static_assert(sizeof(UHelaCrowCloakAnimInstance) == 0x000430, "Wrong size on UHelaCrowCloakAnimInstance");
static_assert(offsetof(UHelaCrowCloakAnimInstance, bShouldTransIdle) == 0x000418, "Member 'UHelaCrowCloakAnimInstance::bShouldTransIdle' has a wrong offset!");
static_assert(offsetof(UHelaCrowCloakAnimInstance, StateSeconds) == 0x00041C, "Member 'UHelaCrowCloakAnimInstance::StateSeconds' has a wrong offset!");

// Class Hero_1024.HelaCrowAnimInstance
// 0x0030 (0x0980 - 0x0950)
class UHelaCrowAnimInstance final : public UHelaAnimInstance
{
public:
	bool                                          bIsEnd;                                            // 0x0950(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransToLoop;                                   // 0x0951(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterStart;                                    // 0x0952(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_953[0x2D];                                     // 0x0953(0x002D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaCrowAnimInstance">();
	}
	static class UHelaCrowAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaCrowAnimInstance>();
	}
};
static_assert(alignof(UHelaCrowAnimInstance) == 0x000010, "Wrong alignment on UHelaCrowAnimInstance");
static_assert(sizeof(UHelaCrowAnimInstance) == 0x000980, "Wrong size on UHelaCrowAnimInstance");
static_assert(offsetof(UHelaCrowAnimInstance, bIsEnd) == 0x000950, "Member 'UHelaCrowAnimInstance::bIsEnd' has a wrong offset!");
static_assert(offsetof(UHelaCrowAnimInstance, bCanTransToLoop) == 0x000951, "Member 'UHelaCrowAnimInstance::bCanTransToLoop' has a wrong offset!");
static_assert(offsetof(UHelaCrowAnimInstance, bCanEnterStart) == 0x000952, "Member 'UHelaCrowAnimInstance::bCanEnterStart' has a wrong offset!");

// Class Hero_1024.HelaCrowFPAnimInstance
// 0x0010 (0x0960 - 0x0950)
class UHelaCrowFPAnimInstance final : public UHelaAnimInstance
{
public:
	float                                         PlayRate;                                          // 0x0950(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_954[0xC];                                      // 0x0954(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaCrowFPAnimInstance">();
	}
	static class UHelaCrowFPAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaCrowFPAnimInstance>();
	}
};
static_assert(alignof(UHelaCrowFPAnimInstance) == 0x000010, "Wrong alignment on UHelaCrowFPAnimInstance");
static_assert(sizeof(UHelaCrowFPAnimInstance) == 0x000960, "Wrong size on UHelaCrowFPAnimInstance");
static_assert(offsetof(UHelaCrowFPAnimInstance, PlayRate) == 0x000950, "Member 'UHelaCrowFPAnimInstance::PlayRate' has a wrong offset!");

// Class Hero_1024.HelaChildActor
// 0x0048 (0x0A88 - 0x0A40)
class AHelaChildActor : public AMarvelCharacterChildActor
{
public:
	float                                         MinSpeed;                                          // 0x0A40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0A44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloakTimeOffset;                                   // 0x0A48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4C[0x4];                                      // 0x0A4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CrowStormChildActor;                               // 0x0A50(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHelaCharacter*                         OwnerCharacter;                                    // 0x0A80(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaChildActor">();
	}
	static class AHelaChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHelaChildActor>();
	}
};
static_assert(alignof(AHelaChildActor) == 0x000008, "Wrong alignment on AHelaChildActor");
static_assert(sizeof(AHelaChildActor) == 0x000A88, "Wrong size on AHelaChildActor");
static_assert(offsetof(AHelaChildActor, MinSpeed) == 0x000A40, "Member 'AHelaChildActor::MinSpeed' has a wrong offset!");
static_assert(offsetof(AHelaChildActor, MaxSpeed) == 0x000A44, "Member 'AHelaChildActor::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AHelaChildActor, CloakTimeOffset) == 0x000A48, "Member 'AHelaChildActor::CloakTimeOffset' has a wrong offset!");
static_assert(offsetof(AHelaChildActor, CrowStormChildActor) == 0x000A50, "Member 'AHelaChildActor::CrowStormChildActor' has a wrong offset!");
static_assert(offsetof(AHelaChildActor, OwnerCharacter) == 0x000A80, "Member 'AHelaChildActor::OwnerCharacter' has a wrong offset!");

// Class Hero_1024.HelaCharacter
// 0x0040 (0x1800 - 0x17C0)
class AHelaCharacter : public AMarvelBaseCharacter
{
public:
	class ASplineActor*                           StingActor;                                        // 0x17B8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSculptAssetLoaded;                               // 0x17C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 CrowSummoner;                                      // 0x17D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHelaMoveLogicBaseComponent*            HelaMoveLogic;                                     // 0x17D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASplineActor>               StingActorClass;                                   // 0x17E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TransitionDuration;                                // 0x17E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17EC[0x14];                                    // 0x17EC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelaySpawnPassiveAbilityDamageScope(class UGameplayAbility* InAbility, struct FMarvelAbilitySocketInfo* SocketInfo, float DelayTime, int32 ScopeId);
	void OnDeathDeal(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnRebornDeal(class AActor* InActor, const struct FCharacterRebornParam& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaCharacter">();
	}
	static class AHelaCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHelaCharacter>();
	}
};
static_assert(alignof(AHelaCharacter) == 0x000010, "Wrong alignment on AHelaCharacter");
static_assert(sizeof(AHelaCharacter) == 0x001800, "Wrong size on AHelaCharacter");
static_assert(offsetof(AHelaCharacter, StingActor) == 0x0017B8, "Member 'AHelaCharacter::StingActor' has a wrong offset!");
static_assert(offsetof(AHelaCharacter, OnSculptAssetLoaded) == 0x0017C0, "Member 'AHelaCharacter::OnSculptAssetLoaded' has a wrong offset!");
static_assert(offsetof(AHelaCharacter, CrowSummoner) == 0x0017D0, "Member 'AHelaCharacter::CrowSummoner' has a wrong offset!");
static_assert(offsetof(AHelaCharacter, HelaMoveLogic) == 0x0017D8, "Member 'AHelaCharacter::HelaMoveLogic' has a wrong offset!");
static_assert(offsetof(AHelaCharacter, StingActorClass) == 0x0017E0, "Member 'AHelaCharacter::StingActorClass' has a wrong offset!");
static_assert(offsetof(AHelaCharacter, TransitionDuration) == 0x0017E8, "Member 'AHelaCharacter::TransitionDuration' has a wrong offset!");

// Class Hero_1024.HelaMovementComponent
// 0x0000 (0x1AF0 - 0x1AF0)
class UHelaMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaMovementComponent">();
	}
	static class UHelaMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaMovementComponent>();
	}
};
static_assert(alignof(UHelaMovementComponent) == 0x000010, "Wrong alignment on UHelaMovementComponent");
static_assert(sizeof(UHelaMovementComponent) == 0x001AF0, "Wrong size on UHelaMovementComponent");

// Class Hero_1024.HelaShowBPTickComponent
// 0x0008 (0x00F8 - 0x00F0)
class UHelaShowBPTickComponent final : public UActorComponent
{
public:
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaShowBPTickComponent">();
	}
	static class UHelaShowBPTickComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaShowBPTickComponent>();
	}
};
static_assert(alignof(UHelaShowBPTickComponent) == 0x000008, "Wrong alignment on UHelaShowBPTickComponent");
static_assert(sizeof(UHelaShowBPTickComponent) == 0x0000F8, "Wrong size on UHelaShowBPTickComponent");
static_assert(offsetof(UHelaShowBPTickComponent, SkeletalMesh) == 0x0000F0, "Member 'UHelaShowBPTickComponent::SkeletalMesh' has a wrong offset!");

// Class Hero_1024.HelaMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UHelaMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaMoveLogicBaseComponent">();
	}
	static class UHelaMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UHelaMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UHelaMoveLogicBaseComponent");
static_assert(sizeof(UHelaMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UHelaMoveLogicBaseComponent");

// Class Hero_1024.TabData_1024
// 0x0000 (0x0050 - 0x0050)
class UTabData_1024 final : public UHeroTabDataBase
{
public:
	void OnPostApplyDamage(class AActor* InSource, class AActor* InTarget, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1024">();
	}
	static class UTabData_1024* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1024>();
	}
};
static_assert(alignof(UTabData_1024) == 0x000008, "Wrong alignment on UTabData_1024");
static_assert(sizeof(UTabData_1024) == 0x000050, "Wrong size on UTabData_1024");

}

