#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1031

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Hero_1031_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1031.Config_103111
// 0x0030 (0x00C8 - 0x0098)
class UConfig_103111 final : public UMarvelAbilityConfig
{
public:
	float                                         EnterDuration;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedCurve;                                        // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CameraTurnCurve;                                   // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitSkatingTime;                                   // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopSkateInBattleState;                           // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnterSkatingSpeedThreshold;                        // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitSkatingSpeedThreshold;                         // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZVelocity;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103111">();
	}
	static class UConfig_103111* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103111>();
	}
};
static_assert(alignof(UConfig_103111) == 0x000008, "Wrong alignment on UConfig_103111");
static_assert(sizeof(UConfig_103111) == 0x0000C8, "Wrong size on UConfig_103111");
static_assert(offsetof(UConfig_103111, EnterDuration) == 0x000098, "Member 'UConfig_103111::EnterDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103111, SpeedCurve) == 0x0000A0, "Member 'UConfig_103111::SpeedCurve' has a wrong offset!");
static_assert(offsetof(UConfig_103111, CameraTurnCurve) == 0x0000A8, "Member 'UConfig_103111::CameraTurnCurve' has a wrong offset!");
static_assert(offsetof(UConfig_103111, ExitSkatingTime) == 0x0000B0, "Member 'UConfig_103111::ExitSkatingTime' has a wrong offset!");
static_assert(offsetof(UConfig_103111, bStopSkateInBattleState) == 0x0000B4, "Member 'UConfig_103111::bStopSkateInBattleState' has a wrong offset!");
static_assert(offsetof(UConfig_103111, EnterSkatingSpeedThreshold) == 0x0000B8, "Member 'UConfig_103111::EnterSkatingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UConfig_103111, ExitSkatingSpeedThreshold) == 0x0000BC, "Member 'UConfig_103111::ExitSkatingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UConfig_103111, JumpZVelocity) == 0x0000C0, "Member 'UConfig_103111::JumpZVelocity' has a wrong offset!");

// Class Hero_1031.Ability_103111
// 0x0080 (0x25D0 - 0x2550)
class UAbility_103111 : public UMarvelGameplayAbility
{
public:
	class UConfig_103111*                         Config;                                            // 0x2550(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMarvelBaseCharacter*                   Owner;                                             // 0x2558(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelCharacterMovementComponent*      Movement;                                          // 0x2560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelMoveLogicBaseComponent*          MoveLogic;                                         // 0x2568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WalkingToSkatingTime;                              // 0x2570(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InSkatingTime;                                     // 0x2574(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           SkatingToWalkingTimerHandle;                       // 0x2578(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CachedWalkSpeed;                                   // 0x2590(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CachedJumpZVelocity;                               // 0x2594(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CachedTurnScale;                                   // 0x2598(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           TagSkating;                                        // 0x259C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           TagSkateEnd;                                       // 0x25A8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESkatingState                                 SkatingState;                                      // 0x25B4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInFallingWhileSkating;                            // 0x25B5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNeedEnterSkateQuickly;                            // 0x25B6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOnPressFwdKey;                                    // 0x25B7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFirstSkate;                                     // 0x25B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25B9[0x7];                                     // 0x25B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilitySystemCom*                Abs;                                               // 0x25C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelAttributeSet*                    AttributeSet;                                      // 0x25C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CheckVelocityForSkate();
	void OnPressFwdKey(float TimeWaited);
	void OnReleaseFwdKey(float TimeWaited);
	void OnStopSkating(float TimeWaited);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103111">();
	}
	static class UAbility_103111* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103111>();
	}
};
static_assert(alignof(UAbility_103111) == 0x000008, "Wrong alignment on UAbility_103111");
static_assert(sizeof(UAbility_103111) == 0x0025D0, "Wrong size on UAbility_103111");
static_assert(offsetof(UAbility_103111, Config) == 0x002550, "Member 'UAbility_103111::Config' has a wrong offset!");
static_assert(offsetof(UAbility_103111, Owner) == 0x002558, "Member 'UAbility_103111::Owner' has a wrong offset!");
static_assert(offsetof(UAbility_103111, Movement) == 0x002560, "Member 'UAbility_103111::Movement' has a wrong offset!");
static_assert(offsetof(UAbility_103111, MoveLogic) == 0x002568, "Member 'UAbility_103111::MoveLogic' has a wrong offset!");
static_assert(offsetof(UAbility_103111, WalkingToSkatingTime) == 0x002570, "Member 'UAbility_103111::WalkingToSkatingTime' has a wrong offset!");
static_assert(offsetof(UAbility_103111, InSkatingTime) == 0x002574, "Member 'UAbility_103111::InSkatingTime' has a wrong offset!");
static_assert(offsetof(UAbility_103111, SkatingToWalkingTimerHandle) == 0x002578, "Member 'UAbility_103111::SkatingToWalkingTimerHandle' has a wrong offset!");
static_assert(offsetof(UAbility_103111, CachedWalkSpeed) == 0x002590, "Member 'UAbility_103111::CachedWalkSpeed' has a wrong offset!");
static_assert(offsetof(UAbility_103111, CachedJumpZVelocity) == 0x002594, "Member 'UAbility_103111::CachedJumpZVelocity' has a wrong offset!");
static_assert(offsetof(UAbility_103111, CachedTurnScale) == 0x002598, "Member 'UAbility_103111::CachedTurnScale' has a wrong offset!");
static_assert(offsetof(UAbility_103111, TagSkating) == 0x00259C, "Member 'UAbility_103111::TagSkating' has a wrong offset!");
static_assert(offsetof(UAbility_103111, TagSkateEnd) == 0x0025A8, "Member 'UAbility_103111::TagSkateEnd' has a wrong offset!");
static_assert(offsetof(UAbility_103111, SkatingState) == 0x0025B4, "Member 'UAbility_103111::SkatingState' has a wrong offset!");
static_assert(offsetof(UAbility_103111, bInFallingWhileSkating) == 0x0025B5, "Member 'UAbility_103111::bInFallingWhileSkating' has a wrong offset!");
static_assert(offsetof(UAbility_103111, bNeedEnterSkateQuickly) == 0x0025B6, "Member 'UAbility_103111::bNeedEnterSkateQuickly' has a wrong offset!");
static_assert(offsetof(UAbility_103111, bOnPressFwdKey) == 0x0025B7, "Member 'UAbility_103111::bOnPressFwdKey' has a wrong offset!");
static_assert(offsetof(UAbility_103111, bIsFirstSkate) == 0x0025B8, "Member 'UAbility_103111::bIsFirstSkate' has a wrong offset!");
static_assert(offsetof(UAbility_103111, Abs) == 0x0025C0, "Member 'UAbility_103111::Abs' has a wrong offset!");
static_assert(offsetof(UAbility_103111, AttributeSet) == 0x0025C8, "Member 'UAbility_103111::AttributeSet' has a wrong offset!");

// Class Hero_1031.Cue_Instant_HitImpact_10313101
// 0x0008 (0x0508 - 0x0500)
class UCue_Instant_HitImpact_10313101 final : public UMarvelCueNotify_InstantHitImpact
{
public:
	int32                                         HitAllyAudioID;                                    // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitOtherAudioID;                                   // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Instant_HitImpact_10313101">();
	}
	static class UCue_Instant_HitImpact_10313101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Instant_HitImpact_10313101>();
	}
};
static_assert(alignof(UCue_Instant_HitImpact_10313101) == 0x000008, "Wrong alignment on UCue_Instant_HitImpact_10313101");
static_assert(sizeof(UCue_Instant_HitImpact_10313101) == 0x000508, "Wrong size on UCue_Instant_HitImpact_10313101");
static_assert(offsetof(UCue_Instant_HitImpact_10313101, HitAllyAudioID) == 0x000500, "Member 'UCue_Instant_HitImpact_10313101::HitAllyAudioID' has a wrong offset!");
static_assert(offsetof(UCue_Instant_HitImpact_10313101, HitOtherAudioID) == 0x000504, "Member 'UCue_Instant_HitImpact_10313101::HitOtherAudioID' has a wrong offset!");

// Class Hero_1031.Cue_Ability_Loop_10315101
// 0x0048 (0x0E48 - 0x0E00)
class ACue_Ability_Loop_10315101 final : public AMarvelCueNotify_Ability
{
public:
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x0E00(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     RayFxComp;                                         // 0x0E08(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         RayFx;                                             // 0x0E10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RayLocSocketName;                                  // 0x0E18(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetLength;                                      // 0x0E24(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerExecRate;                                     // 0x0E28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2C[0x4];                                      // 0x0E2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x0E30(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdateRayFx();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10315101">();
	}
	static class ACue_Ability_Loop_10315101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10315101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10315101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10315101");
static_assert(sizeof(ACue_Ability_Loop_10315101) == 0x000E48, "Wrong size on ACue_Ability_Loop_10315101");
static_assert(offsetof(ACue_Ability_Loop_10315101, OwnerChar) == 0x000E00, "Member 'ACue_Ability_Loop_10315101::OwnerChar' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, RayFxComp) == 0x000E08, "Member 'ACue_Ability_Loop_10315101::RayFxComp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, RayFx) == 0x000E10, "Member 'ACue_Ability_Loop_10315101::RayFx' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, RayLocSocketName) == 0x000E18, "Member 'ACue_Ability_Loop_10315101::RayLocSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, OffsetLength) == 0x000E24, "Member 'ACue_Ability_Loop_10315101::OffsetLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, TimerExecRate) == 0x000E28, "Member 'ACue_Ability_Loop_10315101::TimerExecRate' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, LoopTimerHandle) == 0x000E30, "Member 'ACue_Ability_Loop_10315101::LoopTimerHandle' has a wrong offset!");

// Class Hero_1031.Cue_Buff_10315102
// 0x0390 (0x1378 - 0x0FE8)
class ACue_Buff_10315102 final : public AMarvelCueNotify_Buff
{
public:
	class FName                                   SwitchParamName;                                   // 0x0FE8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF4[0x4];                                      // 0x0FF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UCurveFloat*>         ParamCurves;                                       // 0x0FF8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   DirParamName;                                      // 0x1048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1054[0x4];                                     // 0x1054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DirCoefficient;                                    // 0x1058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultParamValue;                                 // 0x1070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoundsTopParmName;                                 // 0x1074(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoundsBottomParmName;                              // 0x1080(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108C[0x4];                                     // 0x108C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UMeshComponent>>       HandleClasses;                                     // 0x1090(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bNeedDisappearEffect;                              // 0x10E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E1[0x3];                                     // 0x10E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           BlockUpdateTag;                                    // 0x10E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomAutoDestroyDelay;                            // 0x10F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisappearCurveTime;                                // 0x10F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         IceThornFx;                                        // 0x10F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IceThornFxAttachSocket;                            // 0x1100(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IceThornFxDirParam;                                // 0x110C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeInterval;                                      // 0x1118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111C[0x4];                                     // 0x111C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueParameters                 CacheCueParam;                                     // 0x1120(0x01B8)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ACharacter*                             OwnerChar;                                         // 0x12D8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CueBeginTime;                                      // 0x12E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChargeTime;                                        // 0x12E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     IceThornComp;                                      // 0x12E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuffTotalTime;                                     // 0x12F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F4[0x4];                                     // 0x12F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x12F8(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       CachedMaterials;                                   // 0x1310(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 CachedMeshComps;                                   // 0x1320(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FMeshOverlayMaterialHandle             TargetMaterialHandle;                              // 0x1330(0x001C)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_134C[0x2C];                                    // 0x134C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CacheAndHandleTargetMaterial();
	void HandleIceThornFx(bool bReset);
	void HandleMaterialDirParam(bool bReset);
	void HandleMaterialFloatParam(float InChargeTime);
	void HandleUVParam();
	void ListenTargetSculptChanged(bool bListen);
	void OnSculptChanged(int32 SculptID);
	void OnTargetMaterialChanged();
	void ResetTargetMaterial();
	void SwitchMaterial(bool bIsSwitch);
	void UpdateMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10315102">();
	}
	static class ACue_Buff_10315102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10315102>();
	}
};
static_assert(alignof(ACue_Buff_10315102) == 0x000008, "Wrong alignment on ACue_Buff_10315102");
static_assert(sizeof(ACue_Buff_10315102) == 0x001378, "Wrong size on ACue_Buff_10315102");
static_assert(offsetof(ACue_Buff_10315102, SwitchParamName) == 0x000FE8, "Member 'ACue_Buff_10315102::SwitchParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, ParamCurves) == 0x000FF8, "Member 'ACue_Buff_10315102::ParamCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, DirParamName) == 0x001048, "Member 'ACue_Buff_10315102::DirParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, DirCoefficient) == 0x001058, "Member 'ACue_Buff_10315102::DirCoefficient' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, DefaultParamValue) == 0x001070, "Member 'ACue_Buff_10315102::DefaultParamValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, BoundsTopParmName) == 0x001074, "Member 'ACue_Buff_10315102::BoundsTopParmName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, BoundsBottomParmName) == 0x001080, "Member 'ACue_Buff_10315102::BoundsBottomParmName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, HandleClasses) == 0x001090, "Member 'ACue_Buff_10315102::HandleClasses' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, bNeedDisappearEffect) == 0x0010E0, "Member 'ACue_Buff_10315102::bNeedDisappearEffect' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, BlockUpdateTag) == 0x0010E4, "Member 'ACue_Buff_10315102::BlockUpdateTag' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, CustomAutoDestroyDelay) == 0x0010F0, "Member 'ACue_Buff_10315102::CustomAutoDestroyDelay' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, DisappearCurveTime) == 0x0010F4, "Member 'ACue_Buff_10315102::DisappearCurveTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, IceThornFx) == 0x0010F8, "Member 'ACue_Buff_10315102::IceThornFx' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, IceThornFxAttachSocket) == 0x001100, "Member 'ACue_Buff_10315102::IceThornFxAttachSocket' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, IceThornFxDirParam) == 0x00110C, "Member 'ACue_Buff_10315102::IceThornFxDirParam' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, TimeInterval) == 0x001118, "Member 'ACue_Buff_10315102::TimeInterval' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, CacheCueParam) == 0x001120, "Member 'ACue_Buff_10315102::CacheCueParam' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, OwnerChar) == 0x0012D8, "Member 'ACue_Buff_10315102::OwnerChar' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, CueBeginTime) == 0x0012E0, "Member 'ACue_Buff_10315102::CueBeginTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, ChargeTime) == 0x0012E4, "Member 'ACue_Buff_10315102::ChargeTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, IceThornComp) == 0x0012E8, "Member 'ACue_Buff_10315102::IceThornComp' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, BuffTotalTime) == 0x0012F0, "Member 'ACue_Buff_10315102::BuffTotalTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, LoopTimerHandle) == 0x0012F8, "Member 'ACue_Buff_10315102::LoopTimerHandle' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, CachedMaterials) == 0x001310, "Member 'ACue_Buff_10315102::CachedMaterials' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, CachedMeshComps) == 0x001320, "Member 'ACue_Buff_10315102::CachedMeshComps' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, TargetMaterialHandle) == 0x001330, "Member 'ACue_Buff_10315102::TargetMaterialHandle' has a wrong offset!");

// Class Hero_1031.Cue_Buff_10316101
// 0x0078 (0x1060 - 0x0FE8)
class ACue_Buff_10316101 final : public AMarvelCueNotify_Buff
{
public:
	class FName                                   SwitchParamName;                                   // 0x0FE8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialParamName;                                 // 0x0FF4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultParamValue;                                 // 0x1000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1004[0x4];                                     // 0x1004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ParamCurve;                                        // 0x1008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeInterval;                                      // 0x1010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1014[0x4];                                     // 0x1014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x1018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChargeTime;                                        // 0x1020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1024[0x4];                                     // 0x1024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x1028(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMeshOverlayMaterialHandle             TargetMaterialHandle;                              // 0x1040(0x001C)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_105C[0x4];                                     // 0x105C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMaterial(float InChargeTime);
	bool IsViewingTarget(class AActor* Target);
	void SwitchMaterial(bool bIsSwitch);
	void UpdateMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10316101">();
	}
	static class ACue_Buff_10316101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10316101>();
	}
};
static_assert(alignof(ACue_Buff_10316101) == 0x000008, "Wrong alignment on ACue_Buff_10316101");
static_assert(sizeof(ACue_Buff_10316101) == 0x001060, "Wrong size on ACue_Buff_10316101");
static_assert(offsetof(ACue_Buff_10316101, SwitchParamName) == 0x000FE8, "Member 'ACue_Buff_10316101::SwitchParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, MaterialParamName) == 0x000FF4, "Member 'ACue_Buff_10316101::MaterialParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, DefaultParamValue) == 0x001000, "Member 'ACue_Buff_10316101::DefaultParamValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, ParamCurve) == 0x001008, "Member 'ACue_Buff_10316101::ParamCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, TimeInterval) == 0x001010, "Member 'ACue_Buff_10316101::TimeInterval' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, OwnerChar) == 0x001018, "Member 'ACue_Buff_10316101::OwnerChar' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, ChargeTime) == 0x001020, "Member 'ACue_Buff_10316101::ChargeTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, LoopTimerHandle) == 0x001028, "Member 'ACue_Buff_10316101::LoopTimerHandle' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, TargetMaterialHandle) == 0x001040, "Member 'ACue_Buff_10316101::TargetMaterialHandle' has a wrong offset!");

// Class Hero_1031.Scope_10314201
// 0x0020 (0x16E0 - 0x16C0)
class AScope_10314201 final : public AMarvelAbilityTargetActor_Scope
{
public:
	bool                                          bHasCachedHitRes;                                  // 0x16C0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C1[0x7];                                     // 0x16C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     CachedHitResults;                                  // 0x16C8(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D8[0x8];                                     // 0x16D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10314201">();
	}
	static class AScope_10314201* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10314201>();
	}
};
static_assert(alignof(AScope_10314201) == 0x000010, "Wrong alignment on AScope_10314201");
static_assert(sizeof(AScope_10314201) == 0x0016E0, "Wrong size on AScope_10314201");
static_assert(offsetof(AScope_10314201, bHasCachedHitRes) == 0x0016C0, "Member 'AScope_10314201::bHasCachedHitRes' has a wrong offset!");
static_assert(offsetof(AScope_10314201, CachedHitResults) == 0x0016C8, "Member 'AScope_10314201::CachedHitResults' has a wrong offset!");

// Class Hero_1031.TraceComponent_10314201
// 0x0000 (0x16B0 - 0x16B0)
class UTraceComponent_10314201 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10314201">();
	}
	static class UTraceComponent_10314201* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10314201>();
	}
};
static_assert(alignof(UTraceComponent_10314201) == 0x000010, "Wrong alignment on UTraceComponent_10314201");
static_assert(sizeof(UTraceComponent_10314201) == 0x0016B0, "Wrong size on UTraceComponent_10314201");

// Class Hero_1031.Cue_Scope_Loop_10314201
// 0x0078 (0x0D98 - 0x0D20)
class ACue_Scope_Loop_10314201 final : public AMarvelCueNotify_Scope
{
public:
	class UFXSystemAsset*                         LaserFX;                                           // 0x0D20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FXStartSocketName;                                 // 0x0D28(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartOuterLength;                                  // 0x0D34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FXLengthParam;                                     // 0x0D38(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LunaLaserAudioID;                                  // 0x0D44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             IgnoreClasses;                                     // 0x0D48(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AScope_10314201*                        OwnerScope;                                        // 0x0D58(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0D60(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FXStart;                                           // 0x0D68(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FXEnd;                                             // 0x0D80(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleLaserFX();
	void OnScopeTraceHitRes(const TArray<struct FHitResult>& HitResults);
	void SpawnLaserFX(const struct FVector& InFXStart, const struct FVector& InFXEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10314201">();
	}
	static class ACue_Scope_Loop_10314201* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10314201>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10314201) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10314201");
static_assert(sizeof(ACue_Scope_Loop_10314201) == 0x000D98, "Wrong size on ACue_Scope_Loop_10314201");
static_assert(offsetof(ACue_Scope_Loop_10314201, LaserFX) == 0x000D20, "Member 'ACue_Scope_Loop_10314201::LaserFX' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, FXStartSocketName) == 0x000D28, "Member 'ACue_Scope_Loop_10314201::FXStartSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, StartOuterLength) == 0x000D34, "Member 'ACue_Scope_Loop_10314201::StartOuterLength' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, FXLengthParam) == 0x000D38, "Member 'ACue_Scope_Loop_10314201::FXLengthParam' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, LunaLaserAudioID) == 0x000D44, "Member 'ACue_Scope_Loop_10314201::LunaLaserAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, IgnoreClasses) == 0x000D48, "Member 'ACue_Scope_Loop_10314201::IgnoreClasses' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, OwnerScope) == 0x000D58, "Member 'ACue_Scope_Loop_10314201::OwnerScope' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, OwnerCharacter) == 0x000D60, "Member 'ACue_Scope_Loop_10314201::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, FXStart) == 0x000D68, "Member 'ACue_Scope_Loop_10314201::FXStart' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, FXEnd) == 0x000D80, "Member 'ACue_Scope_Loop_10314201::FXEnd' has a wrong offset!");

// Class Hero_1031.Config_103161
// 0x0010 (0x1100 - 0x10F0)
class UConfig_103161 final : public USelectAbilityConfigBase
{
public:
	int32                                         DefendAbilityID;                                   // 0x10F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F4[0xC];                                     // 0x10F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103161">();
	}
	static class UConfig_103161* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103161>();
	}
};
static_assert(alignof(UConfig_103161) == 0x000010, "Wrong alignment on UConfig_103161");
static_assert(sizeof(UConfig_103161) == 0x001100, "Wrong size on UConfig_103161");
static_assert(offsetof(UConfig_103161, DefendAbilityID) == 0x0010F0, "Member 'UConfig_103161::DefendAbilityID' has a wrong offset!");

// Class Hero_1031.Ability_103161
// 0x0018 (0x25E0 - 0x25C8)
class UAbility_103161 : public UMarvelAbility_SelectTarget
{
public:
	class UAbility_103162*                        DefendAbility;                                     // 0x25C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103161*                         Config;                                            // 0x25D0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ActiveTarget;                                      // 0x25D8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UAbility_103162* GetDefendAbility();
	class AActor* GetTarget();
	bool SetDefendTarget(class AActor* TargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103161">();
	}
	static class UAbility_103161* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103161>();
	}
};
static_assert(alignof(UAbility_103161) == 0x000008, "Wrong alignment on UAbility_103161");
static_assert(sizeof(UAbility_103161) == 0x0025E0, "Wrong size on UAbility_103161");
static_assert(offsetof(UAbility_103161, DefendAbility) == 0x0025C8, "Member 'UAbility_103161::DefendAbility' has a wrong offset!");
static_assert(offsetof(UAbility_103161, Config) == 0x0025D0, "Member 'UAbility_103161::Config' has a wrong offset!");
static_assert(offsetof(UAbility_103161, ActiveTarget) == 0x0025D8, "Member 'UAbility_103161::ActiveTarget' has a wrong offset!");

// Class Hero_1031.Config_103162
// 0x1068 (0x1100 - 0x0098)
class UConfig_103162 final : public UMarvelAbilityConfig
{
public:
	int32                                         DefendBuffID;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveBuffWhenLoseVision;                         // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RemoveBuffTime;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSelectTaskParam                       SelectParam;                                       // 0x00B0(0x1040)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         CheckRate;                                         // 0x10F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F4[0xC];                                     // 0x10F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103162">();
	}
	static class UConfig_103162* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103162>();
	}
};
static_assert(alignof(UConfig_103162) == 0x000010, "Wrong alignment on UConfig_103162");
static_assert(sizeof(UConfig_103162) == 0x001100, "Wrong size on UConfig_103162");
static_assert(offsetof(UConfig_103162, DefendBuffID) == 0x000098, "Member 'UConfig_103162::DefendBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103162, bRemoveBuffWhenLoseVision) == 0x00009C, "Member 'UConfig_103162::bRemoveBuffWhenLoseVision' has a wrong offset!");
static_assert(offsetof(UConfig_103162, RemoveBuffTime) == 0x0000A0, "Member 'UConfig_103162::RemoveBuffTime' has a wrong offset!");
static_assert(offsetof(UConfig_103162, SelectParam) == 0x0000B0, "Member 'UConfig_103162::SelectParam' has a wrong offset!");
static_assert(offsetof(UConfig_103162, CheckRate) == 0x0010F0, "Member 'UConfig_103162::CheckRate' has a wrong offset!");

// Class Hero_1031.Ability_103162
// 0x0FA0 (0x34F0 - 0x2550)
class UAbility_103162 : public UMarvelGameplayAbility
{
public:
	class AActor*                                 DefendTarget;                                      // 0x2550(0x0008)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTargetChanged;                                   // 0x2558(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UConfig_103162*                         Config;                                            // 0x2568(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMarvelAbilityTraceContext             VisibleCheckContext;                               // 0x2570(0x0F30)(BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UAbility_103161*                        SelectAbility;                                     // 0x34A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           OutOfSightTimer;                                   // 0x34A8(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilitySystemComponent*                OwnerASC;                                          // 0x34C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwningChar;                                        // 0x34C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_SelectTarget*        SelectTask;                                        // 0x34D0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x34D8(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeDefendTarget(class AActor* NewTarget);
	void ClearDefendState();
	class ACharacter* GetOwningChar();
	bool IsTargetCanBeSelected(const class AActor* TargetActor);
	void LoopCheck();
	void OnDefendTargetChanged__DelegateSignature(class AActor* TargetActor);
	void OnRep_DefendTarget();
	void SetDefendTarget(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103162">();
	}
	static class UAbility_103162* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103162>();
	}
};
static_assert(alignof(UAbility_103162) == 0x000010, "Wrong alignment on UAbility_103162");
static_assert(sizeof(UAbility_103162) == 0x0034F0, "Wrong size on UAbility_103162");
static_assert(offsetof(UAbility_103162, DefendTarget) == 0x002550, "Member 'UAbility_103162::DefendTarget' has a wrong offset!");
static_assert(offsetof(UAbility_103162, OnTargetChanged) == 0x002558, "Member 'UAbility_103162::OnTargetChanged' has a wrong offset!");
static_assert(offsetof(UAbility_103162, Config) == 0x002568, "Member 'UAbility_103162::Config' has a wrong offset!");
static_assert(offsetof(UAbility_103162, VisibleCheckContext) == 0x002570, "Member 'UAbility_103162::VisibleCheckContext' has a wrong offset!");
static_assert(offsetof(UAbility_103162, SelectAbility) == 0x0034A0, "Member 'UAbility_103162::SelectAbility' has a wrong offset!");
static_assert(offsetof(UAbility_103162, OutOfSightTimer) == 0x0034A8, "Member 'UAbility_103162::OutOfSightTimer' has a wrong offset!");
static_assert(offsetof(UAbility_103162, OwnerASC) == 0x0034C0, "Member 'UAbility_103162::OwnerASC' has a wrong offset!");
static_assert(offsetof(UAbility_103162, OwningChar) == 0x0034C8, "Member 'UAbility_103162::OwningChar' has a wrong offset!");
static_assert(offsetof(UAbility_103162, SelectTask) == 0x0034D0, "Member 'UAbility_103162::SelectTask' has a wrong offset!");
static_assert(offsetof(UAbility_103162, LoopTimerHandle) == 0x0034D8, "Member 'UAbility_103162::LoopTimerHandle' has a wrong offset!");

// Class Hero_1031.DefendTreatAbility
// 0x0050 (0x1138 - 0x10E8)
class UDefendTreatAbility : public UMarvelEffectGameplayAbility
{
public:
	float                                         TreatPercentFromOther;                             // 0x10E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraTreatPercent;                                 // 0x10EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTreatVal;                                       // 0x10F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatSpan;                                          // 0x10F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TreatBuffID;                                       // 0x10F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenLog;                                          // 0x10FC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10FD[0x3];                                     // 0x10FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelBaseGameplayAbility*             DefendSourceAbility;                               // 0x1100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   DefendSource;                                      // 0x1108(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   DefendTarget;                                      // 0x1110(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTreatVal;                                     // 0x1118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111C[0x4];                                     // 0x111C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CleanTimerHandle;                                  // 0x1120(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnApplyTreatToOther(class AActor* Source, class AActor* InTarget, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnTimeSliceArrive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefendTreatAbility">();
	}
	static class UDefendTreatAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefendTreatAbility>();
	}
};
static_assert(alignof(UDefendTreatAbility) == 0x000008, "Wrong alignment on UDefendTreatAbility");
static_assert(sizeof(UDefendTreatAbility) == 0x001138, "Wrong size on UDefendTreatAbility");
static_assert(offsetof(UDefendTreatAbility, TreatPercentFromOther) == 0x0010E8, "Member 'UDefendTreatAbility::TreatPercentFromOther' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, ExtraTreatPercent) == 0x0010EC, "Member 'UDefendTreatAbility::ExtraTreatPercent' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, MaxTreatVal) == 0x0010F0, "Member 'UDefendTreatAbility::MaxTreatVal' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, StatSpan) == 0x0010F4, "Member 'UDefendTreatAbility::StatSpan' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, TreatBuffID) == 0x0010F8, "Member 'UDefendTreatAbility::TreatBuffID' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, bOpenLog) == 0x0010FC, "Member 'UDefendTreatAbility::bOpenLog' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, DefendSourceAbility) == 0x001100, "Member 'UDefendTreatAbility::DefendSourceAbility' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, DefendSource) == 0x001108, "Member 'UDefendTreatAbility::DefendSource' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, DefendTarget) == 0x001110, "Member 'UDefendTreatAbility::DefendTarget' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, TotalTreatVal) == 0x001118, "Member 'UDefendTreatAbility::TotalTreatVal' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, CleanTimerHandle) == 0x001120, "Member 'UDefendTreatAbility::CleanTimerHandle' has a wrong offset!");

// Class Hero_1031.CueDataProcessor_AttachJeff_103192
// 0x0000 (0x00C0 - 0x00C0)
class UCueDataProcessor_AttachJeff_103192 final : public UCueDataProcessor_AttachCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueDataProcessor_AttachJeff_103192">();
	}
	static class UCueDataProcessor_AttachJeff_103192* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCueDataProcessor_AttachJeff_103192>();
	}
};
static_assert(alignof(UCueDataProcessor_AttachJeff_103192) == 0x000008, "Wrong alignment on UCueDataProcessor_AttachJeff_103192");
static_assert(sizeof(UCueDataProcessor_AttachJeff_103192) == 0x0000C0, "Wrong size on UCueDataProcessor_AttachJeff_103192");

// Class Hero_1031.CueNotify_103192
// 0x00B0 (0x1098 - 0x0FE8)
class ACueNotify_103192 final : public AMarvelCueNotify_Buff
{
public:
	struct FPortableMaterialSlotName              JeffMaterialSlotName;                              // 0x0FE8(0x0018)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialParamName;                                 // 0x1000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100C[0x4];                                     // 0x100C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DivingTags;                                        // 0x1010(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_1078[0x20];                                    // 0x1078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnJeffTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueNotify_103192">();
	}
	static class ACueNotify_103192* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueNotify_103192>();
	}
};
static_assert(alignof(ACueNotify_103192) == 0x000008, "Wrong alignment on ACueNotify_103192");
static_assert(sizeof(ACueNotify_103192) == 0x001098, "Wrong size on ACueNotify_103192");
static_assert(offsetof(ACueNotify_103192, JeffMaterialSlotName) == 0x000FE8, "Member 'ACueNotify_103192::JeffMaterialSlotName' has a wrong offset!");
static_assert(offsetof(ACueNotify_103192, MaterialParamName) == 0x001000, "Member 'ACueNotify_103192::MaterialParamName' has a wrong offset!");
static_assert(offsetof(ACueNotify_103192, DivingTags) == 0x001010, "Member 'ACueNotify_103192::DivingTags' has a wrong offset!");

// Class Hero_1031.TraceComponent_10319301
// 0x0000 (0x16B0 - 0x16B0)
class UTraceComponent_10319301 : public UMarvelAgentTraceComponent
{
public:
	class UCurveFloat*                            Curve_Radius;                                      // 0x16A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10319301">();
	}
	static class UTraceComponent_10319301* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10319301>();
	}
};
static_assert(alignof(UTraceComponent_10319301) == 0x000010, "Wrong alignment on UTraceComponent_10319301");
static_assert(sizeof(UTraceComponent_10319301) == 0x0016B0, "Wrong size on UTraceComponent_10319301");
static_assert(offsetof(UTraceComponent_10319301, Curve_Radius) == 0x0016A8, "Member 'UTraceComponent_10319301::Curve_Radius' has a wrong offset!");

// Class Hero_1031.EpicMomentAction_1031
// 0x0050 (0x01C0 - 0x0170)
class UEpicMomentAction_1031 : public UEpicMomentAction_Treat
{
public:
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    IceConfig;                                         // 0x0180(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    IceInterruptConfig;                                // 0x018C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    IceUltimateConfig;                                 // 0x0198(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 IceInterruptAbilities;                             // 0x01A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         IceBuffID;                                         // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QArmorBuffID;                                      // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnActorAbilityCancel(class AActor* Source, int32 AbilityID, const class FString& SessionID, class UMarvelGameplayAbility* SourceAbility);
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1031">();
	}
	static class UEpicMomentAction_1031* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1031>();
	}
};
static_assert(alignof(UEpicMomentAction_1031) == 0x000008, "Wrong alignment on UEpicMomentAction_1031");
static_assert(sizeof(UEpicMomentAction_1031) == 0x0001C0, "Wrong size on UEpicMomentAction_1031");
static_assert(offsetof(UEpicMomentAction_1031, IceConfig) == 0x000180, "Member 'UEpicMomentAction_1031::IceConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1031, IceInterruptConfig) == 0x00018C, "Member 'UEpicMomentAction_1031::IceInterruptConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1031, IceUltimateConfig) == 0x000198, "Member 'UEpicMomentAction_1031::IceUltimateConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1031, IceInterruptAbilities) == 0x0001A8, "Member 'UEpicMomentAction_1031::IceInterruptAbilities' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1031, IceBuffID) == 0x0001B8, "Member 'UEpicMomentAction_1031::IceBuffID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1031, QArmorBuffID) == 0x0001BC, "Member 'UEpicMomentAction_1031::QArmorBuffID' has a wrong offset!");

// Class Hero_1031.LunaSnowAnimInstance
// 0x0040 (0x0940 - 0x0900)
class ULunaSnowAnimInstance final : public UMarvelAnimInstance
{
public:
	float                                         SmoothAccRotateSpeed;                              // 0x0900(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_904[0x4];                                      // 0x0904(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SmoothAcceleration;                                // 0x0908(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMovingOrTurnInPlace;                            // 0x0920(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSkating;                                        // 0x0921(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSkateEnding;                                    // 0x0922(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_923[0x1];                                      // 0x0923(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkatingState;                                      // 0x0924(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_928[0x18];                                     // 0x0928(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeGroundMotionTo103141(bool IsOn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LunaSnowAnimInstance">();
	}
	static class ULunaSnowAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULunaSnowAnimInstance>();
	}
};
static_assert(alignof(ULunaSnowAnimInstance) == 0x000010, "Wrong alignment on ULunaSnowAnimInstance");
static_assert(sizeof(ULunaSnowAnimInstance) == 0x000940, "Wrong size on ULunaSnowAnimInstance");
static_assert(offsetof(ULunaSnowAnimInstance, SmoothAccRotateSpeed) == 0x000900, "Member 'ULunaSnowAnimInstance::SmoothAccRotateSpeed' has a wrong offset!");
static_assert(offsetof(ULunaSnowAnimInstance, SmoothAcceleration) == 0x000908, "Member 'ULunaSnowAnimInstance::SmoothAcceleration' has a wrong offset!");
static_assert(offsetof(ULunaSnowAnimInstance, bIsMovingOrTurnInPlace) == 0x000920, "Member 'ULunaSnowAnimInstance::bIsMovingOrTurnInPlace' has a wrong offset!");
static_assert(offsetof(ULunaSnowAnimInstance, bIsSkating) == 0x000921, "Member 'ULunaSnowAnimInstance::bIsSkating' has a wrong offset!");
static_assert(offsetof(ULunaSnowAnimInstance, bIsSkateEnding) == 0x000922, "Member 'ULunaSnowAnimInstance::bIsSkateEnding' has a wrong offset!");
static_assert(offsetof(ULunaSnowAnimInstance, SkatingState) == 0x000924, "Member 'ULunaSnowAnimInstance::SkatingState' has a wrong offset!");

// Class Hero_1031.LunaSnowCharacter
// 0x0000 (0x17C0 - 0x17C0)
class ALunaSnowCharacter : public AMarvelBaseCharacter
{
public:
	class ULunaSnowMoveLogicBaseComponent*        LunaSnowMoveLogic;                                 // 0x17B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LunaSnowCharacter">();
	}
	static class ALunaSnowCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALunaSnowCharacter>();
	}
};
static_assert(alignof(ALunaSnowCharacter) == 0x000010, "Wrong alignment on ALunaSnowCharacter");
static_assert(sizeof(ALunaSnowCharacter) == 0x0017C0, "Wrong size on ALunaSnowCharacter");
static_assert(offsetof(ALunaSnowCharacter, LunaSnowMoveLogic) == 0x0017B8, "Member 'ALunaSnowCharacter::LunaSnowMoveLogic' has a wrong offset!");

// Class Hero_1031.LunaSnowMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class ULunaSnowMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LunaSnowMoveLogicBaseComponent">();
	}
	static class ULunaSnowMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULunaSnowMoveLogicBaseComponent>();
	}
};
static_assert(alignof(ULunaSnowMoveLogicBaseComponent) == 0x000008, "Wrong alignment on ULunaSnowMoveLogicBaseComponent");
static_assert(sizeof(ULunaSnowMoveLogicBaseComponent) == 0x0003F0, "Wrong size on ULunaSnowMoveLogicBaseComponent");

// Class Hero_1031.LunaSnowMovementComponent
// 0x0000 (0x1AF0 - 0x1AF0)
class ULunaSnowMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LunaSnowMovementComponent">();
	}
	static class ULunaSnowMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULunaSnowMovementComponent>();
	}
};
static_assert(alignof(ULunaSnowMovementComponent) == 0x000010, "Wrong alignment on ULunaSnowMovementComponent");
static_assert(sizeof(ULunaSnowMovementComponent) == 0x001AF0, "Wrong size on ULunaSnowMovementComponent");

// Class Hero_1031.TabData_1031
// 0x0000 (0x0050 - 0x0050)
class UTabData_1031 final : public UHeroTabDataBase
{
public:
	void OnActorTakeHealth(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnBuffAddEvent(class UAbilitySystemComponent* Source, class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& EffectSpecStackHandle, const struct FActiveGameplayEffectHandle& EffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1031">();
	}
	static class UTabData_1031* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1031>();
	}
};
static_assert(alignof(UTabData_1031) == 0x000008, "Wrong alignment on UTabData_1031");
static_assert(sizeof(UTabData_1031) == 0x000050, "Wrong size on UTabData_1031");

}

