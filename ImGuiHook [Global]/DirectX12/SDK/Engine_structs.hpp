#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Engine

#include "Basic.hpp"

#include "AudioExtensions_structs.hpp"
#include "NetCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "IrisStub_structs.hpp"
#include "CoreOnline_structs.hpp"
#include "InputCore_structs.hpp"
#include "Slate_structs.hpp"
#include "Chaos_structs.hpp"


namespace SDK
{

// Enum Engine.ETextGender
// NumValues: 0x0004
enum class ETextGender : uint8
{
	Masculine                                = 0,
	Feminine                                 = 1,
	Neuter                                   = 2,
	ETextGender_MAX                          = 3,
};

// Enum Engine.EFormatArgumentType
// NumValues: 0x0007
enum class EFormatArgumentType : uint8
{
	Int                                      = 0,
	UInt                                     = 1,
	Float                                    = 2,
	Double                                   = 3,
	Text                                     = 4,
	Gender                                   = 5,
	EFormatArgumentType_MAX                  = 6,
};

// Enum Engine.EAnimDataModelNotifyType
// NumValues: 0x0016
enum class EAnimDataModelNotifyType : uint8
{
	BracketOpened                            = 0,
	BracketClosed                            = 1,
	TrackAdded                               = 2,
	TrackChanged                             = 3,
	TrackRemoved                             = 4,
	SequenceLengthChanged                    = 5,
	FrameRateChanged                         = 6,
	CurveAdded                               = 7,
	CurvePreChange                           = 8,
	CurveChanged                             = 9,
	CurveRemoved                             = 10,
	CurveFlagsChanged                        = 11,
	CurveRenamed                             = 12,
	CurveScaled                              = 13,
	CurveColorChanged                        = 14,
	AttributeAdded                           = 15,
	AttributeRemoved                         = 16,
	AttributeChanged                         = 17,
	Populated                                = 18,
	Reset                                    = 19,
	Invalid                                  = 20,
	EAnimDataModelNotifyType_MAX             = 21,
};

// Enum Engine.EMovementMode
// NumValues: 0x000A
enum class EMovementMode : uint8
{
	MOVE_None                                = 0,
	MOVE_Walking                             = 1,
	MOVE_NavWalking                          = 2,
	MOVE_Falling                             = 3,
	MOVE_Swimming                            = 4,
	MOVE_Flying                              = 5,
	MOVE_Custom                              = 6,
	Move_Dashing                             = 7,
	MOVE_MAX                                 = 8,
	EMovementMode_MAX                        = 9,
};

// Enum Engine.EAudioComponentPlayState
// NumValues: 0x0007
enum class EAudioComponentPlayState : uint8
{
	Playing                                  = 0,
	Stopped                                  = 1,
	Paused                                   = 2,
	FadingIn                                 = 3,
	FadingOut                                = 4,
	Count                                    = 5,
	EAudioComponentPlayState_MAX             = 6,
};

// Enum Engine.EDataLayerRuntimeState
// NumValues: 0x0004
enum class EDataLayerRuntimeState : uint8
{
	Unloaded                                 = 0,
	Loaded                                   = 1,
	Activated                                = 2,
	EDataLayerRuntimeState_MAX               = 3,
};

// Enum Engine.EQuartzCommandDelegateSubType
// NumValues: 0x0007
enum class EQuartzCommandDelegateSubType : uint8
{
	CommandOnFailedToQueue                   = 0,
	CommandOnQueued                          = 1,
	CommandOnCanceled                        = 2,
	CommandOnAboutToStart                    = 3,
	CommandOnStarted                         = 4,
	Count                                    = 5,
	EQuartzCommandDelegateSubType_MAX        = 6,
};

// Enum Engine.EQuartzCommandQuantization
// NumValues: 0x0015
enum class EQuartzCommandQuantization : uint8
{
	Bar                                      = 0,
	Beat                                     = 1,
	ThirtySecondNote                         = 2,
	SixteenthNote                            = 3,
	EighthNote                               = 4,
	QuarterNote                              = 5,
	HalfNote                                 = 6,
	WholeNote                                = 7,
	DottedSixteenthNote                      = 8,
	DottedEighthNote                         = 9,
	DottedQuarterNote                        = 10,
	DottedHalfNote                           = 11,
	DottedWholeNote                          = 12,
	SixteenthNoteTriplet                     = 13,
	EighthNoteTriplet                        = 14,
	QuarterNoteTriplet                       = 15,
	HalfNoteTriplet                          = 16,
	Tick                                     = 17,
	Count                                    = 18,
	None                                     = 19,
	EQuartzCommandQuantization_MAX           = 20,
};

// Enum Engine.ECameraShakePlaySpace
// NumValues: 0x0004
enum class ECameraShakePlaySpace : uint8
{
	CameraLocal                              = 0,
	World                                    = 1,
	UserDefined                              = 2,
	ECameraShakePlaySpace_MAX                = 3,
};

// Enum Engine.EPlatformInterfaceDataType
// NumValues: 0x0007
enum class EPlatformInterfaceDataType : uint8
{
	PIDT_None                                = 0,
	PIDT_Int                                 = 1,
	PIDT_Float                               = 2,
	PIDT_String                              = 3,
	PIDT_Object                              = 4,
	PIDT_Custom                              = 5,
	PIDT_MAX                                 = 6,
};

// Enum Engine.EEndPlayReason
// NumValues: 0x0006
enum class EEndPlayReason : uint8
{
	Destroyed                                = 0,
	LevelTransition                          = 1,
	EndPlayInEditor                          = 2,
	RemovedFromWorld                         = 3,
	Quit                                     = 4,
	EEndPlayReason_MAX                       = 5,
};

// Enum Engine.ETickingGroup
// NumValues: 0x000A
enum class ETickingGroup : uint8
{
	TG_BeginTicks                            = 0,
	TG_PrePhysics                            = 1,
	TG_StartPhysics                          = 2,
	TG_DuringPhysics                         = 3,
	TG_EndPhysics                            = 4,
	TG_PostPhysics                           = 5,
	TG_PostUpdateWork                        = 6,
	TG_LastDemotable                         = 7,
	TG_NewlySpawned                          = 8,
	TG_MAX                                   = 9,
};

// Enum Engine.EComponentCreationMethod
// NumValues: 0x0005
enum class EComponentCreationMethod : uint8
{
	Native                                   = 0,
	SimpleConstructionScript                 = 1,
	UserConstructionScript                   = 2,
	Instance                                 = 3,
	EComponentCreationMethod_MAX             = 4,
};

// Enum Engine.ETemperatureSeverityType
// NumValues: 0x0007
enum class ETemperatureSeverityType : uint8
{
	Unknown                                  = 0,
	Good                                     = 1,
	Bad                                      = 2,
	Serious                                  = 3,
	Critical                                 = 4,
	NumSeverities                            = 5,
	ETemperatureSeverityType_MAX             = 6,
};

// Enum Engine.EPlaneConstraintAxisSetting
// NumValues: 0x0006
enum class EPlaneConstraintAxisSetting : uint8
{
	Custom                                   = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	UseGlobalPhysicsSetting                  = 4,
	EPlaneConstraintAxisSetting_MAX          = 5,
};

// Enum Engine.EVisibilityBasedUpdateFlag
// NumValues: 0x0005
enum class EVisibilityBasedUpdateFlag : uint8
{
	AlwaysUpdate                             = 0,
	UpdateOnlyIfRendered                     = 1,
	UpdateOnlyIfRendered_ClientOnly          = 2,
	LowRateUpdateWhenNotRendered_ClientOnly  = 3,
	EVisibilityBasedUpdateFlag_MAX           = 4,
};

// Enum Engine.EInterpToBehaviourType
// NumValues: 0x0005
enum class EInterpToBehaviourType : uint8
{
	OneShot                                  = 0,
	OneShot_Reverse                          = 1,
	Loop_Reset                               = 2,
	PingPong                                 = 3,
	EInterpToBehaviourType_MAX               = 4,
};

// Enum Engine.ETeleportType
// NumValues: 0x0004
enum class ETeleportType : uint8
{
	None                                     = 0,
	TeleportPhysics                          = 1,
	ResetPhysics                             = 2,
	ETeleportType_MAX                        = 3,
};

// Enum Engine.EObjectTypeQuery
// NumValues: 0x0022
enum class EObjectTypeQuery : uint8
{
	ObjectTypeQuery1                         = 0,
	ObjectTypeQuery2                         = 1,
	ObjectTypeQuery3                         = 2,
	ObjectTypeQuery4                         = 3,
	ObjectTypeQuery5                         = 4,
	ObjectTypeQuery6                         = 5,
	ObjectTypeQuery7                         = 6,
	ObjectTypeQuery8                         = 7,
	ObjectTypeQuery9                         = 8,
	ObjectTypeQuery10                        = 9,
	ObjectTypeQuery11                        = 10,
	ObjectTypeQuery12                        = 11,
	ObjectTypeQuery13                        = 12,
	ObjectTypeQuery14                        = 13,
	ObjectTypeQuery15                        = 14,
	ObjectTypeQuery16                        = 15,
	ObjectTypeQuery17                        = 16,
	ObjectTypeQuery18                        = 17,
	ObjectTypeQuery19                        = 18,
	ObjectTypeQuery20                        = 19,
	ObjectTypeQuery21                        = 20,
	ObjectTypeQuery22                        = 21,
	ObjectTypeQuery23                        = 22,
	ObjectTypeQuery24                        = 23,
	ObjectTypeQuery25                        = 24,
	ObjectTypeQuery26                        = 25,
	ObjectTypeQuery27                        = 26,
	ObjectTypeQuery28                        = 27,
	ObjectTypeQuery29                        = 28,
	ObjectTypeQuery30                        = 29,
	ObjectTypeQuery31                        = 30,
	ObjectTypeQuery32                        = 31,
	ObjectTypeQuery_MAX                      = 32,
	EObjectTypeQuery_MAX                     = 33,
};

// Enum Engine.EDrawDebugTrace
// NumValues: 0x0005
enum class EDrawDebugTrace : uint8
{
	None                                     = 0,
	ForOneFrame                              = 1,
	ForDuration                              = 2,
	Persistent                               = 3,
	EDrawDebugTrace_MAX                      = 4,
};

// Enum Engine.ETraceTypeQuery
// NumValues: 0x0022
enum class ETraceTypeQuery : uint8
{
	TraceTypeQuery1                          = 0,
	TraceTypeQuery2                          = 1,
	TraceTypeQuery3                          = 2,
	TraceTypeQuery4                          = 3,
	TraceTypeQuery5                          = 4,
	TraceTypeQuery6                          = 5,
	TraceTypeQuery7                          = 6,
	TraceTypeQuery8                          = 7,
	TraceTypeQuery9                          = 8,
	TraceTypeQuery10                         = 9,
	TraceTypeQuery11                         = 10,
	TraceTypeQuery12                         = 11,
	TraceTypeQuery13                         = 12,
	TraceTypeQuery14                         = 13,
	TraceTypeQuery15                         = 14,
	TraceTypeQuery16                         = 15,
	TraceTypeQuery17                         = 16,
	TraceTypeQuery18                         = 17,
	TraceTypeQuery19                         = 18,
	TraceTypeQuery20                         = 19,
	TraceTypeQuery21                         = 20,
	TraceTypeQuery22                         = 21,
	TraceTypeQuery23                         = 22,
	TraceTypeQuery24                         = 23,
	TraceTypeQuery25                         = 24,
	TraceTypeQuery26                         = 25,
	TraceTypeQuery27                         = 26,
	TraceTypeQuery28                         = 27,
	TraceTypeQuery29                         = 28,
	TraceTypeQuery30                         = 29,
	TraceTypeQuery31                         = 30,
	TraceTypeQuery32                         = 31,
	TraceTypeQuery_MAX                       = 32,
	ETraceTypeQuery_MAX                      = 33,
};

// Enum Engine.EMoveComponentAction
// NumValues: 0x0004
enum class EMoveComponentAction : uint8
{
	Move                                     = 0,
	Stop                                     = 1,
	Return                                   = 2,
	EMoveComponentAction_MAX                 = 3,
};

// Enum Engine.EQuitPreference
// NumValues: 0x0003
enum class EQuitPreference : uint8
{
	Quit                                     = 0,
	Background                               = 1,
	EQuitPreference_MAX                      = 2,
};

// Enum Engine.ETravelFailure
// NumValues: 0x000D
enum class ETravelFailure : uint8
{
	NoLevel                                  = 0,
	LoadMapFailure                           = 1,
	InvalidURL                               = 2,
	PackageMissing                           = 3,
	PackageVersion                           = 4,
	NoDownload                               = 5,
	TravelFailure                            = 6,
	CheatCommands                            = 7,
	PendingNetGameCreateFailure              = 8,
	CloudSaveFailure                         = 9,
	ServerTravelFailure                      = 10,
	ClientTravelFailure                      = 11,
	ETravelFailure_MAX                       = 12,
};

// Enum Engine.EScreenOrientation
// NumValues: 0x000B
enum class EScreenOrientation : uint8
{
	Unknown                                  = 0,
	Portrait                                 = 1,
	PortraitUpsideDown                       = 2,
	LandscapeLeft                            = 3,
	LandscapeRight                           = 4,
	FaceUp                                   = 5,
	FaceDown                                 = 6,
	PortraitSensor                           = 7,
	LandscapeSensor                          = 8,
	FullSensor                               = 9,
	EScreenOrientation_MAX                   = 10,
};

// Enum Engine.EApplicationState
// NumValues: 0x0005
enum class EApplicationState : uint8
{
	Unknown                                  = 0,
	Inactive                                 = 1,
	Background                               = 2,
	Active                                   = 3,
	EApplicationState_MAX                    = 4,
};

// Enum Engine.EComponentPhysicsStateChange
// NumValues: 0x0003
enum class EComponentPhysicsStateChange : uint8
{
	Created                                  = 0,
	Destroyed                                = 1,
	EComponentPhysicsStateChange_MAX         = 2,
};

// Enum Engine.ERelativeTransformSpace
// NumValues: 0x0005
enum class ERelativeTransformSpace : uint8
{
	RTS_World                                = 0,
	RTS_Actor                                = 1,
	RTS_Component                            = 2,
	RTS_ParentBoneSpace                      = 3,
	RTS_MAX                                  = 4,
};

// Enum Engine.EAttachLocation
// NumValues: 0x0005
enum class EAttachLocation : uint8
{
	KeepRelativeOffset                       = 0,
	KeepWorldPosition                        = 1,
	SnapToTarget                             = 2,
	SnapToTargetIncludingScale               = 3,
	EAttachLocation_MAX                      = 4,
};

// Enum Engine.EAttachmentRule
// NumValues: 0x0004
enum class EAttachmentRule : uint8
{
	KeepRelative                             = 0,
	KeepWorld                                = 1,
	SnapToTarget                             = 2,
	EAttachmentRule_MAX                      = 3,
};

// Enum Engine.EDetachmentRule
// NumValues: 0x0003
enum class EDetachmentRule : uint8
{
	KeepRelative                             = 0,
	KeepWorld                                = 1,
	EDetachmentRule_MAX                      = 2,
};

// Enum Engine.EComponentMobility
// NumValues: 0x0004
enum class EComponentMobility : uint8
{
	Static                                   = 0,
	Stationary                               = 1,
	Movable                                  = 2,
	EComponentMobility_MAX                   = 3,
};

// Enum Engine.EDetailMode
// NumValues: 0x0005
enum class EDetailMode : uint8
{
	DM_Low                                   = 0,
	DM_Medium                                = 1,
	DM_High                                  = 2,
	DM_Epic                                  = 3,
	DM_MAX                                   = 4,
};

// Enum Engine.ECollisionEnabled
// NumValues: 0x0007
enum class ECollisionEnabled : uint8
{
	NoCollision                              = 0,
	QueryOnly                                = 1,
	PhysicsOnly                              = 2,
	QueryAndPhysics                          = 3,
	ProbeOnly                                = 4,
	QueryAndProbe                            = 5,
	ECollisionEnabled_MAX                    = 6,
};

// Enum Engine.ECollisionChannel
// NumValues: 0x0022
enum class ECollisionChannel : uint8
{
	ECC_WorldStatic                          = 0,
	ECC_WorldDynamic                         = 1,
	ECC_Pawn                                 = 2,
	ECC_Visibility                           = 3,
	ECC_Camera                               = 4,
	ECC_PhysicsBody                          = 5,
	ECC_Vehicle                              = 6,
	ECC_Destructible                         = 7,
	ECC_EngineTraceChannel1                  = 8,
	ECC_GameTraceChannel1                    = 9,
	ECC_GameTraceChannel2                    = 10,
	ECC_GameTraceChannel3                    = 11,
	ECC_GameTraceChannel4                    = 12,
	ECC_GameTraceChannel5                    = 13,
	ECC_GameTraceChannel6                    = 14,
	ECC_GameTraceChannel7                    = 15,
	ECC_GameTraceChannel8                    = 16,
	ECC_GameTraceChannel9                    = 17,
	ECC_GameTraceChannel10                   = 18,
	ECC_GameTraceChannel11                   = 19,
	ECC_GameTraceChannel12                   = 20,
	ECC_GameTraceChannel13                   = 21,
	ECC_GameTraceChannel14                   = 22,
	ECC_GameTraceChannel15                   = 23,
	ECC_GameTraceChannel16                   = 24,
	ECC_GameTraceChannel17                   = 25,
	ECC_GameTraceChannel18                   = 26,
	ECC_GameTraceChannel19                   = 27,
	ECC_GameTraceChannel20                   = 28,
	ECC_GameTraceChannel21                   = 29,
	ECC_GameTraceChannel22                   = 30,
	ECC_GameTraceChannel23                   = 31,
	ECC_OverlapAll_Deprecated                = 32,
	ECC_MAX                                  = 33,
};

// Enum Engine.ECollisionResponse
// NumValues: 0x0004
enum class ECollisionResponse : uint8
{
	ECR_Ignore                               = 0,
	ECR_Overlap                              = 1,
	ECR_Block                                = 2,
	ECR_MAX                                  = 3,
};

// Enum Engine.EWalkableSlopeBehavior
// NumValues: 0x0006
enum class EWalkableSlopeBehavior : uint8
{
	WalkableSlope_Default                    = 0,
	WalkableSlope_Increase                   = 1,
	WalkableSlope_Decrease                   = 2,
	WalkableSlope_Unwalkable                 = 3,
	WalkableSlope_Max                        = 4,
	WalkableSlope_Max_0                      = 5,
};

// Enum Engine.EHLODLevelExclusion
// NumValues: 0x0009
enum class EHLODLevelExclusion : uint8
{
	HLOD0                                    = 1,
	HLOD1                                    = 2,
	HLOD2                                    = 4,
	HLOD3                                    = 8,
	HLOD4                                    = 16,
	HLOD5                                    = 32,
	HLOD6                                    = 64,
	HLOD7                                    = 128,
	EHLODLevelExclusion_MAX                  = 129,
};

// Enum Engine.EDOFMode
// NumValues: 0x0008
enum class EDOFMode : uint8
{
	Default                                  = 0,
	SixDOF                                   = 1,
	YZPlane                                  = 2,
	XZPlane                                  = 3,
	XYPlane                                  = 4,
	CustomPlane                              = 5,
	None                                     = 6,
	EDOFMode_MAX                             = 7,
};

// Enum Engine.ERendererStencilMask
// NumValues: 0x000B
enum class ERendererStencilMask : uint8
{
	ERSM_Default                             = 0,
	ERSM_255                                 = 1,
	ERSM_1                                   = 2,
	ERSM_2                                   = 3,
	ERSM_4                                   = 4,
	ERSM_8                                   = 5,
	ERSM_16                                  = 6,
	ERSM_32                                  = 7,
	ERSM_64                                  = 8,
	ERSM_128                                 = 9,
	ERSM_MAX                                 = 10,
};

// Enum Engine.ETeamOutlineShowStatus
// NumValues: 0x0004
enum class ETeamOutlineShowStatus : uint32
{
	ETOSS_Unoccluded                         = 0,
	ETOSS_Occluded                           = 1,
	ETOSS_Always                             = 2,
	ETOSS_MAX                                = 3,
};

// Enum Engine.ERecentlyRenderedType
// NumValues: 0x0004
enum class ERecentlyRenderedType : uint8
{
	Default                                  = 0,
	OnScreen                                 = 1,
	OnScreenMainView                         = 2,
	ERecentlyRenderedType_MAX                = 3,
};

// Enum Engine.ERendererCustomDepthPassType
// NumValues: 0x0003
enum class ERendererCustomDepthPassType : uint8
{
	ECDPT_Main                               = 1,
	ECDPT_Secondary                          = 2,
	ECDPT_MAX                                = 3,
};

// Enum Engine.ERayTracingGroupCullingPriority
// NumValues: 0x000A
enum class ERayTracingGroupCullingPriority : uint8
{
	CP_0_NEVER_CULL                          = 0,
	CP_1                                     = 1,
	CP_2                                     = 2,
	CP_3                                     = 3,
	CP_4_DEFAULT                             = 4,
	CP_5                                     = 5,
	CP_6                                     = 6,
	CP_7                                     = 7,
	CP_8_QUICKLY_CULL                        = 8,
	CP_MAX                                   = 9,
};

// Enum Engine.ERuntimeVirtualTextureMainPassType
// NumValues: 0x0004
enum class ERuntimeVirtualTextureMainPassType : uint8
{
	Never                                    = 0,
	Exclusive                                = 1,
	Always                                   = 2,
	ERuntimeVirtualTextureMainPassType_MAX   = 3,
};

// Enum Engine.ECanBeCharacterBase
// NumValues: 0x0004
enum class ECanBeCharacterBase : uint8
{
	ECB_No                                   = 0,
	ECB_Yes                                  = 1,
	ECB_Owner                                = 2,
	ECB_MAX                                  = 3,
};

// Enum Engine.EHasCustomNavigableGeometry
// NumValues: 0x0005
enum class EHasCustomNavigableGeometry : uint8
{
	No                                       = 0,
	Yes                                      = 1,
	EvenIfNotCollidable                      = 2,
	DontExport                               = 3,
	EHasCustomNavigableGeometry_MAX          = 4,
};

// Enum Engine.EShadowCacheInvalidationBehavior
// NumValues: 0x0005
enum class EShadowCacheInvalidationBehavior : uint8
{
	Auto                                     = 0,
	Always                                   = 1,
	Rigid                                    = 2,
	Static                                   = 3,
	EShadowCacheInvalidationBehavior_MAX     = 4,
};

// Enum Engine.EHLODBatchingPolicy
// NumValues: 0x0004
enum class EHLODBatchingPolicy : uint8
{
	None                                     = 0,
	MeshSection                              = 1,
	Instancing                               = 2,
	EHLODBatchingPolicy_MAX                  = 3,
};

// Enum Engine.ELightmapType
// NumValues: 0x0004
enum class ELightmapType : uint8
{
	Default                                  = 0,
	ForceSurface                             = 1,
	ForceVolumetric                          = 2,
	ELightmapType_MAX                        = 3,
};

// Enum Engine.EIndirectLightingCacheQuality
// NumValues: 0x0004
enum class EIndirectLightingCacheQuality : uint8
{
	ILCQ_Off                                 = 0,
	ILCQ_Point                               = 1,
	ILCQ_Volume                              = 2,
	ILCQ_MAX                                 = 3,
};

// Enum Engine.ESceneDepthPriorityGroup
// NumValues: 0x0003
enum class ESceneDepthPriorityGroup : uint8
{
	SDPG_World                               = 0,
	SDPG_Foreground                          = 1,
	SDPG_MAX                                 = 2,
};

// Enum Engine.EMouseLockMode
// NumValues: 0x0005
enum class EMouseLockMode : uint8
{
	DoNotLock                                = 0,
	LockOnCapture                            = 1,
	LockAlways                               = 2,
	LockInFullscreen                         = 3,
	EMouseLockMode_MAX                       = 4,
};

// Enum Engine.EWindowTitleBarMode
// NumValues: 0x0003
enum class EWindowTitleBarMode : uint8
{
	Overlay                                  = 0,
	VerticalBox                              = 1,
	EWindowTitleBarMode_MAX                  = 2,
};

// Enum Engine.AnimationKeyFormat
// NumValues: 0x0004
enum class EAnimationKeyFormat : uint8
{
	AKF_ConstantKeyLerp                      = 0,
	AKF_VariableKeyLerp                      = 1,
	AKF_PerTrackCompression                  = 2,
	AKF_MAX                                  = 3,
};

// Enum Engine.EAnimCurveType
// NumValues: 0x0005
enum class EAnimCurveType : uint8
{
	AttributeCurve                           = 0,
	MaterialCurve                            = 1,
	MorphTargetCurve                         = 2,
	MaxAnimCurveType                         = 3,
	EAnimCurveType_MAX                       = 4,
};

// Enum Engine.EAnimAssetCurveFlags
// NumValues: 0x0009
enum class EAnimAssetCurveFlags : uint8
{
	AACF_NONE                                = 0,
	AACF_DriveMorphTarget_DEPRECATED         = 1,
	AACF_DriveAttribute_DEPRECATED           = 2,
	AACF_Editable                            = 4,
	AACF_DriveMaterial_DEPRECATED            = 8,
	AACF_Metadata                            = 16,
	AACF_DriveTrack                          = 32,
	AACF_Disabled                            = 64,
	AACF_MAX                                 = 65,
};

// Enum Engine.ERawCurveTrackTypes
// NumValues: 0x0004
enum class ERawCurveTrackTypes : uint8
{
	RCT_Float                                = 0,
	RCT_Vector                               = 1,
	RCT_Transform                            = 2,
	RCT_MAX                                  = 3,
};

// Enum Engine.ERootMotionRootLock
// NumValues: 0x0004
enum class ERootMotionRootLock : uint8
{
	RefPose                                  = 0,
	AnimFirstFrame                           = 1,
	Zero                                     = 2,
	ERootMotionRootLock_MAX                  = 3,
};

// Enum Engine.ERootMotionMode
// NumValues: 0x0005
enum class ERootMotionMode : uint8
{
	NoRootMotionExtraction                   = 0,
	IgnoreRootMotion                         = 1,
	RootMotionFromEverything                 = 2,
	RootMotionFromMontagesOnly               = 3,
	ERootMotionMode_MAX                      = 4,
};

// Enum Engine.EAdditiveBasePoseType
// NumValues: 0x0006
enum class EAdditiveBasePoseType : uint8
{
	ABPT_None                                = 0,
	ABPT_RefPose                             = 1,
	ABPT_AnimScaled                          = 2,
	ABPT_AnimFrame                           = 3,
	ABPT_LocalAnimFrame                      = 4,
	ABPT_MAX                                 = 5,
};

// Enum Engine.AnimationCompressionFormat
// NumValues: 0x0008
enum class EAnimationCompressionFormat : uint8
{
	ACF_None                                 = 0,
	ACF_Float96NoW                           = 1,
	ACF_Fixed48NoW                           = 2,
	ACF_IntervalFixed32NoW                   = 3,
	ACF_Fixed32NoW                           = 4,
	ACF_Float32NoW                           = 5,
	ACF_Identity                             = 6,
	ACF_MAX                                  = 7,
};

// Enum Engine.AnimPhysTwistAxis
// NumValues: 0x0004
enum class EAnimPhysTwistAxis : uint8
{
	AxisX                                    = 0,
	AxisY                                    = 1,
	AxisZ                                    = 2,
	AnimPhysTwistAxis_MAX                    = 3,
};

// Enum Engine.AnimPhysCollisionType
// NumValues: 0x0005
enum class EAnimPhysCollisionType : uint8
{
	CoM                                      = 0,
	CustomSphere                             = 1,
	InnerSphere                              = 2,
	OuterSphere                              = 3,
	AnimPhysCollisionType_MAX                = 4,
};

// Enum Engine.ETypeAdvanceAnim
// NumValues: 0x0004
enum class ETypeAdvanceAnim : uint8
{
	ETAA_Default                             = 0,
	ETAA_Finished                            = 1,
	ETAA_Looped                              = 2,
	ETAA_MAX                                 = 3,
};

// Enum Engine.UAnimTimelineVersion
// NumValues: 0x000B
enum class EUAnimTimelineVersion : uint8
{
	Empty                                    = 0,
	Initial                                  = 1,
	Section                                  = 2,
	Object                                   = 3,
	State                                    = 4,
	Durtaion                                 = 5,
	MontagePath                              = 6,
	TriggerTimeOffset                        = 7,
	VersionPlusOne                           = 8,
	LatestVersion                            = 7,
	UAnimTimelineVersion_MAX                 = 9,
};

// Enum Engine.ETimelineStepResult
// NumValues: 0x0004
enum class ETimelineStepResult : uint8
{
	Moved                                    = 0,
	NotMoved                                 = 1,
	InvalidSection                           = 2,
	ETimelineStepResult_MAX                  = 3,
};

// Enum Engine.EBoneAxis
// NumValues: 0x0004
enum class EBoneAxis : uint8
{
	BA_X                                     = 0,
	BA_Y                                     = 1,
	BA_Z                                     = 2,
	BA_MAX                                   = 3,
};

// Enum Engine.EBoneControlSpace
// NumValues: 0x0005
enum class EBoneControlSpace : uint8
{
	BCS_WorldSpace                           = 0,
	BCS_ComponentSpace                       = 1,
	BCS_ParentBoneSpace                      = 2,
	BCS_BoneSpace                            = 3,
	BCS_MAX                                  = 4,
};

// Enum Engine.EBoneRotationSource
// NumValues: 0x0004
enum class EBoneRotationSource : uint8
{
	BRS_KeepComponentSpaceRotation           = 0,
	BRS_KeepLocalSpaceRotation               = 1,
	BRS_CopyFromTarget                       = 2,
	BRS_MAX                                  = 3,
};

// Enum Engine.EMontageNotifyTickType
// NumValues: 0x0003
enum class EMontageNotifyTickType : uint8
{
	Queued                                   = 0,
	BranchingPoint                           = 1,
	EMontageNotifyTickType_MAX               = 2,
};

// Enum Engine.ENotifyFilterType
// NumValues: 0x0004
enum class ENotifyFilterType : uint8
{
	NoFiltering                              = 0,
	LOD                                      = 1,
	OwnerCharacterLOD                        = 2,
	ENotifyFilterType_MAX                    = 3,
};

// Enum Engine.EMarvelNotifyCategory
// NumValues: 0x0003
enum class EMarvelNotifyCategory : uint8
{
	Default                                  = 0,
	Audio                                    = 1,
	EMarvelNotifyCategory_MAX                = 2,
};

// Enum Engine.EAdditiveAnimationType
// NumValues: 0x0004
enum class EAdditiveAnimationType : uint8
{
	AAT_None                                 = 0,
	AAT_LocalSpaceBase                       = 1,
	AAT_RotationOffsetMeshSpace              = 2,
	AAT_MAX                                  = 3,
};

// Enum Engine.ECurveBlendOption
// NumValues: 0x0008
enum class ECurveBlendOption : uint8
{
	Override                                 = 0,
	DoNotOverride                            = 1,
	NormalizeByWeight                        = 2,
	BlendByWeight                            = 3,
	UseBasePose                              = 4,
	UseMaxValue                              = 5,
	UseMinValue                              = 6,
	ECurveBlendOption_MAX                    = 7,
};

// Enum Engine.EAnimInterpolationType
// NumValues: 0x0003
enum class EAnimInterpolationType : uint8
{
	Linear                                   = 0,
	Step                                     = 1,
	EAnimInterpolationType_MAX               = 2,
};

// Enum Engine.EAxisOption
// NumValues: 0x0008
enum class EAxisOption : uint8
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	X_Neg                                    = 3,
	Y_Neg                                    = 4,
	Z_Neg                                    = 5,
	Custom                                   = 6,
	EAxisOption_MAX                          = 7,
};

// Enum Engine.EComponentType
// NumValues: 0x000C
enum class EComponentType : uint8
{
	None                                     = 0,
	TranslationX                             = 1,
	TranslationY                             = 2,
	TranslationZ                             = 3,
	RotationX                                = 4,
	RotationY                                = 5,
	RotationZ                                = 6,
	Scale                                    = 7,
	ScaleX                                   = 8,
	ScaleY                                   = 9,
	ScaleZ                                   = 10,
	EComponentType_MAX                       = 11,
};

// Enum Engine.EExternMontageBlendMode
// NumValues: 0x0004
enum class EExternMontageBlendMode : uint8
{
	None                                     = 0,
	UseNoShortestRotateInterpolation         = 1,
	UseSourceRotate                          = 2,
	EExternMontageBlendMode_MAX              = 3,
};

// Enum Engine.EAudioOutputTarget
// NumValues: 0x0004
enum class EAudioOutputTarget : uint8
{
	Speaker                                  = 0,
	Controller                               = 1,
	ControllerFallbackToSpeaker              = 2,
	EAudioOutputTarget_MAX                   = 3,
};

// Enum Engine.EBlendableLocation
// NumValues: 0x0009
enum class EBlendableLocation : uint8
{
	BL_AfterTonemapping                      = 0,
	BL_BeforeTonemapping                     = 1,
	BL_BeforeTranslucency                    = 2,
	BL_ReplacingTonemapper                   = 3,
	BL_SSRInput                              = 4,
	BL_DOFMask                               = 5,
	BL_AfterLighting                         = 6,
	BL_AfterDof                              = 7,
	BL_MAX                                   = 8,
};

// Enum Engine.EBlendSpaceAxis
// NumValues: 0x0004
enum class EBlendSpaceAxis : uint8
{
	BSA_None                                 = 0,
	BSA_X                                    = 1,
	BSA_Y                                    = 2,
	BSA_MAX                                  = 3,
};

// Enum Engine.EPreferredTriangulationDirection
// NumValues: 0x0004
enum class EPreferredTriangulationDirection : uint8
{
	None                                     = 0,
	Tangential                               = 1,
	Radial                                   = 2,
	EPreferredTriangulationDirection_MAX     = 3,
};

// Enum Engine.EBlendSpacePerBoneBlendMode
// NumValues: 0x0003
enum class EBlendSpacePerBoneBlendMode : uint8
{
	ManualPerBoneOverride                    = 0,
	BlendProfile                             = 1,
	EBlendSpacePerBoneBlendMode_MAX          = 2,
};

// Enum Engine.ENotifyTriggerMode
// NumValues: 0x0004
enum class ENotifyTriggerMode : uint8
{
	AllAnimations                            = 0,
	HighestWeightedAnimation                 = 1,
	None                                     = 2,
	ENotifyTriggerMode_MAX                   = 3,
};

// Enum Engine.EBlueprintStatus
// NumValues: 0x0007
enum class EBlueprintStatus : uint8
{
	BS_Unknown                               = 0,
	BS_Dirty                                 = 1,
	BS_Error                                 = 2,
	BS_UpToDate                              = 3,
	BS_BeingCreated                          = 4,
	BS_UpToDateWithWarnings                  = 5,
	BS_MAX                                   = 6,
};

// Enum Engine.EBlueprintType
// NumValues: 0x0007
enum class EBlueprintType : uint8
{
	BPTYPE_Normal                            = 0,
	BPTYPE_Const                             = 1,
	BPTYPE_MacroLibrary                      = 2,
	BPTYPE_Interface                         = 3,
	BPTYPE_LevelScript                       = 4,
	BPTYPE_FunctionLibrary                   = 5,
	BPTYPE_MAX                               = 6,
};

// Enum Engine.EBlueprintCompileMode
// NumValues: 0x0004
enum class EBlueprintCompileMode : uint8
{
	Default                                  = 0,
	Development                              = 1,
	FinalRelease                             = 2,
	EBlueprintCompileMode_MAX                = 3,
};

// Enum Engine.EBlueprintNativizationFlag
// NumValues: 0x0004
enum class EBlueprintNativizationFlag : uint8
{
	Disabled                                 = 0,
	Dependency                               = 1,
	ExplicitlyEnabled                        = 2,
	EBlueprintNativizationFlag_MAX           = 3,
};

// Enum Engine.EShouldCookBlueprintPropertyGuids
// NumValues: 0x0004
enum class EShouldCookBlueprintPropertyGuids : uint8
{
	No                                       = 0,
	Yes                                      = 1,
	Inherit                                  = 2,
	EShouldCookBlueprintPropertyGuids_MAX    = 3,
};

// Enum Engine.ECsgOper
// NumValues: 0x0007
enum class ECsgOper : uint8
{
	CSG_Active                               = 0,
	CSG_Add                                  = 1,
	CSG_Subtract                             = 2,
	CSG_Intersect                            = 3,
	CSG_Deintersect                          = 4,
	CSG_None                                 = 5,
	CSG_MAX                                  = 6,
};

// Enum Engine.EBrushType
// NumValues: 0x0004
enum class EBrushType : uint8
{
	Brush_Default                            = 0,
	Brush_Add                                = 1,
	Brush_Subtract                           = 2,
	Brush_MAX                                = 3,
};

// Enum Engine.ECameraProjectionMode
// NumValues: 0x0003
enum class ECameraProjectionMode : uint8
{
	Perspective                              = 0,
	Orthographic                             = 1,
	ECameraProjectionMode_MAX                = 2,
};

// Enum Engine.ECloudStorageDelegate
// NumValues: 0x0008
enum class ECloudStorageDelegate : uint8
{
	CSD_KeyValueReadComplete                 = 0,
	CSD_KeyValueWriteComplete                = 1,
	CSD_ValueChanged                         = 2,
	CSD_DocumentQueryComplete                = 3,
	CSD_DocumentReadComplete                 = 4,
	CSD_DocumentWriteComplete                = 5,
	CSD_DocumentConflictDetected             = 6,
	CSD_MAX                                  = 7,
};

// Enum Engine.EContentBundleClientState
// NumValues: 0x0006
enum class EContentBundleClientState : uint8
{
	Unregistered                             = 0,
	Registered                               = 1,
	ContentInjectionRequested                = 2,
	ContentRemovalRequested                  = 3,
	RegistrationFailed                       = 4,
	EContentBundleClientState_MAX            = 5,
};

// Enum Engine.EWorldContentState
// NumValues: 0x0003
enum class EWorldContentState : uint8
{
	NoContent                                = 0,
	ContentBundleInjected                    = 1,
	EWorldContentState_MAX                   = 2,
};

// Enum Engine.EContentBundleStatus
// NumValues: 0x0006
enum class EContentBundleStatus : uint64
{
	Registered                               = 0,
	ReadyToInject                            = 1,
	FailedToInject                           = 2,
	ContentInjected                          = 3,
	Unknown                                  = 18446744073709551615,
	EContentBundleStatus_MAX                 = 4,
};

// Enum Engine.ECustomAttributeBlendType
// NumValues: 0x0003
enum class ECustomAttributeBlendType : uint8
{
	Override                                 = 0,
	Blend                                    = 1,
	ECustomAttributeBlendType_MAX            = 2,
};

// Enum Engine.EDataLayerType
// NumValues: 0x0005
enum class EDataLayerType : uint8
{
	Runtime                                  = 0,
	Editor                                   = 1,
	Unknown                                  = 2,
	Size                                     = 3,
	EDataLayerType_MAX                       = 4,
};

// Enum Engine.EDataTableExportFlags
// NumValues: 0x0007
enum class EDataTableExportFlags : uint8
{
	None                                     = 0,
	UseJsonObjectsForStructs                 = 1,
	UseSimpleText                            = 2,
	UseForMos                                = 4,
	UseForRowMetaInfo                        = 8,
	UseForColumnMetaInfo                     = 16,
	EDataTableExportFlags_MAX                = 17,
};

// Enum Engine.DistributionParamMode
// NumValues: 0x0004
enum class EDistributionParamMode : uint8
{
	DPM_Normal                               = 0,
	DPM_Abs                                  = 1,
	DPM_Direct                               = 2,
	DPM_MAX                                  = 3,
};

// Enum Engine.EDistributionVectorLockFlags
// NumValues: 0x0006
enum class EDistributionVectorLockFlags : uint8
{
	EDVLF_None                               = 0,
	EDVLF_XY                                 = 1,
	EDVLF_XZ                                 = 2,
	EDVLF_YZ                                 = 3,
	EDVLF_XYZ                                = 4,
	EDVLF_MAX                                = 5,
};

// Enum Engine.EDistributionVectorMirrorFlags
// NumValues: 0x0004
enum class EDistributionVectorMirrorFlags : uint8
{
	EDVMF_Same                               = 0,
	EDVMF_Different                          = 1,
	EDVMF_Mirror                             = 2,
	EDVMF_MAX                                = 3,
};

// Enum Engine.EEdGraphPinDirection
// NumValues: 0x0003
enum class EEdGraphPinDirection : uint8
{
	EGPD_Input                               = 0,
	EGPD_Output                              = 1,
	EGPD_MAX                                 = 2,
};

// Enum Engine.EPinContainerType
// NumValues: 0x0005
enum class EPinContainerType : uint8
{
	None                                     = 0,
	Array                                    = 1,
	Set                                      = 2,
	Map                                      = 3,
	EPinContainerType_MAX                    = 4,
};

// Enum Engine.ENodeTitleType
// NumValues: 0x0006
enum class ENodeTitleType : uint8
{
	FullTitle                                = 0,
	ListView                                 = 1,
	EditableTitle                            = 2,
	MenuTitle                                = 3,
	MAX_TitleTypes                           = 4,
	ENodeTitleType_MAX                       = 5,
};

// Enum Engine.ENodeAdvancedPins
// NumValues: 0x0004
enum class ENodeAdvancedPins : uint8
{
	NoPins                                   = 0,
	Shown                                    = 1,
	Hidden                                   = 2,
	ENodeAdvancedPins_MAX                    = 3,
};

// Enum Engine.ENodeEnabledState
// NumValues: 0x0004
enum class ENodeEnabledState : uint8
{
	Enabled                                  = 0,
	Disabled                                 = 1,
	DevelopmentOnly                          = 2,
	ENodeEnabledState_MAX                    = 3,
};

// Enum Engine.EBlueprintPinStyleType
// NumValues: 0x0003
enum class EBlueprintPinStyleType : uint8
{
	BPST_Original                            = 0,
	BPST_VariantA                            = 1,
	BPST_MAX                                 = 2,
};

// Enum Engine.EGraphType
// NumValues: 0x0006
enum class EGraphType : uint8
{
	GT_Function                              = 0,
	GT_Ubergraph                             = 1,
	GT_Macro                                 = 2,
	GT_Animation                             = 3,
	GT_StateMachine                          = 4,
	GT_MAX                                   = 5,
};

// Enum Engine.ECanCreateConnectionResponse
// NumValues: 0x0008
enum class ECanCreateConnectionResponse : uint8
{
	CONNECT_RESPONSE_MAKE                    = 0,
	CONNECT_RESPONSE_DISALLOW                = 1,
	CONNECT_RESPONSE_BREAK_OTHERS_A          = 2,
	CONNECT_RESPONSE_BREAK_OTHERS_B          = 3,
	CONNECT_RESPONSE_BREAK_OTHERS_AB         = 4,
	CONNECT_RESPONSE_MAKE_WITH_CONVERSION_NODE = 5,
	CONNECT_RESPONSE_MAKE_WITH_PROMOTION     = 6,
	CONNECT_RESPONSE_MAX                     = 7,
};

// Enum Engine.EFullyLoadPackageType
// NumValues: 0x0006
enum class EFullyLoadPackageType : uint8
{
	FULLYLOAD_Map                            = 0,
	FULLYLOAD_Game_PreLoadClass              = 1,
	FULLYLOAD_Game_PostLoadClass             = 2,
	FULLYLOAD_Always                         = 3,
	FULLYLOAD_Mutator                        = 4,
	FULLYLOAD_MAX                            = 5,
};

// Enum Engine.ETransitionType
// NumValues: 0x0008
enum class ETransitionType : uint8
{
	None                                     = 0,
	Paused                                   = 1,
	Loading                                  = 2,
	Saving                                   = 3,
	Connecting                               = 4,
	Precaching                               = 5,
	WaitingToConnect                         = 6,
	MAX                                      = 7,
};

// Enum Engine.EInputEvent
// NumValues: 0x0006
enum class EInputEvent : uint8
{
	IE_Pressed                               = 0,
	IE_Released                              = 1,
	IE_Repeat                                = 2,
	IE_DoubleClick                           = 3,
	IE_Axis                                  = 4,
	IE_MAX                                   = 5,
};

// Enum Engine.EMouseCaptureMode
// NumValues: 0x0006
enum class EMouseCaptureMode : uint8
{
	NoCapture                                = 0,
	CapturePermanently                       = 1,
	CapturePermanently_IncludingInitialMouseDown = 2,
	CaptureDuringMouseDown                   = 3,
	CaptureDuringRightMouseDown              = 4,
	EMouseCaptureMode_MAX                    = 5,
};

// Enum Engine.ENetworkLagState
// NumValues: 0x0003
enum class ENetworkLagState : uint8
{
	NotLagging                               = 0,
	Lagging                                  = 1,
	ENetworkLagState_MAX                     = 2,
};

// Enum Engine.ETravelType
// NumValues: 0x0004
enum class ETravelType : uint8
{
	TRAVEL_Absolute                          = 0,
	TRAVEL_Partial                           = 1,
	TRAVEL_Relative                          = 2,
	TRAVEL_MAX                               = 3,
};

// Enum Engine.EDemoPlayFailure
// NumValues: 0x000A
enum class EDemoPlayFailure : uint8
{
	Generic                                  = 0,
	DemoNotFound                             = 1,
	Corrupt                                  = 2,
	InvalidVersion                           = 3,
	InitBase                                 = 4,
	GameSpecificHeader                       = 5,
	ReplayStreamerInternal                   = 6,
	LoadMap                                  = 7,
	Serialization                            = 8,
	EDemoPlayFailure_MAX                     = 9,
};

// Enum Engine.EViewModeIndex
// NumValues: 0x0030
enum class EViewModeIndex : uint8
{
	VMI_BrushWireframe                       = 0,
	VMI_Wireframe                            = 1,
	VMI_Unlit                                = 2,
	VMI_Lit                                  = 3,
	VMI_Lit_DetailLighting                   = 4,
	VMI_LightingOnly                         = 5,
	VMI_LightComplexity                      = 6,
	VMI_ShaderComplexity                     = 8,
	VMI_LightmapDensity                      = 9,
	VMI_LitLightmapDensity                   = 10,
	VMI_ReflectionOverride                   = 11,
	VMI_VisualizeBuffer                      = 12,
	VMI_StationaryLightOverlap               = 14,
	VMI_CollisionPawn                        = 15,
	VMI_CollisionVisibility                  = 16,
	VMI_LODColoration                        = 18,
	VMI_QuadOverdraw                         = 19,
	VMI_PrimitiveDistanceAccuracy            = 20,
	VMI_MeshUVDensityAccuracy                = 21,
	VMI_ShaderComplexityWithQuadOverdraw     = 22,
	VMI_HLODColoration                       = 23,
	VMI_GroupLODColoration                   = 24,
	VMI_MaterialTextureScaleAccuracy         = 25,
	VMI_RequiredTextureResolution            = 26,
	VMI_PathTracing                          = 27,
	VMI_RayTracingDebug                      = 28,
	VMI_VisualizeNanite                      = 29,
	VMI_VirtualTexturePendingMips            = 30,
	VMI_VisualizeLumen                       = 31,
	VMI_VisualizeVirtualShadowMap            = 32,
	VMI_VisualizeGPUSkinCache                = 33,
	VMI_VisualizeSubstrate                   = 34,
	VMI_VisualizeGroom                       = 35,
	VMI_VertexColorRGB                       = 36,
	VMI_VertexColorAlpha                     = 37,
	VMI_VertexColorRed                       = 38,
	VMI_VertexColorGreen                     = 39,
	VMI_VertexColorBlue                      = 40,
	VMI_MaterialLayersComplexity             = 41,
	VMI_CastShadowLightOverlap               = 42,
	VMI_OnlyMaterialAO                       = 43,
	VMI_MeshTriangleDensity                  = 44,
	VMI_MeshMaterialsNum                     = 45,
	VMI_MeshWPO                              = 46,
	VMI_QuadOverdrawWithMaskOverdraw         = 47,
	VMI_Max                                  = 48,
	VMI_Unknown                              = 255,
	VMI_Max_0                                = 256,
};

// Enum Engine.EAspectRatioAxisConstraint
// NumValues: 0x0004
enum class EAspectRatioAxisConstraint : uint8
{
	AspectRatio_MaintainYFOV                 = 0,
	AspectRatio_MaintainXFOV                 = 1,
	AspectRatio_MajorAxisFOV                 = 2,
	AspectRatio_MAX                          = 3,
};

// Enum Engine.EOcclusionCombineMode
// NumValues: 0x0003
enum class EOcclusionCombineMode : uint8
{
	OCM_Minimum                              = 0,
	OCM_Multiply                             = 1,
	OCM_MAX                                  = 2,
};

// Enum Engine.EBlendMode
// NumValues: 0x000B
enum class EBlendMode : uint8
{
	BLEND_Opaque                             = 0,
	BLEND_Masked                             = 1,
	BLEND_Translucent                        = 2,
	BLEND_Additive                           = 3,
	BLEND_Modulate                           = 4,
	BLEND_AlphaComposite                     = 5,
	BLEND_AlphaHoldout                       = 6,
	BLEND_TranslucentColoredTransmittance    = 7,
	BLEND_MAX                                = 8,
	BLEND_TranslucentGreyTransmittance       = 2,
	BLEND_ColoredTransmittanceOnly           = 4,
};

// Enum Engine.EMaterialFloatPrecisionMode
// NumValues: 0x0005
enum class EMaterialFloatPrecisionMode : uint8
{
	MFPM_Default                             = 0,
	MFPM_Full_MaterialExpressionOnly         = 1,
	MFPM_Full                                = 2,
	MFPM_Half                                = 3,
	MFPM_MAX                                 = 4,
};

// Enum Engine.ESamplerSourceMode
// NumValues: 0x0005
enum class ESamplerSourceMode : uint8
{
	SSM_FromTextureAsset                     = 0,
	SSM_Wrap_WorldGroupSettings              = 1,
	SSM_Clamp_WorldGroupSettings             = 2,
	SSM_TerrainWeightmapGroupSettings        = 3,
	SSM_MAX                                  = 4,
};

// Enum Engine.ETextureMipValueMode
// NumValues: 0x0005
enum class ETextureMipValueMode : uint8
{
	TMVM_None                                = 0,
	TMVM_MipLevel                            = 1,
	TMVM_MipBias                             = 2,
	TMVM_Derivative                          = 3,
	TMVM_MAX                                 = 4,
};

// Enum Engine.ETranslucencyLightingMode
// NumValues: 0x0007
enum class ETranslucencyLightingMode : uint8
{
	TLM_VolumetricNonDirectional             = 0,
	TLM_VolumetricDirectional                = 1,
	TLM_VolumetricPerVertexNonDirectional    = 2,
	TLM_VolumetricPerVertexDirectional       = 3,
	TLM_Surface                              = 4,
	TLM_SurfacePerPixelLighting              = 5,
	TLM_MAX                                  = 6,
};

// Enum Engine.EMaterialDecalResponse
// NumValues: 0x0009
enum class EMaterialDecalResponse : uint8
{
	MDR_None                                 = 0,
	MDR_ColorNormalRoughness                 = 1,
	MDR_Color                                = 2,
	MDR_ColorNormal                          = 3,
	MDR_ColorRoughness                       = 4,
	MDR_Normal                               = 5,
	MDR_NormalRoughness                      = 6,
	MDR_Roughness                            = 7,
	MDR_MAX                                  = 8,
};

// Enum Engine.ERefractionMode
// NumValues: 0x0005
enum class ERefractionMode : uint8
{
	RM_IndexOfRefraction                     = 0,
	RM_PixelNormalOffset                     = 1,
	RM_2DOffset                              = 2,
	RM_None                                  = 3,
	RM_MAX                                   = 4,
};

// Enum Engine.ERefractionCoverageMode
// NumValues: 0x0003
enum class ERefractionCoverageMode : uint8
{
	RCM_CoverageIgnored                      = 0,
	RCM_CoverageAccountedFor                 = 1,
	RCM_MAX                                  = 2,
};

// Enum Engine.ETranslucentSortPolicy
// NumValues: 0x0004
enum class ETranslucentSortPolicy : uint8
{
	SortByDistance                           = 0,
	SortByProjectedZ                         = 1,
	SortAlongAxis                            = 2,
	ETranslucentSortPolicy_MAX               = 3,
};

// Enum Engine.EDynamicGlobalIlluminationMethod
// NumValues: 0x0006
enum class EDynamicGlobalIlluminationMethod : uint8
{
	None                                     = 0,
	Lumen                                    = 1,
	ScreenSpace                              = 2,
	RayTraced                                = 3,
	Plugin                                   = 4,
	EDynamicGlobalIlluminationMethod_MAX     = 5,
};

// Enum Engine.EReflectionMethod
// NumValues: 0x0005
enum class EReflectionMethod : uint8
{
	None                                     = 0,
	Lumen                                    = 1,
	ScreenSpace                              = 2,
	RayTraced                                = 3,
	EReflectionMethod_MAX                    = 4,
};

// Enum Engine.EShadowMapMethod
// NumValues: 0x0003
enum class EShadowMapMethod : uint8
{
	ShadowMaps                               = 0,
	VirtualShadowMaps                        = 1,
	EShadowMapMethod_MAX                     = 2,
};

// Enum Engine.ECastRayTracedShadow
// NumValues: 0x0004
enum class ECastRayTracedShadow : uint8
{
	Disabled                                 = 0,
	UseProjectSetting                        = 1,
	Enabled                                  = 2,
	ECastRayTracedShadow_MAX                 = 3,
};

// Enum Engine.ESceneCaptureSource
// NumValues: 0x000B
enum class ESceneCaptureSource : uint8
{
	SCS_SceneColorHDR                        = 0,
	SCS_SceneColorHDRNoAlpha                 = 1,
	SCS_FinalColorLDR                        = 2,
	SCS_SceneColorSceneDepth                 = 3,
	SCS_SceneDepth                           = 4,
	SCS_DeviceDepth                          = 5,
	SCS_Normal                               = 6,
	SCS_BaseColor                            = 7,
	SCS_FinalColorHDR                        = 8,
	SCS_FinalToneCurveHDR                    = 9,
	SCS_MAX                                  = 10,
};

// Enum Engine.ESceneCaptureCompositeMode
// NumValues: 0x0004
enum class ESceneCaptureCompositeMode : uint8
{
	SCCM_Overwrite                           = 0,
	SCCM_Additive                            = 1,
	SCCM_Composite                           = 2,
	SCCM_MAX                                 = 3,
};

// Enum Engine.EGBufferFormat
// NumValues: 0x0005
enum class EGBufferFormat : uint8
{
	Force8BitsPerChannel                     = 0,
	Default                                  = 1,
	HighPrecisionNormals                     = 3,
	Force16BitsPerChannel                    = 5,
	EGBufferFormat_MAX                       = 6,
};

// Enum Engine.ETrailWidthMode
// NumValues: 0x0004
enum class ETrailWidthMode : uint8
{
	ETrailWidthMode_FromCentre               = 0,
	ETrailWidthMode_FromFirst                = 1,
	ETrailWidthMode_FromSecond               = 2,
	ETrailWidthMode_MAX                      = 3,
};

// Enum Engine.EParticleCollisionMode
// NumValues: 0x0003
enum class EParticleCollisionMode : uint8
{
	SceneDepth                               = 0,
	DistanceField                            = 1,
	EParticleCollisionMode_MAX               = 2,
};

// Enum Engine.EMaterialShadingModel
// NumValues: 0x0013
enum class EMaterialShadingModel : uint8
{
	MSM_Unlit                                = 0,
	MSM_DefaultLit                           = 1,
	MSM_Subsurface                           = 2,
	MSM_PreintegratedSkin                    = 3,
	MSM_ClearCoat                            = 4,
	MSM_SubsurfaceProfile                    = 5,
	MSM_TwoSidedFoliage                      = 6,
	MSM_Hair                                 = 7,
	MSM_Cloth                                = 8,
	MSM_Eye                                  = 9,
	MSM_SingleLayerWater                     = 10,
	MSM_ThinTranslucent                      = 11,
	MSM_Strata                               = 12,
	MSM_MarvelStylized                       = 13,
	MSM_MarvelStylizedHair                   = 14,
	MSM_MarvelStylizedSubsurface             = 15,
	MSM_NUM                                  = 16,
	MSM_FromMaterialExpression               = 17,
	MSM_MAX                                  = 18,
};

// Enum Engine.EStrataShadingModel
// NumValues: 0x000E
enum class EStrataShadingModel : uint8
{
	SSM_Unlit                                = 0,
	SSM_DefaultLit                           = 1,
	SSM_SubsurfaceLit                        = 2,
	SSM_VolumetricFogCloud                   = 3,
	SSM_Hair                                 = 4,
	SSM_Eye                                  = 5,
	SSM_Cloth                                = 6,
	SSM_ClearCoat                            = 7,
	SSM_SingleLayerWater                     = 8,
	SSM_LightFunction                        = 9,
	SSM_PostProcess                          = 10,
	SSM_Decal                                = 11,
	SSM_UI                                   = 12,
	SSM_NUM                                  = 13,
};

// Enum Engine.EMaterialSamplerType
// NumValues: 0x0012
enum class EMaterialSamplerType : uint8
{
	SAMPLERTYPE_Color                        = 0,
	SAMPLERTYPE_Grayscale                    = 1,
	SAMPLERTYPE_Alpha                        = 2,
	SAMPLERTYPE_Normal                       = 3,
	SAMPLERTYPE_Masks                        = 4,
	SAMPLERTYPE_DistanceFieldFont            = 5,
	SAMPLERTYPE_LinearColor                  = 6,
	SAMPLERTYPE_LinearGrayscale              = 7,
	SAMPLERTYPE_Data                         = 8,
	SAMPLERTYPE_External                     = 9,
	SAMPLERTYPE_VirtualColor                 = 10,
	SAMPLERTYPE_VirtualGrayscale             = 11,
	SAMPLERTYPE_VirtualAlpha                 = 12,
	SAMPLERTYPE_VirtualNormal                = 13,
	SAMPLERTYPE_VirtualMasks                 = 14,
	SAMPLERTYPE_VirtualLinearColor           = 15,
	SAMPLERTYPE_VirtualLinearGrayscale       = 16,
	SAMPLERTYPE_MAX                          = 17,
};

// Enum Engine.EMaterialStencilCompare
// NumValues: 0x000A
enum class EMaterialStencilCompare : uint8
{
	MSC_Less                                 = 0,
	MSC_LessEqual                            = 1,
	MSC_Greater                              = 2,
	MSC_GreaterEqual                         = 3,
	MSC_Equal                                = 4,
	MSC_NotEqual                             = 5,
	MSC_Never                                = 6,
	MSC_Always                               = 7,
	MSC_Count                                = 8,
	MSC_MAX                                  = 9,
};

// Enum Engine.EMaterialShadingRate
// NumValues: 0x0009
enum class EMaterialShadingRate : uint8
{
	MSR_1x1                                  = 0,
	MSR_2x1                                  = 1,
	MSR_1x2                                  = 2,
	MSR_2x2                                  = 3,
	MSR_4x2                                  = 4,
	MSR_2x4                                  = 5,
	MSR_4x4                                  = 6,
	MSR_Count                                = 7,
	MSR_MAX                                  = 8,
};

// Enum Engine.ELightingBuildQuality
// NumValues: 0x0005
enum class ELightingBuildQuality : uint8
{
	Quality_Preview                          = 0,
	Quality_Medium                           = 1,
	Quality_High                             = 2,
	Quality_Production                       = 3,
	Quality_MAX                              = 4,
};

// Enum Engine.ENetworkSmoothingMode
// NumValues: 0x0004
enum class ENetworkSmoothingMode : uint8
{
	Disabled                                 = 0,
	Linear                                   = 1,
	Exponential                              = 2,
	ENetworkSmoothingMode_MAX                = 3,
};

// Enum Engine.EOverlapFilterOption
// NumValues: 0x0004
enum class EOverlapFilterOption : uint8
{
	OverlapFilter_All                        = 0,
	OverlapFilter_DynamicOnly                = 1,
	OverlapFilter_StaticOnly                 = 2,
	OverlapFilter_MAX                        = 3,
};

// Enum Engine.EFilterInterpolationType
// NumValues: 0x0007
enum class EFilterInterpolationType : uint8
{
	BSIT_Average                             = 0,
	BSIT_Linear                              = 1,
	BSIT_Cubic                               = 2,
	BSIT_EaseInOut                           = 3,
	BSIT_ExponentialDecay                    = 4,
	BSIT_SpringDamper                        = 5,
	BSIT_MAX                                 = 6,
};

// Enum Engine.ETimelineSigType
// NumValues: 0x0006
enum class ETimelineSigType : uint8
{
	ETS_EventSignature                       = 0,
	ETS_FloatSignature                       = 1,
	ETS_VectorSignature                      = 2,
	ETS_LinearColorSignature                 = 3,
	ETS_InvalidSignature                     = 4,
	ETS_MAX                                  = 5,
};

// Enum Engine.ELightMapPaddingType
// NumValues: 0x0004
enum class ELightMapPaddingType : uint8
{
	LMPT_NormalPadding                       = 0,
	LMPT_PrePadding                          = 1,
	LMPT_NoPadding                           = 2,
	LMPT_MAX                                 = 3,
};

// Enum Engine.EShadowMapFlags
// NumValues: 0x0003
enum class EShadowMapFlags : uint8
{
	SMF_None                                 = 0,
	SMF_Streamed                             = 1,
	SMF_MAX                                  = 2,
};

// Enum Engine.EUpdateRateShiftBucket
// NumValues: 0x0008
enum class EUpdateRateShiftBucket : uint8
{
	ShiftBucket0                             = 0,
	ShiftBucket1                             = 1,
	ShiftBucket2                             = 2,
	ShiftBucket3                             = 3,
	ShiftBucket4                             = 4,
	ShiftBucket5                             = 5,
	ShiftBucketMax                           = 6,
	EUpdateRateShiftBucket_MAX               = 7,
};

// Enum Engine.ENaniteFallbackTarget
// NumValues: 0x0004
enum class ENaniteFallbackTarget : uint8
{
	Auto                                     = 0,
	PercentTriangles                         = 1,
	RelativeError                            = 2,
	ENaniteFallbackTarget_MAX                = 3,
};

// Enum Engine.ENetRole
// NumValues: 0x0005
enum class ENetRole : uint8
{
	ROLE_None                                = 0,
	ROLE_SimulatedProxy                      = 1,
	ROLE_AutonomousProxy                     = 2,
	ROLE_Authority                           = 3,
	ROLE_MAX                                 = 4,
};

// Enum Engine.ENetDormancy
// NumValues: 0x0006
enum class ENetDormancy : uint8
{
	DORM_Never                               = 0,
	DORM_Awake                               = 1,
	DORM_DormantAll                          = 2,
	DORM_DormantPartial                      = 3,
	DORM_Initial                             = 4,
	DORM_MAX                                 = 5,
};

// Enum Engine.EPhysicsReplicationMode
// NumValues: 0x0004
enum class EPhysicsReplicationMode : uint8
{
	Default                                  = 0,
	PredictiveInterpolation                  = 1,
	Resimulation                             = 2,
	EPhysicsReplicationMode_MAX              = 3,
};

// Enum Engine.EAutoReceiveInput
// NumValues: 0x000A
enum class EAutoReceiveInput : uint8
{
	Disabled                                 = 0,
	Player0                                  = 1,
	Player1                                  = 2,
	Player2                                  = 3,
	Player3                                  = 4,
	Player4                                  = 5,
	Player5                                  = 6,
	Player6                                  = 7,
	Player7                                  = 8,
	EAutoReceiveInput_MAX                    = 9,
};

// Enum Engine.EAutoPossessAI
// NumValues: 0x0005
enum class EAutoPossessAI : uint8
{
	Disabled                                 = 0,
	PlacedInWorld                            = 1,
	Spawned                                  = 2,
	PlacedInWorldOrSpawned                   = 3,
	EAutoPossessAI_MAX                       = 4,
};

// Enum Engine.EPhysicalMaterialMaskColor
// NumValues: 0x0009
enum class EPhysicalMaterialMaskColor : uint8
{
	Red                                      = 0,
	Green                                    = 1,
	Blue                                     = 2,
	Cyan                                     = 3,
	Magenta                                  = 4,
	Yellow                                   = 5,
	White                                    = 6,
	Black                                    = 7,
	MAX                                      = 8,
};

// Enum Engine.EComponentSocketType
// NumValues: 0x0004
enum class EComponentSocketType : uint8
{
	Invalid                                  = 0,
	Bone                                     = 1,
	Socket                                   = 2,
	EComponentSocketType_MAX                 = 3,
};

// Enum Engine.ESpawnActorCollisionHandlingMethod
// NumValues: 0x0006
enum class ESpawnActorCollisionHandlingMethod : uint8
{
	Undefined                                = 0,
	AlwaysSpawn                              = 1,
	AdjustIfPossibleButAlwaysSpawn           = 2,
	AdjustIfPossibleButDontSpawnIfColliding  = 3,
	DontSpawnIfColliding                     = 4,
	ESpawnActorCollisionHandlingMethod_MAX   = 5,
};

// Enum Engine.EMeshBufferAccess
// NumValues: 0x0003
enum class EMeshBufferAccess : uint8
{
	Default                                  = 0,
	ForceCPUAndGPU                           = 1,
	EMeshBufferAccess_MAX                    = 2,
};

// Enum Engine.EFontImportCharacterSet
// NumValues: 0x0004
enum class EFontImportCharacterSet : uint8
{
	FontICS_Default                          = 0,
	FontICS_Ansi                             = 1,
	FontICS_Symbol                           = 2,
	FontICS_MAX                              = 3,
};

// Enum Engine.EStandbyType
// NumValues: 0x0004
enum class EStandbyType : uint8
{
	STDBY_Rx                                 = 0,
	STDBY_Tx                                 = 1,
	STDBY_BadPing                            = 2,
	STDBY_MAX                                = 3,
};

// Enum Engine.ESuggestProjVelocityTraceOption
// NumValues: 0x0004
enum class ESuggestProjVelocityTraceOption : uint8
{
	DoNotTrace                               = 0,
	TraceFullPath                            = 1,
	OnlyTraceWhileAscending                  = 2,
	ESuggestProjVelocityTraceOption_MAX      = 3,
};

// Enum Engine.EHISMViewRelevanceType
// NumValues: 0x0004
enum class EHISMViewRelevanceType : uint8
{
	Grass                                    = 0,
	Foliage                                  = 1,
	HISM                                     = 2,
	EHISMViewRelevanceType_MAX               = 3,
};

// Enum Engine.EHitProxyPriority
// NumValues: 0x0005
enum class EHitProxyPriority : uint8
{
	HPP_World                                = 0,
	HPP_Wireframe                            = 1,
	HPP_Foreground                           = 2,
	HPP_UI                                   = 3,
	HPP_MAX                                  = 4,
};

// Enum Engine.EAdManagerDelegate
// NumValues: 0x0003
enum class EAdManagerDelegate : uint8
{
	AMD_ClickedBanner                        = 0,
	AMD_UserClosedAd                         = 1,
	AMD_MAX                                  = 2,
};

// Enum Engine.ERoundingMode
// NumValues: 0x0008
enum class ERoundingMode : uint8
{
	HalfToEven                               = 0,
	HalfFromZero                             = 1,
	HalfToZero                               = 2,
	FromZero                                 = 3,
	ToZero                                   = 4,
	ToNegativeInfinity                       = 5,
	ToPositiveInfinity                       = 6,
	ERoundingMode_MAX                        = 7,
};

// Enum Engine.EViewStatusForScreenPercentage
// NumValues: 0x0006
enum class EViewStatusForScreenPercentage : uint8
{
	NonRealtime                              = 0,
	Desktop                                  = 1,
	Mobile                                   = 2,
	VR                                       = 3,
	PathTracer                               = 4,
	EViewStatusForScreenPercentage_MAX       = 5,
};

// Enum Engine.EScreenPercentageMode
// NumValues: 0x0004
enum class EScreenPercentageMode : uint32
{
	Manual                                   = 0,
	BasedOnDisplayResolution                 = 1,
	BasedOnDPIScale                          = 2,
	EScreenPercentageMode_MAX                = 3,
};

// Enum Engine.ELevelInstanceRuntimeBehavior
// NumValues: 0x0005
enum class ELevelInstanceRuntimeBehavior : uint8
{
	None                                     = 0,
	Embedded_Deprecated                      = 1,
	Partitioned                              = 2,
	LevelStreaming                           = 3,
	ELevelInstanceRuntimeBehavior_MAX        = 4,
};

// Enum Engine.ELevelInstanceCreationType
// NumValues: 0x0003
enum class ELevelInstanceCreationType : uint8
{
	LevelInstance                            = 0,
	PackedLevelActor                         = 1,
	ELevelInstanceCreationType_MAX           = 2,
};

// Enum Engine.ELevelInstancePivotType
// NumValues: 0x0005
enum class ELevelInstancePivotType : uint8
{
	CenterMinZ                               = 0,
	Center                                   = 1,
	Actor                                    = 2,
	WorldOrigin                              = 3,
	ELevelInstancePivotType_MAX              = 4,
};

// Enum Engine.EStreamingVolumeUsage
// NumValues: 0x0006
enum class EStreamingVolumeUsage : uint8
{
	SVB_Loading                              = 0,
	SVB_LoadingAndVisibility                 = 1,
	SVB_VisibilityBlockingOnLoad             = 2,
	SVB_BlockingOnLoad                       = 3,
	SVB_LoadingNotVisible                    = 4,
	SVB_MAX                                  = 5,
};

// Enum Engine.EStrikePartType
// NumValues: 0x000C
enum class EStrikePartType : uint8
{
	NAME_None                                = 0,
	BODY                                     = 1,
	HEAD                                     = 2,
	CHEST                                    = 3,
	LEFTARM                                  = 4,
	RIGHTARM                                 = 5,
	LEFTLEG                                  = 6,
	RIGHTLEG                                 = 7,
	WAISTANDHIP                              = 8,
	ABDOMEN                                  = 9,
	OUTER_BOUND                              = 10,
	EStrikePartType_MAX                      = 11,
};

// Enum Engine.EMoveMaskFlags
// NumValues: 0x000A
enum class EMoveMaskFlags : uint8
{
	MaskNone                                 = 0,
	MaskTeamRed                              = 1,
	MaskTeamBlue                             = 2,
	MaskAmmo                                 = 4,
	MaskPawnPenetrable                       = 8,
	MaskTeamAll                              = 3,
	MaskAmmoAll                              = 4,
	MaskPawnMoveIgnore                       = 12,
	MaskAgentMoveIgnore                      = 4,
	EMoveMaskFlags_MAX                       = 13,
};

// Enum Engine.EModifierPriority
// NumValues: 0x0005
enum class EModifierPriority : uint8
{
	Auto                                     = 0,
	Ability                                  = 1,
	Task                                     = 2,
	Max                                      = 3,
	EModifierPriority_MAX                    = 4,
};

// Enum Engine.EMaterialDomain
// NumValues: 0x0008
enum class EMaterialDomain : uint8
{
	MD_Surface                               = 0,
	MD_DeferredDecal                         = 1,
	MD_LightFunction                         = 2,
	MD_Volume                                = 3,
	MD_PostProcess                           = 4,
	MD_UI                                    = 5,
	MD_RuntimeVirtualTexture                 = 6,
	MD_MAX                                   = 7,
};

// Enum Engine.EPositionOrigin
// NumValues: 0x0003
enum class EPositionOrigin : uint8
{
	Absolute                                 = 0,
	CameraRelative                           = 1,
	EPositionOrigin_MAX                      = 2,
};

// Enum Engine.ETextureColorChannel
// NumValues: 0x0005
enum class ETextureColorChannel : uint8
{
	TCC_Red                                  = 0,
	TCC_Green                                = 1,
	TCC_Blue                                 = 2,
	TCC_Alpha                                = 3,
	TCC_MAX                                  = 4,
};

// Enum Engine.EMaterialAttributeBlend
// NumValues: 0x0004
enum class EMaterialAttributeBlend : uint8
{
	Blend                                    = 0,
	UseA                                     = 1,
	UseB                                     = 2,
	EMaterialAttributeBlend_MAX              = 3,
};

// Enum Engine.EMaterialBranchCondition
// NumValues: 0x0007
enum class EMaterialBranchCondition : uint8
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	Less                                     = 2,
	LessOrEqual                              = 3,
	Greater                                  = 4,
	GreaterOrEqual                           = 5,
	EMaterialBranchCondition_MAX             = 6,
};

// Enum Engine.EMaterialBranchAttribute
// NumValues: 0x0004
enum class EMaterialBranchAttribute : uint8
{
	None                                     = 0,
	Branch                                   = 1,
	Flatten                                  = 2,
	EMaterialBranchAttribute_MAX             = 3,
};

// Enum Engine.EChannelMaskParameterColor
// NumValues: 0x0005
enum class EChannelMaskParameterColor : uint8
{
	Red                                      = 0,
	Green                                    = 1,
	Blue                                     = 2,
	Alpha                                    = 3,
	EChannelMaskParameterColor_MAX           = 4,
};

// Enum Engine.EClampMode
// NumValues: 0x0004
enum class EClampMode : uint8
{
	CMODE_Clamp                              = 0,
	CMODE_ClampMin                           = 1,
	CMODE_ClampMax                           = 2,
	CMODE_MAX                                = 3,
};

// Enum Engine.ECustomMaterialOutputType
// NumValues: 0x0006
enum class ECustomMaterialOutputType : uint8
{
	CMOT_Float1                              = 0,
	CMOT_Float2                              = 1,
	CMOT_Float3                              = 2,
	CMOT_Float4                              = 3,
	CMOT_MaterialAttributes                  = 4,
	CMOT_MAX                                 = 5,
};

// Enum Engine.EDataDrivenShaderPlatformInfoCondition
// NumValues: 0x0003
enum class EDataDrivenShaderPlatformInfoCondition : uint8
{
	COND_True                                = 0,
	COND_False                               = 1,
	COND_Max                                 = 2,
};

// Enum Engine.EDBufferTextureId
// NumValues: 0x0004
enum class EDBufferTextureId : uint8
{
	DBT_A                                    = 0,
	DBT_B                                    = 1,
	DBT_C                                    = 2,
	DBT_MAX                                  = 3,
};

// Enum Engine.EDepthOfFieldFunctionValue
// NumValues: 0x0005
enum class EDepthOfFieldFunctionValue : uint8
{
	TDOF_NearAndFarMask                      = 0,
	TDOF_NearMask                            = 1,
	TDOF_FarMask                             = 2,
	TDOF_CircleOfConfusionRadius             = 3,
	TDOF_MAX                                 = 4,
};

// Enum Engine.EFunctionInputType
// NumValues: 0x000E
enum class EFunctionInputType : uint8
{
	FunctionInput_Scalar                     = 0,
	FunctionInput_Vector2                    = 1,
	FunctionInput_Vector3                    = 2,
	FunctionInput_Vector4                    = 3,
	FunctionInput_Texture2D                  = 4,
	FunctionInput_TextureCube                = 5,
	FunctionInput_Texture2DArray             = 6,
	FunctionInput_VolumeTexture              = 7,
	FunctionInput_StaticBool                 = 8,
	FunctionInput_MaterialAttributes         = 9,
	FunctionInput_TextureExternal            = 10,
	FunctionInput_Bool                       = 11,
	FunctionInput_Substrate                  = 12,
	FunctionInput_MAX                        = 13,
};

// Enum Engine.EX20LowResolutionMaskMode
// NumValues: 0x0002
enum class EX20LowResolutionMaskMode : uint8
{
	CharacterArea                            = 0,
	EX20LowResolutionMaskMode_MAX            = 1,
};

// Enum Engine.ENoiseFunction
// NumValues: 0x0007
enum class ENoiseFunction : uint8
{
	NOISEFUNCTION_SimplexTex                 = 0,
	NOISEFUNCTION_GradientTex                = 1,
	NOISEFUNCTION_GradientTex3D              = 2,
	NOISEFUNCTION_GradientALU                = 3,
	NOISEFUNCTION_ValueALU                   = 4,
	NOISEFUNCTION_VoronoiALU                 = 5,
	NOISEFUNCTION_MAX                        = 6,
};

// Enum Engine.EPathTracingBufferTextureId
// NumValues: 0x0006
enum class EPathTracingBufferTextureId : uint8
{
	PTBT_Radiance                            = 0,
	PTBT_DenoisedRadiance                    = 1,
	PTBT_Albedo                              = 2,
	PTBT_Normal                              = 3,
	PTBT_Variance                            = 4,
	PTBT_MAX                                 = 5,
};

// Enum Engine.ERuntimeVirtualTextureMipValueMode
// NumValues: 0x0005
enum class ERuntimeVirtualTextureMipValueMode : uint8
{
	RVTMVM_None                              = 0,
	RVTMVM_MipLevel                          = 1,
	RVTMVM_MipBias                           = 2,
	RVTMVM_RecalculateDerivatives            = 3,
	RVTMVM_MAX                               = 4,
};

// Enum Engine.ERuntimeVirtualTextureTextureAddressMode
// NumValues: 0x0003
enum class ERuntimeVirtualTextureTextureAddressMode : uint8
{
	RVTTA_Clamp                              = 0,
	RVTTA_Wrap                               = 1,
	RVTTA_MAX                                = 2,
};

// Enum Engine.EMaterialSceneAttributeInputMode
// NumValues: 0x0003
enum class EMaterialSceneAttributeInputMode : uint8
{
	Coordinates                              = 0,
	OffsetFraction                           = 1,
	EMaterialSceneAttributeInputMode_MAX     = 2,
};

// Enum Engine.ESpeedTreeGeometryType
// NumValues: 0x0006
enum class ESpeedTreeGeometryType : uint8
{
	STG_Branch                               = 0,
	STG_Frond                                = 1,
	STG_Leaf                                 = 2,
	STG_FacingLeaf                           = 3,
	STG_Billboard                            = 4,
	STG_MAX                                  = 5,
};

// Enum Engine.ESpeedTreeWindType
// NumValues: 0x0008
enum class ESpeedTreeWindType : uint8
{
	STW_None                                 = 0,
	STW_Fastest                              = 1,
	STW_Fast                                 = 2,
	STW_Better                               = 3,
	STW_Best                                 = 4,
	STW_Palm                                 = 5,
	STW_BestPlus                             = 6,
	STW_MAX                                  = 7,
};

// Enum Engine.ESpeedTreeLODType
// NumValues: 0x0003
enum class ESpeedTreeLODType : uint8
{
	STLOD_Pop                                = 0,
	STLOD_Smooth                             = 1,
	STLOD_MAX                                = 2,
};

// Enum Engine.ESwitchMaterialOutputType
// NumValues: 0x0005
enum class ESwitchMaterialOutputType : uint8
{
	TMMOT_Float1                             = 0,
	TMMOT_Float2                             = 1,
	TMMOT_Float3                             = 2,
	TMMOT_Float4                             = 3,
	TMMOT_MAX                                = 4,
};

// Enum Engine.EMaterialExposedTextureProperty
// NumValues: 0x0003
enum class EMaterialExposedTextureProperty : uint8
{
	TMTM_TextureSize                         = 0,
	TMTM_TexelSize                           = 1,
	TMTM_MAX                                 = 2,
};

// Enum Engine.EMaterialVectorCoordTransformSource
// NumValues: 0x0008
enum class EMaterialVectorCoordTransformSource : uint8
{
	TRANSFORMSOURCE_Tangent                  = 0,
	TRANSFORMSOURCE_Local                    = 1,
	TRANSFORMSOURCE_World                    = 2,
	TRANSFORMSOURCE_View                     = 3,
	TRANSFORMSOURCE_Camera                   = 4,
	TRANSFORMSOURCE_ParticleWorld            = 5,
	TRANSFORMSOURCE_Instance                 = 6,
	TRANSFORMSOURCE_MAX                      = 7,
};

// Enum Engine.EMaterialVectorCoordTransform
// NumValues: 0x0008
enum class EMaterialVectorCoordTransform : uint8
{
	TRANSFORM_Tangent                        = 0,
	TRANSFORM_Local                          = 1,
	TRANSFORM_World                          = 2,
	TRANSFORM_View                           = 3,
	TRANSFORM_Camera                         = 4,
	TRANSFORM_ParticleWorld                  = 5,
	TRANSFORM_Instance                       = 6,
	TRANSFORM_MAX                            = 7,
};

// Enum Engine.EMaterialPositionTransformSource
// NumValues: 0x0008
enum class EMaterialPositionTransformSource : uint8
{
	TRANSFORMPOSSOURCE_Local                 = 0,
	TRANSFORMPOSSOURCE_World                 = 1,
	TRANSFORMPOSSOURCE_TranslatedWorld       = 2,
	TRANSFORMPOSSOURCE_View                  = 3,
	TRANSFORMPOSSOURCE_Camera                = 4,
	TRANSFORMPOSSOURCE_Particle              = 5,
	TRANSFORMPOSSOURCE_Instance              = 6,
	TRANSFORMPOSSOURCE_MAX                   = 7,
};

// Enum Engine.EVectorNoiseFunction
// NumValues: 0x0006
enum class EVectorNoiseFunction : uint8
{
	VNF_CellnoiseALU                         = 0,
	VNF_VectorALU                            = 1,
	VNF_GradientALU                          = 2,
	VNF_CurlALU                              = 3,
	VNF_VoronoiALU                           = 4,
	VNF_MAX                                  = 5,
};

// Enum Engine.EMEVertexBonePositionType
// NumValues: 0x0003
enum class EMEVertexBonePositionType : uint8
{
	Current                                  = 0,
	Previous                                 = 1,
	EMEVertexBonePositionType_MAX            = 2,
};

// Enum Engine.EMaterialExposedViewProperty
// NumValues: 0x0012
enum class EMaterialExposedViewProperty : uint8
{
	MEVP_BufferSize                          = 0,
	MEVP_FieldOfView                         = 1,
	MEVP_TanHalfFieldOfView                  = 2,
	MEVP_ViewSize                            = 3,
	MEVP_WorldSpaceViewPosition              = 4,
	MEVP_WorldSpaceCameraPosition            = 5,
	MEVP_ViewportOffset                      = 6,
	MEVP_TemporalSampleCount                 = 7,
	MEVP_TemporalSampleIndex                 = 8,
	MEVP_TemporalSampleOffset                = 9,
	MEVP_RuntimeVirtualTextureOutputLevel    = 10,
	MEVP_RuntimeVirtualTextureOutputDerivative = 11,
	MEVP_PreExposure                         = 12,
	MEVP_RuntimeVirtualTextureMaxLevel       = 13,
	MEVP_ResolutionFraction                  = 14,
	MEVP_EnhancedWaterWavePosition           = 15,
	MEVP_EnhancedWaterWaveSize               = 16,
	MEVP_MAX                                 = 17,
};

// Enum Engine.EWorldPositionIncludedOffsets
// NumValues: 0x0005
enum class EWorldPositionIncludedOffsets : uint8
{
	WPT_Default                              = 0,
	WPT_ExcludeAllShaderOffsets              = 1,
	WPT_CameraRelative                       = 2,
	WPT_CameraRelativeNoOffsets              = 3,
	WPT_MAX                                  = 4,
};

// Enum Engine.EMaterialFunctionUsage
// NumValues: 0x0004
enum class EMaterialFunctionUsage : uint8
{
	Default                                  = 0,
	MaterialLayer                            = 1,
	MaterialLayerBlend                       = 2,
	EMaterialFunctionUsage_MAX               = 3,
};

// Enum Engine.EMaterialUsage
// NumValues: 0x0016
enum class EMaterialUsage : uint8
{
	MATUSAGE_SkeletalMesh                    = 0,
	MATUSAGE_ParticleSprites                 = 1,
	MATUSAGE_BeamTrails                      = 2,
	MATUSAGE_MeshParticles                   = 3,
	MATUSAGE_StaticLighting                  = 4,
	MATUSAGE_MorphTargets                    = 5,
	MATUSAGE_SplineMesh                      = 6,
	MATUSAGE_InstancedStaticMeshes           = 7,
	MATUSAGE_GeometryCollections             = 8,
	MATUSAGE_Clothing                        = 9,
	MATUSAGE_NiagaraSprites                  = 10,
	MATUSAGE_NiagaraRibbons                  = 11,
	MATUSAGE_NiagaraMeshParticles            = 12,
	MATUSAGE_GeometryCache                   = 13,
	MATUSAGE_Water                           = 14,
	MATUSAGE_HairStrands                     = 15,
	MATUSAGE_LidarPointCloud                 = 16,
	MATUSAGE_VirtualHeightfieldMesh          = 17,
	MATUSAGE_Nanite                          = 18,
	MATUSAGE_VolumetricCloud                 = 19,
	MATUSAGE_HeterogeneousVolumes            = 20,
	MATUSAGE_MAX                             = 21,
};

// Enum Engine.EMaterialLayerLinkState
// NumValues: 0x0005
enum class EMaterialLayerLinkState : uint8
{
	Uninitialized                            = 0,
	LinkedToParent                           = 1,
	UnlinkedFromParent                       = 2,
	NotFromParent                            = 3,
	EMaterialLayerLinkState_MAX              = 4,
};

// Enum Engine.ETextureSizingType
// NumValues: 0x0008
enum class ETextureSizingType : uint8
{
	TextureSizingType_UseSingleTextureSize   = 0,
	TextureSizingType_UseAutomaticBiasedSizes = 1,
	TextureSizingType_UseManualOverrideTextureSize = 2,
	TextureSizingType_UseSimplygonAutomaticSizing = 3,
	TextureSizingType_AutomaticFromTexelDensity = 4,
	TextureSizingType_AutomaticFromMeshScreenSize = 5,
	TextureSizingType_AutomaticFromMeshDrawDistance = 6,
	TextureSizingType_MAX                    = 7,
};

// Enum Engine.EMaterialMergeType
// NumValues: 0x0003
enum class EMaterialMergeType : uint8
{
	MaterialMergeType_Default                = 0,
	MaterialMergeType_Simplygon              = 1,
	MaterialMergeType_MAX                    = 2,
};

// Enum Engine.ESceneTextureId
// NumValues: 0x002E
enum class ESceneTextureId : uint8
{
	PPI_SceneColor                           = 0,
	PPI_SceneDepth                           = 1,
	PPI_DiffuseColor                         = 2,
	PPI_SpecularColor                        = 3,
	PPI_SubsurfaceColor                      = 4,
	PPI_BaseColor                            = 5,
	PPI_Specular                             = 6,
	PPI_Metallic                             = 7,
	PPI_WorldNormal                          = 8,
	PPI_SeparateTranslucency                 = 9,
	PPI_Opacity                              = 10,
	PPI_Roughness                            = 11,
	PPI_MaterialAO                           = 12,
	PPI_CustomDepth                          = 13,
	PPI_PostProcessInput0                    = 14,
	PPI_PostProcessInput1                    = 15,
	PPI_PostProcessInput2                    = 16,
	PPI_PostProcessInput3                    = 17,
	PPI_PostProcessInput4                    = 18,
	PPI_PostProcessInput5                    = 19,
	PPI_PostProcessInput6                    = 20,
	PPI_DecalMask                            = 21,
	PPI_ShadingModelColor                    = 22,
	PPI_ShadingModelID                       = 23,
	PPI_AmbientOcclusion                     = 24,
	PPI_CustomStencil                        = 25,
	PPI_StoredBaseColor                      = 26,
	PPI_StoredSpecular                       = 27,
	PPI_Velocity                             = 28,
	PPI_WorldTangent                         = 29,
	PPI_Anisotropy                           = 30,
	PPI_AdditionalBloom                      = 31,
	PPI_SmoothOutlinePixelMask               = 32,
	PPI_SmoothOutlineStandardDepth           = 33,
	PPI_SmoothOutlineOccludedDepth           = 34,
	PPI_BasePassCustomPixelMask              = 35,
	PPI_PerObjectGBufferData                 = 36,
	PPI_RimlightShellMask                    = 37,
	PPI_RimlightShellDepth                   = 38,
	PPI_RimlightShellNormal                  = 39,
	PPI_ScreenSpaceBentNormal                = 40,
	PPI_MeshSectionIndex                     = 41,
	PPI_ExtraCustomData                      = 42,
	PPI_SecondaryCustomDepth                 = 43,
	PPI_SecondaryCustomStencil               = 44,
	PPI_MAX                                  = 45,
};

// Enum Engine.ELWCFunctionKind
// NumValues: 0x000C
enum class ELWCFunctionKind : uint8
{
	Constructor                              = 0,
	Promote                                  = 1,
	Demote                                   = 2,
	Add                                      = 3,
	Subtract                                 = 4,
	Divide                                   = 5,
	MultiplyVectorVector                     = 6,
	MultiplyVectorMatrix                     = 7,
	MultiplyMatrixMatrix                     = 8,
	Other                                    = 9,
	Max                                      = 10,
	ELWCFunctionKind_MAX                     = 11,
};

// Enum Engine.EMaterialParameterAssociation
// NumValues: 0x0004
enum class EMaterialParameterAssociation : uint8
{
	LayerParameter                           = 0,
	BlendParameter                           = 1,
	GlobalParameter                          = 2,
	EMaterialParameterAssociation_MAX        = 3,
};

// Enum Engine.EMicroTransactionDelegate
// NumValues: 0x0003
enum class EMicroTransactionDelegate : uint8
{
	MTD_PurchaseQueryComplete                = 0,
	MTD_PurchaseComplete                     = 1,
	MTD_MAX                                  = 2,
};

// Enum Engine.EMicroTransactionResult
// NumValues: 0x0005
enum class EMicroTransactionResult : uint8
{
	MTR_Succeeded                            = 0,
	MTR_Failed                               = 1,
	MTR_Canceled                             = 2,
	MTR_RestoredFromServer                   = 3,
	MTR_MAX                                  = 4,
};

// Enum Engine.ENavigationDataResolution
// NumValues: 0x0005
enum class ENavigationDataResolution : uint8
{
	Low                                      = 0,
	Default                                  = 1,
	High                                     = 2,
	Invalid                                  = 3,
	MAX                                      = 3,
};

// Enum Engine.ENavigationInvokerPriority
// NumValues: 0x0006
enum class ENavigationInvokerPriority : uint8
{
	VeryLow                                  = 1,
	Low                                      = 2,
	Default                                  = 3,
	High                                     = 4,
	VeryHigh                                 = 5,
	MAX                                      = 6,
};

// Enum Engine.ENavLinkDirection
// NumValues: 0x0004
enum class ENavLinkDirection : uint8
{
	BothWays                                 = 0,
	LeftToRight                              = 1,
	RightToLeft                              = 2,
	ENavLinkDirection_MAX                    = 3,
};

// Enum Engine.EPingType
// NumValues: 0x0008
enum class EPingType : uint8
{
	None                                     = 0,
	RoundTrip                                = 1,
	RoundTripExclFrame                       = 2,
	ICMP                                     = 4,
	UDPQoS                                   = 8,
	Max                                      = 8,
	Count                                    = 4,
	EPingType_MAX                            = 9,
};

// Enum Engine.EPingAverageType
// NumValues: 0x0004
enum class EPingAverageType : uint8
{
	None                                     = 0,
	MovingAverage                            = 1,
	PlayerStateAvg                           = 2,
	EPingAverageType_MAX                     = 3,
};

// Enum Engine.EParticleBurstMethod
// NumValues: 0x0003
enum class EParticleBurstMethod : uint8
{
	EPBM_Instant                             = 0,
	EPBM_Interpolated                        = 1,
	EPBM_MAX                                 = 2,
};

// Enum Engine.EParticleSubUVInterpMethod
// NumValues: 0x0006
enum class EParticleSubUVInterpMethod : uint8
{
	PSUVIM_None                              = 0,
	PSUVIM_Linear                            = 1,
	PSUVIM_Linear_Blend                      = 2,
	PSUVIM_Random                            = 3,
	PSUVIM_Random_Blend                      = 4,
	PSUVIM_MAX                               = 5,
};

// Enum Engine.EEmitterRenderMode
// NumValues: 0x0006
enum class EEmitterRenderMode : uint8
{
	ERM_Normal                               = 0,
	ERM_Point                                = 1,
	ERM_Cross                                = 2,
	ERM_LightsOnly                           = 3,
	ERM_None                                 = 4,
	ERM_MAX                                  = 5,
};

// Enum Engine.EParticleDetailMode
// NumValues: 0x0005
enum class EParticleDetailMode : uint8
{
	PDM_Low                                  = 0,
	PDM_Medium                               = 1,
	PDM_High                                 = 2,
	PDM_Epic                                 = 3,
	PDM_MAX                                  = 4,
};

// Enum Engine.EParticleSignificanceLevel
// NumValues: 0x0006
enum class EParticleSignificanceLevel : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Critical                                 = 3,
	Num                                      = 4,
	EParticleSignificanceLevel_MAX           = 5,
};

// Enum Engine.EParticleSystemInsignificanceReaction
// NumValues: 0x0006
enum class EParticleSystemInsignificanceReaction : uint8
{
	Auto                                     = 0,
	Complete                                 = 1,
	DisableTick                              = 2,
	DisableTickAndKill                       = 3,
	Num                                      = 4,
	EParticleSystemInsignificanceReaction_MAX = 5,
};

// Enum Engine.EModuleType
// NumValues: 0x000A
enum class EModuleType : uint8
{
	EPMT_General                             = 0,
	EPMT_TypeData                            = 1,
	EPMT_Beam                                = 2,
	EPMT_Trail                               = 3,
	EPMT_Spawn                               = 4,
	EPMT_Required                            = 5,
	EPMT_Event                               = 6,
	EPMT_Light                               = 7,
	EPMT_SubUV                               = 8,
	EPMT_MAX                                 = 9,
};

// Enum Engine.EParticleSourceSelectionMethod
// NumValues: 0x0003
enum class EParticleSourceSelectionMethod : uint8
{
	EPSSM_Random                             = 0,
	EPSSM_Sequential                         = 1,
	EPSSM_MAX                                = 2,
};

// Enum Engine.EAttractorParticleSelectionMethod
// NumValues: 0x0003
enum class EAttractorParticleSelectionMethod : uint8
{
	EAPSM_Random                             = 0,
	EAPSM_Sequential                         = 1,
	EAPSM_MAX                                = 2,
};

// Enum Engine.Beam2SourceTargetMethod
// NumValues: 0x0006
enum class EBeam2SourceTargetMethod : uint8
{
	PEB2STM_Default                          = 0,
	PEB2STM_UserSet                          = 1,
	PEB2STM_Emitter                          = 2,
	PEB2STM_Particle                         = 3,
	PEB2STM_Actor                            = 4,
	PEB2STM_MAX                              = 5,
};

// Enum Engine.Beam2SourceTargetTangentMethod
// NumValues: 0x0005
enum class EBeam2SourceTargetTangentMethod : uint8
{
	PEB2STTM_Direct                          = 0,
	PEB2STTM_UserSet                         = 1,
	PEB2STTM_Distribution                    = 2,
	PEB2STTM_Emitter                         = 3,
	PEB2STTM_MAX                             = 4,
};

// Enum Engine.BeamModifierType
// NumValues: 0x0003
enum class EBeamModifierType : uint8
{
	PEB2MT_Source                            = 0,
	PEB2MT_Target                            = 1,
	PEB2MT_MAX                               = 2,
};

// Enum Engine.EParticleCameraOffsetUpdateMethod
// NumValues: 0x0004
enum class EParticleCameraOffsetUpdateMethod : uint8
{
	EPCOUM_DirectSet                         = 0,
	EPCOUM_Additive                          = 1,
	EPCOUM_Scalar                            = 2,
	EPCOUM_MAX                               = 3,
};

// Enum Engine.EParticleCollisionComplete
// NumValues: 0x0007
enum class EParticleCollisionComplete : uint8
{
	EPCC_Kill                                = 0,
	EPCC_Freeze                              = 1,
	EPCC_HaltCollisions                      = 2,
	EPCC_FreezeTranslation                   = 3,
	EPCC_FreezeRotation                      = 4,
	EPCC_FreezeMovement                      = 5,
	EPCC_MAX                                 = 6,
};

// Enum Engine.EParticleCollisionResponse
// NumValues: 0x0004
enum class EParticleCollisionResponse : uint8
{
	Bounce                                   = 0,
	Stop                                     = 1,
	Kill                                     = 2,
	EParticleCollisionResponse_MAX           = 3,
};

// Enum Engine.ELocationBoneSocketSource
// NumValues: 0x0003
enum class ELocationBoneSocketSource : uint8
{
	BONESOCKETSOURCE_Bones                   = 0,
	BONESOCKETSOURCE_Sockets                 = 1,
	BONESOCKETSOURCE_MAX                     = 2,
};

// Enum Engine.ELocationBoneSocketSelectionMethod
// NumValues: 0x0003
enum class ELocationBoneSocketSelectionMethod : uint8
{
	BONESOCKETSEL_Sequential                 = 0,
	BONESOCKETSEL_Random                     = 1,
	BONESOCKETSEL_MAX                        = 2,
};

// Enum Engine.ELocationEmitterSelectionMethod
// NumValues: 0x0003
enum class ELocationEmitterSelectionMethod : uint8
{
	ELESM_Random                             = 0,
	ELESM_Sequential                         = 1,
	ELESM_MAX                                = 2,
};

// Enum Engine.CylinderHeightAxis
// NumValues: 0x0004
enum class ECylinderHeightAxis : uint8
{
	PMLPC_HEIGHTAXIS_X                       = 0,
	PMLPC_HEIGHTAXIS_Y                       = 1,
	PMLPC_HEIGHTAXIS_Z                       = 2,
	PMLPC_HEIGHTAXIS_MAX                     = 3,
};

// Enum Engine.ELocationSkelVertSurfaceSource
// NumValues: 0x0003
enum class ELocationSkelVertSurfaceSource : uint8
{
	VERTSURFACESOURCE_Vert                   = 0,
	VERTSURFACESOURCE_Surface                = 1,
	VERTSURFACESOURCE_MAX                    = 2,
};

// Enum Engine.EOrbitChainMode
// NumValues: 0x0004
enum class EOrbitChainMode : uint8
{
	EOChainMode_Add                          = 0,
	EOChainMode_Scale                        = 1,
	EOChainMode_Link                         = 2,
	EOChainMode_MAX                          = 3,
};

// Enum Engine.EParticleAxisLock
// NumValues: 0x000B
enum class EParticleAxisLock : uint8
{
	EPAL_NONE                                = 0,
	EPAL_X                                   = 1,
	EPAL_Y                                   = 2,
	EPAL_Z                                   = 3,
	EPAL_NEGATIVE_X                          = 4,
	EPAL_NEGATIVE_Y                          = 5,
	EPAL_NEGATIVE_Z                          = 6,
	EPAL_ROTATE_X                            = 7,
	EPAL_ROTATE_Y                            = 8,
	EPAL_ROTATE_Z                            = 9,
	EPAL_MAX                                 = 10,
};

// Enum Engine.EEmitterDynamicParameterValue
// NumValues: 0x0007
enum class EEmitterDynamicParameterValue : uint8
{
	EDPV_UserSet                             = 0,
	EDPV_AutoSet                             = 1,
	EDPV_VelocityX                           = 2,
	EDPV_VelocityY                           = 3,
	EDPV_VelocityZ                           = 4,
	EDPV_VelocityMag                         = 5,
	EDPV_MAX                                 = 6,
};

// Enum Engine.EParticleUVFlipMode
// NumValues: 0x0009
enum class EParticleUVFlipMode : uint8
{
	None                                     = 0,
	FlipUV                                   = 1,
	FlipUOnly                                = 2,
	FlipVOnly                                = 3,
	RandomFlipUV                             = 4,
	RandomFlipUOnly                          = 5,
	RandomFlipVOnly                          = 6,
	RandomFlipUVIndependent                  = 7,
	EParticleUVFlipMode_MAX                  = 8,
};

// Enum Engine.EParticleSortMode
// NumValues: 0x0006
enum class EParticleSortMode : uint8
{
	PSORTMODE_None                           = 0,
	PSORTMODE_ViewProjDepth                  = 1,
	PSORTMODE_DistanceToView                 = 2,
	PSORTMODE_Age_OldestFirst                = 3,
	PSORTMODE_Age_NewestFirst                = 4,
	PSORTMODE_MAX                            = 5,
};

// Enum Engine.EEmitterNormalsMode
// NumValues: 0x0004
enum class EEmitterNormalsMode : uint8
{
	ENM_CameraFacing                         = 0,
	ENM_Spherical                            = 1,
	ENM_Cylindrical                          = 2,
	ENM_MAX                                  = 3,
};

// Enum Engine.ETrail2SourceMethod
// NumValues: 0x0004
enum class ETrail2SourceMethod : uint8
{
	PET2SRCM_Default                         = 0,
	PET2SRCM_Particle                        = 1,
	PET2SRCM_Actor                           = 2,
	PET2SRCM_MAX                             = 3,
};

// Enum Engine.EBeam2Method
// NumValues: 0x0004
enum class EBeam2Method : uint8
{
	PEB2M_Distance                           = 0,
	PEB2M_Target                             = 1,
	PEB2M_Branch                             = 2,
	PEB2M_MAX                                = 3,
};

// Enum Engine.EBeamTaperMethod
// NumValues: 0x0004
enum class EBeamTaperMethod : uint8
{
	PEBTM_None                               = 0,
	PEBTM_Full                               = 1,
	PEBTM_Partial                            = 2,
	PEBTM_MAX                                = 3,
};

// Enum Engine.EMeshScreenAlignment
// NumValues: 0x0004
enum class EMeshScreenAlignment : uint8
{
	PSMA_MeshFaceCameraWithRoll              = 0,
	PSMA_MeshFaceCameraWithSpin              = 1,
	PSMA_MeshFaceCameraWithLockedAxis        = 2,
	PSMA_MAX                                 = 3,
};

// Enum Engine.EMeshCameraFacingUpAxis
// NumValues: 0x0006
enum class EMeshCameraFacingUpAxis : uint8
{
	CameraFacing_NoneUP                      = 0,
	CameraFacing_ZUp                         = 1,
	CameraFacing_NegativeZUp                 = 2,
	CameraFacing_YUp                         = 3,
	CameraFacing_NegativeYUp                 = 4,
	CameraFacing_MAX                         = 5,
};

// Enum Engine.EMeshCameraFacingOptions
// NumValues: 0x000E
enum class EMeshCameraFacingOptions : uint8
{
	XAxisFacing_NoUp                         = 0,
	XAxisFacing_ZUp                          = 1,
	XAxisFacing_NegativeZUp                  = 2,
	XAxisFacing_YUp                          = 3,
	XAxisFacing_NegativeYUp                  = 4,
	LockedAxis_ZAxisFacing                   = 5,
	LockedAxis_NegativeZAxisFacing           = 6,
	LockedAxis_YAxisFacing                   = 7,
	LockedAxis_NegativeYAxisFacing           = 8,
	VelocityAligned_ZAxisFacing              = 9,
	VelocityAligned_NegativeZAxisFacing      = 10,
	VelocityAligned_YAxisFacing              = 11,
	VelocityAligned_NegativeYAxisFacing      = 12,
	EMeshCameraFacingOptions_MAX             = 13,
};

// Enum Engine.ETrailsRenderAxisOption
// NumValues: 0x0004
enum class ETrailsRenderAxisOption : uint8
{
	Trails_CameraUp                          = 0,
	Trails_SourceUp                          = 1,
	Trails_WorldUp                           = 2,
	Trails_MAX                               = 3,
};

// Enum Engine.EParticleScreenAlignment
// NumValues: 0x0008
enum class EParticleScreenAlignment : uint8
{
	PSA_FacingCameraPosition                 = 0,
	PSA_Square                               = 1,
	PSA_Rectangle                            = 2,
	PSA_Velocity                             = 3,
	PSA_AwayFromCenter                       = 4,
	PSA_TypeSpecific                         = 5,
	PSA_FacingCameraDistanceBlend            = 6,
	PSA_MAX                                  = 7,
};

// Enum Engine.EParticleSystemUpdateMode
// NumValues: 0x0003
enum class EParticleSystemUpdateMode : uint8
{
	EPSUM_RealTime                           = 0,
	EPSUM_FixedTime                          = 1,
	EPSUM_MAX                                = 2,
};

// Enum Engine.ParticleSystemLODMethod
// NumValues: 0x0004
enum class EParticleSystemLODMethod : uint8
{
	PARTICLESYSTEMLODMETHOD_Automatic        = 0,
	PARTICLESYSTEMLODMETHOD_DirectSet        = 1,
	PARTICLESYSTEMLODMETHOD_ActivateAutomatic = 2,
	PARTICLESYSTEMLODMETHOD_MAX              = 3,
};

// Enum Engine.EParticleSystemOcclusionBoundsMethod
// NumValues: 0x0004
enum class EParticleSystemOcclusionBoundsMethod : uint8
{
	EPSOBM_None                              = 0,
	EPSOBM_ParticleBounds                    = 1,
	EPSOBM_CustomBounds                      = 2,
	EPSOBM_MAX                               = 3,
};

// Enum Engine.EParticleSysParamType
// NumValues: 0x000A
enum class EParticleSysParamType : uint8
{
	PSPT_None                                = 0,
	PSPT_Scalar                              = 1,
	PSPT_ScalarRand                          = 2,
	PSPT_Vector                              = 3,
	PSPT_VectorRand                          = 4,
	PSPT_Color                               = 5,
	PSPT_Actor                               = 6,
	PSPT_Material                            = 7,
	PSPT_VectorUnitRand                      = 8,
	PSPT_MAX                                 = 9,
};

// Enum Engine.ParticleReplayState
// NumValues: 0x0004
enum class EParticleReplayState : uint8
{
	PRS_Disabled                             = 0,
	PRS_Capturing                            = 1,
	PRS_Replaying                            = 2,
	PRS_MAX                                  = 3,
};

// Enum Engine.EParticleEventType
// NumValues: 0x0007
enum class EParticleEventType : uint8
{
	EPET_Any                                 = 0,
	EPET_Spawn                               = 1,
	EPET_Death                               = 2,
	EPET_Collision                           = 3,
	EPET_Burst                               = 4,
	EPET_Blueprint                           = 5,
	EPET_MAX                                 = 6,
};

// Enum Engine.EViewTargetBlendFunction
// NumValues: 0x0007
enum class EViewTargetBlendFunction : uint8
{
	VTBlend_Linear                           = 0,
	VTBlend_Cubic                            = 1,
	VTBlend_EaseIn                           = 2,
	VTBlend_EaseOut                          = 3,
	VTBlend_EaseInOut                        = 4,
	VTBlend_PreBlended                       = 5,
	VTBlend_MAX                              = 6,
};

// Enum Engine.EViewTargetBlendOrder
// NumValues: 0x0003
enum class EViewTargetBlendOrder : uint8
{
	VTBlendOrder_Base                        = 0,
	VTBlendOrder_Override                    = 1,
	VTBlendOrder_MAX                         = 2,
};

// Enum Engine.ERichCurveInterpMode
// NumValues: 0x0005
enum class ERichCurveInterpMode : uint8
{
	RCIM_Linear                              = 0,
	RCIM_Constant                            = 1,
	RCIM_Cubic                               = 2,
	RCIM_None                                = 3,
	RCIM_MAX                                 = 4,
};

// Enum Engine.ERichCurveExtrapolation
// NumValues: 0x0007
enum class ERichCurveExtrapolation : uint8
{
	RCCE_Cycle                               = 0,
	RCCE_CycleWithOffset                     = 1,
	RCCE_Oscillate                           = 2,
	RCCE_Linear                              = 3,
	RCCE_Constant                            = 4,
	RCCE_None                                = 5,
	RCCE_MAX                                 = 6,
};

// Enum Engine.EDemoRecordType
// NumValues: 0x0005
enum class EDemoRecordType : uint8
{
	CommonBattle                             = 0,
	CustomRoomBattle                         = 1,
	LeagueBattle                             = 2,
	Max                                      = 100,
	EDemoRecordType_MAX                      = 101,
};

// Enum Engine.EDemoPlayType
// NumValues: 0x0009
enum class EDemoPlayType : uint8
{
	Replay                                   = 0,
	DeathReplay                              = 1,
	OutsiderOb                               = 2,
	RoomOb                                   = 3,
	EpicMoment                               = 4,
	LeagueOb                                 = 5,
	QSecReplay                               = 6,
	Max                                      = 100,
	EDemoPlayType_MAX                        = 101,
};

// Enum Engine.EDemoProcessState
// NumValues: 0x0005
enum class EDemoProcessState : uint8
{
	Empty                                    = 0,
	Checkpoint                               = 1,
	FastForwarding                           = 2,
	FramePacket                              = 3,
	EDemoProcessState_MAX                    = 4,
};

// Enum Engine.FRepCheckFlag
// NumValues: 0x0007
enum class EFRepCheckFlag : uint8
{
	Replicating                              = 0,
	Dormant                                  = 1,
	InitDormant                              = 2,
	Cached                                   = 3,
	Other                                    = 4,
	Max                                      = 5,
	FRepCheckFlag_MAX                        = 6,
};

// Enum Engine.ReverbPreset
// NumValues: 0x0018
enum class EReverbPreset : uint8
{
	REVERB_Default                           = 0,
	REVERB_Bathroom                          = 1,
	REVERB_StoneRoom                         = 2,
	REVERB_Auditorium                        = 3,
	REVERB_ConcertHall                       = 4,
	REVERB_Cave                              = 5,
	REVERB_Hallway                           = 6,
	REVERB_StoneCorridor                     = 7,
	REVERB_Alley                             = 8,
	REVERB_Forest                            = 9,
	REVERB_City                              = 10,
	REVERB_Mountains                         = 11,
	REVERB_Quarry                            = 12,
	REVERB_Plain                             = 13,
	REVERB_ParkingLot                        = 14,
	REVERB_SewerPipe                         = 15,
	REVERB_Underwater                        = 16,
	REVERB_SmallRoom                         = 17,
	REVERB_MediumRoom                        = 18,
	REVERB_LargeRoom                         = 19,
	REVERB_MediumHall                        = 20,
	REVERB_LargeHall                         = 21,
	REVERB_Plate                             = 22,
	REVERB_MAX                               = 23,
};

// Enum Engine.ERichCurveTangentMode
// NumValues: 0x0006
enum class ERichCurveTangentMode : uint8
{
	RCTM_Auto                                = 0,
	RCTM_User                                = 1,
	RCTM_Break                               = 2,
	RCTM_None                                = 3,
	RCTM_SmartAuto                           = 4,
	RCTM_MAX                                 = 5,
};

// Enum Engine.ERichCurveTangentWeightMode
// NumValues: 0x0005
enum class ERichCurveTangentWeightMode : uint8
{
	RCTWM_WeightedNone                       = 0,
	RCTWM_WeightedArrive                     = 1,
	RCTWM_WeightedLeave                      = 2,
	RCTWM_WeightedBoth                       = 3,
	RCTWM_MAX                                = 4,
};

// Enum Engine.ERichCurveCompressionFormat
// NumValues: 0x0007
enum class ERichCurveCompressionFormat : uint8
{
	RCCF_Empty                               = 0,
	RCCF_Constant                            = 1,
	RCCF_Linear                              = 2,
	RCCF_Cubic                               = 3,
	RCCF_Mixed                               = 4,
	RCCF_Weighted                            = 5,
	RCCF_MAX                                 = 6,
};

// Enum Engine.ERichCurveKeyTimeCompressionFormat
// NumValues: 0x0003
enum class ERichCurveKeyTimeCompressionFormat : uint8
{
	RCKTCF_uint16                            = 0,
	RCKTCF_float32                           = 1,
	RCKTCF_MAX                               = 2,
};

// Enum Engine.ERuntimeVirtualTextureMaterialType
// NumValues: 0x0009
enum class ERuntimeVirtualTextureMaterialType : uint8
{
	BaseColor                                = 0,
	BaseColor_Normal_DEPRECATED              = 1,
	BaseColor_Normal_Roughness               = 2,
	BaseColor_Normal_Specular                = 3,
	BaseColor_Normal_Specular_YCoCg          = 4,
	BaseColor_Normal_Specular_Mask_YCoCg     = 5,
	WorldHeight                              = 6,
	Count                                    = 7,
	ERuntimeVirtualTextureMaterialType_MAX   = 8,
};

// Enum Engine.EDepthOfFieldMethod
// NumValues: 0x0004
enum class EDepthOfFieldMethod : uint8
{
	DOFM_BokehDOF                            = 0,
	DOFM_Gaussian                            = 1,
	DOFM_CircleDOF                           = 2,
	DOFM_MAX                                 = 3,
};

// Enum Engine.EAutoExposureMethod
// NumValues: 0x0004
enum class EAutoExposureMethod : uint8
{
	AEM_Histogram                            = 0,
	AEM_Basic                                = 1,
	AEM_Manual                               = 2,
	AEM_MAX                                  = 3,
};

// Enum Engine.EBloomMethod
// NumValues: 0x0003
enum class EBloomMethod : uint8
{
	BM_SOG                                   = 0,
	BM_FFT                                   = 1,
	BM_MAX                                   = 2,
};

// Enum Engine.EAmbientOcclusionType
// NumValues: 0x0004
enum class EAmbientOcclusionType : uint8
{
	AOT_None                                 = 0,
	AOT_Lagacy                               = 1,
	AOT_LumenShortRange                      = 2,
	AOT_MAX                                  = 3,
};

// Enum Engine.ETemperatureMethod
// NumValues: 0x0003
enum class ETemperatureMethod : uint8
{
	TEMP_WhiteBalance                        = 0,
	TEMP_ColorTemperature                    = 1,
	TEMP_MAX                                 = 2,
};

// Enum Engine.ELightUnits
// NumValues: 0x0005
enum class ELightUnits : uint8
{
	Unitless                                 = 0,
	Candelas                                 = 1,
	Lumens                                   = 2,
	EV                                       = 3,
	ELightUnits_MAX                          = 4,
};

// Enum Engine.EReflectionsType
// NumValues: 0x0003
enum class EReflectionsType : uint8
{
	ScreenSpace                              = 0,
	RayTracing                               = 1,
	EReflectionsType_MAX                     = 2,
};

// Enum Engine.ELumenRayLightingModeOverride
// NumValues: 0x0004
enum class ELumenRayLightingModeOverride : uint8
{
	Default                                  = 0,
	SurfaceCache                             = 1,
	HitLighting                              = 2,
	ELumenRayLightingModeOverride_MAX        = 3,
};

// Enum Engine.ETranslucencyType
// NumValues: 0x0003
enum class ETranslucencyType : uint8
{
	Raster                                   = 0,
	RayTracing                               = 1,
	ETranslucencyType_MAX                    = 2,
};

// Enum Engine.ERayTracingGlobalIlluminationType
// NumValues: 0x0004
enum class ERayTracingGlobalIlluminationType : uint8
{
	Disabled                                 = 0,
	BruteForce                               = 1,
	FinalGather                              = 2,
	ERayTracingGlobalIlluminationType_MAX    = 3,
};

// Enum Engine.EReflectedAndRefractedRayTracedShadows
// NumValues: 0x0004
enum class EReflectedAndRefractedRayTracedShadows : uint8
{
	Disabled                                 = 0,
	Hard_shadows                             = 1,
	Area_shadows                             = 2,
	EReflectedAndRefractedRayTracedShadows_MAX = 3,
};

// Enum Engine.EMobilePlanarReflectionMode
// NumValues: 0x0004
enum class EMobilePlanarReflectionMode : uint8
{
	Usual                                    = 0,
	MobilePPRExclusive                       = 1,
	MobilePPR                                = 2,
	EMobilePlanarReflectionMode_MAX          = 3,
};

// Enum Engine.EMobilePixelProjectedReflectionQuality
// NumValues: 0x0005
enum class EMobilePixelProjectedReflectionQuality : uint8
{
	Disabled                                 = 0,
	BestPerformance                          = 1,
	BetterQuality                            = 2,
	BestQuality                              = 3,
	EMobilePixelProjectedReflectionQuality_MAX = 4,
};

// Enum Engine.EScenePaintTeamType
// NumValues: 0x0004
enum class EScenePaintTeamType : uint8
{
	Blue                                     = 0,
	Red                                      = 1,
	Max                                      = 2,
	EScenePaintTeamType_MAX                  = 3,
};

// Enum Engine.EScenePaintType
// NumValues: 0x0004
enum class EScenePaintType : uint8
{
	Addition                                 = 0,
	Digging                                  = 1,
	Max                                      = 2,
	EScenePaintType_MAX                      = 3,
};

// Enum Engine.EMaterialProperty
// NumValues: 0x0024
enum class EMaterialProperty : uint8
{
	MP_EmissiveColor                         = 0,
	MP_Opacity                               = 1,
	MP_OpacityMask                           = 2,
	MP_DiffuseColor                          = 3,
	MP_SpecularColor                         = 4,
	MP_BaseColor                             = 5,
	MP_Metallic                              = 6,
	MP_Specular                              = 7,
	MP_Roughness                             = 8,
	MP_Anisotropy                            = 9,
	MP_Normal                                = 10,
	MP_Tangent                               = 11,
	MP_WorldPositionOffset                   = 12,
	MP_WorldDisplacement_DEPRECATED          = 13,
	MP_TessellationMultiplier_DEPRECATED     = 14,
	MP_SubsurfaceColor                       = 15,
	MP_CustomData0                           = 16,
	MP_CustomData1                           = 17,
	MP_AmbientOcclusion                      = 18,
	MP_Refraction                            = 19,
	MP_CustomizedUVs0                        = 20,
	MP_CustomizedUVs1                        = 21,
	MP_CustomizedUVs2                        = 22,
	MP_CustomizedUVs3                        = 23,
	MP_CustomizedUVs4                        = 24,
	MP_CustomizedUVs5                        = 25,
	MP_CustomizedUVs6                        = 26,
	MP_CustomizedUVs7                        = 27,
	MP_PixelDepthOffset                      = 28,
	MP_ShadingModel                          = 29,
	MP_FrontMaterial                         = 30,
	MP_SurfaceThickness                      = 31,
	MP_Displacement                          = 32,
	MP_MaterialAttributes                    = 33,
	MP_CustomOutput                          = 34,
	MP_MAX                                   = 35,
};

// Enum Engine.EAntiAliasingMethod
// NumValues: 0x0007
enum class EAntiAliasingMethod : uint8
{
	AAM_None                                 = 0,
	AAM_FXAA                                 = 1,
	AAM_TemporalAA                           = 2,
	AAM_SMAA                                 = 3,
	AAM_MSAA                                 = 4,
	AAM_TSR                                  = 5,
	AAM_MAX                                  = 6,
};

// Enum Engine.SkeletalMeshTerminationCriterion
// NumValues: 0x0007
enum class ESkeletalMeshTerminationCriterion : uint8
{
	SMTC_NumOfTriangles                      = 0,
	SMTC_NumOfVerts                          = 1,
	SMTC_TriangleOrVert                      = 2,
	SMTC_AbsNumOfTriangles                   = 3,
	SMTC_AbsNumOfVerts                       = 4,
	SMTC_AbsTriangleOrVert                   = 5,
	SMTC_MAX                                 = 6,
};

// Enum Engine.SkeletalMeshOptimizationType
// NumValues: 0x0004
enum class ESkeletalMeshOptimizationType : uint8
{
	SMOT_NumOfTriangles                      = 0,
	SMOT_MaxDeviation                        = 1,
	SMOT_TriangleOrDeviation                 = 2,
	SMOT_MAX                                 = 3,
};

// Enum Engine.SkeletalMeshOptimizationImportance
// NumValues: 0x0007
enum class ESkeletalMeshOptimizationImportance : uint8
{
	SMOI_Off                                 = 0,
	SMOI_Lowest                              = 1,
	SMOI_Low                                 = 2,
	SMOI_Normal                              = 3,
	SMOI_High                                = 4,
	SMOI_Highest                             = 5,
	SMOI_MAX                                 = 6,
};

// Enum Engine.ESkinVertexColorChannel
// NumValues: 0x0006
enum class ESkinVertexColorChannel : uint8
{
	Red                                      = 0,
	Green                                    = 1,
	Blue                                     = 2,
	Alpha                                    = 3,
	None                                     = 3,
	ESkinVertexColorChannel_MAX              = 4,
};

// Enum Engine.EBoneVisibilityStatus
// NumValues: 0x0004
enum class EBoneVisibilityStatus : uint8
{
	BVS_HiddenByParent                       = 0,
	BVS_Visible                              = 1,
	BVS_ExplicitlyHidden                     = 2,
	BVS_MAX                                  = 3,
};

// Enum Engine.EPhysBodyOp
// NumValues: 0x0003
enum class EPhysBodyOp : uint8
{
	PBO_None                                 = 0,
	PBO_Term                                 = 1,
	PBO_MAX                                  = 2,
};

// Enum Engine.EVisibilityBasedAnimTickOption
// NumValues: 0x0005
enum class EVisibilityBasedAnimTickOption : uint8
{
	AlwaysTickPoseAndRefreshBones            = 0,
	AlwaysTickPose                           = 1,
	OnlyTickMontagesWhenNotRendered          = 2,
	OnlyTickPoseWhenRendered                 = 3,
	EVisibilityBasedAnimTickOption_MAX       = 4,
};

// Enum Engine.EBoneSpaces
// NumValues: 0x0003
enum class EBoneSpaces : uint8
{
	WorldSpace                               = 0,
	ComponentSpace                           = 1,
	EBoneSpaces_MAX                          = 2,
};

// Enum Engine.ESkyLightSourceType
// NumValues: 0x0003
enum class ESkyLightSourceType : uint8
{
	SLS_CapturedScene                        = 0,
	SLS_SpecifiedCubemap                     = 1,
	SLS_MAX                                  = 2,
};

// Enum Engine.ESoundDistanceCalc
// NumValues: 0x0005
enum class ESoundDistanceCalc : uint8
{
	SOUNDDISTANCE_Normal                     = 0,
	SOUNDDISTANCE_InfiniteXYPlane            = 1,
	SOUNDDISTANCE_InfiniteXZPlane            = 2,
	SOUNDDISTANCE_InfiniteYZPlane            = 3,
	SOUNDDISTANCE_MAX                        = 4,
};

// Enum Engine.ESoundSpatializationAlgorithm
// NumValues: 0x0003
enum class ESoundSpatializationAlgorithm : uint8
{
	SPATIALIZATION_Default                   = 0,
	SPATIALIZATION_HRTF                      = 1,
	SPATIALIZATION_MAX                       = 2,
};

// Enum Engine.EAirAbsorptionMethod
// NumValues: 0x0003
enum class EAirAbsorptionMethod : uint8
{
	Linear                                   = 0,
	CustomCurve                              = 1,
	EAirAbsorptionMethod_MAX                 = 2,
};

// Enum Engine.EReverbSendMethod
// NumValues: 0x0004
enum class EReverbSendMethod : uint8
{
	Linear                                   = 0,
	CustomCurve                              = 1,
	Manual                                   = 2,
	EReverbSendMethod_MAX                    = 3,
};

// Enum Engine.ESubmixSendMethod
// NumValues: 0x0004
enum class ESubmixSendMethod : uint8
{
	Linear                                   = 0,
	CustomCurve                              = 1,
	Manual                                   = 2,
	ESubmixSendMethod_MAX                    = 3,
};

// Enum Engine.EPriorityAttenuationMethod
// NumValues: 0x0004
enum class EPriorityAttenuationMethod : uint8
{
	Linear                                   = 0,
	CustomCurve                              = 1,
	Manual                                   = 2,
	EPriorityAttenuationMethod_MAX           = 3,
};

// Enum Engine.ENonSpatializedRadiusSpeakerMapMode
// NumValues: 0x0004
enum class ENonSpatializedRadiusSpeakerMapMode : uint8
{
	OmniDirectional                          = 0,
	Direct2D                                 = 1,
	Surround2D                               = 2,
	ENonSpatializedRadiusSpeakerMapMode_MAX  = 3,
};

// Enum Engine.ESoundGroup
// NumValues: 0x001A
enum class ESoundGroup : uint8
{
	SOUNDGROUP_Default                       = 0,
	SOUNDGROUP_Effects                       = 1,
	SOUNDGROUP_UI                            = 2,
	SOUNDGROUP_Music                         = 3,
	SOUNDGROUP_Voice                         = 4,
	SOUNDGROUP_GameSoundGroup1               = 5,
	SOUNDGROUP_GameSoundGroup2               = 6,
	SOUNDGROUP_GameSoundGroup3               = 7,
	SOUNDGROUP_GameSoundGroup4               = 8,
	SOUNDGROUP_GameSoundGroup5               = 9,
	SOUNDGROUP_GameSoundGroup6               = 10,
	SOUNDGROUP_GameSoundGroup7               = 11,
	SOUNDGROUP_GameSoundGroup8               = 12,
	SOUNDGROUP_GameSoundGroup9               = 13,
	SOUNDGROUP_GameSoundGroup10              = 14,
	SOUNDGROUP_GameSoundGroup11              = 15,
	SOUNDGROUP_GameSoundGroup12              = 16,
	SOUNDGROUP_GameSoundGroup13              = 17,
	SOUNDGROUP_GameSoundGroup14              = 18,
	SOUNDGROUP_GameSoundGroup15              = 19,
	SOUNDGROUP_GameSoundGroup16              = 20,
	SOUNDGROUP_GameSoundGroup17              = 21,
	SOUNDGROUP_GameSoundGroup18              = 22,
	SOUNDGROUP_GameSoundGroup19              = 23,
	SOUNDGROUP_GameSoundGroup20              = 24,
	SOUNDGROUP_MAX                           = 25,
};

// Enum Engine.ModulationParamMode
// NumValues: 0x0004
enum class EModulationParamMode : uint8
{
	MPM_Normal                               = 0,
	MPM_Abs                                  = 1,
	MPM_Direct                               = 2,
	MPM_MAX                                  = 3,
};

// Enum Engine.ESourceBusSendLevelControlMethod
// NumValues: 0x0004
enum class ESourceBusSendLevelControlMethod : uint8
{
	Linear                                   = 0,
	CustomCurve                              = 1,
	Manual                                   = 2,
	ESourceBusSendLevelControlMethod_MAX     = 3,
};

// Enum Engine.EDecompressionType
// NumValues: 0x0009
enum class EDecompressionType : uint8
{
	DTYPE_Setup                              = 0,
	DTYPE_Invalid                            = 1,
	DTYPE_Preview                            = 2,
	DTYPE_Native                             = 3,
	DTYPE_RealTime                           = 4,
	DTYPE_Procedural                         = 5,
	DTYPE_Xenon                              = 6,
	DTYPE_Streaming                          = 7,
	DTYPE_MAX                                = 8,
};

// Enum Engine.ESoundWaveFFTSize
// NumValues: 0x0006
enum class ESoundWaveFFTSize : uint8
{
	VerySmall_64                             = 0,
	Small_256                                = 1,
	Medium_512                               = 2,
	Large_1024                               = 3,
	VeryLarge_2048                           = 4,
	ESoundWaveFFTSize_MAX                    = 5,
};

// Enum Engine.ESoundAssetCompressionType
// NumValues: 0x0006
enum class ESoundAssetCompressionType : uint8
{
	BinkAudio                                = 0,
	ADPCM                                    = 1,
	PCM                                      = 2,
	PlatformSpecific                         = 3,
	ProjectDefined                           = 4,
	ESoundAssetCompressionType_MAX           = 5,
};

// Enum Engine.ESoundWaveLoadingBehavior
// NumValues: 0x0007
enum class ESoundWaveLoadingBehavior : uint8
{
	Inherited                                = 0,
	RetainOnLoad                             = 1,
	PrimeOnLoad                              = 2,
	LoadOnDemand                             = 3,
	ForceInline                              = 4,
	Uninitialized                            = 255,
	ESoundWaveLoadingBehavior_MAX            = 256,
};

// Enum Engine.EStereoLayerType
// NumValues: 0x0004
enum class EStereoLayerType : uint8
{
	SLT_WorldLocked                          = 0,
	SLT_TrackerLocked                        = 1,
	SLT_FaceLocked                           = 2,
	SLT_MAX                                  = 3,
};

// Enum Engine.EStereoLayerShape
// NumValues: 0x0005
enum class EStereoLayerShape : uint8
{
	SLSH_QuadLayer                           = 0,
	SLSH_CylinderLayer                       = 1,
	SLSH_CubemapLayer                        = 2,
	SLSH_EquirectLayer                       = 3,
	SLSH_MAX                                 = 4,
};

// Enum Engine.EChunkSeekTableMode
// NumValues: 0x0003
enum class EChunkSeekTableMode : uint8
{
	ConstantSamplesPerEntry                  = 0,
	VariableSamplesPerEntry                  = 1,
	EChunkSeekTableMode_MAX                  = 2,
};

// Enum Engine.ESubUVBoundingVertexCount
// NumValues: 0x0003
enum class ESubUVBoundingVertexCount : uint8
{
	BVC_FourVertices                         = 0,
	BVC_EightVertices                        = 1,
	BVC_MAX                                  = 2,
};

// Enum Engine.EOpacitySourceMode
// NumValues: 0x0006
enum class EOpacitySourceMode : uint8
{
	OSM_Alpha                                = 0,
	OSM_ColorBrightness                      = 1,
	OSM_RedChannel                           = 2,
	OSM_GreenChannel                         = 3,
	OSM_BlueChannel                          = 4,
	OSM_MAX                                  = 5,
};

// Enum Engine.ETaskSyncPoint
// NumValues: 0x000D
enum class ETaskSyncPoint : uint8
{
	TSP_FrameStart                           = 0,
	TSP_NetTickEnd                           = 1,
	TSP_BeginTicksEnd                        = 2,
	TSP_PrePhysicsEnd                        = 3,
	TSP_StartPhysicsEnd                      = 4,
	TSP_DuringPhysicsEnd                     = 5,
	TSP_EndPhysicsEnd                        = 6,
	TSP_PostPhysicsEnd                       = 7,
	TSP_PostUpdateWorkEnd                    = 8,
	TSP_LastDemotableEnd                     = 9,
	TSP_FrameEnd                             = 10,
	TSP_Max                                  = 11,
	TSP_Max_0                                = 12,
};

// Enum Engine.EHorizTextAligment
// NumValues: 0x0004
enum class EHorizTextAligment : uint8
{
	EHTA_Left                                = 0,
	EHTA_Center                              = 1,
	EHTA_Right                               = 2,
	EHTA_MAX                                 = 3,
};

// Enum Engine.EVerticalTextAligment
// NumValues: 0x0005
enum class EVerticalTextAligment : uint8
{
	EVRTA_TextTop                            = 0,
	EVRTA_TextCenter                         = 1,
	EVRTA_TextBottom                         = 2,
	EVRTA_QuadTop                            = 3,
	EVRTA_MAX                                = 4,
};

// Enum Engine.TextureGroup
// NumValues: 0x0043
enum class ETextureGroup : uint8
{
	TEXTUREGROUP_World                       = 0,
	TEXTUREGROUP_WorldNormalMap              = 1,
	TEXTUREGROUP_WorldSpecular               = 2,
	TEXTUREGROUP_Character                   = 3,
	TEXTUREGROUP_CharacterNormalMap          = 4,
	TEXTUREGROUP_CharacterSpecular           = 5,
	TEXTUREGROUP_Weapon                      = 6,
	TEXTUREGROUP_WeaponNormalMap             = 7,
	TEXTUREGROUP_WeaponSpecular              = 8,
	TEXTUREGROUP_Vehicle                     = 9,
	TEXTUREGROUP_VehicleNormalMap            = 10,
	TEXTUREGROUP_VehicleSpecular             = 11,
	TEXTUREGROUP_Cinematic                   = 12,
	TEXTUREGROUP_Effects                     = 13,
	TEXTUREGROUP_EffectsNotFiltered          = 14,
	TEXTUREGROUP_Skybox                      = 15,
	TEXTUREGROUP_UI                          = 16,
	TEXTUREGROUP_Lightmap                    = 17,
	TEXTUREGROUP_RenderTarget                = 18,
	TEXTUREGROUP_MobileFlattened             = 19,
	TEXTUREGROUP_ProcBuilding_Face           = 20,
	TEXTUREGROUP_ProcBuilding_LightMap       = 21,
	TEXTUREGROUP_Shadowmap                   = 22,
	TEXTUREGROUP_ColorLookupTable            = 23,
	TEXTUREGROUP_Terrain_Heightmap           = 24,
	TEXTUREGROUP_Terrain_Weightmap           = 25,
	TEXTUREGROUP_Bokeh                       = 26,
	TEXTUREGROUP_IESLightProfile             = 27,
	TEXTUREGROUP_Pixels2D                    = 28,
	TEXTUREGROUP_HierarchicalLOD             = 29,
	TEXTUREGROUP_Impostor                    = 30,
	TEXTUREGROUP_ImpostorNormalDepth         = 31,
	TEXTUREGROUP_8BitData                    = 32,
	TEXTUREGROUP_16BitData                   = 33,
	TEXTUREGROUP_Project01                   = 34,
	TEXTUREGROUP_Project02                   = 35,
	TEXTUREGROUP_Project03                   = 36,
	TEXTUREGROUP_Project04                   = 37,
	TEXTUREGROUP_Project05                   = 38,
	TEXTUREGROUP_Project06                   = 39,
	TEXTUREGROUP_Project07                   = 40,
	TEXTUREGROUP_Project08                   = 41,
	TEXTUREGROUP_Project09                   = 42,
	TEXTUREGROUP_Project10                   = 43,
	TEXTUREGROUP_Project11                   = 44,
	TEXTUREGROUP_Project12                   = 45,
	TEXTUREGROUP_Project13                   = 46,
	TEXTUREGROUP_Project14                   = 47,
	TEXTUREGROUP_Project15                   = 48,
	TEXTUREGROUP_Project16                   = 49,
	TEXTUREGROUP_Project17                   = 50,
	TEXTUREGROUP_Project18                   = 51,
	TEXTUREGROUP_Project19                   = 52,
	TEXTUREGROUP_Project20                   = 53,
	TEXTUREGROUP_Project21                   = 54,
	TEXTUREGROUP_Project22                   = 55,
	TEXTUREGROUP_Project23                   = 56,
	TEXTUREGROUP_Project24                   = 57,
	TEXTUREGROUP_Project25                   = 58,
	TEXTUREGROUP_Project26                   = 59,
	TEXTUREGROUP_Project27                   = 60,
	TEXTUREGROUP_Project28                   = 61,
	TEXTUREGROUP_Project29                   = 62,
	TEXTUREGROUP_Project30                   = 63,
	TEXTUREGROUP_Project31                   = 64,
	TEXTUREGROUP_Project32                   = 65,
	TEXTUREGROUP_MAX                         = 66,
};

// Enum Engine.TextureMipGenSettings
// NumValues: 0x0017
enum class ETextureMipGenSettings : uint8
{
	TMGS_FromTextureGroup                    = 0,
	TMGS_SimpleAverage                       = 1,
	TMGS_Sharpen0                            = 2,
	TMGS_Sharpen1                            = 3,
	TMGS_Sharpen2                            = 4,
	TMGS_Sharpen3                            = 5,
	TMGS_Sharpen4                            = 6,
	TMGS_Sharpen5                            = 7,
	TMGS_Sharpen6                            = 8,
	TMGS_Sharpen7                            = 9,
	TMGS_Sharpen8                            = 10,
	TMGS_Sharpen9                            = 11,
	TMGS_Sharpen10                           = 12,
	TMGS_NoMipmaps                           = 13,
	TMGS_LeaveExistingMips                   = 14,
	TMGS_Blur1                               = 15,
	TMGS_Blur2                               = 16,
	TMGS_Blur3                               = 17,
	TMGS_Blur4                               = 18,
	TMGS_Blur5                               = 19,
	TMGS_Unfiltered                          = 20,
	TMGS_Angular                             = 21,
	TMGS_MAX                                 = 22,
};

// Enum Engine.ETexturePowerOfTwoSetting
// NumValues: 0x0004
enum class ETexturePowerOfTwoSetting : uint8
{
	None                                     = 0,
	PadToPowerOfTwo                          = 1,
	PadToSquarePowerOfTwo                    = 2,
	ETexturePowerOfTwoSetting_MAX            = 3,
};

// Enum Engine.ETextureSamplerFilter
// NumValues: 0x0006
enum class ETextureSamplerFilter : uint8
{
	Point                                    = 0,
	Bilinear                                 = 1,
	Trilinear                                = 2,
	AnisotropicPoint                         = 3,
	AnisotropicLinear                        = 4,
	ETextureSamplerFilter_MAX                = 5,
};

// Enum Engine.ETextureMipLoadOptions
// NumValues: 0x0004
enum class ETextureMipLoadOptions : uint8
{
	Default                                  = 0,
	AllMips                                  = 1,
	OnlyFirstMip                             = 2,
	ETextureMipLoadOptions_MAX               = 3,
};

// Enum Engine.ETextureDownscaleOptions
// NumValues: 0x000F
enum class ETextureDownscaleOptions : uint8
{
	Default                                  = 0,
	Unfiltered                               = 1,
	SimpleAverage                            = 2,
	Sharpen0                                 = 3,
	Sharpen1                                 = 4,
	Sharpen2                                 = 5,
	Sharpen3                                 = 6,
	Sharpen4                                 = 7,
	Sharpen5                                 = 8,
	Sharpen6                                 = 9,
	Sharpen7                                 = 10,
	Sharpen8                                 = 11,
	Sharpen9                                 = 12,
	Sharpen10                                = 13,
	ETextureDownscaleOptions_MAX             = 14,
};

// Enum Engine.ETextureLossyCompressionAmount
// NumValues: 0x0008
enum class ETextureLossyCompressionAmount : uint8
{
	TLCA_Default                             = 0,
	TLCA_None                                = 1,
	TLCA_Lowest                              = 2,
	TLCA_Low                                 = 3,
	TLCA_Medium                              = 4,
	TLCA_High                                = 5,
	TLCA_Highest                             = 6,
	TLCA_MAX                                 = 7,
};

// Enum Engine.ETextureEncodeSpeed
// NumValues: 0x0004
enum class ETextureEncodeSpeed : uint8
{
	Final                                    = 0,
	FinalIfAvailable                         = 1,
	Fast                                     = 2,
	ETextureEncodeSpeed_MAX                  = 3,
};

// Enum Engine.ETextureClass
// NumValues: 0x000B
enum class ETextureClass : uint8
{
	Invalid                                  = 0,
	TwoD                                     = 1,
	Cube                                     = 2,
	Array                                    = 3,
	CubeArray                                = 4,
	Volume                                   = 5,
	TwoDDynamic                              = 6,
	RenderTarget                             = 7,
	Other2DNoSource                          = 8,
	OtherUnknown                             = 9,
	ETextureClass_MAX                        = 10,
};

// Enum Engine.ECompositeTextureMode
// NumValues: 0x0006
enum class ECompositeTextureMode : uint8
{
	CTM_Disabled                             = 0,
	CTM_NormalRoughnessToRed                 = 1,
	CTM_NormalRoughnessToGreen               = 2,
	CTM_NormalRoughnessToBlue                = 3,
	CTM_NormalRoughnessToAlpha               = 4,
	CTM_MAX                                  = 5,
};

// Enum Engine.ETextureSourceCompressionFormat
// NumValues: 0x0004
enum class ETextureSourceCompressionFormat : uint8
{
	TSCF_None                                = 0,
	TSCF_PNG                                 = 1,
	TSCF_JPEG                                = 2,
	TSCF_MAX                                 = 3,
};

// Enum Engine.ETextureSourceFormat
// NumValues: 0x000F
enum class ETextureSourceFormat : uint8
{
	TSF_Invalid                              = 0,
	TSF_G8                                   = 1,
	TSF_BGRA8                                = 2,
	TSF_BGRE8                                = 3,
	TSF_RGBA16                               = 4,
	TSF_RGBA16F                              = 5,
	TSF_RGBA8_DEPRECATED                     = 6,
	TSF_RGBE8_DEPRECATED                     = 7,
	TSF_G16                                  = 8,
	TSF_RGBA32F                              = 9,
	TSF_R16F                                 = 10,
	TSF_R32F                                 = 11,
	TSF_MAX                                  = 12,
	TSF_RGBA8                                = 6,
	TSF_RGBE8                                = 7,
};

// Enum Engine.TextureCompressionSettings
// NumValues: 0x0012
enum class ETextureCompressionSettings : uint8
{
	TC_Default                               = 0,
	TC_Normalmap                             = 1,
	TC_Masks                                 = 2,
	TC_Grayscale                             = 3,
	TC_Displacementmap                       = 4,
	TC_VectorDisplacementmap                 = 5,
	TC_HDR                                   = 6,
	TC_EditorIcon                            = 7,
	TC_Alpha                                 = 8,
	TC_DistanceFieldFont                     = 9,
	TC_HDR_Compressed                        = 10,
	TC_BC7                                   = 11,
	TC_HalfFloat                             = 12,
	TC_LQ                                    = 13,
	TC_EncodedReflectionCapture              = 14,
	TC_SingleFloat                           = 15,
	TC_HDR_F32                               = 16,
	TC_MAX                                   = 17,
};

// Enum Engine.ETextureSourceEncoding
// NumValues: 0x0012
enum class ETextureSourceEncoding : uint8
{
	TSE_None                                 = 0,
	TSE_Linear                               = 1,
	TSE_sRGB                                 = 2,
	TSE_ST2084                               = 3,
	TSE_Gamma22                              = 4,
	TSE_BT1886                               = 5,
	TSE_Gamma26                              = 6,
	TSE_Cineon                               = 7,
	TSE_REDLog                               = 8,
	TSE_REDLog3G10                           = 9,
	TSE_SLog1                                = 10,
	TSE_SLog2                                = 11,
	TSE_SLog3                                = 12,
	TSE_AlexaV3LogC                          = 13,
	TSE_CanonLog                             = 14,
	TSE_ProTune                              = 15,
	TSE_VLog                                 = 16,
	TSE_MAX                                  = 17,
};

// Enum Engine.ETextureColorSpace
// NumValues: 0x0010
enum class ETextureColorSpace : uint8
{
	TCS_None                                 = 0,
	TCS_sRGB                                 = 1,
	TCS_Rec2020                              = 2,
	TCS_ACESAP0                              = 3,
	TCS_ACESAP1                              = 4,
	TCS_P3DCI                                = 5,
	TCS_P3D65                                = 6,
	TCS_REDWideGamut                         = 7,
	TCS_SonySGamut3                          = 8,
	TCS_SonySGamut3Cine                      = 9,
	TCS_AlexaWideGamut                       = 10,
	TCS_CanonCinemaGamut                     = 11,
	TCS_GoProProtuneNative                   = 12,
	TCS_PanasonicVGamut                      = 13,
	TCS_Custom                               = 99,
	TCS_MAX                                  = 100,
};

// Enum Engine.TextureCookPlatformTilingSettings
// NumValues: 0x0004
enum class ETextureCookPlatformTilingSettings : uint8
{
	TCPTS_FromTextureGroup                   = 0,
	TCPTS_Tile                               = 1,
	TCPTS_DoNotTile                          = 2,
	TCPTS_MAX                                = 3,
};

// Enum Engine.ETextureChromaticAdaptationMethod
// NumValues: 0x0004
enum class ETextureChromaticAdaptationMethod : uint8
{
	TCAM_None                                = 0,
	TCAM_Bradford                            = 1,
	TCAM_CAT02                               = 2,
	TCAM_MAX                                 = 3,
};

// Enum Engine.TextureFilter
// NumValues: 0x0005
enum class ETextureFilter : uint8
{
	TF_Nearest                               = 0,
	TF_Bilinear                              = 1,
	TF_Trilinear                             = 2,
	TF_Default                               = 3,
	TF_MAX                                   = 4,
};

// Enum Engine.TextureAddress
// NumValues: 0x0004
enum class ETextureAddress : uint8
{
	TA_Wrap                                  = 0,
	TA_Clamp                                 = 1,
	TA_Mirror                                = 2,
	TA_MAX                                   = 3,
};

// Enum Engine.ETextureMipCount
// NumValues: 0x0004
enum class ETextureMipCount : uint8
{
	TMC_ResidentMips                         = 0,
	TMC_AllMips                              = 1,
	TMC_AllMipsBiased                        = 2,
	TMC_MAX                                  = 3,
};

// Enum Engine.ETextureCompressionQuality
// NumValues: 0x0007
enum class ETextureCompressionQuality : uint8
{
	TCQ_Default                              = 0,
	TCQ_Lowest                               = 1,
	TCQ_Low                                  = 2,
	TCQ_Medium                               = 3,
	TCQ_High                                 = 4,
	TCQ_Highest                              = 5,
	TCQ_MAX                                  = 6,
};

// Enum Engine.ETimelineLengthMode
// NumValues: 0x0003
enum class ETimelineLengthMode : uint8
{
	TL_TimelineLength                        = 0,
	TL_LastKeyFrame                          = 1,
	TL_MAX                                   = 2,
};

// Enum Engine.ETimelineDirection
// NumValues: 0x0003
enum class ETimelineDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	ETimelineDirection_MAX                   = 2,
};

// Enum Engine.ETimerType
// NumValues: 0x0004
enum class ETimerType : uint8
{
	Default                                  = 0,
	WorldCommon                              = 1,
	UnPausable                               = 2,
	ETimerType_MAX                           = 3,
};

// Enum Engine.ETwitterRequestMethod
// NumValues: 0x0004
enum class ETwitterRequestMethod : uint8
{
	TRM_Get                                  = 0,
	TRM_Post                                 = 1,
	TRM_Delete                               = 2,
	TRM_MAX                                  = 3,
};

// Enum Engine.ETwitterIntegrationDelegate
// NumValues: 0x0004
enum class ETwitterIntegrationDelegate : uint8
{
	TID_AuthorizeComplete                    = 0,
	TID_TweetUIComplete                      = 1,
	TID_RequestComplete                      = 2,
	TID_MAX                                  = 3,
};

// Enum Engine.EUserDefinedStructureStatus
// NumValues: 0x0005
enum class EUserDefinedStructureStatus : uint8
{
	UDSS_UpToDate                            = 0,
	UDSS_Dirty                               = 1,
	UDSS_Error                               = 2,
	UDSS_Duplicate                           = 3,
	UDSS_MAX                                 = 4,
};

// Enum Engine.EVectorFieldConstructionOp
// NumValues: 0x0003
enum class EVectorFieldConstructionOp : uint8
{
	VFCO_Extrude                             = 0,
	VFCO_Revolve                             = 1,
	VFCO_MAX                                 = 2,
};

// Enum Engine.ESplitScreenType
// NumValues: 0x000C
enum class ESplitScreenType : uint8
{
	None                                     = 0,
	TwoPlayer_Horizontal                     = 1,
	TwoPlayer_Vertical                       = 2,
	ThreePlayer_FavorTop                     = 3,
	ThreePlayer_FavorBottom                  = 4,
	ThreePlayer_Vertical                     = 5,
	ThreePlayer_Horizontal                   = 6,
	FourPlayer_Grid                          = 7,
	FourPlayer_Vertical                      = 8,
	FourPlayer_Horizontal                    = 9,
	SplitTypeCount                           = 10,
	ESplitScreenType_MAX                     = 11,
};

// Enum Engine.EWindSourceType
// NumValues: 0x0003
enum class EWindSourceType : uint8
{
	Directional                              = 0,
	Point                                    = 1,
	EWindSourceType_MAX                      = 2,
};

// Enum Engine.EVisibilityAggressiveness
// NumValues: 0x0005
enum class EVisibilityAggressiveness : uint8
{
	VIS_LeastAggressive                      = 0,
	VIS_ModeratelyAggressive                 = 1,
	VIS_MostAggressive                       = 2,
	VIS_Max                                  = 3,
	VIS_Max_0                                = 4,
};

// Enum Engine.EVolumeLightingMethod
// NumValues: 0x0003
enum class EVolumeLightingMethod : uint8
{
	VLM_VolumetricLightmap                   = 0,
	VLM_SparseVolumeLightingSamples          = 1,
	VLM_MAX                                  = 2,
};

// Enum Engine.EHierarchicalSimplificationMethod
// NumValues: 0x0005
enum class EHierarchicalSimplificationMethod : uint8
{
	None                                     = 0,
	Merge                                    = 1,
	Simplify                                 = 2,
	Approximate                              = 3,
	EHierarchicalSimplificationMethod_MAX    = 4,
};

// Enum Engine.EQuartzTimeSignatureQuantization
// NumValues: 0x0007
enum class EQuartzTimeSignatureQuantization : uint8
{
	HalfNote                                 = 0,
	QuarterNote                              = 1,
	EighthNote                               = 2,
	SixteenthNote                            = 3,
	ThirtySecondNote                         = 4,
	Count                                    = 5,
	EQuartzTimeSignatureQuantization_MAX     = 6,
};

// Enum Engine.EQuartzDelegateType
// NumValues: 0x0004
enum class EQuartzDelegateType : uint8
{
	MetronomeTick                            = 0,
	CommandEvent                             = 1,
	Count                                    = 2,
	EQuartzDelegateType_MAX                  = 3,
};

// Enum Engine.EQuarztQuantizationReference
// NumValues: 0x0005
enum class EQuarztQuantizationReference : uint8
{
	BarRelative                              = 0,
	TransportRelative                        = 1,
	CurrentTimeRelative                      = 2,
	Count                                    = 3,
	EQuarztQuantizationReference_MAX         = 4,
};

// Enum Engine.EQuartzCommandType
// NumValues: 0x0009
enum class EQuartzCommandType : uint8
{
	PlaySound                                = 0,
	QueueSoundToPlay                         = 1,
	RetriggerSound                           = 2,
	TickRateChange                           = 3,
	TransportReset                           = 4,
	StartOtherClock                          = 5,
	Notify                                   = 6,
	Custom                                   = 7,
	EQuartzCommandType_MAX                   = 8,
};

// Enum Engine.EActorUpdateOverlapsMethod
// NumValues: 0x0005
enum class EActorUpdateOverlapsMethod : uint8
{
	UseConfigDefault                         = 0,
	AlwaysUpdate                             = 1,
	OnlyUpdateMovable                        = 2,
	NeverUpdate                              = 3,
	EActorUpdateOverlapsMethod_MAX           = 4,
};

// Enum Engine.ESpawnActorScaleMethod
// NumValues: 0x0004
enum class ESpawnActorScaleMethod : uint8
{
	OverrideRootScale                        = 0,
	MultiplyWithRoot                         = 1,
	SelectDefaultAtRuntime                   = 2,
	ESpawnActorScaleMethod_MAX               = 3,
};

// Enum Engine.EActorNetUpdatePriority
// NumValues: 0x0009
enum class EActorNetUpdatePriority : uint8
{
	Priority_Unknow                          = 0,
	Priority_BlastMeshActor                  = 2,
	Priority_Default                         = 4,
	Priority_AbilityActor                    = 8,
	Priority_Character                       = 9,
	Priority_GameState                       = 10,
	Priority_PC                              = 11,
	Max                                      = 11,
	EActorNetUpdatePriority_MAX              = 12,
};

// Enum Engine.FNavigationSystemRunMode
// NumValues: 0x0008
enum class EFNavigationSystemRunMode : uint8
{
	InvalidMode                              = 0,
	GameMode                                 = 1,
	EditorMode                               = 2,
	SimulationMode                           = 3,
	PIEMode                                  = 4,
	InferFromWorldMode                       = 5,
	EditorWorldPartitionBuildMode            = 6,
	FNavigationSystemRunMode_MAX             = 7,
};

// Enum Engine.ENavigationOptionFlag
// NumValues: 0x0004
enum class ENavigationOptionFlag : uint8
{
	Default                                  = 0,
	Enable                                   = 1,
	Disable                                  = 2,
	MAX                                      = 3,
};

// Enum Engine.ENavDataGatheringMode
// NumValues: 0x0004
enum class ENavDataGatheringMode : uint8
{
	Default                                  = 0,
	Instant                                  = 1,
	Lazy                                     = 2,
	ENavDataGatheringMode_MAX                = 3,
};

// Enum Engine.ENavDataGatheringModeConfig
// NumValues: 0x0004
enum class ENavDataGatheringModeConfig : uint8
{
	Invalid                                  = 0,
	Instant                                  = 1,
	Lazy                                     = 2,
	ENavDataGatheringModeConfig_MAX          = 3,
};

// Enum Engine.ENavigationSortPendingTilesMethod
// NumValues: 0x0004
enum class ENavigationSortPendingTilesMethod : uint8
{
	SortWithSeedLocations                    = 0,
	SortByPriority                           = 1,
	None                                     = 2,
	ENavigationSortPendingTilesMethod_MAX    = 3,
};

// Enum Engine.ENavPathEvent
// NumValues: 0x0009
enum class ENavPathEvent : uint8
{
	Cleared                                  = 0,
	NewPath                                  = 1,
	UpdatedDueToGoalMoved                    = 2,
	UpdatedDueToNavigationChanged            = 3,
	Invalidated                              = 4,
	RePathFailed                             = 5,
	MetaPathUpdate                           = 6,
	Custom                                   = 7,
	ENavPathEvent_MAX                        = 8,
};

// Enum Engine.ENavigationQueryResult
// NumValues: 0x0005
enum class ENavigationQueryResult : uint8
{
	Invalid                                  = 0,
	Error                                    = 1,
	Fail                                     = 2,
	Success                                  = 3,
	ENavigationQueryResult_MAX               = 4,
};

// Enum Engine.EAlphaBlendOption
// NumValues: 0x001A
enum class EAlphaBlendOption : uint8
{
	Linear                                   = 0,
	Cubic                                    = 1,
	HermiteCubic                             = 2,
	Sinusoidal                               = 3,
	QuadraticInOut                           = 4,
	CubicInOut                               = 5,
	QuarticInOut                             = 6,
	QuinticInOut                             = 7,
	CircularIn                               = 8,
	CircularOut                              = 9,
	CircularInOut                            = 10,
	ExpIn                                    = 11,
	ExpOut                                   = 12,
	ExpInOut                                 = 13,
	SinusoidalIn                             = 14,
	SinusoidalOut                            = 15,
	QuadraticIn                              = 16,
	QuadraticOut                             = 17,
	CubicIn                                  = 18,
	CubicOut                                 = 19,
	QuarticIn                                = 20,
	QuarticOut                               = 21,
	QuinticIn                                = 22,
	QuinticOut                               = 23,
	Custom                                   = 24,
	EAlphaBlendOption_MAX                    = 25,
};

// Enum Engine.EAnimGroupRole
// NumValues: 0x0006
enum class EAnimGroupRole : uint8
{
	CanBeLeader                              = 0,
	AlwaysFollower                           = 1,
	AlwaysLeader                             = 2,
	TransitionLeader                         = 3,
	TransitionFollower                       = 4,
	EAnimGroupRole_MAX                       = 5,
};

// Enum Engine.EAnimSyncGroupScope
// NumValues: 0x0003
enum class EAnimSyncGroupScope : uint8
{
	Local                                    = 0,
	Component                                = 1,
	EAnimSyncGroupScope_MAX                  = 2,
};

// Enum Engine.EAnimSyncMethod
// NumValues: 0x0004
enum class EAnimSyncMethod : uint8
{
	DoNotSync                                = 0,
	SyncGroup                                = 1,
	Graph                                    = 2,
	EAnimSyncMethod_MAX                      = 3,
};

// Enum Engine.EAnimExecutionContextConversionResult
// NumValues: 0x0003
enum class EAnimExecutionContextConversionResult : uint8
{
	Succeeded                                = 1,
	Failed                                   = 0,
	EAnimExecutionContextConversionResult_MAX = 2,
};

// Enum Engine.EMontagePlayReturnType
// NumValues: 0x0003
enum class EMontagePlayReturnType : uint8
{
	MontageLength                            = 0,
	Duration                                 = 1,
	EMontagePlayReturnType_MAX               = 2,
};

// Enum Engine.EDrawDebugItemType
// NumValues: 0x000A
enum class EDrawDebugItemType : uint8
{
	DirectionalArrow                         = 0,
	Sphere                                   = 1,
	Line                                     = 2,
	OnScreenMessage                          = 3,
	CoordinateSystem                         = 4,
	Point                                    = 5,
	Circle                                   = 6,
	Cone                                     = 7,
	InWorldMessage                           = 8,
	EDrawDebugItemType_MAX                   = 9,
};

// Enum Engine.EAnimLinkMethod
// NumValues: 0x0004
enum class EAnimLinkMethod : uint8
{
	Absolute                                 = 0,
	Relative                                 = 1,
	Proportional                             = 2,
	EAnimLinkMethod_MAX                      = 3,
};

// Enum Engine.EAnimNotifyEventType
// NumValues: 0x0003
enum class EAnimNotifyEventType : uint8
{
	Begin                                    = 0,
	End                                      = 1,
	EAnimNotifyEventType_MAX                 = 2,
};

// Enum Engine.EMontageBlendMode
// NumValues: 0x0003
enum class EMontageBlendMode : uint8
{
	Standard                                 = 0,
	Inertialization                          = 1,
	EMontageBlendMode_MAX                    = 2,
};

// Enum Engine.EMontageSubStepResult
// NumValues: 0x0005
enum class EMontageSubStepResult : uint8
{
	Moved                                    = 0,
	NotMoved                                 = 1,
	InvalidSection                           = 2,
	InvalidMontage                           = 3,
	EMontageSubStepResult_MAX                = 4,
};

// Enum Engine.ECameraCurveOption
// NumValues: 0x0008
enum class ECameraCurveOption : uint8
{
	All                                      = 0,
	CameraLocationOffsetX                    = 1,
	CameraLocationOffsetY                    = 2,
	CameraLocationOffsetZ                    = 3,
	CameraRotationOffsetX                    = 4,
	CameraRotationOffsetY                    = 5,
	CameraRotationOffsetZ                    = 6,
	ECameraCurveOption_MAX                   = 7,
};

// Enum Engine.EPinHidingMode
// NumValues: 0x0005
enum class EPinHidingMode : uint8
{
	NeverAsPin                               = 0,
	PinHiddenByDefault                       = 1,
	PinShownByDefault                        = 2,
	AlwaysAsPin                              = 3,
	EPinHidingMode_MAX                       = 4,
};

// Enum Engine.EAnimNodeDataFlags
// NumValues: 0x0005
enum class EAnimNodeDataFlags : uint8
{
	None                                     = 0,
	HasInitialUpdateFunction                 = 1,
	HasBecomeRelevantFunction                = 2,
	HasUpdateFunction                        = 4,
	EAnimNodeDataFlags_MAX                   = 5,
};

// Enum Engine.EAnimNodeReferenceConversionResult
// NumValues: 0x0003
enum class EAnimNodeReferenceConversionResult : uint8
{
	Succeeded                                = 1,
	Failed                                   = 0,
	EAnimNodeReferenceConversionResult_MAX   = 2,
};

// Enum Engine.EInertializationState
// NumValues: 0x0004
enum class EInertializationState : uint8
{
	Inactive                                 = 0,
	Pending                                  = 1,
	Active                                   = 2,
	EInertializationState_MAX                = 3,
};

// Enum Engine.EInertializationBoneState
// NumValues: 0x0004
enum class EInertializationBoneState : uint8
{
	Invalid                                  = 0,
	Valid                                    = 1,
	Excluded                                 = 2,
	EInertializationBoneState_MAX            = 3,
};

// Enum Engine.EInertializationSpace
// NumValues: 0x0004
enum class EInertializationSpace : uint8
{
	Default                                  = 0,
	WorldSpace                               = 1,
	WorldRotation                            = 2,
	EInertializationSpace_MAX                = 3,
};

// Enum Engine.EEvaluatorDataSource
// NumValues: 0x0003
enum class EEvaluatorDataSource : uint8
{
	EDS_SourcePose                           = 0,
	EDS_DestinationPose                      = 1,
	EDS_MAX                                  = 2,
};

// Enum Engine.EEvaluatorMode
// NumValues: 0x0004
enum class EEvaluatorMode : uint8
{
	EM_Standard                              = 0,
	EM_Freeze                                = 1,
	EM_DelayedFreeze                         = 2,
	EM_MAX                                   = 3,
};

// Enum Engine.ETransitionRequestQueueMode
// NumValues: 0x0003
enum class ETransitionRequestQueueMode : uint8
{
	Shared                                   = 0,
	Unique                                   = 1,
	ETransitionRequestQueueMode_MAX          = 2,
};

// Enum Engine.ETransitionRequestOverwriteMode
// NumValues: 0x0004
enum class ETransitionRequestOverwriteMode : uint8
{
	Append                                   = 0,
	Ignore                                   = 1,
	Overwrite                                = 2,
	ETransitionRequestOverwriteMode_MAX      = 3,
};

// Enum Engine.ETransitionBlendMode
// NumValues: 0x0003
enum class ETransitionBlendMode : uint8
{
	TBM_Linear                               = 0,
	TBM_Cubic                                = 1,
	TBM_MAX                                  = 2,
};

// Enum Engine.ETransitionLogicType
// NumValues: 0x0004
enum class ETransitionLogicType : uint8
{
	TLT_StandardBlend                        = 0,
	TLT_Inertialization                      = 1,
	TLT_Custom                               = 2,
	TLT_MAX                                  = 3,
};

// Enum Engine.EAnimPropertyAccessCallSite
// NumValues: 0x0006
enum class EAnimPropertyAccessCallSite : uint8
{
	WorkerThread_Unbatched                   = 0,
	WorkerThread_Batched_PreEventGraph       = 1,
	WorkerThread_Batched_PostEventGraph      = 2,
	GameThread_Batched_PreEventGraph         = 3,
	GameThread_Batched_PostEventGraph        = 4,
	EAnimPropertyAccessCallSite_MAX          = 5,
};

// Enum Engine.EBlendProfileMode
// NumValues: 0x0004
enum class EBlendProfileMode : uint8
{
	TimeFactor                               = 0,
	WeightFactor                             = 1,
	BlendMask                                = 2,
	EBlendProfileMode_MAX                    = 3,
};

// Enum Engine.ETransformCurveChannel
// NumValues: 0x0005
enum class ETransformCurveChannel : uint8
{
	Position                                 = 0,
	Rotation                                 = 1,
	Scale                                    = 2,
	Invalid                                  = 3,
	ETransformCurveChannel_MAX               = 4,
};

// Enum Engine.EVectorCurveChannel
// NumValues: 0x0005
enum class EVectorCurveChannel : uint8
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	Invalid                                  = 3,
	EVectorCurveChannel_MAX                  = 4,
};

// Enum Engine.EPostCopyOperation
// NumValues: 0x0003
enum class EPostCopyOperation : uint8
{
	None                                     = 0,
	LogicalNegateBool                        = 1,
	EPostCopyOperation_MAX                   = 2,
};

// Enum Engine.EAnimAlphaInputType
// NumValues: 0x0004
enum class EAnimAlphaInputType : uint8
{
	Float                                    = 0,
	Bool                                     = 1,
	Curve                                    = 2,
	EAnimAlphaInputType_MAX                  = 3,
};

// Enum Engine.EMirrorRowType
// NumValues: 0x0006
enum class EMirrorRowType : uint8
{
	Bone                                     = 0,
	AnimationNotify                          = 1,
	Curve                                    = 2,
	SyncMarker                               = 3,
	Custom                                   = 4,
	EMirrorRowType_MAX                       = 5,
};

// Enum Engine.EMirrorFindReplaceMethod
// NumValues: 0x0004
enum class EMirrorFindReplaceMethod : uint8
{
	Prefix                                   = 0,
	Suffix                                   = 1,
	RegularExpression                        = 2,
	EMirrorFindReplaceMethod_MAX             = 3,
};

// Enum Engine.EControlConstraint
// NumValues: 0x0003
enum class EControlConstraint : uint8
{
	Orientation                              = 0,
	Translation                              = 1,
	MAX                                      = 2,
};

// Enum Engine.EConstraintTransform
// NumValues: 0x0003
enum class EConstraintTransform : uint8
{
	Absolute                                 = 0,
	Relative                                 = 1,
	EConstraintTransform_MAX                 = 2,
};

// Enum Engine.ESkeletalMeshVertexAttributeDataType
// NumValues: 0x0004
enum class ESkeletalMeshVertexAttributeDataType : uint32
{
	Float                                    = 0,
	HalfFloat                                = 1,
	NUInt8                                   = 2,
	ESkeletalMeshVertexAttributeDataType_MAX = 3,
};

// Enum Engine.EBoneTranslationRetargetingMode
// NumValues: 0x0006
enum class EBoneTranslationRetargetingMode : uint8
{
	Animation                                = 0,
	Skeleton                                 = 1,
	AnimationScaled                          = 2,
	AnimationRelative                        = 3,
	OrientAndScale                           = 4,
	EBoneTranslationRetargetingMode_MAX      = 5,
};

// Enum Engine.ETimeStretchCurveMapping
// NumValues: 0x0004
enum class ETimeStretchCurveMapping : uint8
{
	T_Original                               = 0,
	T_TargetMin                              = 1,
	T_TargetMax                              = 2,
	MAX                                      = 3,
};

// Enum Engine.EPreviewAnimationBlueprintApplicationMethod
// NumValues: 0x0003
enum class EPreviewAnimationBlueprintApplicationMethod : uint8
{
	LinkedLayers                             = 0,
	LinkedAnimGraph                          = 1,
	EPreviewAnimationBlueprintApplicationMethod_MAX = 2,
};

// Enum Engine.EPrimaryAssetCookRule
// NumValues: 0x0009
enum class EPrimaryAssetCookRule : uint8
{
	Unknown                                  = 0,
	NeverCook                                = 1,
	ProductionNeverCook                      = 2,
	DevelopmentCook                          = 2,
	DevelopmentAlwaysProductionNeverCook     = 3,
	DevelopmentAlwaysCook                    = 3,
	DevelopmentAlwaysProductionUnknownCook   = 4,
	AlwaysCook                               = 5,
	EPrimaryAssetCookRule_MAX                = 6,
};

// Enum Engine.EAttenuationDistanceModel
// NumValues: 0x0007
enum class EAttenuationDistanceModel : uint8
{
	Linear                                   = 0,
	Logarithmic                              = 1,
	Inverse                                  = 2,
	LogReverse                               = 3,
	NaturalSound                             = 4,
	Custom                                   = 5,
	EAttenuationDistanceModel_MAX            = 6,
};

// Enum Engine.EAttenuationShape
// NumValues: 0x0005
enum class EAttenuationShape : uint8
{
	Sphere                                   = 0,
	Capsule                                  = 1,
	Box                                      = 2,
	Cone                                     = 3,
	EAttenuationShape_MAX                    = 4,
};

// Enum Engine.ENaturalSoundFalloffMode
// NumValues: 0x0004
enum class ENaturalSoundFalloffMode : uint8
{
	Continues                                = 0,
	Silent                                   = 1,
	Hold                                     = 2,
	ENaturalSoundFalloffMode_MAX             = 3,
};

// Enum Engine.EAudioBusChannels
// NumValues: 0x0006
enum class EAudioBusChannels : uint8
{
	Mono                                     = 0,
	Stereo                                   = 1,
	Quad                                     = 3,
	FivePointOne                             = 5,
	SevenPointOne                            = 7,
	EAudioBusChannels_MAX                    = 8,
};

// Enum Engine.EVoiceSampleRate
// NumValues: 0x0003
enum class EVoiceSampleRate : uint32
{
	Low16000Hz                               = 16000,
	Normal24000Hz                            = 24000,
	EVoiceSampleRate_MAX                     = 24001,
};

// Enum Engine.EPanningMethod
// NumValues: 0x0003
enum class EPanningMethod : uint8
{
	Linear                                   = 0,
	EqualPower                               = 1,
	EPanningMethod_MAX                       = 2,
};

// Enum Engine.EMonoChannelUpmixMethod
// NumValues: 0x0004
enum class EMonoChannelUpmixMethod : uint8
{
	Linear                                   = 0,
	EqualPower                               = 1,
	FullVolume                               = 2,
	EMonoChannelUpmixMethod_MAX              = 3,
};

// Enum Engine.EDefaultAudioCompressionType
// NumValues: 0x0005
enum class EDefaultAudioCompressionType : uint8
{
	BinkAudio                                = 0,
	ADPCM                                    = 1,
	PCM                                      = 2,
	PlatformSpecific                         = 3,
	EDefaultAudioCompressionType_MAX         = 4,
};

// Enum Engine.EAudioVolumeLocationState
// NumValues: 0x0003
enum class EAudioVolumeLocationState : uint8
{
	InsideTheVolume                          = 0,
	OutsideTheVolume                         = 1,
	EAudioVolumeLocationState_MAX            = 2,
};

// Enum Engine.EInterfaceValidResult
// NumValues: 0x0003
enum class EInterfaceValidResult : uint8
{
	Valid                                    = 0,
	Invalid                                  = 1,
	EInterfaceValidResult_MAX                = 2,
};

// Enum Engine.ECameraShakeUpdateResultFlags
// NumValues: 0x0005
enum class ECameraShakeUpdateResultFlags : uint8
{
	ApplyAsAbsolute                          = 1,
	SkipAutoScale                            = 2,
	SkipAutoPlaySpace                        = 4,
	Default                                  = 0,
	ECameraShakeUpdateResultFlags_MAX        = 5,
};

// Enum Engine.ECameraShakeDurationType
// NumValues: 0x0004
enum class ECameraShakeDurationType : uint8
{
	Fixed                                    = 0,
	Infinite                                 = 1,
	Custom                                   = 2,
	ECameraShakeDurationType_MAX             = 3,
};

// Enum Engine.ECameraShakeAttenuation
// NumValues: 0x0003
enum class ECameraShakeAttenuation : uint8
{
	Linear                                   = 0,
	Quadratic                                = 1,
	ECameraShakeAttenuation_MAX              = 2,
};

// Enum Engine.ECameraAlphaBlendMode
// NumValues: 0x0003
enum class ECameraAlphaBlendMode : uint8
{
	CABM_Linear                              = 0,
	CABM_Cubic                               = 1,
	CABM_MAX                                 = 2,
};

// Enum Engine.EAudioFaderCurve
// NumValues: 0x0006
enum class EAudioFaderCurve : uint8
{
	Linear                                   = 0,
	Logarithmic                              = 1,
	SCurve                                   = 2,
	Sin                                      = 3,
	Count                                    = 4,
	EAudioFaderCurve_MAX                     = 5,
};

// Enum Engine.EModulationDestination
// NumValues: 0x0006
enum class EModulationDestination : uint8
{
	Volume                                   = 0,
	Pitch                                    = 1,
	Lowpass                                  = 2,
	Highpass                                 = 3,
	Count                                    = 4,
	EModulationDestination_MAX               = 5,
};

// Enum Engine.EMovementNetStatus
// NumValues: 0x0007
enum class EMovementNetStatus : uint8
{
	MovementNet_None                         = 0,
	MovementNet_WeakNet_Level1               = 1,
	MovementNet_WeakNet_Level2               = 2,
	MovementNet_WeakNet_Level3               = 4,
	MovementNet_LogicMoveLost                = 8,
	MovementNet_Recover                      = 22,
	MovementNet_MAX                          = 23,
};

// Enum Engine.ESetMovementModePriority
// NumValues: 0x0008
enum class ESetMovementModePriority : uint8
{
	Auto                                     = 0,
	Movement                                 = 1,
	Ability                                  = 2,
	Task                                     = 3,
	Dash                                     = 4,
	Max                                      = 5,
	Revert                                   = 6,
	ESetMovementModePriority_MAX             = 7,
};

// Enum Engine.EMovementParamTag
// NumValues: 0x0028
enum class EMovementParamTag : uint8
{
	EmptyTag                                 = 0,
	Velocity                                 = 1,
	MovementMode                             = 2,
	PendingLaunchVelocity                    = 3,
	CustomMovementMode                       = 4,
	PriorityMovementMode                     = 5,
	EnvParamTagStarter                       = 64,
	GravityScale                             = 65,
	MaxStepHeight                            = 66,
	JumpZVelocity                            = 67,
	JumpOffJumpZFactor                       = 68,
	GroundFriction                           = 69,
	MaxWalkSpeed                             = 70,
	MaxWalkSpeedCrouched                     = 71,
	MaxSwimSpeed                             = 72,
	MaxFlySpeed                              = 73,
	MaxCustomMovementSpeed                   = 74,
	MaxAcceleration                          = 75,
	MinAnalogWalkSpeed                       = 76,
	BrakingFrictionFactor                    = 77,
	BrakingSubStepTime                       = 78,
	BrakingDecelerationWalking               = 79,
	BrakingDecelerationFalling               = 80,
	BrakingDecelerationSwimming              = 81,
	BrakingDecelerationFlying                = 82,
	BrakingDecelerationCustom                = 83,
	AirControl                               = 84,
	AirControlBoostMultiplier                = 85,
	AirControlBoostVelocityThreshold         = 86,
	FallingLateralFriction                   = 87,
	CrouchedHalfHeight                       = 88,
	Buoyancy                                 = 89,
	PerchRadiusThreshold                     = 90,
	PerchAdditionalHeight                    = 91,
	RotationRate                             = 92,
	DefaultLandMovementMode                  = 93,
	DefaultWaterMovementMode                 = 94,
	FluidFriction                            = 95,
	bLimitLandingSpeedOnce                   = 96,
	EMovementParamTag_MAX                    = 97,
};

// Enum Engine.EControllerAnalogStick
// NumValues: 0x0003
enum class EControllerAnalogStick : uint8
{
	CAS_LeftStick                            = 0,
	CAS_RightStick                           = 1,
	CAS_MAX                                  = 2,
};

// Enum Engine.ELocalFogMode
// NumValues: 0x0003
enum class ELocalFogMode : uint8
{
	LocalHeightFog                           = 0,
	LocalSphereFog                           = 1,
	ELocalFogMode_MAX                        = 2,
};

// Enum Engine.ESyncOption
// NumValues: 0x0004
enum class ESyncOption : uint8
{
	Drive                                    = 0,
	Passive                                  = 1,
	Disabled                                 = 2,
	ESyncOption_MAX                          = 3,
};

// Enum Engine.EPhysicsStateAction
// NumValues: 0x000C
enum class EPhysicsStateAction : uint8
{
	AddForce                                 = 0,
	AddTorque                                = 1,
	AddForceAtPosition                       = 2,
	AddLinearVelocity                        = 3,
	AddAngularVelocity                       = 4,
	AddVelocityAtPosition                    = 5,
	AddLinearImpulse                         = 6,
	AddAngularImpulse                        = 7,
	AddImpulseAtPosition                     = 8,
	AddAcceleration                          = 9,
	NumActions                               = 10,
	EPhysicsStateAction_MAX                  = 11,
};

// Enum Engine.EReflectionSourceType
// NumValues: 0x0003
enum class EReflectionSourceType : uint8
{
	CapturedScene                            = 0,
	SpecifiedCubemap                         = 1,
	EReflectionSourceType_MAX                = 2,
};

// Enum Engine.ESceneCapturePrimitiveRenderMode
// NumValues: 0x0004
enum class ESceneCapturePrimitiveRenderMode : uint8
{
	PRM_LegacySceneCapture                   = 0,
	PRM_RenderScenePrimitives                = 1,
	PRM_UseShowOnlyList                      = 2,
	PRM_MAX                                  = 3,
};

// Enum Engine.ECustomBoneAttributeLookup
// NumValues: 0x0004
enum class ECustomBoneAttributeLookup : uint8
{
	BoneOnly                                 = 0,
	ImmediateParent                          = 1,
	ParentHierarchy                          = 2,
	ECustomBoneAttributeLookup_MAX           = 3,
};

// Enum Engine.EKinematicBonesUpdateToPhysics
// NumValues: 0x0003
enum class EKinematicBonesUpdateToPhysics : uint8
{
	SkipSimulatingBones                      = 0,
	SkipAllBones                             = 1,
	EKinematicBonesUpdateToPhysics_MAX       = 2,
};

// Enum Engine.EAnimationMode
// NumValues: 0x0004
enum class EAnimationMode : uint8
{
	AnimationBlueprint                       = 0,
	AnimationSingleNode                      = 1,
	AnimationCustomMode                      = 2,
	EAnimationMode_MAX                       = 3,
};

// Enum Engine.EPhysicsTransformUpdateMode
// NumValues: 0x0003
enum class EPhysicsTransformUpdateMode : uint8
{
	SimulationUpatesComponentTransform       = 0,
	ComponentTransformIsKinematic            = 1,
	EPhysicsTransformUpdateMode_MAX          = 2,
};

// Enum Engine.ESkyAtmosphereTransformMode
// NumValues: 0x0004
enum class ESkyAtmosphereTransformMode : uint8
{
	PlanetTopAtAbsoluteWorldOrigin           = 0,
	PlanetTopAtComponentTransform            = 1,
	PlanetCenterAtComponentTransform         = 2,
	ESkyAtmosphereTransformMode_MAX          = 3,
};

// Enum Engine.ESplinePointType
// NumValues: 0x0006
enum class ESplinePointType : uint8
{
	Linear                                   = 0,
	Curve                                    = 1,
	Constant                                 = 2,
	CurveClamped                             = 3,
	CurveCustomTangent                       = 4,
	ESplinePointType_MAX                     = 5,
};

// Enum Engine.ESplineCoordinateSpace
// NumValues: 0x0003
enum class ESplineCoordinateSpace : uint8
{
	Local                                    = 0,
	World                                    = 1,
	ESplineCoordinateSpace_MAX               = 2,
};

// Enum Engine.ESplineMeshAxis
// NumValues: 0x0004
enum class ESplineMeshAxis : uint8
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	ESplineMeshAxis_MAX                      = 3,
};

// Enum Engine.EVolumetricCloudTracingMaxDistanceMode
// NumValues: 0x0003
enum class EVolumetricCloudTracingMaxDistanceMode : uint8
{
	DistanceFromCloudLayerEntryPoint         = 0,
	DistanceFromPointOfView                  = 1,
	EVolumetricCloudTracingMaxDistanceMode_MAX = 2,
};

// Enum Engine.ECurveTableMode
// NumValues: 0x0004
enum class ECurveTableMode : uint8
{
	Empty                                    = 0,
	SimpleCurves                             = 1,
	RichCurves                               = 2,
	ECurveTableMode_MAX                      = 3,
};

// Enum Engine.FDataDrivenCVarType
// NumValues: 0x0004
enum class EFDataDrivenCVarType : uint8
{
	CVarFloat                                = 0,
	CVarInt                                  = 1,
	CVarBool                                 = 2,
	FDataDrivenCVarType_MAX                  = 3,
};

// Enum Engine.EEvaluateCurveTableResult
// NumValues: 0x0003
enum class EEvaluateCurveTableResult : uint8
{
	RowFound                                 = 0,
	RowNotFound                              = 1,
	EEvaluateCurveTableResult_MAX            = 2,
};

// Enum Engine.EReporterLineStyle
// NumValues: 0x0003
enum class EReporterLineStyle : uint8
{
	Line                                     = 0,
	Dash                                     = 1,
	EReporterLineStyle_MAX                   = 2,
};

// Enum Engine.EGraphAxisStyle
// NumValues: 0x0004
enum class EGraphAxisStyle : uint8
{
	Lines                                    = 0,
	Notches                                  = 1,
	Grid                                     = 2,
	EGraphAxisStyle_MAX                      = 3,
};

// Enum Engine.EGraphDataStyle
// NumValues: 0x0003
enum class EGraphDataStyle : uint8
{
	Lines                                    = 0,
	Filled                                   = 1,
	EGraphDataStyle_MAX                      = 2,
};

// Enum Engine.ELegendPosition
// NumValues: 0x0003
enum class ELegendPosition : uint8
{
	Outside                                  = 0,
	Inside                                   = 1,
	ELegendPosition_MAX                      = 2,
};

// Enum Engine.EReplayRecordType
// NumValues: 0x0004
enum class EReplayRecordType : uint8
{
	Record_None                              = 0,
	Record_UE                                = 1,
	Record_Jarvis                            = 2,
	Record_MAX                               = 3,
};

// Enum Engine.EGrammaticalGender
// NumValues: 0x0005
enum class EGrammaticalGender : uint8
{
	Neuter                                   = 0,
	Masculine                                = 1,
	Feminine                                 = 2,
	Mixed                                    = 3,
	EGrammaticalGender_MAX                   = 4,
};

// Enum Engine.EGrammaticalNumber
// NumValues: 0x0003
enum class EGrammaticalNumber : uint8
{
	Singular                                 = 0,
	Plural                                   = 1,
	EGrammaticalNumber_MAX                   = 2,
};

// Enum Engine.ETypedElementWorldType
// NumValues: 0x0003
enum class ETypedElementWorldType : uint8
{
	Game                                     = 0,
	Editor                                   = 1,
	ETypedElementWorldType_MAX               = 2,
};

// Enum Engine.ECustomTimeStepSynchronizationState
// NumValues: 0x0005
enum class ECustomTimeStepSynchronizationState : uint8
{
	Closed                                   = 0,
	Error                                    = 1,
	Synchronized                             = 2,
	Synchronizing                            = 3,
	ECustomTimeStepSynchronizationState_MAX  = 4,
};

// Enum Engine.EVectorQuantization
// NumValues: 0x0006
enum class EVectorQuantization : uint8
{
	RoundWholeNumber                         = 0,
	RoundOneDecimal                          = 1,
	RoundTwoDecimals                         = 2,
	FloatComponents                          = 3,
	NoQuantization                           = 4,
	EVectorQuantization_MAX                  = 5,
};

// Enum Engine.ERotatorQuantization
// NumValues: 0x0004
enum class ERotatorQuantization : uint8
{
	ByteComponents                           = 0,
	ShortComponents                          = 1,
	FloatComponents                          = 2,
	ERotatorQuantization_MAX                 = 3,
};

// Enum Engine.ETimecodeProviderSynchronizationState
// NumValues: 0x0005
enum class ETimecodeProviderSynchronizationState : uint32
{
	Closed                                   = 0,
	Error                                    = 1,
	Synchronized                             = 2,
	Synchronizing                            = 3,
	ETimecodeProviderSynchronizationState_MAX = 4,
};

// Enum Engine.EFontCacheType
// NumValues: 0x0003
enum class EFontCacheType : uint8
{
	Offline                                  = 0,
	Runtime                                  = 1,
	EFontCacheType_MAX                       = 2,
};

// Enum Engine.ERootMotionAccumulateMode
// NumValues: 0x0003
enum class ERootMotionAccumulateMode : uint8
{
	Override                                 = 0,
	Additive                                 = 1,
	ERootMotionAccumulateMode_MAX            = 2,
};

// Enum Engine.ERootMotionSourceStatusFlags
// NumValues: 0x0009
enum class ERootMotionSourceStatusFlags : uint8
{
	Prepared                                 = 1,
	Finished                                 = 2,
	MarkedForRemoval                         = 4,
	Arrived                                  = 8,
	Terminated                               = 16,
	Holding                                  = 32,
	DisableVelocity                          = 64,
	InvalidFlags                             = 22,
	ERootMotionSourceStatusFlags_MAX         = 65,
};

// Enum Engine.ERootMotionSourceSettingsFlags
// NumValues: 0x0004
enum class ERootMotionSourceSettingsFlags : uint8
{
	UseSensitiveLiftoffCheck                 = 1,
	DisablePartialEndTick                    = 2,
	IgnoreZAccumulate                        = 4,
	ERootMotionSourceSettingsFlags_MAX       = 5,
};

// Enum Engine.ERootMotionFinishVelocityMode
// NumValues: 0x0004
enum class ERootMotionFinishVelocityMode : uint8
{
	MaintainLastRootMotionVelocity           = 0,
	SetVelocity                              = 1,
	ClampVelocity                            = 2,
	ERootMotionFinishVelocityMode_MAX        = 3,
};

// Enum Engine.EWindowMode
// NumValues: 0x0004
enum class EWindowMode : uint8
{
	Fullscreen                               = 0,
	WindowedFullscreen                       = 1,
	Windowed                                 = 2,
	EWindowMode_MAX                          = 3,
};

// Enum Engine.ESlateGesture
// NumValues: 0x0007
enum class ESlateGesture : uint8
{
	None                                     = 0,
	Scroll                                   = 1,
	Magnify                                  = 2,
	Swipe                                    = 3,
	Rotate                                   = 4,
	LongPress                                = 5,
	ESlateGesture_MAX                        = 6,
};

// Enum Engine.EMIDCreationFlags
// NumValues: 0x0003
enum class EMIDCreationFlags : uint8
{
	None                                     = 0,
	Transient                                = 1,
	EMIDCreationFlags_MAX                    = 2,
};

// Enum Engine.EEasingFunc
// NumValues: 0x000F
enum class EEasingFunc : uint8
{
	Linear                                   = 0,
	Step                                     = 1,
	SinusoidalIn                             = 2,
	SinusoidalOut                            = 3,
	SinusoidalInOut                          = 4,
	EaseIn                                   = 5,
	EaseOut                                  = 6,
	EaseInOut                                = 7,
	ExpoIn                                   = 8,
	ExpoOut                                  = 9,
	ExpoInOut                                = 10,
	CircularIn                               = 11,
	CircularOut                              = 12,
	CircularInOut                            = 13,
	EEasingFunc_MAX                          = 14,
};

// Enum Engine.ELerpInterpolationMode
// NumValues: 0x0004
enum class ELerpInterpolationMode : uint8
{
	QuatInterp                               = 0,
	EulerInterp                              = 1,
	DualQuatInterp                           = 2,
	ELerpInterpolationMode_MAX               = 3,
};

// Enum Engine.EMatrixColumns
// NumValues: 0x0005
enum class EMatrixColumns : uint8
{
	First                                    = 0,
	Second                                   = 1,
	Third                                    = 2,
	Fourth                                   = 3,
	EMatrixColumns_MAX                       = 4,
};

// Enum Engine.EImportanceWeight
// NumValues: 0x0006
enum class EImportanceWeight : uint8
{
	Luminance                                = 0,
	Red                                      = 1,
	Green                                    = 2,
	Blue                                     = 3,
	Alpha                                    = 4,
	EImportanceWeight_MAX                    = 5,
};

// Enum Engine.EDecalBlendMode
// NumValues: 0x0012
enum class EDecalBlendMode : uint8
{
	DBM_Translucent                          = 0,
	DBM_Stain                                = 1,
	DBM_Normal                               = 2,
	DBM_Emissive                             = 3,
	DBM_DBuffer_ColorNormalRoughness         = 4,
	DBM_DBuffer_Color                        = 5,
	DBM_DBuffer_ColorNormal                  = 6,
	DBM_DBuffer_ColorRoughness               = 7,
	DBM_DBuffer_Normal                       = 8,
	DBM_DBuffer_NormalRoughness              = 9,
	DBM_DBuffer_Roughness                    = 10,
	DBM_DBuffer_Emissive                     = 11,
	DBM_DBuffer_AlphaComposite               = 12,
	DBM_DBuffer_EmissiveAlphaComposite       = 13,
	DBM_Volumetric_DistanceFunction          = 14,
	DBM_AlphaComposite                       = 15,
	DBM_AmbientOcclusion                     = 16,
	DBM_MAX                                  = 17,
};

// Enum Engine.EMaterialTranslucencyPass
// NumValues: 0x0006
enum class EMaterialTranslucencyPass : uint8
{
	MTP_BeforeDOF                            = 0,
	MTP_AfterDOF                             = 1,
	MTP_AfterMotionBlur                      = 2,
	MTP_AfterOutline                         = 3,
	MTP_AfterPP                              = 4,
	MTP_MAX                                  = 5,
};

// Enum Engine.EMeshFeatureImportance
// NumValues: 0x0007
enum class EMeshFeatureImportance : uint8
{
	Off                                      = 0,
	Lowest                                   = 1,
	Low                                      = 2,
	Normal                                   = 3,
	High                                     = 4,
	Highest                                  = 5,
	EMeshFeatureImportance_MAX               = 6,
};

// Enum Engine.EStaticMeshReductionTerimationCriterion
// NumValues: 0x0004
enum class EStaticMeshReductionTerimationCriterion : uint8
{
	Triangles                                = 0,
	Vertices                                 = 1,
	Any                                      = 2,
	EStaticMeshReductionTerimationCriterion_MAX = 3,
};

// Enum Engine.ELandscapeCullingPrecision
// NumValues: 0x0004
enum class ELandscapeCullingPrecision : uint8
{
	High                                     = 0,
	Medium                                   = 1,
	Low                                      = 2,
	ELandscapeCullingPrecision_MAX           = 3,
};

// Enum Engine.EProxyNormalComputationMethod
// NumValues: 0x0004
enum class EProxyNormalComputationMethod : uint8
{
	AngleWeighted                            = 0,
	AreaWeighted                             = 1,
	EqualWeighted                            = 2,
	EProxyNormalComputationMethod_MAX        = 3,
};

// Enum Engine.EMeshLODSelectionType
// NumValues: 0x0005
enum class EMeshLODSelectionType : uint8
{
	AllLODs                                  = 0,
	SpecificLOD                              = 1,
	CalculateLOD                             = 2,
	LowestDetailLOD                          = 3,
	EMeshLODSelectionType_MAX                = 4,
};

// Enum Engine.EMeshMergeType
// NumValues: 0x0003
enum class EMeshMergeType : uint8
{
	MeshMergeType_Default                    = 0,
	MeshMergeType_MergeActor                 = 1,
	MeshMergeType_MAX                        = 2,
};

// Enum Engine.EUVOutput
// NumValues: 0x0003
enum class EUVOutput : uint8
{
	DoNotOutputChannel                       = 0,
	OutputChannel                            = 1,
	EUVOutput_MAX                            = 2,
};

// Enum Engine.EMeshApproximationType
// NumValues: 0x0003
enum class EMeshApproximationType : uint8
{
	MeshAndMaterials                         = 0,
	MeshShapeOnly                            = 1,
	EMeshApproximationType_MAX               = 2,
};

// Enum Engine.EMeshApproximationBaseCappingType
// NumValues: 0x0004
enum class EMeshApproximationBaseCappingType : uint8
{
	NoBaseCapping                            = 0,
	ConvexPolygon                            = 1,
	ConvexSolid                              = 2,
	EMeshApproximationBaseCappingType_MAX    = 3,
};

// Enum Engine.EOccludedGeometryFilteringPolicy
// NumValues: 0x0003
enum class EOccludedGeometryFilteringPolicy : uint8
{
	NoOcclusionFiltering                     = 0,
	VisibilityBasedFiltering                 = 1,
	EOccludedGeometryFilteringPolicy_MAX     = 2,
};

// Enum Engine.EMeshApproximationSimplificationPolicy
// NumValues: 0x0004
enum class EMeshApproximationSimplificationPolicy : uint8
{
	FixedTriangleCount                       = 0,
	TrianglesPerArea                         = 1,
	GeometricTolerance                       = 2,
	EMeshApproximationSimplificationPolicy_MAX = 3,
};

// Enum Engine.EMeshApproximationGroundPlaneClippingPolicy
// NumValues: 0x0005
enum class EMeshApproximationGroundPlaneClippingPolicy : uint8
{
	NoGroundClipping                         = 0,
	DiscardWithZPlane                        = 1,
	CutWithZPlane                            = 2,
	CutAndFillWithZPlane                     = 3,
	EMeshApproximationGroundPlaneClippingPolicy_MAX = 4,
};

// Enum Engine.EMeshApproximationUVGenerationPolicy
// NumValues: 0x0004
enum class EMeshApproximationUVGenerationPolicy : uint8
{
	PreferUVAtlas                            = 0,
	PreferXAtlas                             = 1,
	PreferPatchBuilder                       = 2,
	EMeshApproximationUVGenerationPolicy_MAX = 3,
};

// Enum Engine.EVertexPaintAxis
// NumValues: 0x0004
enum class EVertexPaintAxis : uint8
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	EVertexPaintAxis_MAX                     = 3,
};

// Enum Engine.EReplayResult
// NumValues: 0x000E
enum class EReplayResult : uint8
{
	Success                                  = 0,
	ReplayNotFound                           = 1,
	Corrupt                                  = 2,
	UnsupportedCheckpoint                    = 3,
	GameSpecific                             = 4,
	InitConnect                              = 5,
	LoadMap                                  = 6,
	Serialization                            = 7,
	StreamerError                            = 8,
	ConnectionClosed                         = 9,
	MissingArchive                           = 10,
	ReplayVersionWrong                       = 11,
	Unknown                                  = 12,
	EReplayResult_MAX                        = 13,
};

// Enum Engine.EPSCPoolMethod
// NumValues: 0x0006
enum class EPSCPoolMethod : uint8
{
	None                                     = 0,
	AutoRelease                              = 1,
	ManualRelease                            = 2,
	ManualRelease_OnComplete                 = 3,
	FreeInPool                               = 4,
	EPSCPoolMethod_MAX                       = 5,
};

// Enum Engine.EPerQualityLevels
// NumValues: 0x0007
enum class EPerQualityLevels : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Epic                                     = 3,
	Cinematic                                = 4,
	Num                                      = 5,
	EPerQualityLevels_MAX                    = 6,
};

// Enum Engine.EAngularDriveMode
// NumValues: 0x0003
enum class EAngularDriveMode : uint8
{
	SLERP                                    = 0,
	TwistAndSwing                            = 1,
	EAngularDriveMode_MAX                    = 2,
};

// Enum Engine.EConstraintTransformComponentFlags
// NumValues: 0x000B
enum class EConstraintTransformComponentFlags : uint8
{
	None                                     = 0,
	ChildPosition                            = 1,
	ChildRotation                            = 2,
	ParentPosition                           = 4,
	ParentRotation                           = 8,
	AllChild                                 = 3,
	AllParent                                = 12,
	AllPosition                              = 5,
	AllRotation                              = 10,
	All                                      = 15,
	EConstraintTransformComponentFlags_MAX   = 16,
};

// Enum Engine.EPhysicsAssetSolverType
// NumValues: 0x0003
enum class EPhysicsAssetSolverType : uint8
{
	RBAN                                     = 0,
	World                                    = 1,
	EPhysicsAssetSolverType_MAX              = 2,
};

// Enum Engine.ESettingsDOF
// NumValues: 0x0005
enum class ESettingsDOF : uint8
{
	Full3D                                   = 0,
	YZPlane                                  = 1,
	XZPlane                                  = 2,
	XYPlane                                  = 3,
	ESettingsDOF_MAX                         = 4,
};

// Enum Engine.ESettingsLockedAxis
// NumValues: 0x0006
enum class ESettingsLockedAxis : uint8
{
	None                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	Invalid                                  = 4,
	ESettingsLockedAxis_MAX                  = 5,
};

// Enum Engine.EDynamicForceFeedbackAction
// NumValues: 0x0004
enum class EDynamicForceFeedbackAction : uint8
{
	Start                                    = 0,
	Update                                   = 1,
	Stop                                     = 2,
	EDynamicForceFeedbackAction_MAX          = 3,
};

// Enum Engine.EVoiceBlockReasons
// NumValues: 0x0006
enum class EVoiceBlockReasons : uint8
{
	None                                     = 0,
	Muted                                    = 1,
	Gameplay                                 = 2,
	Blocked                                  = 4,
	BlockedBy                                = 8,
	EVoiceBlockReasons_MAX                   = 9,
};

// Enum Engine.EPropertyAccessCopyBatch
// NumValues: 0x0006
enum class EPropertyAccessCopyBatch : uint8
{
	InternalUnbatched                        = 0,
	ExternalUnbatched                        = 1,
	InternalBatched                          = 2,
	ExternalBatched                          = 3,
	Count                                    = 4,
	EPropertyAccessCopyBatch_MAX             = 5,
};

// Enum Engine.EPropertyAccessIndirectionType
// NumValues: 0x0006
enum class EPropertyAccessIndirectionType : uint8
{
	Offset                                   = 0,
	Object                                   = 1,
	Array                                    = 2,
	ScriptFunction                           = 3,
	NativeFunction                           = 4,
	EPropertyAccessIndirectionType_MAX       = 5,
};

// Enum Engine.EPropertyAccessObjectType
// NumValues: 0x0005
enum class EPropertyAccessObjectType : uint8
{
	None                                     = 0,
	Object                                   = 1,
	WeakObject                               = 2,
	SoftObject                               = 3,
	EPropertyAccessObjectType_MAX            = 4,
};

// Enum Engine.EPropertyAccessCopyType
// NumValues: 0x001B
enum class EPropertyAccessCopyType : uint8
{
	None                                     = 0,
	Plain                                    = 1,
	Complex                                  = 2,
	Bool                                     = 3,
	Struct                                   = 4,
	Object                                   = 5,
	Name                                     = 6,
	Array                                    = 7,
	PromoteBoolToByte                        = 8,
	PromoteBoolToInt32                       = 9,
	PromoteBoolToInt64                       = 10,
	PromoteBoolToFloat                       = 11,
	PromoteBoolToDouble                      = 12,
	PromoteByteToInt32                       = 13,
	PromoteByteToInt64                       = 14,
	PromoteByteToFloat                       = 15,
	PromoteByteToDouble                      = 16,
	PromoteInt32ToInt64                      = 17,
	PromoteInt32ToFloat                      = 18,
	PromoteInt32ToDouble                     = 19,
	PromoteFloatToDouble                     = 20,
	DemoteDoubleToFloat                      = 21,
	PromoteArrayFloatToDouble                = 22,
	DemoteArrayDoubleToFloat                 = 23,
	PromoteMapValueFloatToDouble             = 24,
	DemoteMapValueDoubleToFloat              = 25,
	EPropertyAccessCopyType_MAX              = 26,
};

// Enum Engine.EClearSceneOptions
// NumValues: 0x0004
enum class EClearSceneOptions : uint8
{
	NoClear                                  = 0,
	HardwareClear                            = 1,
	QuadAtMaxZ                               = 2,
	EClearSceneOptions_MAX                   = 3,
};

// Enum Engine.ECompositingSampleCount
// NumValues: 0x0005
enum class ECompositingSampleCount : uint8
{
	One                                      = 1,
	Two                                      = 2,
	Four                                     = 4,
	Eight                                    = 8,
	ECompositingSampleCount_MAX              = 9,
};

// Enum Engine.ECustomDepthStencil
// NumValues: 0x0005
enum class ECustomDepthStencil : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	EnabledOnDemand                          = 2,
	EnabledWithStencil                       = 3,
	ECustomDepthStencil_MAX                  = 4,
};

// Enum Engine.EEarlyZPass
// NumValues: 0x0005
enum class EEarlyZPass : uint8
{
	None                                     = 0,
	OpaqueOnly                               = 1,
	OpaqueAndMasked                          = 2,
	Auto                                     = 3,
	EEarlyZPass_MAX                          = 4,
};

// Enum Engine.EVelocityOutputPass
// NumValues: 0x0004
enum class EVelocityOutputPass : uint8
{
	DepthPass                                = 0,
	BasePass                                 = 1,
	AfterBasePass                            = 2,
	EVelocityOutputPass_MAX                  = 3,
};

// Enum Engine.EVertexDeformationOutputsVelocity
// NumValues: 0x0004
enum class EVertexDeformationOutputsVelocity : uint8
{
	Off                                      = 0,
	On                                       = 1,
	Auto                                     = 2,
	EVertexDeformationOutputsVelocity_MAX    = 3,
};

// Enum Engine.EAlphaChannelMode
// NumValues: 0x0004
enum class EAlphaChannelMode : uint8
{
	Disabled                                 = 0,
	LinearColorSpaceOnly                     = 1,
	AllowThroughTonemapper                   = 2,
	EAlphaChannelMode_MAX                    = 3,
};

// Enum Engine.EAutoExposureMethodUI
// NumValues: 0x0004
enum class EAutoExposureMethodUI : uint8
{
	AEM_Histogram                            = 0,
	AEM_Basic                                = 1,
	AEM_Manual                               = 2,
	AEM_MAX                                  = 3,
};

// Enum Engine.EDefaultBackBufferPixelFormat
// NumValues: 0x0006
enum class EDefaultBackBufferPixelFormat : uint8
{
	DBBPF_B8G8R8A8                           = 0,
	DBBPF_A16B16G16R16_DEPRECATED            = 1,
	DBBPF_FloatRGB_DEPRECATED                = 2,
	DBBPF_FloatRGBA                          = 3,
	DBBPF_A2B10G10R10                        = 4,
	DBBPF_MAX                                = 5,
};

// Enum Engine.EFixedFoveationLevels
// NumValues: 0x0006
enum class EFixedFoveationLevels : uint8
{
	Disabled                                 = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	HighTop                                  = 4,
	EFixedFoveationLevels_MAX                = 5,
};

// Enum Engine.EMobileAntiAliasingMethod
// NumValues: 0x0005
enum class EMobileAntiAliasingMethod : uint8
{
	None                                     = 0,
	FXAA                                     = 1,
	TemporalAA                               = 2,
	MSAA                                     = 4,
	EMobileAntiAliasingMethod_MAX            = 5,
};

// Enum Engine.EMobileFloatPrecisionMode
// NumValues: 0x0004
enum class EMobileFloatPrecisionMode : uint8
{
	Half                                     = 0,
	Full_MaterialExpressionOnly              = 1,
	Full                                     = 2,
	EMobileFloatPrecisionMode_MAX            = 3,
};

// Enum Engine.EMobileShadingPath
// NumValues: 0x0003
enum class EMobileShadingPath : uint8
{
	Forward                                  = 0,
	Deferred                                 = 1,
	EMobileShadingPath_MAX                   = 2,
};

// Enum Engine.EShaderCompressionFormat
// NumValues: 0x0005
enum class EShaderCompressionFormat : uint8
{
	None                                     = 0,
	LZ4                                      = 1,
	Oodle                                    = 2,
	Zlib                                     = 3,
	EShaderCompressionFormat_MAX             = 4,
};

// Enum Engine.ELumenSoftwareTracingMode
// NumValues: 0x0003
enum class ELumenSoftwareTracingMode : uint8
{
	DetailTracing                            = 1,
	GlobalTracing                            = 0,
	ELumenSoftwareTracingMode_MAX            = 2,
};

// Enum Engine.ELumenRayLightingMode
// NumValues: 0x0003
enum class ELumenRayLightingMode : uint8
{
	SurfaceCache                             = 0,
	HitLighting                              = 2,
	ELumenRayLightingMode_MAX                = 3,
};

// Enum Engine.EWorkingColorSpace
// NumValues: 0x0008
enum class EWorkingColorSpace : uint8
{
	SRGB                                     = 1,
	Rec2020                                  = 2,
	ACESAP0                                  = 3,
	ACESAP1                                  = 4,
	P3DCI                                    = 5,
	P3D65                                    = 6,
	Custom                                   = 7,
	EWorkingColorSpace_MAX                   = 8,
};

// Enum Engine.ESpecularProfileFormat
// NumValues: 0x0003
enum class ESpecularProfileFormat : uint8
{
	ViewLightVector                          = 0,
	HalfVector                               = 1,
	ESpecularProfileFormat_MAX               = 2,
};

// Enum Engine.ESkeletalMeshAsyncProperties
// NumValues: 0x003E
enum class ESkeletalMeshAsyncProperties : uint64
{
	None                                     = 0,
	Materials                                = 1,
	Skeleton                                 = 2,
	RefSkeleton                              = 4,
	RetargetBasePose                         = 8,
	RefBasesInvMatrix                        = 16,
	MeshClothingAssets                       = 32,
	UseLegacyMeshDerivedDataKey              = 64,
	HasActiveClothingAssets                  = 128,
	LODSettings                              = 256,
	HasVertexColors                          = 512,
	VertexColorGuid                          = 1024,
	MorphTargets                             = 2048,
	SkeletalMeshRenderData                   = 4096,
	MeshEditorDataObject                     = 8192,
	NeverStream                              = 16384,
	OverrideLODStreamingSettings             = 32768,
	SupportLODStreaming                      = 65536,
	MaxNumStreamedLODs                       = 131072,
	MaxNumOptionalLODs                       = 262144,
	ImportedModel                            = 524288,
	LODInfo                                  = 1048576,
	SkinWeightProfiles                       = 2097152,
	CachedComposedRefPoseMatrices            = 4194304,
	SamplingInfo                             = 8388608,
	NodeMappingData                          = 16777216,
	ShadowPhysicsAsset                       = 33554432,
	SkelMirrorTable                          = 67108864,
	MinLod                                   = 134217728,
	DisableBelowMinLodStripping              = 268435456,
	SkelMirrorAxis                           = 536870912,
	SkelMirrorFlipAxis                       = 1073741824,
	DefaultAnimationRig                      = 2147483648,
	NegativeBoundsExtension                  = 4294967296,
	PositiveBoundsExtension                  = 8589934592,
	ExtendedBounds                           = 17179869184,
	HasBeenSimplified                        = 34359738368,
	EnablePerPolyCollision                   = 68719476736,
	BodySetup                                = 137438953472,
	MorphTargetIndexMap                      = 274877906944,
	FloorOffset                              = 549755813888,
	ImportedBounds                           = 1099511627776,
	PhysicsAsset                             = 2199023255552,
	AssetImportData                          = 4398046511104,
	ThumbnailInfo                            = 8796093022208,
	HasCustomDefaultEditorCamera             = 17592186044416,
	DefaultEditorCameraLocation              = 35184372088832,
	DefaultEditorCameraRotation              = 70368744177664,
	RequiresLODScreenSizeConversion          = 140737488355328,
	PostProcessAnimBlueprint                 = 281474976710656,
	DefaultEditorCameraLookAt                = 562949953421312,
	PreviewAttachedAssetContainer            = 1125899906842624,
	DefaultEditorCameraOrthoZoom             = 2251799813685248,
	RequiresLODHysteresisConversion          = 4503599627370496,
	bSupportRayTracing                       = 9007199254740992,
	RayTracingMinLOD                         = 18014398509481984,
	ClothLODBiasMode                         = 36028797018963968,
	DefaultMeshDeformer                      = 72057594037927936,
	OverlayMaterial                          = 144115188075855872,
	OverlayMaterialMaxDrawDistance           = 288230376151711744,
	All                                      = 18446744073709551615,
	ESkeletalMeshAsyncProperties_MAX         = 288230376151711745,
};

// Enum Engine.EClothLODBiasMode
// NumValues: 0x0004
enum class EClothLODBiasMode : uint8
{
	MappingsToSameLOD                        = 0,
	MappingsToMinLOD                         = 1,
	MappingsToAnyLOD                         = 2,
	EClothLODBiasMode_MAX                    = 3,
};

// Enum Engine.EBoneFilterActionOption
// NumValues: 0x0004
enum class EBoneFilterActionOption : uint8
{
	Remove                                   = 0,
	Keep                                     = 1,
	Invalid                                  = 2,
	EBoneFilterActionOption_MAX              = 3,
};

// Enum Engine.ESkinCacheUsage
// NumValues: 0x0004
enum class ESkinCacheUsage : uint8
{
	Auto                                     = 0,
	Disabled                                 = 255,
	Enabled                                  = 1,
	ESkinCacheUsage_MAX                      = 256,
};

// Enum Engine.ESkinCacheDefaultBehavior
// NumValues: 0x0003
enum class ESkinCacheDefaultBehavior : uint8
{
	Exclusive                                = 0,
	Inclusive                                = 1,
	ESkinCacheDefaultBehavior_MAX            = 2,
};

// Enum Engine.EVirtualizationMode
// NumValues: 0x0004
enum class EVirtualizationMode : uint8
{
	Disabled                                 = 0,
	PlayWhenSilent                           = 1,
	Restart                                  = 2,
	EVirtualizationMode_MAX                  = 3,
};

// Enum Engine.EMaxConcurrentResolutionRule
// NumValues: 0x0009
enum class EMaxConcurrentResolutionRule : uint8
{
	PreventNew                               = 0,
	StopOldest                               = 1,
	StopFarthestThenPreventNew               = 2,
	StopFarthestThenOldest                   = 3,
	StopLowestPriority                       = 4,
	StopQuietest                             = 5,
	StopLowestPriorityThenPreventNew         = 6,
	Count                                    = 7,
	EMaxConcurrentResolutionRule_MAX         = 8,
};

// Enum Engine.EConcurrencyVolumeScaleMode
// NumValues: 0x0004
enum class EConcurrencyVolumeScaleMode : uint32
{
	Default                                  = 0,
	Distance                                 = 1,
	Priority                                 = 2,
	EConcurrencyVolumeScaleMode_MAX          = 3,
};

// Enum Engine.EModulationRouting
// NumValues: 0x0005
enum class EModulationRouting : uint8
{
	Disable                                  = 0,
	Inherit                                  = 1,
	Override                                 = 2,
	Union                                    = 3,
	EModulationRouting_MAX                   = 4,
};

// Enum Engine.ESourceBusChannels
// NumValues: 0x0003
enum class ESourceBusChannels : uint8
{
	Mono                                     = 0,
	Stereo                                   = 1,
	ESourceBusChannels_MAX                   = 2,
};

// Enum Engine.EFFTSize
// NumValues: 0x0008
enum class EFFTSize : uint8
{
	DefaultSize                              = 0,
	Min                                      = 1,
	Small                                    = 2,
	Medium                                   = 3,
	Large                                    = 4,
	VeryLarge                                = 5,
	Max                                      = 6,
	EFFTSize_MAX                             = 7,
};

// Enum Engine.EFFTPeakInterpolationMethod
// NumValues: 0x0005
enum class EFFTPeakInterpolationMethod : uint8
{
	NearestNeighbor                          = 0,
	Linear                                   = 1,
	Quadratic                                = 2,
	ConstantQ                                = 3,
	EFFTPeakInterpolationMethod_MAX          = 4,
};

// Enum Engine.EFFTWindowType
// NumValues: 0x0005
enum class EFFTWindowType : uint8
{
	None                                     = 0,
	Hamming                                  = 1,
	Hann                                     = 2,
	Blackman                                 = 3,
	EFFTWindowType_MAX                       = 4,
};

// Enum Engine.EAudioSpectrumType
// NumValues: 0x0004
enum class EAudioSpectrumType : uint8
{
	MagnitudeSpectrum                        = 0,
	PowerSpectrum                            = 1,
	Decibel                                  = 2,
	EAudioSpectrumType_MAX                   = 3,
};

// Enum Engine.EGainParamMode
// NumValues: 0x0003
enum class EGainParamMode : uint8
{
	Linear                                   = 0,
	Decibels                                 = 1,
	EGainParamMode_MAX                       = 2,
};

// Enum Engine.EAudioSpectrumBandPresetType
// NumValues: 0x0005
enum class EAudioSpectrumBandPresetType : uint8
{
	KickDrum                                 = 0,
	SnareDrum                                = 1,
	Voice                                    = 2,
	Cymbals                                  = 3,
	EAudioSpectrumBandPresetType_MAX         = 4,
};

// Enum Engine.EAudioRecordingExportType
// NumValues: 0x0003
enum class EAudioRecordingExportType : uint8
{
	SoundWave                                = 0,
	WavFile                                  = 1,
	EAudioRecordingExportType_MAX            = 2,
};

// Enum Engine.ESendLevelControlMethod
// NumValues: 0x0004
enum class ESendLevelControlMethod : uint8
{
	Linear                                   = 0,
	CustomCurve                              = 1,
	Manual                                   = 2,
	ESendLevelControlMethod_MAX              = 3,
};

// Enum Engine.ESubmixSendStage
// NumValues: 0x0003
enum class ESubmixSendStage : uint8
{
	PostDistanceAttenuation                  = 0,
	PreDistanceAttenuation                   = 1,
	ESubmixSendStage_MAX                     = 2,
};

// Enum Engine.ENormalMode
// NumValues: 0x0006
enum class ENormalMode : uint8
{
	NM_PreserveSmoothingGroups               = 0,
	NM_RecalculateNormals                    = 1,
	NM_RecalculateNormalsSmooth              = 2,
	NM_RecalculateNormalsHard                = 3,
	TEMP_BROKEN                              = 4,
	ENormalMode_MAX                          = 5,
};

// Enum Engine.EImportanceLevel
// NumValues: 0x0008
enum class EImportanceLevel : uint8
{
	IL_Off                                   = 0,
	IL_Lowest                                = 1,
	IL_Low                                   = 2,
	IL_Normal                                = 3,
	IL_High                                  = 4,
	IL_Highest                               = 5,
	TEMP_BROKEN2                             = 6,
	EImportanceLevel_MAX                     = 7,
};

// Enum Engine.EOptimizationType
// NumValues: 0x0003
enum class EOptimizationType : uint8
{
	OT_NumOfTriangles                        = 0,
	OT_MaxDeviation                          = 1,
	OT_MAX                                   = 2,
};

// Enum Engine.ETextureEncodeEffort
// NumValues: 0x0005
enum class ETextureEncodeEffort : uint8
{
	Default                                  = 0,
	Low                                      = 10,
	Normal                                   = 20,
	High                                     = 30,
	ETextureEncodeEffort_MAX                 = 31,
};

// Enum Engine.ETextureUniversalTiling
// NumValues: 0x0004
enum class ETextureUniversalTiling : uint8
{
	Disabled                                 = 0,
	Enabled_256KB                            = 1,
	Enabled_64KB                             = 2,
	ETextureUniversalTiling_MAX              = 3,
};

// Enum Engine.ETextureEncodeSpeedOverride
// NumValues: 0x0005
enum class ETextureEncodeSpeedOverride : uint8
{
	Disabled                                 = 255,
	Final                                    = 0,
	FinalIfAvailable                         = 1,
	Fast                                     = 2,
	ETextureEncodeSpeedOverride_MAX          = 256,
};

// Enum Engine.ETextureRenderTargetFormat
// NumValues: 0x000C
enum class ETextureRenderTargetFormat : uint8
{
	RTF_R8                                   = 0,
	RTF_RG8                                  = 1,
	RTF_RGBA8                                = 2,
	RTF_RGBA8_SRGB                           = 3,
	RTF_R16f                                 = 4,
	RTF_RG16f                                = 5,
	RTF_RGBA16f                              = 6,
	RTF_R32f                                 = 7,
	RTF_RG32f                                = 8,
	RTF_RGBA32f                              = 9,
	RTF_RGB10A2                              = 10,
	RTF_MAX                                  = 11,
};

// Enum Engine.ERenderFocusRule
// NumValues: 0x0005
enum class ERenderFocusRule : uint8
{
	Always                                   = 0,
	NonPointer                               = 1,
	NavigationOnly                           = 2,
	Never                                    = 3,
	ERenderFocusRule_MAX                     = 4,
};

// Enum Engine.EUIScalingRule
// NumValues: 0x0007
enum class EUIScalingRule : uint8
{
	ShortestSide                             = 0,
	LongestSide                              = 1,
	Horizontal                               = 2,
	Vertical                                 = 3,
	ScaleToFit                               = 4,
	Custom                                   = 5,
	EUIScalingRule_MAX                       = 6,
};

// Enum Engine.EFontDPI
// NumValues: 0x0004
enum class EFontDPI : uint8
{
	Standard                                 = 0,
	Unreal                                   = 1,
	Custom                                   = 2,
	EFontDPI_MAX                             = 3,
};

// Enum Engine.EHardwareDeviceSupportedFeatures
// NumValues: 0x0015
enum class EHardwareDeviceSupportedFeatures : uint32
{
	Unspecified                              = 0,
	Keypress                                 = 1,
	Pointer                                  = 2,
	Gamepad                                  = 4,
	Touch                                    = 8,
	Camera                                   = 16,
	MotionTracking                           = 32,
	Lights                                   = 64,
	TriggerHaptics                           = 128,
	ForceFeedback                            = 256,
	AudioBasedVibrations                     = 512,
	Acceleration                             = 1024,
	Virtual                                  = 2048,
	Microphone                               = 4096,
	Orientation                              = 8192,
	CustomA                                  = 16777216,
	CustomB                                  = 33554432,
	CustomC                                  = 67108864,
	CustomD                                  = 134217728,
	All                                      = 2147483647,
	EHardwareDeviceSupportedFeatures_MAX     = 2147483648,
};

// Enum Engine.EHardwareDevicePrimaryType
// NumValues: 0x000E
enum class EHardwareDevicePrimaryType : uint8
{
	Unspecified                              = 0,
	KeyboardAndMouse                         = 1,
	Gamepad                                  = 2,
	Touch                                    = 3,
	MotionTracking                           = 4,
	RacingWheel                              = 5,
	FlightStick                              = 6,
	Camera                                   = 7,
	Instrument                               = 8,
	CustomTypeA                              = 9,
	CustomTypeB                              = 10,
	CustomTypeC                              = 11,
	CustomTypeD                              = 12,
	EHardwareDevicePrimaryType_MAX           = 13,
};

// Enum Engine.EConsumeKeyCause
// NumValues: 0x0007
enum class EConsumeKeyCause : uint32
{
	InputComponentConsume                    = 0,
	PriorityConsume                          = 1,
	ActionEventConsume                       = 2,
	KeyBindConsume                           = 3,
	InputContextConsumeNotRegister           = 4,
	EnhancedConsumeActionAndAxisMappings     = 5,
	EConsumeKeyCause_MAX                     = 6,
};

// Enum Engine.ERollbackState
// NumValues: 0x0004
enum class ERollbackState : uint8
{
	Disable                                  = 0,
	Enable                                   = 1,
	ISDEBUG                                  = 2,
	ERollbackState_MAX                       = 3,
};

// Enum Engine.EDataLayerState
// NumValues: 0x0004
enum class EDataLayerState : uint8
{
	Unloaded                                 = 0,
	Loaded                                   = 1,
	Activated                                = 2,
	EDataLayerState_MAX                      = 3,
};

// Enum Engine.EHLODLayerType
// NumValues: 0x0006
enum class EHLODLayerType : uint8
{
	Instancing                               = 0,
	MeshMerge                                = 1,
	MeshSimplify                             = 2,
	MeshApproximate                          = 3,
	Custom                                   = 4,
	EHLODLayerType_MAX                       = 5,
};

// Enum Engine.EWorldPartitionServerStreamingMode
// NumValues: 0x0005
enum class EWorldPartitionServerStreamingMode : uint8
{
	ProjectDefault                           = 0,
	Disabled                                 = 1,
	Enabled                                  = 2,
	EnabledInPIE                             = 3,
	EWorldPartitionServerStreamingMode_MAX   = 4,
};

// Enum Engine.EWorldPartitionServerStreamingOutMode
// NumValues: 0x0004
enum class EWorldPartitionServerStreamingOutMode : uint8
{
	ProjectDefault                           = 0,
	Disabled                                 = 1,
	Enabled                                  = 2,
	EWorldPartitionServerStreamingOutMode_MAX = 3,
};

// Enum Engine.EWorldPartitionRuntimeCellState
// NumValues: 0x0004
enum class EWorldPartitionRuntimeCellState : uint8
{
	Unloaded                                 = 0,
	Loaded                                   = 1,
	Activated                                = 2,
	EWorldPartitionRuntimeCellState_MAX      = 3,
};

// Enum Engine.EWorldPartitionStreamingPerformance
// NumValues: 0x0004
enum class EWorldPartitionStreamingPerformance : uint8
{
	Good                                     = 0,
	Slow                                     = 1,
	Critical                                 = 2,
	EWorldPartitionStreamingPerformance_MAX  = 3,
};

// Enum Engine.EWorldPartitionCVarProjectDefaultOverride
// NumValues: 0x0004
enum class EWorldPartitionCVarProjectDefaultOverride : uint8
{
	ProjectDefault                           = 0,
	Disabled                                 = 1,
	Enabled                                  = 2,
	EWorldPartitionCVarProjectDefaultOverride_MAX = 3,
};

// Enum Engine.EStreamingSourceTargetBehavior
// NumValues: 0x0003
enum class EStreamingSourceTargetBehavior : uint8
{
	Include                                  = 0,
	Exclude                                  = 1,
	EStreamingSourceTargetBehavior_MAX       = 2,
};

// Enum Engine.EStreamingSourceTargetState
// NumValues: 0x0003
enum class EStreamingSourceTargetState : uint8
{
	Loaded                                   = 0,
	Activated                                = 1,
	EStreamingSourceTargetState_MAX          = 2,
};

// Enum Engine.EStreamingSourcePriority
// NumValues: 0x0007
enum class EStreamingSourcePriority : uint8
{
	Highest                                  = 0,
	High                                     = 64,
	Normal                                   = 128,
	Low                                      = 192,
	Lowest                                   = 255,
	Default                                  = 128,
	EStreamingSourcePriority_MAX             = 256,
};

// ScriptStruct Engine.PieFixupStructWithSoftObjectPath
// 0x0058 (0x0058 - 0x0000)
struct FPieFixupStructWithSoftObjectPath final
{
public:
	struct FSoftObjectPath                        Path;                                              // 0x0000(0x0028)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  TypedPtr;                                          // 0x0028(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPieFixupStructWithSoftObjectPath) == 0x000008, "Wrong alignment on FPieFixupStructWithSoftObjectPath");
//(sizeof(FPieFixupStructWithSoftObjectPath) == 0x000058, "Wrong size on FPieFixupStructWithSoftObjectPath");
//(offsetof(FPieFixupStructWithSoftObjectPath, Path) == 0x000000, "Member 'FPieFixupStructWithSoftObjectPath::Path' has a wrong offset!");
//(offsetof(FPieFixupStructWithSoftObjectPath, TypedPtr) == 0x000028, "Member 'FPieFixupStructWithSoftObjectPath::TypedPtr' has a wrong offset!");

// ScriptStruct Engine.BaseComponentReference
// 0x0028 (0x0028 - 0x0000)
struct FBaseComponentReference
{
public:
	class FName                                   ComponentProperty;                                 // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PathToComponent;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBaseComponentReference) == 0x000008, "Wrong alignment on FBaseComponentReference");
//(sizeof(FBaseComponentReference) == 0x000028, "Wrong size on FBaseComponentReference");
//(offsetof(FBaseComponentReference, ComponentProperty) == 0x000000, "Member 'FBaseComponentReference::ComponentProperty' has a wrong offset!");
//(offsetof(FBaseComponentReference, PathToComponent) == 0x000010, "Member 'FBaseComponentReference::PathToComponent' has a wrong offset!");

// ScriptStruct Engine.AnimCurveParam
// 0x0010 (0x0010 - 0x0000)
struct FAnimCurveParam final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimCurveParam) == 0x000004, "Wrong alignment on FAnimCurveParam");
//(sizeof(FAnimCurveParam) == 0x000010, "Wrong size on FAnimCurveParam");
//(offsetof(FAnimCurveParam, Name) == 0x000000, "Member 'FAnimCurveParam::Name' has a wrong offset!");

// ScriptStruct Engine.MaterialInput
// 0x0030 (0x0030 - 0x0000)
struct FMaterialInput
{
public:
	class UMaterialExpression*                    Expression;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutputIndex;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InputName;                                         // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mask;                                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskR;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskG;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskB;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskA;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMaterialInput) == 0x000008, "Wrong alignment on FMaterialInput");
//(sizeof(FMaterialInput) == 0x000030, "Wrong size on FMaterialInput");
//(offsetof(FMaterialInput, Expression) == 0x000000, "Member 'FMaterialInput::Expression' has a wrong offset!");
//(offsetof(FMaterialInput, OutputIndex) == 0x000008, "Member 'FMaterialInput::OutputIndex' has a wrong offset!");
//(offsetof(FMaterialInput, InputName) == 0x00000C, "Member 'FMaterialInput::InputName' has a wrong offset!");
//(offsetof(FMaterialInput, Mask) == 0x000018, "Member 'FMaterialInput::Mask' has a wrong offset!");
//(offsetof(FMaterialInput, MaskR) == 0x00001C, "Member 'FMaterialInput::MaskR' has a wrong offset!");
//(offsetof(FMaterialInput, MaskG) == 0x000020, "Member 'FMaterialInput::MaskG' has a wrong offset!");
//(offsetof(FMaterialInput, MaskB) == 0x000024, "Member 'FMaterialInput::MaskB' has a wrong offset!");
//(offsetof(FMaterialInput, MaskA) == 0x000028, "Member 'FMaterialInput::MaskA' has a wrong offset!");

// ScriptStruct Engine.MaterialParameterInfo
// 0x0014 (0x0014 - 0x0000)
struct FMaterialParameterInfo final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialParameterAssociation                 Association;                                       // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialParameterInfo) == 0x000004, "Wrong alignment on FMaterialParameterInfo");
//(sizeof(FMaterialParameterInfo) == 0x000014, "Wrong size on FMaterialParameterInfo");
//(offsetof(FMaterialParameterInfo, Name) == 0x000000, "Member 'FMaterialParameterInfo::Name' has a wrong offset!");
//(offsetof(FMaterialParameterInfo, Association) == 0x00000C, "Member 'FMaterialParameterInfo::Association' has a wrong offset!");
//(offsetof(FMaterialParameterInfo, Index) == 0x000010, "Member 'FMaterialParameterInfo::Index' has a wrong offset!");

// ScriptStruct Engine.StaticParameterBase
// 0x0028 (0x0028 - 0x0000)
struct FStaticParameterBase
{
public:
	struct FMaterialParameterInfo                 ParameterInfo;                                     // 0x0000(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ExpressionGUID;                                    // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FStaticParameterBase) == 0x000004, "Wrong alignment on FStaticParameterBase");
//(sizeof(FStaticParameterBase) == 0x000028, "Wrong size on FStaticParameterBase");
//(offsetof(FStaticParameterBase, ParameterInfo) == 0x000000, "Member 'FStaticParameterBase::ParameterInfo' has a wrong offset!");
//(offsetof(FStaticParameterBase, bOverride) == 0x000014, "Member 'FStaticParameterBase::bOverride' has a wrong offset!");
//(offsetof(FStaticParameterBase, ExpressionGUID) == 0x000018, "Member 'FStaticParameterBase::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.StaticSwitchParameter
// 0x0004 (0x002C - 0x0028)
struct FStaticSwitchParameter final : public FStaticParameterBase
{
public:
	bool                                          Value;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStaticSwitchParameter) == 0x000004, "Wrong alignment on FStaticSwitchParameter");
//(sizeof(FStaticSwitchParameter) == 0x00002C, "Wrong size on FStaticSwitchParameter");
//(offsetof(FStaticSwitchParameter, Value) == 0x000028, "Member 'FStaticSwitchParameter::Value' has a wrong offset!");

// ScriptStruct Engine.MaterialLayersFunctionsRuntimeData
// 0x0020 (0x0020 - 0x0000)
struct FMaterialLayersFunctionsRuntimeData
{
public:
	TArray<class UMaterialFunctionInterface*>     Layers;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMaterialFunctionInterface*>     Blends;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialLayersFunctionsRuntimeData) == 0x000008, "Wrong alignment on FMaterialLayersFunctionsRuntimeData");
//(sizeof(FMaterialLayersFunctionsRuntimeData) == 0x000020, "Wrong size on FMaterialLayersFunctionsRuntimeData");
//(offsetof(FMaterialLayersFunctionsRuntimeData, Layers) == 0x000000, "Member 'FMaterialLayersFunctionsRuntimeData::Layers' has a wrong offset!");
//(offsetof(FMaterialLayersFunctionsRuntimeData, Blends) == 0x000010, "Member 'FMaterialLayersFunctionsRuntimeData::Blends' has a wrong offset!");

// ScriptStruct Engine.StaticParameterSetRuntimeData
// 0x0038 (0x0038 - 0x0000)
struct FStaticParameterSetRuntimeData
{
public:
	TArray<struct FStaticSwitchParameter>         StaticSwitchParameters;                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FMaterialLayersFunctionsRuntimeData    MaterialLayers;                                    // 0x0010(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         bHasMaterialLayers : 1;                            // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStaticParameterSetRuntimeData) == 0x000008, "Wrong alignment on FStaticParameterSetRuntimeData");
//(sizeof(FStaticParameterSetRuntimeData) == 0x000038, "Wrong size on FStaticParameterSetRuntimeData");
//(offsetof(FStaticParameterSetRuntimeData, StaticSwitchParameters) == 0x000000, "Member 'FStaticParameterSetRuntimeData::StaticSwitchParameters' has a wrong offset!");
//(offsetof(FStaticParameterSetRuntimeData, MaterialLayers) == 0x000010, "Member 'FStaticParameterSetRuntimeData::MaterialLayers' has a wrong offset!");

// ScriptStruct Engine.BPEditorBookmarkNode
// 0x0038 (0x0038 - 0x0000)
struct FBPEditorBookmarkNode final
{
public:
	struct FGuid                                  NodeGuid;                                          // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ParentGuid;                                        // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0020(0x0018)(NativeAccessSpecifierPublic)
};
//(alignof(FBPEditorBookmarkNode) == 0x000008, "Wrong alignment on FBPEditorBookmarkNode");
//(sizeof(FBPEditorBookmarkNode) == 0x000038, "Wrong size on FBPEditorBookmarkNode");
//(offsetof(FBPEditorBookmarkNode, NodeGuid) == 0x000000, "Member 'FBPEditorBookmarkNode::NodeGuid' has a wrong offset!");
//(offsetof(FBPEditorBookmarkNode, ParentGuid) == 0x000010, "Member 'FBPEditorBookmarkNode::ParentGuid' has a wrong offset!");
//(offsetof(FBPEditorBookmarkNode, DisplayName) == 0x000020, "Member 'FBPEditorBookmarkNode::DisplayName' has a wrong offset!");

// ScriptStruct Engine.ColorMaterialInput
// 0x0008 (0x0038 - 0x0030)
struct FColorMaterialInput final : public FMaterialInput
{
public:
	uint8                                         UseConstant : 1;                                   // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Constant;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FColorMaterialInput) == 0x000008, "Wrong alignment on FColorMaterialInput");
//(sizeof(FColorMaterialInput) == 0x000038, "Wrong size on FColorMaterialInput");
//(offsetof(FColorMaterialInput, Constant) == 0x000034, "Member 'FColorMaterialInput::Constant' has a wrong offset!");

// ScriptStruct Engine.TickFunction
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FTickFunction
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETickingGroup                                 TickGroup;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETickingGroup                                 EndTickGroup;                                      // 0x0009(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTickEvenWhenPaused : 1;                           // 0x000A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanEverTick : 1;                                  // 0x000A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartWithTickEnabled : 1;                         // 0x000A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseBatchTick : 1;                                 // 0x000A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowTickOnDedicatedServer : 1;                   // 0x000A(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x1C];                                      // 0x0014(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTickFunction) == 0x000008, "Wrong alignment on FTickFunction");
//(sizeof(FTickFunction) == 0x000030, "Wrong size on FTickFunction");
//(offsetof(FTickFunction, TickGroup) == 0x000008, "Member 'FTickFunction::TickGroup' has a wrong offset!");
//(offsetof(FTickFunction, EndTickGroup) == 0x000009, "Member 'FTickFunction::EndTickGroup' has a wrong offset!");
//(offsetof(FTickFunction, TickInterval) == 0x000010, "Member 'FTickFunction::TickInterval' has a wrong offset!");

// ScriptStruct Engine.ActorTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FActorTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FActorTickFunction) == 0x000008, "Wrong alignment on FActorTickFunction");
//(sizeof(FActorTickFunction) == 0x000038, "Wrong size on FActorTickFunction");

// ScriptStruct Engine.BookmarkBaseJumpToSettings
// 0x0001 (0x0001 - 0x0000)
struct FBookmarkBaseJumpToSettings
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBookmarkBaseJumpToSettings) == 0x000001, "Wrong alignment on FBookmarkBaseJumpToSettings");
//(sizeof(FBookmarkBaseJumpToSettings) == 0x000001, "Wrong size on FBookmarkBaseJumpToSettings");

// ScriptStruct Engine.MeshUVChannelInfo
// 0x0014 (0x0014 - 0x0000)
struct FMeshUVChannelInfo final
{
public:
	bool                                          bInitialized;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDensities;                                // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocalUVDensities[0x4];                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMeshUVChannelInfo) == 0x000004, "Wrong alignment on FMeshUVChannelInfo");
//(sizeof(FMeshUVChannelInfo) == 0x000014, "Wrong size on FMeshUVChannelInfo");
//(offsetof(FMeshUVChannelInfo, bInitialized) == 0x000000, "Member 'FMeshUVChannelInfo::bInitialized' has a wrong offset!");
//(offsetof(FMeshUVChannelInfo, bOverrideDensities) == 0x000001, "Member 'FMeshUVChannelInfo::bOverrideDensities' has a wrong offset!");
//(offsetof(FMeshUVChannelInfo, LocalUVDensities) == 0x000004, "Member 'FMeshUVChannelInfo::LocalUVDensities' has a wrong offset!");

// ScriptStruct Engine.DistributionLookupTable
// 0x0020 (0x0020 - 0x0000)
struct FDistributionLookupTable final
{
public:
	float                                         TimeScale;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBias;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Values;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Op;                                                // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EntryCount;                                        // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EntryStride;                                       // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SubEntryStride;                                    // 0x001B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LockFlag;                                          // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDistributionLookupTable) == 0x000008, "Wrong alignment on FDistributionLookupTable");
//(sizeof(FDistributionLookupTable) == 0x000020, "Wrong size on FDistributionLookupTable");
//(offsetof(FDistributionLookupTable, TimeScale) == 0x000000, "Member 'FDistributionLookupTable::TimeScale' has a wrong offset!");
//(offsetof(FDistributionLookupTable, TimeBias) == 0x000004, "Member 'FDistributionLookupTable::TimeBias' has a wrong offset!");
//(offsetof(FDistributionLookupTable, Values) == 0x000008, "Member 'FDistributionLookupTable::Values' has a wrong offset!");
//(offsetof(FDistributionLookupTable, Op) == 0x000018, "Member 'FDistributionLookupTable::Op' has a wrong offset!");
//(offsetof(FDistributionLookupTable, EntryCount) == 0x000019, "Member 'FDistributionLookupTable::EntryCount' has a wrong offset!");
//(offsetof(FDistributionLookupTable, EntryStride) == 0x00001A, "Member 'FDistributionLookupTable::EntryStride' has a wrong offset!");
//(offsetof(FDistributionLookupTable, SubEntryStride) == 0x00001B, "Member 'FDistributionLookupTable::SubEntryStride' has a wrong offset!");
//(offsetof(FDistributionLookupTable, LockFlag) == 0x00001C, "Member 'FDistributionLookupTable::LockFlag' has a wrong offset!");

// ScriptStruct Engine.PlatformInterfaceData
// 0x0030 (0x0030 - 0x0000)
struct FPlatformInterfaceData final
{
public:
	class FName                                   DataName;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlatformInterfaceDataType                    Type;                                              // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntValue;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringValue;                                       // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ObjectValue;                                       // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPlatformInterfaceData) == 0x000008, "Wrong alignment on FPlatformInterfaceData");
//(sizeof(FPlatformInterfaceData) == 0x000030, "Wrong size on FPlatformInterfaceData");
//(offsetof(FPlatformInterfaceData, DataName) == 0x000000, "Member 'FPlatformInterfaceData::DataName' has a wrong offset!");
//(offsetof(FPlatformInterfaceData, Type) == 0x00000C, "Member 'FPlatformInterfaceData::Type' has a wrong offset!");
//(offsetof(FPlatformInterfaceData, IntValue) == 0x000010, "Member 'FPlatformInterfaceData::IntValue' has a wrong offset!");
//(offsetof(FPlatformInterfaceData, FloatValue) == 0x000014, "Member 'FPlatformInterfaceData::FloatValue' has a wrong offset!");
//(offsetof(FPlatformInterfaceData, StringValue) == 0x000018, "Member 'FPlatformInterfaceData::StringValue' has a wrong offset!");
//(offsetof(FPlatformInterfaceData, ObjectValue) == 0x000028, "Member 'FPlatformInterfaceData::ObjectValue' has a wrong offset!");

// ScriptStruct Engine.PlatformInterfaceDelegateResult
// 0x0038 (0x0038 - 0x0000)
struct FPlatformInterfaceDelegateResult final
{
public:
	bool                                          bSuccessful;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlatformInterfaceData                 Data;                                              // 0x0008(0x0030)(NativeAccessSpecifierPublic)
};
//(alignof(FPlatformInterfaceDelegateResult) == 0x000008, "Wrong alignment on FPlatformInterfaceDelegateResult");
//(sizeof(FPlatformInterfaceDelegateResult) == 0x000038, "Wrong size on FPlatformInterfaceDelegateResult");
//(offsetof(FPlatformInterfaceDelegateResult, bSuccessful) == 0x000000, "Member 'FPlatformInterfaceDelegateResult::bSuccessful' has a wrong offset!");
//(offsetof(FPlatformInterfaceDelegateResult, Data) == 0x000008, "Member 'FPlatformInterfaceDelegateResult::Data' has a wrong offset!");

// ScriptStruct Engine.ConstraintDrive
// 0x0010 (0x0010 - 0x0000)
struct FConstraintDrive final
{
public:
	float                                         Stiffness;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForce;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnablePositionDrive : 1;                          // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableVelocityDrive : 1;                          // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FConstraintDrive) == 0x000004, "Wrong alignment on FConstraintDrive");
//(sizeof(FConstraintDrive) == 0x000010, "Wrong size on FConstraintDrive");
//(offsetof(FConstraintDrive, Stiffness) == 0x000000, "Member 'FConstraintDrive::Stiffness' has a wrong offset!");
//(offsetof(FConstraintDrive, Damping) == 0x000004, "Member 'FConstraintDrive::Damping' has a wrong offset!");
//(offsetof(FConstraintDrive, MaxForce) == 0x000008, "Member 'FConstraintDrive::MaxForce' has a wrong offset!");

// ScriptStruct Engine.AngularDriveConstraint
// 0x0068 (0x0068 - 0x0000)
struct FAngularDriveConstraint final
{
public:
	struct FConstraintDrive                       TwistDrive;                                        // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FConstraintDrive                       SwingDrive;                                        // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FConstraintDrive                       SlerpDrive;                                        // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               OrientationTarget;                                 // 0x0030(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocityTarget;                             // 0x0048(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngularDriveMode                             AngularDriveMode;                                  // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAngularDriveConstraint) == 0x000008, "Wrong alignment on FAngularDriveConstraint");
//(sizeof(FAngularDriveConstraint) == 0x000068, "Wrong size on FAngularDriveConstraint");
//(offsetof(FAngularDriveConstraint, TwistDrive) == 0x000000, "Member 'FAngularDriveConstraint::TwistDrive' has a wrong offset!");
//(offsetof(FAngularDriveConstraint, SwingDrive) == 0x000010, "Member 'FAngularDriveConstraint::SwingDrive' has a wrong offset!");
//(offsetof(FAngularDriveConstraint, SlerpDrive) == 0x000020, "Member 'FAngularDriveConstraint::SlerpDrive' has a wrong offset!");
//(offsetof(FAngularDriveConstraint, OrientationTarget) == 0x000030, "Member 'FAngularDriveConstraint::OrientationTarget' has a wrong offset!");
//(offsetof(FAngularDriveConstraint, AngularVelocityTarget) == 0x000048, "Member 'FAngularDriveConstraint::AngularVelocityTarget' has a wrong offset!");
//(offsetof(FAngularDriveConstraint, AngularDriveMode) == 0x000060, "Member 'FAngularDriveConstraint::AngularDriveMode' has a wrong offset!");

// ScriptStruct Engine.InputDevicePropertyHandle
// 0x0004 (0x0004 - 0x0000)
struct FInputDevicePropertyHandle final
{
public:
	uint32                                        InternalId;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FInputDevicePropertyHandle) == 0x000004, "Wrong alignment on FInputDevicePropertyHandle");
//(sizeof(FInputDevicePropertyHandle) == 0x000004, "Wrong size on FInputDevicePropertyHandle");
//(offsetof(FInputDevicePropertyHandle, InternalId) == 0x000000, "Member 'FInputDevicePropertyHandle::InternalId' has a wrong offset!");

// ScriptStruct Engine.ExpressionInput
// 0x0030 (0x0030 - 0x0000)
struct FExpressionInput
{
public:
	class UMaterialExpression*                    Expression;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutputIndex;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InputName;                                         // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mask;                                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskR;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskG;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskB;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskA;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FExpressionInput) == 0x000008, "Wrong alignment on FExpressionInput");
//(sizeof(FExpressionInput) == 0x000030, "Wrong size on FExpressionInput");
//(offsetof(FExpressionInput, Expression) == 0x000000, "Member 'FExpressionInput::Expression' has a wrong offset!");
//(offsetof(FExpressionInput, OutputIndex) == 0x000008, "Member 'FExpressionInput::OutputIndex' has a wrong offset!");
//(offsetof(FExpressionInput, InputName) == 0x00000C, "Member 'FExpressionInput::InputName' has a wrong offset!");
//(offsetof(FExpressionInput, Mask) == 0x000018, "Member 'FExpressionInput::Mask' has a wrong offset!");
//(offsetof(FExpressionInput, MaskR) == 0x00001C, "Member 'FExpressionInput::MaskR' has a wrong offset!");
//(offsetof(FExpressionInput, MaskG) == 0x000020, "Member 'FExpressionInput::MaskG' has a wrong offset!");
//(offsetof(FExpressionInput, MaskB) == 0x000024, "Member 'FExpressionInput::MaskB' has a wrong offset!");
//(offsetof(FExpressionInput, MaskA) == 0x000028, "Member 'FExpressionInput::MaskA' has a wrong offset!");

// ScriptStruct Engine.EdGraphTerminalType
// 0x0024 (0x0024 - 0x0000)
struct FEdGraphTerminalType final
{
public:
	class FName                                   TerminalCategory;                                  // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TerminalSubCategory;                               // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 TerminalSubCategoryObject;                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTerminalIsConst;                                  // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTerminalIsWeakPointer;                            // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTerminalIsUObjectWrapper;                         // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FEdGraphTerminalType) == 0x000004, "Wrong alignment on FEdGraphTerminalType");
//(sizeof(FEdGraphTerminalType) == 0x000024, "Wrong size on FEdGraphTerminalType");
//(offsetof(FEdGraphTerminalType, TerminalCategory) == 0x000000, "Member 'FEdGraphTerminalType::TerminalCategory' has a wrong offset!");
//(offsetof(FEdGraphTerminalType, TerminalSubCategory) == 0x00000C, "Member 'FEdGraphTerminalType::TerminalSubCategory' has a wrong offset!");
//(offsetof(FEdGraphTerminalType, TerminalSubCategoryObject) == 0x000018, "Member 'FEdGraphTerminalType::TerminalSubCategoryObject' has a wrong offset!");
//(offsetof(FEdGraphTerminalType, bTerminalIsConst) == 0x000020, "Member 'FEdGraphTerminalType::bTerminalIsConst' has a wrong offset!");
//(offsetof(FEdGraphTerminalType, bTerminalIsWeakPointer) == 0x000021, "Member 'FEdGraphTerminalType::bTerminalIsWeakPointer' has a wrong offset!");
//(offsetof(FEdGraphTerminalType, bTerminalIsUObjectWrapper) == 0x000022, "Member 'FEdGraphTerminalType::bTerminalIsUObjectWrapper' has a wrong offset!");

// ScriptStruct Engine.VectorParameterValue
// 0x0034 (0x0034 - 0x0000)
struct FVectorParameterValue final
{
public:
	struct FMaterialParameterInfo                 ParameterInfo;                                     // 0x0000(0x0014)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ParameterValue;                                    // 0x0014(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0024(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FVectorParameterValue) == 0x000004, "Wrong alignment on FVectorParameterValue");
//(sizeof(FVectorParameterValue) == 0x000034, "Wrong size on FVectorParameterValue");
//(offsetof(FVectorParameterValue, ParameterInfo) == 0x000000, "Member 'FVectorParameterValue::ParameterInfo' has a wrong offset!");
//(offsetof(FVectorParameterValue, ParameterValue) == 0x000014, "Member 'FVectorParameterValue::ParameterValue' has a wrong offset!");
//(offsetof(FVectorParameterValue, ExpressionGUID) == 0x000024, "Member 'FVectorParameterValue::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.ExpressionOutput
// 0x0020 (0x0020 - 0x0000)
struct FExpressionOutput final
{
public:
	class FName                                   OutputName;                                        // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mask;                                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskR;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskG;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskB;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskA;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FExpressionOutput) == 0x000004, "Wrong alignment on FExpressionOutput");
//(sizeof(FExpressionOutput) == 0x000020, "Wrong size on FExpressionOutput");
//(offsetof(FExpressionOutput, OutputName) == 0x000000, "Member 'FExpressionOutput::OutputName' has a wrong offset!");
//(offsetof(FExpressionOutput, Mask) == 0x00000C, "Member 'FExpressionOutput::Mask' has a wrong offset!");
//(offsetof(FExpressionOutput, MaskR) == 0x000010, "Member 'FExpressionOutput::MaskR' has a wrong offset!");
//(offsetof(FExpressionOutput, MaskG) == 0x000014, "Member 'FExpressionOutput::MaskG' has a wrong offset!");
//(offsetof(FExpressionOutput, MaskB) == 0x000018, "Member 'FExpressionOutput::MaskB' has a wrong offset!");
//(offsetof(FExpressionOutput, MaskA) == 0x00001C, "Member 'FExpressionOutput::MaskA' has a wrong offset!");

// ScriptStruct Engine.FloatDistribution
// 0x0020 (0x0020 - 0x0000)
struct FFloatDistribution final
{
public:
	struct FDistributionLookupTable               Table;                                             // 0x0000(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FFloatDistribution) == 0x000008, "Wrong alignment on FFloatDistribution");
//(sizeof(FFloatDistribution) == 0x000020, "Wrong size on FFloatDistribution");
//(offsetof(FFloatDistribution, Table) == 0x000000, "Member 'FFloatDistribution::Table' has a wrong offset!");

// ScriptStruct Engine.FloatRK4SpringInterpolator
// 0x0008 (0x0008 - 0x0000)
struct FFloatRK4SpringInterpolator final
{
public:
	float                                         StiffnessConstant;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DampeningRatio;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FFloatRK4SpringInterpolator) == 0x000004, "Wrong alignment on FFloatRK4SpringInterpolator");
//(sizeof(FFloatRK4SpringInterpolator) == 0x000008, "Wrong size on FFloatRK4SpringInterpolator");
//(offsetof(FFloatRK4SpringInterpolator, StiffnessConstant) == 0x000000, "Member 'FFloatRK4SpringInterpolator::StiffnessConstant' has a wrong offset!");
//(offsetof(FFloatRK4SpringInterpolator, DampeningRatio) == 0x000004, "Member 'FFloatRK4SpringInterpolator::DampeningRatio' has a wrong offset!");

// ScriptStruct Engine.PoseLinkBase
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FPoseLinkBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LinkID;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPoseLinkBase) == 0x000008, "Wrong alignment on FPoseLinkBase");
//(sizeof(FPoseLinkBase) == 0x000010, "Wrong size on FPoseLinkBase");
//(offsetof(FPoseLinkBase, LinkID) == 0x000008, "Member 'FPoseLinkBase::LinkID' has a wrong offset!");

// ScriptStruct Engine.BranchingPointNotifyPayload
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FBranchingPointNotifyPayload final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBranchingPointNotifyPayload) == 0x000008, "Wrong alignment on FBranchingPointNotifyPayload");
//(sizeof(FBranchingPointNotifyPayload) == 0x000020, "Wrong size on FBranchingPointNotifyPayload");

// ScriptStruct Engine.DamageEvent
// 0x0010 (0x0010 - 0x0000)
struct FDamageEvent
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDamageEvent) == 0x000008, "Wrong alignment on FDamageEvent");
//(sizeof(FDamageEvent) == 0x000010, "Wrong size on FDamageEvent");
//(offsetof(FDamageEvent, DamageTypeClass) == 0x000008, "Member 'FDamageEvent::DamageTypeClass' has a wrong offset!");

// ScriptStruct Engine.StaticComponentMaskParameter
// 0x0004 (0x002C - 0x0028)
struct FStaticComponentMaskParameter final : public FStaticParameterBase
{
public:
	bool                                          R;                                                 // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          G;                                                 // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          A;                                                 // 0x002B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FStaticComponentMaskParameter) == 0x000004, "Wrong alignment on FStaticComponentMaskParameter");
//(sizeof(FStaticComponentMaskParameter) == 0x00002C, "Wrong size on FStaticComponentMaskParameter");
//(offsetof(FStaticComponentMaskParameter, R) == 0x000028, "Member 'FStaticComponentMaskParameter::R' has a wrong offset!");
//(offsetof(FStaticComponentMaskParameter, G) == 0x000029, "Member 'FStaticComponentMaskParameter::G' has a wrong offset!");
//(offsetof(FStaticComponentMaskParameter, B) == 0x00002A, "Member 'FStaticComponentMaskParameter::B' has a wrong offset!");
//(offsetof(FStaticComponentMaskParameter, A) == 0x00002B, "Member 'FStaticComponentMaskParameter::A' has a wrong offset!");

// ScriptStruct Engine.StaticTerrainLayerWeightParameter
// 0x003C (0x003C - 0x0000)
struct FStaticTerrainLayerWeightParameter final
{
public:
	struct FMaterialParameterInfo                 ParameterInfo;                                     // 0x0000(0x0014)(Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0014(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0024(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LayerName;                                         // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeightmapIndex;                                    // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeightBasedBlend;                                 // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStaticTerrainLayerWeightParameter) == 0x000004, "Wrong alignment on FStaticTerrainLayerWeightParameter");
//(sizeof(FStaticTerrainLayerWeightParameter) == 0x00003C, "Wrong size on FStaticTerrainLayerWeightParameter");
//(offsetof(FStaticTerrainLayerWeightParameter, ParameterInfo) == 0x000000, "Member 'FStaticTerrainLayerWeightParameter::ParameterInfo' has a wrong offset!");
//(offsetof(FStaticTerrainLayerWeightParameter, ExpressionGUID) == 0x000014, "Member 'FStaticTerrainLayerWeightParameter::ExpressionGUID' has a wrong offset!");
//(offsetof(FStaticTerrainLayerWeightParameter, bOverride) == 0x000024, "Member 'FStaticTerrainLayerWeightParameter::bOverride' has a wrong offset!");
//(offsetof(FStaticTerrainLayerWeightParameter, LayerName) == 0x000028, "Member 'FStaticTerrainLayerWeightParameter::LayerName' has a wrong offset!");
//(offsetof(FStaticTerrainLayerWeightParameter, WeightmapIndex) == 0x000034, "Member 'FStaticTerrainLayerWeightParameter::WeightmapIndex' has a wrong offset!");
//(offsetof(FStaticTerrainLayerWeightParameter, bWeightBasedBlend) == 0x000038, "Member 'FStaticTerrainLayerWeightParameter::bWeightBasedBlend' has a wrong offset!");

// ScriptStruct Engine.MaterialLayersFunctionsEditorOnlyData
// 0x0078 (0x0078 - 0x0000)
struct FMaterialLayersFunctionsEditorOnlyData final
{
public:
	TArray<bool>                                  LayerStates;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           LayerNames;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  RestrictToLayerRelatives;                          // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  RestrictToBlendRelatives;                          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          LayerGuids;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EMaterialLayerLinkState>               LayerLinkStates;                                   // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          DeletedParentLayerGuids;                           // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEditorLockState;                                  // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMaterialLayersFunctionsEditorOnlyData) == 0x000008, "Wrong alignment on FMaterialLayersFunctionsEditorOnlyData");
//(sizeof(FMaterialLayersFunctionsEditorOnlyData) == 0x000078, "Wrong size on FMaterialLayersFunctionsEditorOnlyData");
//(offsetof(FMaterialLayersFunctionsEditorOnlyData, LayerStates) == 0x000000, "Member 'FMaterialLayersFunctionsEditorOnlyData::LayerStates' has a wrong offset!");
//(offsetof(FMaterialLayersFunctionsEditorOnlyData, LayerNames) == 0x000010, "Member 'FMaterialLayersFunctionsEditorOnlyData::LayerNames' has a wrong offset!");
//(offsetof(FMaterialLayersFunctionsEditorOnlyData, RestrictToLayerRelatives) == 0x000020, "Member 'FMaterialLayersFunctionsEditorOnlyData::RestrictToLayerRelatives' has a wrong offset!");
//(offsetof(FMaterialLayersFunctionsEditorOnlyData, RestrictToBlendRelatives) == 0x000030, "Member 'FMaterialLayersFunctionsEditorOnlyData::RestrictToBlendRelatives' has a wrong offset!");
//(offsetof(FMaterialLayersFunctionsEditorOnlyData, LayerGuids) == 0x000040, "Member 'FMaterialLayersFunctionsEditorOnlyData::LayerGuids' has a wrong offset!");
//(offsetof(FMaterialLayersFunctionsEditorOnlyData, LayerLinkStates) == 0x000050, "Member 'FMaterialLayersFunctionsEditorOnlyData::LayerLinkStates' has a wrong offset!");
//(offsetof(FMaterialLayersFunctionsEditorOnlyData, DeletedParentLayerGuids) == 0x000060, "Member 'FMaterialLayersFunctionsEditorOnlyData::DeletedParentLayerGuids' has a wrong offset!");
//(offsetof(FMaterialLayersFunctionsEditorOnlyData, bEditorLockState) == 0x000070, "Member 'FMaterialLayersFunctionsEditorOnlyData::bEditorLockState' has a wrong offset!");

// ScriptStruct Engine.StaticParameterSetEditorOnlyData
// 0x00A8 (0x00A8 - 0x0000)
struct FStaticParameterSetEditorOnlyData final
{
public:
	TArray<struct FStaticSwitchParameter>         StaticSwitchParameters;                            // 0x0000(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FStaticComponentMaskParameter>  StaticComponentMaskParameters;                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStaticTerrainLayerWeightParameter> TerrainLayerWeightParameters;                      // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FMaterialLayersFunctionsEditorOnlyData MaterialLayers;                                    // 0x0030(0x0078)(NativeAccessSpecifierPublic)
};
//(alignof(FStaticParameterSetEditorOnlyData) == 0x000008, "Wrong alignment on FStaticParameterSetEditorOnlyData");
//(sizeof(FStaticParameterSetEditorOnlyData) == 0x0000A8, "Wrong size on FStaticParameterSetEditorOnlyData");
//(offsetof(FStaticParameterSetEditorOnlyData, StaticSwitchParameters) == 0x000000, "Member 'FStaticParameterSetEditorOnlyData::StaticSwitchParameters' has a wrong offset!");
//(offsetof(FStaticParameterSetEditorOnlyData, StaticComponentMaskParameters) == 0x000010, "Member 'FStaticParameterSetEditorOnlyData::StaticComponentMaskParameters' has a wrong offset!");
//(offsetof(FStaticParameterSetEditorOnlyData, TerrainLayerWeightParameters) == 0x000020, "Member 'FStaticParameterSetEditorOnlyData::TerrainLayerWeightParameters' has a wrong offset!");
//(offsetof(FStaticParameterSetEditorOnlyData, MaterialLayers) == 0x000030, "Member 'FStaticParameterSetEditorOnlyData::MaterialLayers' has a wrong offset!");

// ScriptStruct Engine.MemberReference
// 0x0038 (0x0038 - 0x0000)
struct FMemberReference final
{
public:
	class UObject*                                MemberParent;                                      // 0x0000(0x0008)(ZeroConstructor, SaveGame, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MemberScope;                                       // 0x0008(0x0010)(ZeroConstructor, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MemberName;                                        // 0x0018(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  MemberGuid;                                        // 0x0024(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelfContext;                                      // 0x0034(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasDeprecated;                                    // 0x0035(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMemberReference) == 0x000008, "Wrong alignment on FMemberReference");
//(sizeof(FMemberReference) == 0x000038, "Wrong size on FMemberReference");
//(offsetof(FMemberReference, MemberParent) == 0x000000, "Member 'FMemberReference::MemberParent' has a wrong offset!");
//(offsetof(FMemberReference, MemberScope) == 0x000008, "Member 'FMemberReference::MemberScope' has a wrong offset!");
//(offsetof(FMemberReference, MemberName) == 0x000018, "Member 'FMemberReference::MemberName' has a wrong offset!");
//(offsetof(FMemberReference, MemberGuid) == 0x000024, "Member 'FMemberReference::MemberGuid' has a wrong offset!");
//(offsetof(FMemberReference, bSelfContext) == 0x000034, "Member 'FMemberReference::bSelfContext' has a wrong offset!");
//(offsetof(FMemberReference, bWasDeprecated) == 0x000035, "Member 'FMemberReference::bWasDeprecated' has a wrong offset!");

// ScriptStruct Engine.FormatArgumentData
// 0x0050 (0x0050 - 0x0000)
struct FFormatArgumentData final
{
public:
	class FString                                 ArgumentName;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFormatArgumentType                           ArgumentValueType;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ArgumentValue;                                     // 0x0018(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	int64                                         ArgumentValueInt;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArgumentValueFloat;                                // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ArgumentValueDouble;                               // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextGender                                   ArgumentValueGender;                               // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FFormatArgumentData) == 0x000008, "Wrong alignment on FFormatArgumentData");
//(sizeof(FFormatArgumentData) == 0x000050, "Wrong size on FFormatArgumentData");
//(offsetof(FFormatArgumentData, ArgumentName) == 0x000000, "Member 'FFormatArgumentData::ArgumentName' has a wrong offset!");
//(offsetof(FFormatArgumentData, ArgumentValueType) == 0x000010, "Member 'FFormatArgumentData::ArgumentValueType' has a wrong offset!");
//(offsetof(FFormatArgumentData, ArgumentValue) == 0x000018, "Member 'FFormatArgumentData::ArgumentValue' has a wrong offset!");
//(offsetof(FFormatArgumentData, ArgumentValueInt) == 0x000030, "Member 'FFormatArgumentData::ArgumentValueInt' has a wrong offset!");
//(offsetof(FFormatArgumentData, ArgumentValueFloat) == 0x000038, "Member 'FFormatArgumentData::ArgumentValueFloat' has a wrong offset!");
//(offsetof(FFormatArgumentData, ArgumentValueDouble) == 0x000040, "Member 'FFormatArgumentData::ArgumentValueDouble' has a wrong offset!");
//(offsetof(FFormatArgumentData, ArgumentValueGender) == 0x000048, "Member 'FFormatArgumentData::ArgumentValueGender' has a wrong offset!");

// ScriptStruct Engine.AnimSlotDesc
// 0x0010 (0x0010 - 0x0000)
struct FAnimSlotDesc final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumChannels;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimSlotDesc) == 0x000004, "Wrong alignment on FAnimSlotDesc");
//(sizeof(FAnimSlotDesc) == 0x000010, "Wrong size on FAnimSlotDesc");
//(offsetof(FAnimSlotDesc, SlotName) == 0x000000, "Member 'FAnimSlotDesc::SlotName' has a wrong offset!");
//(offsetof(FAnimSlotDesc, NumChannels) == 0x00000C, "Member 'FAnimSlotDesc::NumChannels' has a wrong offset!");

// ScriptStruct Engine.ModulatorContinuousParams
// 0x0024 (0x0024 - 0x0000)
struct FModulatorContinuousParams final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinInput;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInput;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOutput;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOutput;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModulationParamMode                          ParamMode;                                         // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FModulatorContinuousParams) == 0x000004, "Wrong alignment on FModulatorContinuousParams");
//(sizeof(FModulatorContinuousParams) == 0x000024, "Wrong size on FModulatorContinuousParams");
//(offsetof(FModulatorContinuousParams, ParameterName) == 0x000000, "Member 'FModulatorContinuousParams::ParameterName' has a wrong offset!");
//(offsetof(FModulatorContinuousParams, Default) == 0x00000C, "Member 'FModulatorContinuousParams::Default' has a wrong offset!");
//(offsetof(FModulatorContinuousParams, MinInput) == 0x000010, "Member 'FModulatorContinuousParams::MinInput' has a wrong offset!");
//(offsetof(FModulatorContinuousParams, MaxInput) == 0x000014, "Member 'FModulatorContinuousParams::MaxInput' has a wrong offset!");
//(offsetof(FModulatorContinuousParams, MinOutput) == 0x000018, "Member 'FModulatorContinuousParams::MinOutput' has a wrong offset!");
//(offsetof(FModulatorContinuousParams, MaxOutput) == 0x00001C, "Member 'FModulatorContinuousParams::MaxOutput' has a wrong offset!");
//(offsetof(FModulatorContinuousParams, ParamMode) == 0x000020, "Member 'FModulatorContinuousParams::ParamMode' has a wrong offset!");

// ScriptStruct Engine.MaterialAttributesInput
// 0x0008 (0x0038 - 0x0030)
struct FMaterialAttributesInput final : public FExpressionInput
{
public:
	int64                                         PropertyConnectedMask;                             // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialAttributesInput) == 0x000008, "Wrong alignment on FMaterialAttributesInput");
//(sizeof(FMaterialAttributesInput) == 0x000038, "Wrong size on FMaterialAttributesInput");
//(offsetof(FMaterialAttributesInput, PropertyConnectedMask) == 0x000030, "Member 'FMaterialAttributesInput::PropertyConnectedMask' has a wrong offset!");

// ScriptStruct Engine.PoseLink
// 0x0000 (0x0010 - 0x0010)
struct FPoseLink final : public FPoseLinkBase
{
};
//(alignof(FPoseLink) == 0x000008, "Wrong alignment on FPoseLink");
//(sizeof(FPoseLink) == 0x000010, "Wrong size on FPoseLink");

// ScriptStruct Engine.Evaluation_Cache_Base
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FEvaluation_Cache_Base
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FEvaluation_Cache_Base) == 0x000008, "Wrong alignment on FEvaluation_Cache_Base");
//(sizeof(FEvaluation_Cache_Base) == 0x000008, "Wrong size on FEvaluation_Cache_Base");

// ScriptStruct Engine.AnimNode_Base
// 0x0020 (0x0028 - 0x0008)
struct FAnimNode_Base : public FEvaluation_Cache_Base
{
public:
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_Base) == 0x000008, "Wrong alignment on FAnimNode_Base");
//(sizeof(FAnimNode_Base) == 0x000028, "Wrong size on FAnimNode_Base");

// ScriptStruct Engine.AnimNode_SingleNode
// 0x0028 (0x0050 - 0x0028)
struct FAnimNode_SingleNode final : public FAnimNode_Base
{
public:
	struct FPoseLink                              SourcePose;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_SingleNode) == 0x000008, "Wrong alignment on FAnimNode_SingleNode");
//(sizeof(FAnimNode_SingleNode) == 0x000050, "Wrong size on FAnimNode_SingleNode");
//(offsetof(FAnimNode_SingleNode, SourcePose) == 0x000028, "Member 'FAnimNode_SingleNode::SourcePose' has a wrong offset!");

// ScriptStruct Engine.BlendSpaceSegment
// 0x0010 (0x0010 - 0x0000)
struct FBlendSpaceSegment final
{
public:
	int32                                         SampleIndices[0x2];                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vertices[0x2];                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBlendSpaceSegment) == 0x000004, "Wrong alignment on FBlendSpaceSegment");
//(sizeof(FBlendSpaceSegment) == 0x000010, "Wrong size on FBlendSpaceSegment");
//(offsetof(FBlendSpaceSegment, SampleIndices) == 0x000000, "Member 'FBlendSpaceSegment::SampleIndices' has a wrong offset!");
//(offsetof(FBlendSpaceSegment, Vertices) == 0x000008, "Member 'FBlendSpaceSegment::Vertices' has a wrong offset!");

// ScriptStruct Engine.BlendSpaceTriangleEdgeInfo
// 0x0028 (0x0028 - 0x0000)
struct FBlendSpaceTriangleEdgeInfo final
{
public:
	struct FVector2D                              Normal;                                            // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NeighbourTriangleIndex;                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdjacentPerimeterTriangleIndices[0x2];             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdjacentPerimeterVertexIndices[0x2];               // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBlendSpaceTriangleEdgeInfo) == 0x000008, "Wrong alignment on FBlendSpaceTriangleEdgeInfo");
//(sizeof(FBlendSpaceTriangleEdgeInfo) == 0x000028, "Wrong size on FBlendSpaceTriangleEdgeInfo");
//(offsetof(FBlendSpaceTriangleEdgeInfo, Normal) == 0x000000, "Member 'FBlendSpaceTriangleEdgeInfo::Normal' has a wrong offset!");
//(offsetof(FBlendSpaceTriangleEdgeInfo, NeighbourTriangleIndex) == 0x000010, "Member 'FBlendSpaceTriangleEdgeInfo::NeighbourTriangleIndex' has a wrong offset!");
//(offsetof(FBlendSpaceTriangleEdgeInfo, AdjacentPerimeterTriangleIndices) == 0x000014, "Member 'FBlendSpaceTriangleEdgeInfo::AdjacentPerimeterTriangleIndices' has a wrong offset!");
//(offsetof(FBlendSpaceTriangleEdgeInfo, AdjacentPerimeterVertexIndices) == 0x00001C, "Member 'FBlendSpaceTriangleEdgeInfo::AdjacentPerimeterVertexIndices' has a wrong offset!");

// ScriptStruct Engine.BlendSpaceTriangle
// 0x00B8 (0x00B8 - 0x0000)
struct FBlendSpaceTriangle final
{
public:
	int32                                         SampleIndices[0x3];                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Vertices[0x3];                                     // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlendSpaceTriangleEdgeInfo            EdgeInfo[0x3];                                     // 0x0040(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FBlendSpaceTriangle) == 0x000008, "Wrong alignment on FBlendSpaceTriangle");
//(sizeof(FBlendSpaceTriangle) == 0x0000B8, "Wrong size on FBlendSpaceTriangle");
//(offsetof(FBlendSpaceTriangle, SampleIndices) == 0x000000, "Member 'FBlendSpaceTriangle::SampleIndices' has a wrong offset!");
//(offsetof(FBlendSpaceTriangle, Vertices) == 0x000010, "Member 'FBlendSpaceTriangle::Vertices' has a wrong offset!");
//(offsetof(FBlendSpaceTriangle, EdgeInfo) == 0x000040, "Member 'FBlendSpaceTriangle::EdgeInfo' has a wrong offset!");

// ScriptStruct Engine.BlendSpaceData
// 0x0020 (0x0020 - 0x0000)
struct FBlendSpaceData final
{
public:
	TArray<struct FBlendSpaceSegment>             Segments;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBlendSpaceTriangle>            Triangles;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FBlendSpaceData) == 0x000008, "Wrong alignment on FBlendSpaceData");
//(sizeof(FBlendSpaceData) == 0x000020, "Wrong size on FBlendSpaceData");
//(offsetof(FBlendSpaceData, Segments) == 0x000000, "Member 'FBlendSpaceData::Segments' has a wrong offset!");
//(offsetof(FBlendSpaceData, Triangles) == 0x000010, "Member 'FBlendSpaceData::Triangles' has a wrong offset!");

// ScriptStruct Engine.ChaosRemovalEvent
// 0x0070 (0x0070 - 0x0000)
struct FChaosRemovalEvent final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocity;                                   // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extents;                                           // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FChaosRemovalEvent) == 0x000008, "Wrong alignment on FChaosRemovalEvent");
//(sizeof(FChaosRemovalEvent) == 0x000070, "Wrong size on FChaosRemovalEvent");
//(offsetof(FChaosRemovalEvent, Component) == 0x000000, "Member 'FChaosRemovalEvent::Component' has a wrong offset!");
//(offsetof(FChaosRemovalEvent, Location) == 0x000008, "Member 'FChaosRemovalEvent::Location' has a wrong offset!");
//(offsetof(FChaosRemovalEvent, Mass) == 0x000020, "Member 'FChaosRemovalEvent::Mass' has a wrong offset!");
//(offsetof(FChaosRemovalEvent, Index) == 0x000024, "Member 'FChaosRemovalEvent::Index' has a wrong offset!");
//(offsetof(FChaosRemovalEvent, Velocity) == 0x000028, "Member 'FChaosRemovalEvent::Velocity' has a wrong offset!");
//(offsetof(FChaosRemovalEvent, AngularVelocity) == 0x000040, "Member 'FChaosRemovalEvent::AngularVelocity' has a wrong offset!");
//(offsetof(FChaosRemovalEvent, Extents) == 0x000058, "Member 'FChaosRemovalEvent::Extents' has a wrong offset!");

// ScriptStruct Engine.SoundWaveSpectralDataEntry
// 0x0008 (0x0008 - 0x0000)
struct FSoundWaveSpectralDataEntry final
{
public:
	float                                         Magnitude;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalizedMagnitude;                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoundWaveSpectralDataEntry) == 0x000004, "Wrong alignment on FSoundWaveSpectralDataEntry");
//(sizeof(FSoundWaveSpectralDataEntry) == 0x000008, "Wrong size on FSoundWaveSpectralDataEntry");
//(offsetof(FSoundWaveSpectralDataEntry, Magnitude) == 0x000000, "Member 'FSoundWaveSpectralDataEntry::Magnitude' has a wrong offset!");
//(offsetof(FSoundWaveSpectralDataEntry, NormalizedMagnitude) == 0x000004, "Member 'FSoundWaveSpectralDataEntry::NormalizedMagnitude' has a wrong offset!");

// ScriptStruct Engine.ScalarParameterValue
// 0x0028 (0x0028 - 0x0000)
struct FScalarParameterValue final
{
public:
	struct FMaterialParameterInfo                 ParameterInfo;                                     // 0x0000(0x0014)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParameterValue;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FScalarParameterValue) == 0x000004, "Wrong alignment on FScalarParameterValue");
//(sizeof(FScalarParameterValue) == 0x000028, "Wrong size on FScalarParameterValue");
//(offsetof(FScalarParameterValue, ParameterInfo) == 0x000000, "Member 'FScalarParameterValue::ParameterInfo' has a wrong offset!");
//(offsetof(FScalarParameterValue, ParameterValue) == 0x000014, "Member 'FScalarParameterValue::ParameterValue' has a wrong offset!");
//(offsetof(FScalarParameterValue, ExpressionGUID) == 0x000018, "Member 'FScalarParameterValue::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.RawDistribution
// 0x0020 (0x0020 - 0x0000)
struct FRawDistribution
{
public:
	struct FDistributionLookupTable               Table;                                             // 0x0000(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRawDistribution) == 0x000008, "Wrong alignment on FRawDistribution");
//(sizeof(FRawDistribution) == 0x000020, "Wrong size on FRawDistribution");
//(offsetof(FRawDistribution, Table) == 0x000000, "Member 'FRawDistribution::Table' has a wrong offset!");

// ScriptStruct Engine.ScalarMaterialInput
// 0x0008 (0x0038 - 0x0030)
struct FScalarMaterialInput final : public FMaterialInput
{
public:
	uint8                                         UseConstant : 1;                                   // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Constant;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FScalarMaterialInput) == 0x000008, "Wrong alignment on FScalarMaterialInput");
//(sizeof(FScalarMaterialInput) == 0x000038, "Wrong size on FScalarMaterialInput");
//(offsetof(FScalarMaterialInput, Constant) == 0x000034, "Member 'FScalarMaterialInput::Constant' has a wrong offset!");

// ScriptStruct Engine.AnimNodeFunctionRef
// 0x0028 (0x0028 - 0x0000)
struct FAnimNodeFunctionRef final
{
public:
	class FName                                   ClassName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FunctionName;                                      // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UObject>                    Class;                                             // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFunction*                              Function;                                          // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FAnimNodeFunctionRef) == 0x000008, "Wrong alignment on FAnimNodeFunctionRef");
//(sizeof(FAnimNodeFunctionRef) == 0x000028, "Wrong size on FAnimNodeFunctionRef");
//(offsetof(FAnimNodeFunctionRef, ClassName) == 0x000000, "Member 'FAnimNodeFunctionRef::ClassName' has a wrong offset!");
//(offsetof(FAnimNodeFunctionRef, FunctionName) == 0x00000C, "Member 'FAnimNodeFunctionRef::FunctionName' has a wrong offset!");
//(offsetof(FAnimNodeFunctionRef, Class) == 0x000018, "Member 'FAnimNodeFunctionRef::Class' has a wrong offset!");
//(offsetof(FAnimNodeFunctionRef, Function) == 0x000020, "Member 'FAnimNodeFunctionRef::Function' has a wrong offset!");

// ScriptStruct Engine.ShadingModelMaterialInput
// 0x0000 (0x0030 - 0x0030)
struct FShadingModelMaterialInput final : public FMaterialInput
{
};
//(alignof(FShadingModelMaterialInput) == 0x000008, "Wrong alignment on FShadingModelMaterialInput");
//(sizeof(FShadingModelMaterialInput) == 0x000030, "Wrong size on FShadingModelMaterialInput");

// ScriptStruct Engine.NavAgentSelector
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FNavAgentSelector final
{
public:
	uint8                                         bSupportsAgent0 : 1;                               // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent1 : 1;                               // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent2 : 1;                               // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent3 : 1;                               // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent4 : 1;                               // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent5 : 1;                               // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent6 : 1;                               // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent7 : 1;                               // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent8 : 1;                               // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent9 : 1;                               // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent10 : 1;                              // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent11 : 1;                              // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent12 : 1;                              // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent13 : 1;                              // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent14 : 1;                              // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent15 : 1;                              // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FNavAgentSelector) == 0x000004, "Wrong alignment on FNavAgentSelector");
//(sizeof(FNavAgentSelector) == 0x000004, "Wrong size on FNavAgentSelector");

// ScriptStruct Engine.NavigationLinkBase
// 0x0040 (0x0040 - 0x0000)
struct FNavigationLinkBase
{
public:
	float                                         LeftProjectHeight;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFallDownLength;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SnapRadius;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapHeight;                                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNavAgentSelector                      SupportedAgents;                                   // 0x0020(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bSupportsAgent0 : 1;                               // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent1 : 1;                               // 0x0024(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent2 : 1;                               // 0x0024(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent3 : 1;                               // 0x0024(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent4 : 1;                               // 0x0024(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent5 : 1;                               // 0x0024(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent6 : 1;                               // 0x0024(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent7 : 1;                               // 0x0024(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent8 : 1;                               // 0x0025(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent9 : 1;                               // 0x0025(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent10 : 1;                              // 0x0025(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent11 : 1;                              // 0x0025(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent12 : 1;                              // 0x0025(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent13 : 1;                              // 0x0025(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent14 : 1;                              // 0x0025(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent15 : 1;                              // 0x0025(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ENavLinkDirection                             Direction;                                         // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSnapHeight : 1;                                // 0x0029(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSnapToCheapestArea : 1;                           // 0x0029(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomFlag0 : 1;                                  // 0x0029(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomFlag1 : 1;                                  // 0x0029(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomFlag2 : 1;                                  // 0x0029(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomFlag3 : 1;                                  // 0x0029(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomFlag4 : 1;                                  // 0x0029(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomFlag5 : 1;                                  // 0x0029(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomFlag6 : 1;                                  // 0x002A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomFlag7 : 1;                                  // 0x002A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavAreaBase>               AreaClass;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FNavigationLinkBase) == 0x000008, "Wrong alignment on FNavigationLinkBase");
//(sizeof(FNavigationLinkBase) == 0x000040, "Wrong size on FNavigationLinkBase");
//(offsetof(FNavigationLinkBase, LeftProjectHeight) == 0x000000, "Member 'FNavigationLinkBase::LeftProjectHeight' has a wrong offset!");
//(offsetof(FNavigationLinkBase, MaxFallDownLength) == 0x000004, "Member 'FNavigationLinkBase::MaxFallDownLength' has a wrong offset!");
//(offsetof(FNavigationLinkBase, SnapRadius) == 0x000018, "Member 'FNavigationLinkBase::SnapRadius' has a wrong offset!");
//(offsetof(FNavigationLinkBase, SnapHeight) == 0x00001C, "Member 'FNavigationLinkBase::SnapHeight' has a wrong offset!");
//(offsetof(FNavigationLinkBase, SupportedAgents) == 0x000020, "Member 'FNavigationLinkBase::SupportedAgents' has a wrong offset!");
//(offsetof(FNavigationLinkBase, Direction) == 0x000028, "Member 'FNavigationLinkBase::Direction' has a wrong offset!");
//(offsetof(FNavigationLinkBase, AreaClass) == 0x000030, "Member 'FNavigationLinkBase::AreaClass' has a wrong offset!");

// ScriptStruct Engine.NavigationLink
// 0x0030 (0x0070 - 0x0040)
struct FNavigationLink final : public FNavigationLinkBase
{
public:
	struct FVector                                Left;                                              // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Right;                                             // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNavigationLink) == 0x000008, "Wrong alignment on FNavigationLink");
//(sizeof(FNavigationLink) == 0x000070, "Wrong size on FNavigationLink");
//(offsetof(FNavigationLink, Left) == 0x000040, "Member 'FNavigationLink::Left' has a wrong offset!");
//(offsetof(FNavigationLink, Right) == 0x000058, "Member 'FNavigationLink::Right' has a wrong offset!");

// ScriptStruct Engine.MaterialCachedParameterEntry
// 0x0050 (0x0050 - 0x0000)
struct FMaterialCachedParameterEntry final
{
public:
	TSet<struct FMaterialParameterInfo>           ParameterInfoSet;                                  // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
//(alignof(FMaterialCachedParameterEntry) == 0x000008, "Wrong alignment on FMaterialCachedParameterEntry");
//(sizeof(FMaterialCachedParameterEntry) == 0x000050, "Wrong size on FMaterialCachedParameterEntry");
//(offsetof(FMaterialCachedParameterEntry, ParameterInfoSet) == 0x000000, "Member 'FMaterialCachedParameterEntry::ParameterInfoSet' has a wrong offset!");

// ScriptStruct Engine.MaterialFunctionInfo
// 0x0018 (0x0018 - 0x0000)
struct FMaterialFunctionInfo final
{
public:
	struct FGuid                                  StateId;                                           // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialFunctionInterface*             Function;                                          // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialFunctionInfo) == 0x000008, "Wrong alignment on FMaterialFunctionInfo");
//(sizeof(FMaterialFunctionInfo) == 0x000018, "Wrong size on FMaterialFunctionInfo");
//(offsetof(FMaterialFunctionInfo, StateId) == 0x000000, "Member 'FMaterialFunctionInfo::StateId' has a wrong offset!");
//(offsetof(FMaterialFunctionInfo, Function) == 0x000010, "Member 'FMaterialFunctionInfo::Function' has a wrong offset!");

// ScriptStruct Engine.MaterialParameterCollectionInfo
// 0x0018 (0x0018 - 0x0000)
struct FMaterialParameterCollectionInfo final
{
public:
	struct FGuid                                  StateId;                                           // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           ParameterCollection;                               // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialParameterCollectionInfo) == 0x000008, "Wrong alignment on FMaterialParameterCollectionInfo");
//(sizeof(FMaterialParameterCollectionInfo) == 0x000018, "Wrong size on FMaterialParameterCollectionInfo");
//(offsetof(FMaterialParameterCollectionInfo, StateId) == 0x000000, "Member 'FMaterialParameterCollectionInfo::StateId' has a wrong offset!");
//(offsetof(FMaterialParameterCollectionInfo, ParameterCollection) == 0x000010, "Member 'FMaterialParameterCollectionInfo::ParameterCollection' has a wrong offset!");

// ScriptStruct Engine.MaterialCachedExpressionData
// 0x0420 (0x0420 - 0x0000)
struct FMaterialCachedExpressionData final
{
public:
	struct FMaterialCachedParameterEntry          RuntimeEntries[0x8];                               // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TArray<int32>                                 ScalarPrimitiveDataIndexValues;                    // 0x0280(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 VectorPrimitiveDataIndexValues;                    // 0x0290(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ScalarValues;                                      // 0x02A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  StaticSwitchValues;                                // 0x02B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  DynamicSwitchValues;                               // 0x02C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  ScalaAsCustomPrimitiveDataSourceBaseIndex;         // 0x02D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   VectorValues;                                      // 0x02E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  VectorAsCustomPrimitiveDataSources;                // 0x02F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 VectorCustomPrimitiveDataSourceOffsets;            // 0x0300(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           VectorParameterNames;                              // 0x0310(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector4d>                      DoubleVectorValues;                                // 0x0320(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture>>        TextureValues;                                     // 0x0330(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UFont>>           FontValues;                                        // 0x0340(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<int32>                                 FontPageValues;                                    // 0x0350(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class URuntimeVirtualTexture>> RuntimeVirtualTextureValues;                       // 0x0360(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USparseVolumeTexture>> SparseVolumeTextureValues;                         // 0x0370(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        ReferencedTextures;                                // 0x0380(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FMaterialFunctionInfo>          FunctionInfos;                                     // 0x0390(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        FunctionInfosStateCRC;                             // 0x03A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialParameterCollectionInfo> ParameterCollectionInfos;                          // 0x03A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULandscapeGrassType*>            GrassTypes;                                        // 0x03B8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FMaterialLayersFunctionsRuntimeData    MaterialLayers;                                    // 0x03C8(0x0020)(NativeAccessSpecifierPublic)
	TArray<class FName>                           DynamicParameterNames;                             // 0x03E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  QualityLevelsUsed;                                 // 0x03F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bHasMaterialLayers : 1;                            // 0x0408(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasRuntimeVirtualTextureOutput : 1;               // 0x0408(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasSceneColor : 1;                                // 0x0408(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasPerInstanceCustomData : 1;                     // 0x0408(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasPerInstanceRandom : 1;                         // 0x0408(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasVertexInterpolator : 1;                        // 0x0408(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_409[0x3];                                      // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PropertyConnectedBitmask;                          // 0x040C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        PropertyConnectedMask;                             // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasAdditionalBloomOutput : 1;                     // 0x0418(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasScenePaintOutput : 1;                          // 0x0418(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMaterialCachedExpressionData) == 0x000008, "Wrong alignment on FMaterialCachedExpressionData");
//(sizeof(FMaterialCachedExpressionData) == 0x000420, "Wrong size on FMaterialCachedExpressionData");
//(offsetof(FMaterialCachedExpressionData, RuntimeEntries) == 0x000000, "Member 'FMaterialCachedExpressionData::RuntimeEntries' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, ScalarPrimitiveDataIndexValues) == 0x000280, "Member 'FMaterialCachedExpressionData::ScalarPrimitiveDataIndexValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, VectorPrimitiveDataIndexValues) == 0x000290, "Member 'FMaterialCachedExpressionData::VectorPrimitiveDataIndexValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, ScalarValues) == 0x0002A0, "Member 'FMaterialCachedExpressionData::ScalarValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, StaticSwitchValues) == 0x0002B0, "Member 'FMaterialCachedExpressionData::StaticSwitchValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, DynamicSwitchValues) == 0x0002C0, "Member 'FMaterialCachedExpressionData::DynamicSwitchValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, ScalaAsCustomPrimitiveDataSourceBaseIndex) == 0x0002D0, "Member 'FMaterialCachedExpressionData::ScalaAsCustomPrimitiveDataSourceBaseIndex' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, VectorValues) == 0x0002E0, "Member 'FMaterialCachedExpressionData::VectorValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, VectorAsCustomPrimitiveDataSources) == 0x0002F0, "Member 'FMaterialCachedExpressionData::VectorAsCustomPrimitiveDataSources' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, VectorCustomPrimitiveDataSourceOffsets) == 0x000300, "Member 'FMaterialCachedExpressionData::VectorCustomPrimitiveDataSourceOffsets' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, VectorParameterNames) == 0x000310, "Member 'FMaterialCachedExpressionData::VectorParameterNames' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, DoubleVectorValues) == 0x000320, "Member 'FMaterialCachedExpressionData::DoubleVectorValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, TextureValues) == 0x000330, "Member 'FMaterialCachedExpressionData::TextureValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, FontValues) == 0x000340, "Member 'FMaterialCachedExpressionData::FontValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, FontPageValues) == 0x000350, "Member 'FMaterialCachedExpressionData::FontPageValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, RuntimeVirtualTextureValues) == 0x000360, "Member 'FMaterialCachedExpressionData::RuntimeVirtualTextureValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, SparseVolumeTextureValues) == 0x000370, "Member 'FMaterialCachedExpressionData::SparseVolumeTextureValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, ReferencedTextures) == 0x000380, "Member 'FMaterialCachedExpressionData::ReferencedTextures' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, FunctionInfos) == 0x000390, "Member 'FMaterialCachedExpressionData::FunctionInfos' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, FunctionInfosStateCRC) == 0x0003A0, "Member 'FMaterialCachedExpressionData::FunctionInfosStateCRC' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, ParameterCollectionInfos) == 0x0003A8, "Member 'FMaterialCachedExpressionData::ParameterCollectionInfos' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, GrassTypes) == 0x0003B8, "Member 'FMaterialCachedExpressionData::GrassTypes' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, MaterialLayers) == 0x0003C8, "Member 'FMaterialCachedExpressionData::MaterialLayers' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, DynamicParameterNames) == 0x0003E8, "Member 'FMaterialCachedExpressionData::DynamicParameterNames' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, QualityLevelsUsed) == 0x0003F8, "Member 'FMaterialCachedExpressionData::QualityLevelsUsed' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, PropertyConnectedBitmask) == 0x00040C, "Member 'FMaterialCachedExpressionData::PropertyConnectedBitmask' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionData, PropertyConnectedMask) == 0x000410, "Member 'FMaterialCachedExpressionData::PropertyConnectedMask' has a wrong offset!");

// ScriptStruct Engine.FXSystemSpawnParameters
// 0x0078 (0x0078 - 0x0000)
struct FFXSystemSpawnParameters
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         SystemTemplate;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0060(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x006D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoActivate;                                     // 0x006E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPSCPoolMethod                                PoolingMethod;                                     // 0x006F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreCullCheck;                                     // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerEffect;                                   // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNetCullCheck : 1;                                 // 0x0072(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FFXSystemSpawnParameters) == 0x000008, "Wrong alignment on FFXSystemSpawnParameters");
//(sizeof(FFXSystemSpawnParameters) == 0x000078, "Wrong size on FFXSystemSpawnParameters");
//(offsetof(FFXSystemSpawnParameters, WorldContextObject) == 0x000000, "Member 'FFXSystemSpawnParameters::WorldContextObject' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, SystemTemplate) == 0x000008, "Member 'FFXSystemSpawnParameters::SystemTemplate' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, Location) == 0x000010, "Member 'FFXSystemSpawnParameters::Location' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, Rotation) == 0x000028, "Member 'FFXSystemSpawnParameters::Rotation' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, Scale) == 0x000040, "Member 'FFXSystemSpawnParameters::Scale' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, AttachToComponent) == 0x000058, "Member 'FFXSystemSpawnParameters::AttachToComponent' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, AttachPointName) == 0x000060, "Member 'FFXSystemSpawnParameters::AttachPointName' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, LocationType) == 0x00006C, "Member 'FFXSystemSpawnParameters::LocationType' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, bAutoDestroy) == 0x00006D, "Member 'FFXSystemSpawnParameters::bAutoDestroy' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, bAutoActivate) == 0x00006E, "Member 'FFXSystemSpawnParameters::bAutoActivate' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, PoolingMethod) == 0x00006F, "Member 'FFXSystemSpawnParameters::PoolingMethod' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, bPreCullCheck) == 0x000070, "Member 'FFXSystemSpawnParameters::bPreCullCheck' has a wrong offset!");
//(offsetof(FFXSystemSpawnParameters, bIsPlayerEffect) == 0x000071, "Member 'FFXSystemSpawnParameters::bIsPlayerEffect' has a wrong offset!");

// ScriptStruct Engine.StrataMaterialInput
// 0x0000 (0x0030 - 0x0030)
struct FStrataMaterialInput final : public FMaterialInput
{
};
//(alignof(FStrataMaterialInput) == 0x000008, "Wrong alignment on FStrataMaterialInput");
//(sizeof(FStrataMaterialInput) == 0x000030, "Wrong size on FStrataMaterialInput");

// ScriptStruct Engine.AlphaBlend
// 0x0030 (0x0030 - 0x0000)
struct FAlphaBlend final
{
public:
	class UCurveFloat*                            CustomCurve;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendTime;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x18];                                       // 0x000C(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EAlphaBlendOption                             BlendOption;                                       // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25[0xB];                                       // 0x0025(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAlphaBlend) == 0x000008, "Wrong alignment on FAlphaBlend");
//(sizeof(FAlphaBlend) == 0x000030, "Wrong size on FAlphaBlend");
//(offsetof(FAlphaBlend, CustomCurve) == 0x000000, "Member 'FAlphaBlend::CustomCurve' has a wrong offset!");
//(offsetof(FAlphaBlend, BlendTime) == 0x000008, "Member 'FAlphaBlend::BlendTime' has a wrong offset!");
//(offsetof(FAlphaBlend, BlendOption) == 0x000024, "Member 'FAlphaBlend::BlendOption' has a wrong offset!");

// ScriptStruct Engine.InputAlphaBoolBlend
// 0x0048 (0x0048 - 0x0000)
struct FInputAlphaBoolBlend final
{
public:
	float                                         BlendInTime;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendOption;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialized;                                      // 0x0009(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CustomCurve;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAlphaBlend                            AlphaBlend;                                        // 0x0018(0x0030)(Transient, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FInputAlphaBoolBlend) == 0x000008, "Wrong alignment on FInputAlphaBoolBlend");
//(sizeof(FInputAlphaBoolBlend) == 0x000048, "Wrong size on FInputAlphaBoolBlend");
//(offsetof(FInputAlphaBoolBlend, BlendInTime) == 0x000000, "Member 'FInputAlphaBoolBlend::BlendInTime' has a wrong offset!");
//(offsetof(FInputAlphaBoolBlend, BlendOutTime) == 0x000004, "Member 'FInputAlphaBoolBlend::BlendOutTime' has a wrong offset!");
//(offsetof(FInputAlphaBoolBlend, BlendOption) == 0x000008, "Member 'FInputAlphaBoolBlend::BlendOption' has a wrong offset!");
//(offsetof(FInputAlphaBoolBlend, bInitialized) == 0x000009, "Member 'FInputAlphaBoolBlend::bInitialized' has a wrong offset!");
//(offsetof(FInputAlphaBoolBlend, CustomCurve) == 0x000010, "Member 'FInputAlphaBoolBlend::CustomCurve' has a wrong offset!");
//(offsetof(FInputAlphaBoolBlend, AlphaBlend) == 0x000018, "Member 'FInputAlphaBoolBlend::AlphaBlend' has a wrong offset!");

// ScriptStruct Engine.CameraLensInterfaceClassSupport
// 0x0008 (0x0008 - 0x0000)
struct FCameraLensInterfaceClassSupport final
{
public:
	TSubclassOf<class AActor>                     Class;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCameraLensInterfaceClassSupport) == 0x000008, "Wrong alignment on FCameraLensInterfaceClassSupport");
//(sizeof(FCameraLensInterfaceClassSupport) == 0x000008, "Wrong size on FCameraLensInterfaceClassSupport");
//(offsetof(FCameraLensInterfaceClassSupport, Class) == 0x000000, "Member 'FCameraLensInterfaceClassSupport::Class' has a wrong offset!");

// ScriptStruct Engine.PredictProjectilePathPointData
// 0x0038 (0x0038 - 0x0000)
struct FPredictProjectilePathPointData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPredictProjectilePathPointData) == 0x000008, "Wrong alignment on FPredictProjectilePathPointData");
//(sizeof(FPredictProjectilePathPointData) == 0x000038, "Wrong size on FPredictProjectilePathPointData");
//(offsetof(FPredictProjectilePathPointData, Location) == 0x000000, "Member 'FPredictProjectilePathPointData::Location' has a wrong offset!");
//(offsetof(FPredictProjectilePathPointData, Velocity) == 0x000018, "Member 'FPredictProjectilePathPointData::Velocity' has a wrong offset!");
//(offsetof(FPredictProjectilePathPointData, Time) == 0x000030, "Member 'FPredictProjectilePathPointData::Time' has a wrong offset!");

// ScriptStruct Engine.Vector2MaterialInput
// 0x0010 (0x0040 - 0x0030)
struct FVector2MaterialInput final : public FMaterialInput
{
public:
	uint8                                         UseConstant : 1;                                   // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstantX;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstantY;                                         // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FVector2MaterialInput) == 0x000008, "Wrong alignment on FVector2MaterialInput");
//(sizeof(FVector2MaterialInput) == 0x000040, "Wrong size on FVector2MaterialInput");
//(offsetof(FVector2MaterialInput, ConstantX) == 0x000034, "Member 'FVector2MaterialInput::ConstantX' has a wrong offset!");
//(offsetof(FVector2MaterialInput, ConstantY) == 0x000038, "Member 'FVector2MaterialInput::ConstantY' has a wrong offset!");

// ScriptStruct Engine.Vector4Distribution
// 0x0020 (0x0020 - 0x0000)
struct FVector4Distribution final
{
public:
	struct FDistributionLookupTable               Table;                                             // 0x0000(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FVector4Distribution) == 0x000008, "Wrong alignment on FVector4Distribution");
//(sizeof(FVector4Distribution) == 0x000020, "Wrong size on FVector4Distribution");
//(offsetof(FVector4Distribution, Table) == 0x000000, "Member 'FVector4Distribution::Table' has a wrong offset!");

// ScriptStruct Engine.InputScaleBias
// 0x0008 (0x0008 - 0x0000)
struct FInputScaleBias final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bias;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FInputScaleBias) == 0x000004, "Wrong alignment on FInputScaleBias");
//(sizeof(FInputScaleBias) == 0x000008, "Wrong size on FInputScaleBias");
//(offsetof(FInputScaleBias, Scale) == 0x000000, "Member 'FInputScaleBias::Scale' has a wrong offset!");
//(offsetof(FInputScaleBias, Bias) == 0x000004, "Member 'FInputScaleBias::Bias' has a wrong offset!");

// ScriptStruct Engine.InputRange
// 0x0008 (0x0008 - 0x0000)
struct FInputRange final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FInputRange) == 0x000004, "Wrong alignment on FInputRange");
//(sizeof(FInputRange) == 0x000008, "Wrong size on FInputRange");
//(offsetof(FInputRange, Min) == 0x000000, "Member 'FInputRange::Min' has a wrong offset!");
//(offsetof(FInputRange, Max) == 0x000004, "Member 'FInputRange::Max' has a wrong offset!");

// ScriptStruct Engine.InputScaleBiasClamp
// 0x0030 (0x0030 - 0x0000)
struct FInputScaleBiasClamp final
{
public:
	bool                                          bMapRange;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampResult;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpResult;                                     // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputRange                            InRange;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FInputRange                            OutRange;                                          // 0x000C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bias;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMin;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeedIncreasing;                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeedDecreasing;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FInputScaleBiasClamp) == 0x000004, "Wrong alignment on FInputScaleBiasClamp");
//(sizeof(FInputScaleBiasClamp) == 0x000030, "Wrong size on FInputScaleBiasClamp");
//(offsetof(FInputScaleBiasClamp, bMapRange) == 0x000000, "Member 'FInputScaleBiasClamp::bMapRange' has a wrong offset!");
//(offsetof(FInputScaleBiasClamp, bClampResult) == 0x000001, "Member 'FInputScaleBiasClamp::bClampResult' has a wrong offset!");
//(offsetof(FInputScaleBiasClamp, bInterpResult) == 0x000002, "Member 'FInputScaleBiasClamp::bInterpResult' has a wrong offset!");
//(offsetof(FInputScaleBiasClamp, InRange) == 0x000004, "Member 'FInputScaleBiasClamp::InRange' has a wrong offset!");
//(offsetof(FInputScaleBiasClamp, OutRange) == 0x00000C, "Member 'FInputScaleBiasClamp::OutRange' has a wrong offset!");
//(offsetof(FInputScaleBiasClamp, Scale) == 0x000014, "Member 'FInputScaleBiasClamp::Scale' has a wrong offset!");
//(offsetof(FInputScaleBiasClamp, Bias) == 0x000018, "Member 'FInputScaleBiasClamp::Bias' has a wrong offset!");
//(offsetof(FInputScaleBiasClamp, ClampMin) == 0x00001C, "Member 'FInputScaleBiasClamp::ClampMin' has a wrong offset!");
//(offsetof(FInputScaleBiasClamp, ClampMax) == 0x000020, "Member 'FInputScaleBiasClamp::ClampMax' has a wrong offset!");
//(offsetof(FInputScaleBiasClamp, InterpSpeedIncreasing) == 0x000024, "Member 'FInputScaleBiasClamp::InterpSpeedIncreasing' has a wrong offset!");
//(offsetof(FInputScaleBiasClamp, InterpSpeedDecreasing) == 0x000028, "Member 'FInputScaleBiasClamp::InterpSpeedDecreasing' has a wrong offset!");

// ScriptStruct Engine.AnimNode_ApplyMeshSpaceAdditive
// 0x00C8 (0x00F0 - 0x0028)
struct FAnimNode_ApplyMeshSpaceAdditive final : public FAnimNode_Base
{
public:
	struct FPoseLink                              base;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              Additive;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EAnimAlphaInputType                           AlphaInputType;                                    // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlphaBoolEnabled : 1;                             // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputAlphaBoolBlend                   AlphaBoolBlend;                                    // 0x0058(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AlphaCurveName;                                    // 0x00A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBias                        AlphaScaleBias;                                    // 0x00AC(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FInputScaleBiasClamp                   AlphaScaleBiasClamp;                               // 0x00B4(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LODThreshold;                                      // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_ApplyMeshSpaceAdditive) == 0x000008, "Wrong alignment on FAnimNode_ApplyMeshSpaceAdditive");
//(sizeof(FAnimNode_ApplyMeshSpaceAdditive) == 0x0000F0, "Wrong size on FAnimNode_ApplyMeshSpaceAdditive");
//(offsetof(FAnimNode_ApplyMeshSpaceAdditive, base) == 0x000028, "Member 'FAnimNode_ApplyMeshSpaceAdditive::base' has a wrong offset!");
//(offsetof(FAnimNode_ApplyMeshSpaceAdditive, Additive) == 0x000038, "Member 'FAnimNode_ApplyMeshSpaceAdditive::Additive' has a wrong offset!");
//(offsetof(FAnimNode_ApplyMeshSpaceAdditive, AlphaInputType) == 0x000048, "Member 'FAnimNode_ApplyMeshSpaceAdditive::AlphaInputType' has a wrong offset!");
//(offsetof(FAnimNode_ApplyMeshSpaceAdditive, Alpha) == 0x00004C, "Member 'FAnimNode_ApplyMeshSpaceAdditive::Alpha' has a wrong offset!");
//(offsetof(FAnimNode_ApplyMeshSpaceAdditive, AlphaBoolBlend) == 0x000058, "Member 'FAnimNode_ApplyMeshSpaceAdditive::AlphaBoolBlend' has a wrong offset!");
//(offsetof(FAnimNode_ApplyMeshSpaceAdditive, AlphaCurveName) == 0x0000A0, "Member 'FAnimNode_ApplyMeshSpaceAdditive::AlphaCurveName' has a wrong offset!");
//(offsetof(FAnimNode_ApplyMeshSpaceAdditive, AlphaScaleBias) == 0x0000AC, "Member 'FAnimNode_ApplyMeshSpaceAdditive::AlphaScaleBias' has a wrong offset!");
//(offsetof(FAnimNode_ApplyMeshSpaceAdditive, AlphaScaleBiasClamp) == 0x0000B4, "Member 'FAnimNode_ApplyMeshSpaceAdditive::AlphaScaleBiasClamp' has a wrong offset!");
//(offsetof(FAnimNode_ApplyMeshSpaceAdditive, LODThreshold) == 0x0000E4, "Member 'FAnimNode_ApplyMeshSpaceAdditive::LODThreshold' has a wrong offset!");

// ScriptStruct Engine.BlueprintDebugData
// 0x0001 (0x0001 - 0x0000)
struct FBlueprintDebugData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBlueprintDebugData) == 0x000001, "Wrong alignment on FBlueprintDebugData");
//(sizeof(FBlueprintDebugData) == 0x000001, "Wrong size on FBlueprintDebugData");

// ScriptStruct Engine.MeshDisplacementMap
// 0x0010 (0x0010 - 0x0000)
struct FMeshDisplacementMap final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Center;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMeshDisplacementMap) == 0x000008, "Wrong alignment on FMeshDisplacementMap");
//(sizeof(FMeshDisplacementMap) == 0x000010, "Wrong size on FMeshDisplacementMap");
//(offsetof(FMeshDisplacementMap, Texture) == 0x000000, "Member 'FMeshDisplacementMap::Texture' has a wrong offset!");
//(offsetof(FMeshDisplacementMap, Magnitude) == 0x000008, "Member 'FMeshDisplacementMap::Magnitude' has a wrong offset!");
//(offsetof(FMeshDisplacementMap, Center) == 0x00000C, "Member 'FMeshDisplacementMap::Center' has a wrong offset!");

// ScriptStruct Engine.MeshNaniteSettings
// 0x0040 (0x0040 - 0x0000)
struct FMeshNaniteSettings final
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPreserveArea : 1;                                 // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bExplicitTangents : 1;                             // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PositionPrecision;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalPrecision;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TangentPrecision;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TargetMinimumResidencyInKB;                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepPercentTriangles;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrimRelativeError;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENaniteFallbackTarget                         FallbackTarget;                                    // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallbackPercentTriangles;                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallbackRelativeError;                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplacementUVChannel;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMeshDisplacementMap>           DisplacementMaps;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FMeshNaniteSettings) == 0x000008, "Wrong alignment on FMeshNaniteSettings");
//(sizeof(FMeshNaniteSettings) == 0x000040, "Wrong size on FMeshNaniteSettings");
//(offsetof(FMeshNaniteSettings, PositionPrecision) == 0x000004, "Member 'FMeshNaniteSettings::PositionPrecision' has a wrong offset!");
//(offsetof(FMeshNaniteSettings, NormalPrecision) == 0x000008, "Member 'FMeshNaniteSettings::NormalPrecision' has a wrong offset!");
//(offsetof(FMeshNaniteSettings, TangentPrecision) == 0x00000C, "Member 'FMeshNaniteSettings::TangentPrecision' has a wrong offset!");
//(offsetof(FMeshNaniteSettings, TargetMinimumResidencyInKB) == 0x000010, "Member 'FMeshNaniteSettings::TargetMinimumResidencyInKB' has a wrong offset!");
//(offsetof(FMeshNaniteSettings, KeepPercentTriangles) == 0x000014, "Member 'FMeshNaniteSettings::KeepPercentTriangles' has a wrong offset!");
//(offsetof(FMeshNaniteSettings, TrimRelativeError) == 0x000018, "Member 'FMeshNaniteSettings::TrimRelativeError' has a wrong offset!");
//(offsetof(FMeshNaniteSettings, FallbackTarget) == 0x00001C, "Member 'FMeshNaniteSettings::FallbackTarget' has a wrong offset!");
//(offsetof(FMeshNaniteSettings, FallbackPercentTriangles) == 0x000020, "Member 'FMeshNaniteSettings::FallbackPercentTriangles' has a wrong offset!");
//(offsetof(FMeshNaniteSettings, FallbackRelativeError) == 0x000024, "Member 'FMeshNaniteSettings::FallbackRelativeError' has a wrong offset!");
//(offsetof(FMeshNaniteSettings, DisplacementUVChannel) == 0x000028, "Member 'FMeshNaniteSettings::DisplacementUVChannel' has a wrong offset!");
//(offsetof(FMeshNaniteSettings, DisplacementMaps) == 0x000030, "Member 'FMeshNaniteSettings::DisplacementMaps' has a wrong offset!");

// ScriptStruct Engine.BodyInstanceAsyncPhysicsTickHandle
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FBodyInstanceAsyncPhysicsTickHandle final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBodyInstanceAsyncPhysicsTickHandle) == 0x000008, "Wrong alignment on FBodyInstanceAsyncPhysicsTickHandle");
//(sizeof(FBodyInstanceAsyncPhysicsTickHandle) == 0x000008, "Wrong size on FBodyInstanceAsyncPhysicsTickHandle");

// ScriptStruct Engine.AnimationFrameSnapshot
// 0x0001 (0x0001 - 0x0000)
struct FAnimationFrameSnapshot final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimationFrameSnapshot) == 0x000001, "Wrong alignment on FAnimationFrameSnapshot");
//(sizeof(FAnimationFrameSnapshot) == 0x000001, "Wrong size on FAnimationFrameSnapshot");

// ScriptStruct Engine.DisplacementScaling
// 0x0008 (0x0008 - 0x0000)
struct FDisplacementScaling final
{
public:
	float                                         Magnitude;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Center;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDisplacementScaling) == 0x000004, "Wrong alignment on FDisplacementScaling");
//(sizeof(FDisplacementScaling) == 0x000008, "Wrong size on FDisplacementScaling");
//(offsetof(FDisplacementScaling, Magnitude) == 0x000000, "Member 'FDisplacementScaling::Magnitude' has a wrong offset!");
//(offsetof(FDisplacementScaling, Center) == 0x000004, "Member 'FDisplacementScaling::Center' has a wrong offset!");

// ScriptStruct Engine.VectorDistribution
// 0x0020 (0x0020 - 0x0000)
struct FVectorDistribution final
{
public:
	struct FDistributionLookupTable               Table;                                             // 0x0000(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FVectorDistribution) == 0x000008, "Wrong alignment on FVectorDistribution");
//(sizeof(FVectorDistribution) == 0x000020, "Wrong size on FVectorDistribution");
//(offsetof(FVectorDistribution, Table) == 0x000000, "Member 'FVectorDistribution::Table' has a wrong offset!");

// ScriptStruct Engine.VectorMaterialInput
// 0x0010 (0x0040 - 0x0030)
struct FVectorMaterialInput final : public FMaterialInput
{
public:
	uint8                                         UseConstant : 1;                                   // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector3f                              Constant;                                          // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FVectorMaterialInput) == 0x000008, "Wrong alignment on FVectorMaterialInput");
//(sizeof(FVectorMaterialInput) == 0x000040, "Wrong size on FVectorMaterialInput");
//(offsetof(FVectorMaterialInput, Constant) == 0x000034, "Member 'FVectorMaterialInput::Constant' has a wrong offset!");

// ScriptStruct Engine.MaterialOverrideNanite
// 0x0040 (0x0040 - 0x0000)
struct FMaterialOverrideNanite final
{
public:
	bool                                          bEnableOverride;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     OverrideMaterial;                                  // 0x0008(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      OverrideMaterialRef;                               // 0x0010(0x0030)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
//(alignof(FMaterialOverrideNanite) == 0x000008, "Wrong alignment on FMaterialOverrideNanite");
//(sizeof(FMaterialOverrideNanite) == 0x000040, "Wrong size on FMaterialOverrideNanite");
//(offsetof(FMaterialOverrideNanite, bEnableOverride) == 0x000000, "Member 'FMaterialOverrideNanite::bEnableOverride' has a wrong offset!");
//(offsetof(FMaterialOverrideNanite, OverrideMaterial) == 0x000008, "Member 'FMaterialOverrideNanite::OverrideMaterial' has a wrong offset!");
//(offsetof(FMaterialOverrideNanite, OverrideMaterialRef) == 0x000010, "Member 'FMaterialOverrideNanite::OverrideMaterialRef' has a wrong offset!");

// ScriptStruct Engine.VectorRK4SpringInterpolator
// 0x0008 (0x0008 - 0x0000)
struct FVectorRK4SpringInterpolator final
{
public:
	float                                         StiffnessConstant;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DampeningRatio;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FVectorRK4SpringInterpolator) == 0x000004, "Wrong alignment on FVectorRK4SpringInterpolator");
//(sizeof(FVectorRK4SpringInterpolator) == 0x000008, "Wrong size on FVectorRK4SpringInterpolator");
//(offsetof(FVectorRK4SpringInterpolator, StiffnessConstant) == 0x000000, "Member 'FVectorRK4SpringInterpolator::StiffnessConstant' has a wrong offset!");
//(offsetof(FVectorRK4SpringInterpolator, DampeningRatio) == 0x000004, "Member 'FVectorRK4SpringInterpolator::DampeningRatio' has a wrong offset!");

// ScriptStruct Engine.DataTableRowHandle
// 0x0018 (0x0018 - 0x0000)
struct FDataTableRowHandle final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDataTableRowHandle) == 0x000008, "Wrong alignment on FDataTableRowHandle");
//(sizeof(FDataTableRowHandle) == 0x000018, "Wrong size on FDataTableRowHandle");
//(offsetof(FDataTableRowHandle, DataTable) == 0x000000, "Member 'FDataTableRowHandle::DataTable' has a wrong offset!");
//(offsetof(FDataTableRowHandle, RowName) == 0x000008, "Member 'FDataTableRowHandle::RowName' has a wrong offset!");

// ScriptStruct Engine.AnimDataModelNotifPayload
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAnimDataModelNotifPayload final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimDataModelNotifPayload) == 0x000008, "Wrong alignment on FAnimDataModelNotifPayload");
//(sizeof(FAnimDataModelNotifPayload) == 0x000010, "Wrong size on FAnimDataModelNotifPayload");

// ScriptStruct Engine.SoundWaveSpectralData
// 0x000C (0x000C - 0x0000)
struct FSoundWaveSpectralData final
{
public:
	float                                         FrequencyHz;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalizedMagnitude;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoundWaveSpectralData) == 0x000004, "Wrong alignment on FSoundWaveSpectralData");
//(sizeof(FSoundWaveSpectralData) == 0x00000C, "Wrong size on FSoundWaveSpectralData");
//(offsetof(FSoundWaveSpectralData, FrequencyHz) == 0x000000, "Member 'FSoundWaveSpectralData::FrequencyHz' has a wrong offset!");
//(offsetof(FSoundWaveSpectralData, Magnitude) == 0x000004, "Member 'FSoundWaveSpectralData::Magnitude' has a wrong offset!");
//(offsetof(FSoundWaveSpectralData, NormalizedMagnitude) == 0x000008, "Member 'FSoundWaveSpectralData::NormalizedMagnitude' has a wrong offset!");

// ScriptStruct Engine.SoundWaveSpectralDataPerSound
// 0x0020 (0x0020 - 0x0000)
struct FSoundWaveSpectralDataPerSound final
{
public:
	TArray<struct FSoundWaveSpectralData>         SpectralData;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PlaybackTime;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundWave*                             SoundWave;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoundWaveSpectralDataPerSound) == 0x000008, "Wrong alignment on FSoundWaveSpectralDataPerSound");
//(sizeof(FSoundWaveSpectralDataPerSound) == 0x000020, "Wrong size on FSoundWaveSpectralDataPerSound");
//(offsetof(FSoundWaveSpectralDataPerSound, SpectralData) == 0x000000, "Member 'FSoundWaveSpectralDataPerSound::SpectralData' has a wrong offset!");
//(offsetof(FSoundWaveSpectralDataPerSound, PlaybackTime) == 0x000010, "Member 'FSoundWaveSpectralDataPerSound::PlaybackTime' has a wrong offset!");
//(offsetof(FSoundWaveSpectralDataPerSound, SoundWave) == 0x000018, "Member 'FSoundWaveSpectralDataPerSound::SoundWave' has a wrong offset!");

// ScriptStruct Engine.BoneMirrorInfo
// 0x0008 (0x0008 - 0x0000)
struct FBoneMirrorInfo final
{
public:
	int32                                         SourceIndex;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         BoneFlipAxis;                                      // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBoneMirrorInfo) == 0x000004, "Wrong alignment on FBoneMirrorInfo");
//(sizeof(FBoneMirrorInfo) == 0x000008, "Wrong size on FBoneMirrorInfo");
//(offsetof(FBoneMirrorInfo, SourceIndex) == 0x000000, "Member 'FBoneMirrorInfo::SourceIndex' has a wrong offset!");
//(offsetof(FBoneMirrorInfo, BoneFlipAxis) == 0x000004, "Member 'FBoneMirrorInfo::BoneFlipAxis' has a wrong offset!");

// ScriptStruct Engine.UserActivity
// 0x0018 (0x0018 - 0x0000)
struct FUserActivity final
{
public:
	class FString                                 ActionName;                                        // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FUserActivity) == 0x000008, "Wrong alignment on FUserActivity");
//(sizeof(FUserActivity) == 0x000018, "Wrong size on FUserActivity");
//(offsetof(FUserActivity, ActionName) == 0x000000, "Member 'FUserActivity::ActionName' has a wrong offset!");

// ScriptStruct Engine.FloatAnimationAttribute
// 0x0004 (0x0004 - 0x0000)
struct FFloatAnimationAttribute
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FFloatAnimationAttribute) == 0x000004, "Wrong alignment on FFloatAnimationAttribute");
//(sizeof(FFloatAnimationAttribute) == 0x000004, "Wrong size on FFloatAnimationAttribute");
//(offsetof(FFloatAnimationAttribute, Value) == 0x000000, "Member 'FFloatAnimationAttribute::Value' has a wrong offset!");

// ScriptStruct Engine.NonBlendableFloatAnimationAttribute
// 0x0000 (0x0004 - 0x0004)
struct FNonBlendableFloatAnimationAttribute final : public FFloatAnimationAttribute
{
};
//(alignof(FNonBlendableFloatAnimationAttribute) == 0x000004, "Wrong alignment on FNonBlendableFloatAnimationAttribute");
//(sizeof(FNonBlendableFloatAnimationAttribute) == 0x000004, "Wrong size on FNonBlendableFloatAnimationAttribute");

// ScriptStruct Engine.BandwidthTestItem
// 0x0010 (0x0010 - 0x0000)
struct FBandwidthTestItem final
{
public:
	TArray<uint8>                                 Kilobyte;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FBandwidthTestItem) == 0x000008, "Wrong alignment on FBandwidthTestItem");
//(sizeof(FBandwidthTestItem) == 0x000010, "Wrong size on FBandwidthTestItem");
//(offsetof(FBandwidthTestItem, Kilobyte) == 0x000000, "Member 'FBandwidthTestItem::Kilobyte' has a wrong offset!");

// ScriptStruct Engine.BandwidthTestGenerator
// 0x0020 (0x0020 - 0x0000)
struct FBandwidthTestGenerator final
{
public:
	TArray<struct FBandwidthTestItem>             ReplicatedBuffers;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBandwidthTestGenerator) == 0x000008, "Wrong alignment on FBandwidthTestGenerator");
//(sizeof(FBandwidthTestGenerator) == 0x000020, "Wrong size on FBandwidthTestGenerator");
//(offsetof(FBandwidthTestGenerator, ReplicatedBuffers) == 0x000000, "Member 'FBandwidthTestGenerator::ReplicatedBuffers' has a wrong offset!");

// ScriptStruct Engine.ChaosBreakEvent
// 0x0078 (0x0078 - 0x0000)
struct FChaosBreakEvent final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocity;                                   // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extents;                                           // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromCrumble;                                      // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FChaosBreakEvent) == 0x000008, "Wrong alignment on FChaosBreakEvent");
//(sizeof(FChaosBreakEvent) == 0x000078, "Wrong size on FChaosBreakEvent");
//(offsetof(FChaosBreakEvent, Component) == 0x000000, "Member 'FChaosBreakEvent::Component' has a wrong offset!");
//(offsetof(FChaosBreakEvent, Location) == 0x000008, "Member 'FChaosBreakEvent::Location' has a wrong offset!");
//(offsetof(FChaosBreakEvent, Velocity) == 0x000020, "Member 'FChaosBreakEvent::Velocity' has a wrong offset!");
//(offsetof(FChaosBreakEvent, AngularVelocity) == 0x000038, "Member 'FChaosBreakEvent::AngularVelocity' has a wrong offset!");
//(offsetof(FChaosBreakEvent, Extents) == 0x000050, "Member 'FChaosBreakEvent::Extents' has a wrong offset!");
//(offsetof(FChaosBreakEvent, Mass) == 0x000068, "Member 'FChaosBreakEvent::Mass' has a wrong offset!");
//(offsetof(FChaosBreakEvent, Index) == 0x00006C, "Member 'FChaosBreakEvent::Index' has a wrong offset!");
//(offsetof(FChaosBreakEvent, bFromCrumble) == 0x000070, "Member 'FChaosBreakEvent::bFromCrumble' has a wrong offset!");

// ScriptStruct Engine.RuntimePartitionHLODSetup
// 0x0010 (0x0010 - 0x0000)
struct FRuntimePartitionHLODSetup final
{
public:
	class UHLODLayer*                             HLODLayer;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URuntimePartition*                      PartitionLayer;                                    // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRuntimePartitionHLODSetup) == 0x000008, "Wrong alignment on FRuntimePartitionHLODSetup");
//(sizeof(FRuntimePartitionHLODSetup) == 0x000010, "Wrong size on FRuntimePartitionHLODSetup");
//(offsetof(FRuntimePartitionHLODSetup, HLODLayer) == 0x000000, "Member 'FRuntimePartitionHLODSetup::HLODLayer' has a wrong offset!");
//(offsetof(FRuntimePartitionHLODSetup, PartitionLayer) == 0x000008, "Member 'FRuntimePartitionHLODSetup::PartitionLayer' has a wrong offset!");

// ScriptStruct Engine.ComponentKey
// 0x0028 (0x0028 - 0x0000)
struct FComponentKey final
{
public:
	TSubclassOf<class UObject>                    OwnerClass;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SCSVariableName;                                   // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  AssociatedGuid;                                    // 0x0014(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FComponentKey) == 0x000008, "Wrong alignment on FComponentKey");
//(sizeof(FComponentKey) == 0x000028, "Wrong size on FComponentKey");
//(offsetof(FComponentKey, OwnerClass) == 0x000000, "Member 'FComponentKey::OwnerClass' has a wrong offset!");
//(offsetof(FComponentKey, SCSVariableName) == 0x000008, "Member 'FComponentKey::SCSVariableName' has a wrong offset!");
//(offsetof(FComponentKey, AssociatedGuid) == 0x000014, "Member 'FComponentKey::AssociatedGuid' has a wrong offset!");

// ScriptStruct Engine.BlueprintComponentChangedPropertyInfo
// 0x0018 (0x0018 - 0x0000)
struct FBlueprintComponentChangedPropertyInfo final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArrayIndex;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStruct*                                PropertyScope;                                     // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBlueprintComponentChangedPropertyInfo) == 0x000008, "Wrong alignment on FBlueprintComponentChangedPropertyInfo");
//(sizeof(FBlueprintComponentChangedPropertyInfo) == 0x000018, "Wrong size on FBlueprintComponentChangedPropertyInfo");
//(offsetof(FBlueprintComponentChangedPropertyInfo, PropertyName) == 0x000000, "Member 'FBlueprintComponentChangedPropertyInfo::PropertyName' has a wrong offset!");
//(offsetof(FBlueprintComponentChangedPropertyInfo, ArrayIndex) == 0x00000C, "Member 'FBlueprintComponentChangedPropertyInfo::ArrayIndex' has a wrong offset!");
//(offsetof(FBlueprintComponentChangedPropertyInfo, PropertyScope) == 0x000010, "Member 'FBlueprintComponentChangedPropertyInfo::PropertyScope' has a wrong offset!");

// ScriptStruct Engine.BlueprintCookedComponentInstancingData
// 0x0050 (0x0050 - 0x0000)
struct FBlueprintCookedComponentInstancingData final
{
public:
	TArray<struct FBlueprintComponentChangedPropertyInfo> ChangedPropertyList;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x19];                                      // 0x0010(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasValidCookedData;                               // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x26];                                      // 0x002A(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBlueprintCookedComponentInstancingData) == 0x000008, "Wrong alignment on FBlueprintCookedComponentInstancingData");
//(sizeof(FBlueprintCookedComponentInstancingData) == 0x000050, "Wrong size on FBlueprintCookedComponentInstancingData");
//(offsetof(FBlueprintCookedComponentInstancingData, ChangedPropertyList) == 0x000000, "Member 'FBlueprintCookedComponentInstancingData::ChangedPropertyList' has a wrong offset!");
//(offsetof(FBlueprintCookedComponentInstancingData, bHasValidCookedData) == 0x000029, "Member 'FBlueprintCookedComponentInstancingData::bHasValidCookedData' has a wrong offset!");

// ScriptStruct Engine.ComponentOverrideRecord
// 0x0088 (0x0088 - 0x0000)
struct FComponentOverrideRecord final
{
public:
	TSubclassOf<class UObject>                    ComponentClass;                                    // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ComponentTemplate;                                 // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FComponentKey                          ComponentKey;                                      // 0x0010(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FBlueprintCookedComponentInstancingData CookedComponentInstancingData;                     // 0x0038(0x0050)(NativeAccessSpecifierPublic)
};
//(alignof(FComponentOverrideRecord) == 0x000008, "Wrong alignment on FComponentOverrideRecord");
//(sizeof(FComponentOverrideRecord) == 0x000088, "Wrong size on FComponentOverrideRecord");
//(offsetof(FComponentOverrideRecord, ComponentClass) == 0x000000, "Member 'FComponentOverrideRecord::ComponentClass' has a wrong offset!");
//(offsetof(FComponentOverrideRecord, ComponentTemplate) == 0x000008, "Member 'FComponentOverrideRecord::ComponentTemplate' has a wrong offset!");
//(offsetof(FComponentOverrideRecord, ComponentKey) == 0x000010, "Member 'FComponentOverrideRecord::ComponentKey' has a wrong offset!");
//(offsetof(FComponentOverrideRecord, CookedComponentInstancingData) == 0x000038, "Member 'FComponentOverrideRecord::CookedComponentInstancingData' has a wrong offset!");

// ScriptStruct Engine.CollisionChaosEventBodyInfo
// 0x0070 (0x0070 - 0x0000)
struct FCollisionChaosEventBodyInfo final
{
public:
	struct FVector                                Velocity;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DeltaVelocity;                                     // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocity;                                   // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      PhysMaterial;                                      // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0058(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodyIndex;                                         // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0064(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCollisionChaosEventBodyInfo) == 0x000008, "Wrong alignment on FCollisionChaosEventBodyInfo");
//(sizeof(FCollisionChaosEventBodyInfo) == 0x000070, "Wrong size on FCollisionChaosEventBodyInfo");
//(offsetof(FCollisionChaosEventBodyInfo, Velocity) == 0x000000, "Member 'FCollisionChaosEventBodyInfo::Velocity' has a wrong offset!");
//(offsetof(FCollisionChaosEventBodyInfo, DeltaVelocity) == 0x000018, "Member 'FCollisionChaosEventBodyInfo::DeltaVelocity' has a wrong offset!");
//(offsetof(FCollisionChaosEventBodyInfo, AngularVelocity) == 0x000030, "Member 'FCollisionChaosEventBodyInfo::AngularVelocity' has a wrong offset!");
//(offsetof(FCollisionChaosEventBodyInfo, Mass) == 0x000048, "Member 'FCollisionChaosEventBodyInfo::Mass' has a wrong offset!");
//(offsetof(FCollisionChaosEventBodyInfo, PhysMaterial) == 0x000050, "Member 'FCollisionChaosEventBodyInfo::PhysMaterial' has a wrong offset!");
//(offsetof(FCollisionChaosEventBodyInfo, Component) == 0x000058, "Member 'FCollisionChaosEventBodyInfo::Component' has a wrong offset!");
//(offsetof(FCollisionChaosEventBodyInfo, BodyIndex) == 0x000060, "Member 'FCollisionChaosEventBodyInfo::BodyIndex' has a wrong offset!");
//(offsetof(FCollisionChaosEventBodyInfo, BoneName) == 0x000064, "Member 'FCollisionChaosEventBodyInfo::BoneName' has a wrong offset!");

// ScriptStruct Engine.CollisionChaosEvent
// 0x0130 (0x0130 - 0x0000)
struct FCollisionChaosEvent final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedImpulse;                                // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationDepth;                                  // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionChaosEventBodyInfo           Body1;                                             // 0x0050(0x0070)(BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FCollisionChaosEventBodyInfo           Body2;                                             // 0x00C0(0x0070)(BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
//(alignof(FCollisionChaosEvent) == 0x000008, "Wrong alignment on FCollisionChaosEvent");
//(sizeof(FCollisionChaosEvent) == 0x000130, "Wrong size on FCollisionChaosEvent");
//(offsetof(FCollisionChaosEvent, Location) == 0x000000, "Member 'FCollisionChaosEvent::Location' has a wrong offset!");
//(offsetof(FCollisionChaosEvent, AccumulatedImpulse) == 0x000018, "Member 'FCollisionChaosEvent::AccumulatedImpulse' has a wrong offset!");
//(offsetof(FCollisionChaosEvent, Normal) == 0x000030, "Member 'FCollisionChaosEvent::Normal' has a wrong offset!");
//(offsetof(FCollisionChaosEvent, PenetrationDepth) == 0x000048, "Member 'FCollisionChaosEvent::PenetrationDepth' has a wrong offset!");
//(offsetof(FCollisionChaosEvent, Body1) == 0x000050, "Member 'FCollisionChaosEvent::Body1' has a wrong offset!");
//(offsetof(FCollisionChaosEvent, Body2) == 0x0000C0, "Member 'FCollisionChaosEvent::Body2' has a wrong offset!");

// ScriptStruct Engine.CollisionProfileName
// 0x000C (0x000C - 0x0000)
struct FCollisionProfileName final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCollisionProfileName) == 0x000004, "Wrong alignment on FCollisionProfileName");
//(sizeof(FCollisionProfileName) == 0x00000C, "Wrong size on FCollisionProfileName");
//(offsetof(FCollisionProfileName, Name) == 0x000000, "Member 'FCollisionProfileName::Name' has a wrong offset!");

// ScriptStruct Engine.StaticComponentMaskValue
// 0x0004 (0x0004 - 0x0000)
struct FStaticComponentMaskValue final
{
public:
	bool                                          R;                                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          G;                                                 // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          A;                                                 // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FStaticComponentMaskValue) == 0x000001, "Wrong alignment on FStaticComponentMaskValue");
//(sizeof(FStaticComponentMaskValue) == 0x000004, "Wrong size on FStaticComponentMaskValue");
//(offsetof(FStaticComponentMaskValue, R) == 0x000000, "Member 'FStaticComponentMaskValue::R' has a wrong offset!");
//(offsetof(FStaticComponentMaskValue, G) == 0x000001, "Member 'FStaticComponentMaskValue::G' has a wrong offset!");
//(offsetof(FStaticComponentMaskValue, B) == 0x000002, "Member 'FStaticComponentMaskValue::B' has a wrong offset!");
//(offsetof(FStaticComponentMaskValue, A) == 0x000003, "Member 'FStaticComponentMaskValue::A' has a wrong offset!");

// ScriptStruct Engine.CustomAttributePerBoneData
// 0x0001 (0x0001 - 0x0000)
struct FCustomAttributePerBoneData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCustomAttributePerBoneData) == 0x000001, "Wrong alignment on FCustomAttributePerBoneData");
//(sizeof(FCustomAttributePerBoneData) == 0x000001, "Wrong size on FCustomAttributePerBoneData");

// ScriptStruct Engine.SkelMeshSkinWeightInfo
// 0x003C (0x003C - 0x0000)
struct FSkelMeshSkinWeightInfo final
{
public:
	int32                                         Bones[0xC];                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weights[0xC];                                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSkelMeshSkinWeightInfo) == 0x000004, "Wrong alignment on FSkelMeshSkinWeightInfo");
//(sizeof(FSkelMeshSkinWeightInfo) == 0x00003C, "Wrong size on FSkelMeshSkinWeightInfo");
//(offsetof(FSkelMeshSkinWeightInfo, Bones) == 0x000000, "Member 'FSkelMeshSkinWeightInfo::Bones' has a wrong offset!");
//(offsetof(FSkelMeshSkinWeightInfo, Weights) == 0x000030, "Member 'FSkelMeshSkinWeightInfo::Weights' has a wrong offset!");

// ScriptStruct Engine.RichCurveKey
// 0x001C (0x001C - 0x0000)
struct FRichCurveKey final
{
public:
	ERichCurveInterpMode                          InterpMode;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveTangentMode                         TangentMode;                                       // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveTangentWeightMode                   TangentWeightMode;                                 // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArriveTangent;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArriveTangentWeight;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveTangent;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveTangentWeight;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRichCurveKey) == 0x000004, "Wrong alignment on FRichCurveKey");
//(sizeof(FRichCurveKey) == 0x00001C, "Wrong size on FRichCurveKey");
//(offsetof(FRichCurveKey, InterpMode) == 0x000000, "Member 'FRichCurveKey::InterpMode' has a wrong offset!");
//(offsetof(FRichCurveKey, TangentMode) == 0x000001, "Member 'FRichCurveKey::TangentMode' has a wrong offset!");
//(offsetof(FRichCurveKey, TangentWeightMode) == 0x000002, "Member 'FRichCurveKey::TangentWeightMode' has a wrong offset!");
//(offsetof(FRichCurveKey, Time) == 0x000004, "Member 'FRichCurveKey::Time' has a wrong offset!");
//(offsetof(FRichCurveKey, Value) == 0x000008, "Member 'FRichCurveKey::Value' has a wrong offset!");
//(offsetof(FRichCurveKey, ArriveTangent) == 0x00000C, "Member 'FRichCurveKey::ArriveTangent' has a wrong offset!");
//(offsetof(FRichCurveKey, ArriveTangentWeight) == 0x000010, "Member 'FRichCurveKey::ArriveTangentWeight' has a wrong offset!");
//(offsetof(FRichCurveKey, LeaveTangent) == 0x000014, "Member 'FRichCurveKey::LeaveTangent' has a wrong offset!");
//(offsetof(FRichCurveKey, LeaveTangentWeight) == 0x000018, "Member 'FRichCurveKey::LeaveTangentWeight' has a wrong offset!");

// ScriptStruct Engine.KeyHandleMap
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FKeyHandleMap final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FKeyHandleMap) == 0x000008, "Wrong alignment on FKeyHandleMap");
//(sizeof(FKeyHandleMap) == 0x000060, "Wrong size on FKeyHandleMap");

// ScriptStruct Engine.IndexedCurve
// 0x0068 (0x0068 - 0x0000)
struct FIndexedCurve
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKeyHandleMap                          KeyHandlesToIndices;                               // 0x0008(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
};
//(alignof(FIndexedCurve) == 0x000008, "Wrong alignment on FIndexedCurve");
//(sizeof(FIndexedCurve) == 0x000068, "Wrong size on FIndexedCurve");
//(offsetof(FIndexedCurve, KeyHandlesToIndices) == 0x000008, "Member 'FIndexedCurve::KeyHandlesToIndices' has a wrong offset!");

// ScriptStruct Engine.RealCurve
// 0x0008 (0x0070 - 0x0068)
struct FRealCurve : public FIndexedCurve
{
public:
	float                                         DefaultValue;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveExtrapolation                       PreInfinityExtrap;                                 // 0x006C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveExtrapolation                       PostInfinityExtrap;                                // 0x006D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRealCurve) == 0x000008, "Wrong alignment on FRealCurve");
//(sizeof(FRealCurve) == 0x000070, "Wrong size on FRealCurve");
//(offsetof(FRealCurve, DefaultValue) == 0x000068, "Member 'FRealCurve::DefaultValue' has a wrong offset!");
//(offsetof(FRealCurve, PreInfinityExtrap) == 0x00006C, "Member 'FRealCurve::PreInfinityExtrap' has a wrong offset!");
//(offsetof(FRealCurve, PostInfinityExtrap) == 0x00006D, "Member 'FRealCurve::PostInfinityExtrap' has a wrong offset!");

// ScriptStruct Engine.RichCurve
// 0x0010 (0x0080 - 0x0070)
struct FRichCurve final : public FRealCurve
{
public:
	TArray<struct FRichCurveKey>                  Keys;                                              // 0x0070(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FRichCurve) == 0x000008, "Wrong alignment on FRichCurve");
//(sizeof(FRichCurve) == 0x000080, "Wrong size on FRichCurve");
//(offsetof(FRichCurve, Keys) == 0x000070, "Member 'FRichCurve::Keys' has a wrong offset!");

// ScriptStruct Engine.RuntimeFloatCurve
// 0x0088 (0x0088 - 0x0000)
struct FRuntimeFloatCurve final
{
public:
	struct FRichCurve                             EditorCurveData;                                   // 0x0000(0x0080)(NativeAccessSpecifierPublic)
	class UCurveFloat*                            ExternalCurve;                                     // 0x0080(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRuntimeFloatCurve) == 0x000008, "Wrong alignment on FRuntimeFloatCurve");
//(sizeof(FRuntimeFloatCurve) == 0x000088, "Wrong size on FRuntimeFloatCurve");
//(offsetof(FRuntimeFloatCurve, EditorCurveData) == 0x000000, "Member 'FRuntimeFloatCurve::EditorCurveData' has a wrong offset!");
//(offsetof(FRuntimeFloatCurve, ExternalCurve) == 0x000080, "Member 'FRuntimeFloatCurve::ExternalCurve' has a wrong offset!");

// ScriptStruct Engine.BaseAttenuationSettings
// 0x00C0 (0x00C0 - 0x0000)
struct FBaseAttenuationSettings
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EAttenuationDistanceModel                     DistanceAlgorithm;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttenuationShape                             AttenuationShape;                                  // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENaturalSoundFalloffMode                      FalloffMode;                                       // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DBAttenuationAtMax;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttenuationShapeExtents;                           // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeOffset;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffDistance;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeSphereRadius;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeSphereFalloffDistance;                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     CustomAttenuationCurve;                            // 0x0038(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
//(alignof(FBaseAttenuationSettings) == 0x000008, "Wrong alignment on FBaseAttenuationSettings");
//(sizeof(FBaseAttenuationSettings) == 0x0000C0, "Wrong size on FBaseAttenuationSettings");
//(offsetof(FBaseAttenuationSettings, DistanceAlgorithm) == 0x000008, "Member 'FBaseAttenuationSettings::DistanceAlgorithm' has a wrong offset!");
//(offsetof(FBaseAttenuationSettings, AttenuationShape) == 0x000009, "Member 'FBaseAttenuationSettings::AttenuationShape' has a wrong offset!");
//(offsetof(FBaseAttenuationSettings, FalloffMode) == 0x00000A, "Member 'FBaseAttenuationSettings::FalloffMode' has a wrong offset!");
//(offsetof(FBaseAttenuationSettings, DBAttenuationAtMax) == 0x00000C, "Member 'FBaseAttenuationSettings::DBAttenuationAtMax' has a wrong offset!");
//(offsetof(FBaseAttenuationSettings, AttenuationShapeExtents) == 0x000010, "Member 'FBaseAttenuationSettings::AttenuationShapeExtents' has a wrong offset!");
//(offsetof(FBaseAttenuationSettings, ConeOffset) == 0x000028, "Member 'FBaseAttenuationSettings::ConeOffset' has a wrong offset!");
//(offsetof(FBaseAttenuationSettings, FalloffDistance) == 0x00002C, "Member 'FBaseAttenuationSettings::FalloffDistance' has a wrong offset!");
//(offsetof(FBaseAttenuationSettings, ConeSphereRadius) == 0x000030, "Member 'FBaseAttenuationSettings::ConeSphereRadius' has a wrong offset!");
//(offsetof(FBaseAttenuationSettings, ConeSphereFalloffDistance) == 0x000034, "Member 'FBaseAttenuationSettings::ConeSphereFalloffDistance' has a wrong offset!");
//(offsetof(FBaseAttenuationSettings, CustomAttenuationCurve) == 0x000038, "Member 'FBaseAttenuationSettings::CustomAttenuationCurve' has a wrong offset!");

// ScriptStruct Engine.ForceFeedbackAttenuationSettings
// 0x0000 (0x00C0 - 0x00C0)
struct FForceFeedbackAttenuationSettings final : public FBaseAttenuationSettings
{
};
//(alignof(FForceFeedbackAttenuationSettings) == 0x000008, "Wrong alignment on FForceFeedbackAttenuationSettings");
//(sizeof(FForceFeedbackAttenuationSettings) == 0x0000C0, "Wrong size on FForceFeedbackAttenuationSettings");

// ScriptStruct Engine.ChaosCrumblingEvent
// 0x00C0 (0x00C0 - 0x0000)
struct FChaosCrumblingEvent final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Orientation;                                       // 0x0020(0x0020)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LinearVelocity;                                    // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocity;                                   // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   LocalBounds;                                       // 0x0078(0x0038)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Children;                                          // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FChaosCrumblingEvent) == 0x000010, "Wrong alignment on FChaosCrumblingEvent");
//(sizeof(FChaosCrumblingEvent) == 0x0000C0, "Wrong size on FChaosCrumblingEvent");
//(offsetof(FChaosCrumblingEvent, Component) == 0x000000, "Member 'FChaosCrumblingEvent::Component' has a wrong offset!");
//(offsetof(FChaosCrumblingEvent, Location) == 0x000008, "Member 'FChaosCrumblingEvent::Location' has a wrong offset!");
//(offsetof(FChaosCrumblingEvent, Orientation) == 0x000020, "Member 'FChaosCrumblingEvent::Orientation' has a wrong offset!");
//(offsetof(FChaosCrumblingEvent, LinearVelocity) == 0x000040, "Member 'FChaosCrumblingEvent::LinearVelocity' has a wrong offset!");
//(offsetof(FChaosCrumblingEvent, AngularVelocity) == 0x000058, "Member 'FChaosCrumblingEvent::AngularVelocity' has a wrong offset!");
//(offsetof(FChaosCrumblingEvent, Mass) == 0x000070, "Member 'FChaosCrumblingEvent::Mass' has a wrong offset!");
//(offsetof(FChaosCrumblingEvent, LocalBounds) == 0x000078, "Member 'FChaosCrumblingEvent::LocalBounds' has a wrong offset!");
//(offsetof(FChaosCrumblingEvent, Children) == 0x0000B0, "Member 'FChaosCrumblingEvent::Children' has a wrong offset!");

// ScriptStruct Engine.SoftWorldReference
// 0x0030 (0x0030 - 0x0000)
struct FSoftWorldReference final
{
public:
	TSoftObjectPtr<class UWorld>                  WorldAsset;                                        // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoftWorldReference) == 0x000008, "Wrong alignment on FSoftWorldReference");
//(sizeof(FSoftWorldReference) == 0x000030, "Wrong size on FSoftWorldReference");
//(offsetof(FSoftWorldReference, WorldAsset) == 0x000000, "Member 'FSoftWorldReference::WorldAsset' has a wrong offset!");

// ScriptStruct Engine.AnimationAttributeIdentifier
// 0x0050 (0x0050 - 0x0000)
struct FAnimationAttributeIdentifier final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BoneName;                                          // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BoneIndex;                                         // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UScriptStruct*                          ScriptStruct;                                      // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        ScriptStructPath;                                  // 0x0028(0x0028)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
//(alignof(FAnimationAttributeIdentifier) == 0x000008, "Wrong alignment on FAnimationAttributeIdentifier");
//(sizeof(FAnimationAttributeIdentifier) == 0x000050, "Wrong size on FAnimationAttributeIdentifier");
//(offsetof(FAnimationAttributeIdentifier, Name) == 0x000000, "Member 'FAnimationAttributeIdentifier::Name' has a wrong offset!");
//(offsetof(FAnimationAttributeIdentifier, BoneName) == 0x00000C, "Member 'FAnimationAttributeIdentifier::BoneName' has a wrong offset!");
//(offsetof(FAnimationAttributeIdentifier, BoneIndex) == 0x000018, "Member 'FAnimationAttributeIdentifier::BoneIndex' has a wrong offset!");
//(offsetof(FAnimationAttributeIdentifier, ScriptStruct) == 0x000020, "Member 'FAnimationAttributeIdentifier::ScriptStruct' has a wrong offset!");
//(offsetof(FAnimationAttributeIdentifier, ScriptStructPath) == 0x000028, "Member 'FAnimationAttributeIdentifier::ScriptStructPath' has a wrong offset!");

// ScriptStruct Engine.AttributeKey
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAttributeKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x14];                                       // 0x0004(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAttributeKey) == 0x000008, "Wrong alignment on FAttributeKey");
//(sizeof(FAttributeKey) == 0x000018, "Wrong size on FAttributeKey");
//(offsetof(FAttributeKey, Time) == 0x000000, "Member 'FAttributeKey::Time' has a wrong offset!");

// ScriptStruct Engine.AttributeCurve
// 0x0050 (0x00B8 - 0x0068)
struct FAttributeCurve final : public FIndexedCurve
{
public:
	TArray<struct FAttributeKey>                  Keys;                                              // 0x0068(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        ScriptStructPath;                                  // 0x0078(0x0028)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScriptStruct*                          ScriptStruct;                                      // 0x00A0(0x0008)(Edit, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldInterpolate;                                // 0x00A8(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0xF];                                       // 0x00A9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAttributeCurve) == 0x000008, "Wrong alignment on FAttributeCurve");
//(sizeof(FAttributeCurve) == 0x0000B8, "Wrong size on FAttributeCurve");
//(offsetof(FAttributeCurve, Keys) == 0x000068, "Member 'FAttributeCurve::Keys' has a wrong offset!");
//(offsetof(FAttributeCurve, ScriptStructPath) == 0x000078, "Member 'FAttributeCurve::ScriptStructPath' has a wrong offset!");
//(offsetof(FAttributeCurve, ScriptStruct) == 0x0000A0, "Member 'FAttributeCurve::ScriptStruct' has a wrong offset!");
//(offsetof(FAttributeCurve, bShouldInterpolate) == 0x0000A8, "Member 'FAttributeCurve::bShouldInterpolate' has a wrong offset!");

// ScriptStruct Engine.AnimatedBoneAttribute
// 0x0108 (0x0108 - 0x0000)
struct FAnimatedBoneAttribute final
{
public:
	struct FAnimationAttributeIdentifier          Identifier;                                        // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeCurve                        Curve;                                             // 0x0050(0x00B8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
//(alignof(FAnimatedBoneAttribute) == 0x000008, "Wrong alignment on FAnimatedBoneAttribute");
//(sizeof(FAnimatedBoneAttribute) == 0x000108, "Wrong size on FAnimatedBoneAttribute");
//(offsetof(FAnimatedBoneAttribute, Identifier) == 0x000000, "Member 'FAnimatedBoneAttribute::Identifier' has a wrong offset!");
//(offsetof(FAnimatedBoneAttribute, Curve) == 0x000050, "Member 'FAnimatedBoneAttribute::Curve' has a wrong offset!");

// ScriptStruct Engine.SoundModulationDestinationSettings
// 0x0058 (0x0058 - 0x0000)
struct FSoundModulationDestinationSettings final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class USoundModulatorBase*>              Modulators;                                        // 0x0008(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FSoundModulationDestinationSettings) == 0x000008, "Wrong alignment on FSoundModulationDestinationSettings");
//(sizeof(FSoundModulationDestinationSettings) == 0x000058, "Wrong size on FSoundModulationDestinationSettings");
//(offsetof(FSoundModulationDestinationSettings, Value) == 0x000000, "Member 'FSoundModulationDestinationSettings::Value' has a wrong offset!");
//(offsetof(FSoundModulationDestinationSettings, Modulators) == 0x000008, "Member 'FSoundModulationDestinationSettings::Modulators' has a wrong offset!");

// ScriptStruct Engine.SoundModulationDefaultSettings
// 0x0160 (0x0160 - 0x0000)
struct FSoundModulationDefaultSettings
{
public:
	struct FSoundModulationDestinationSettings    VolumeModulationDestination;                       // 0x0000(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoundModulationDestinationSettings    PitchModulationDestination;                        // 0x0058(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoundModulationDestinationSettings    HighpassModulationDestination;                     // 0x00B0(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoundModulationDestinationSettings    LowpassModulationDestination;                      // 0x0108(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
//(alignof(FSoundModulationDefaultSettings) == 0x000008, "Wrong alignment on FSoundModulationDefaultSettings");
//(sizeof(FSoundModulationDefaultSettings) == 0x000160, "Wrong size on FSoundModulationDefaultSettings");
//(offsetof(FSoundModulationDefaultSettings, VolumeModulationDestination) == 0x000000, "Member 'FSoundModulationDefaultSettings::VolumeModulationDestination' has a wrong offset!");
//(offsetof(FSoundModulationDefaultSettings, PitchModulationDestination) == 0x000058, "Member 'FSoundModulationDefaultSettings::PitchModulationDestination' has a wrong offset!");
//(offsetof(FSoundModulationDefaultSettings, HighpassModulationDestination) == 0x0000B0, "Member 'FSoundModulationDefaultSettings::HighpassModulationDestination' has a wrong offset!");
//(offsetof(FSoundModulationDefaultSettings, LowpassModulationDestination) == 0x000108, "Member 'FSoundModulationDefaultSettings::LowpassModulationDestination' has a wrong offset!");

// ScriptStruct Engine.SoundClassProperties
// 0x0198 (0x0198 - 0x0000)
struct FSoundClassProperties final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowPassFilterFrequency;                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationDistanceScale;                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LFEBleed;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoiceCenterChannelVolume;                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadioFilterVolume;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadioFilterVolumeThreshold;                        // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyEffects : 1;                                 // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysPlay : 1;                                   // 0x0020(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsUISound : 1;                                    // 0x0020(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsMusic : 1;                                      // 0x0020(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCenterChannelOnly : 1;                            // 0x0020(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyAmbientVolumes : 1;                          // 0x0020(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReverb : 1;                                       // 0x0020(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Default2DReverbSendAmount;                         // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoundModulationDefaultSettings        ModulationSettings;                                // 0x0028(0x0160)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EAudioOutputTarget                            OutputTarget;                                      // 0x0188(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundWaveLoadingBehavior                     LoadingBehavior;                                   // 0x0189(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A[0x6];                                      // 0x018A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSubmix*                           DefaultSubmix;                                     // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoundClassProperties) == 0x000008, "Wrong alignment on FSoundClassProperties");
//(sizeof(FSoundClassProperties) == 0x000198, "Wrong size on FSoundClassProperties");
//(offsetof(FSoundClassProperties, Volume) == 0x000000, "Member 'FSoundClassProperties::Volume' has a wrong offset!");
//(offsetof(FSoundClassProperties, Pitch) == 0x000004, "Member 'FSoundClassProperties::Pitch' has a wrong offset!");
//(offsetof(FSoundClassProperties, LowPassFilterFrequency) == 0x000008, "Member 'FSoundClassProperties::LowPassFilterFrequency' has a wrong offset!");
//(offsetof(FSoundClassProperties, AttenuationDistanceScale) == 0x00000C, "Member 'FSoundClassProperties::AttenuationDistanceScale' has a wrong offset!");
//(offsetof(FSoundClassProperties, LFEBleed) == 0x000010, "Member 'FSoundClassProperties::LFEBleed' has a wrong offset!");
//(offsetof(FSoundClassProperties, VoiceCenterChannelVolume) == 0x000014, "Member 'FSoundClassProperties::VoiceCenterChannelVolume' has a wrong offset!");
//(offsetof(FSoundClassProperties, RadioFilterVolume) == 0x000018, "Member 'FSoundClassProperties::RadioFilterVolume' has a wrong offset!");
//(offsetof(FSoundClassProperties, RadioFilterVolumeThreshold) == 0x00001C, "Member 'FSoundClassProperties::RadioFilterVolumeThreshold' has a wrong offset!");
//(offsetof(FSoundClassProperties, Default2DReverbSendAmount) == 0x000024, "Member 'FSoundClassProperties::Default2DReverbSendAmount' has a wrong offset!");
//(offsetof(FSoundClassProperties, ModulationSettings) == 0x000028, "Member 'FSoundClassProperties::ModulationSettings' has a wrong offset!");
//(offsetof(FSoundClassProperties, OutputTarget) == 0x000188, "Member 'FSoundClassProperties::OutputTarget' has a wrong offset!");
//(offsetof(FSoundClassProperties, LoadingBehavior) == 0x000189, "Member 'FSoundClassProperties::LoadingBehavior' has a wrong offset!");
//(offsetof(FSoundClassProperties, DefaultSubmix) == 0x000190, "Member 'FSoundClassProperties::DefaultSubmix' has a wrong offset!");

// ScriptStruct Engine.Vector_NetQuantize
// 0x0000 (0x0018 - 0x0018)
struct FVector_NetQuantize final : public FVector
{
};
//(alignof(FVector_NetQuantize) == 0x000008, "Wrong alignment on FVector_NetQuantize");
//(sizeof(FVector_NetQuantize) == 0x000018, "Wrong size on FVector_NetQuantize");

// ScriptStruct Engine.Vector_NetQuantizeNormal
// 0x0000 (0x0018 - 0x0018)
struct FVector_NetQuantizeNormal final : public FVector
{
};
//(alignof(FVector_NetQuantizeNormal) == 0x000008, "Wrong alignment on FVector_NetQuantizeNormal");
//(sizeof(FVector_NetQuantizeNormal) == 0x000018, "Wrong size on FVector_NetQuantizeNormal");

// ScriptStruct Engine.ActorInstanceHandle
// 0x0018 (0x0018 - 0x0000)
struct FActorInstanceHandle final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FActorInstanceHandle) == 0x000004, "Wrong alignment on FActorInstanceHandle");
//(sizeof(FActorInstanceHandle) == 0x000018, "Wrong size on FActorInstanceHandle");
//(offsetof(FActorInstanceHandle, Actor) == 0x000000, "Member 'FActorInstanceHandle::Actor' has a wrong offset!");

// ScriptStruct Engine.HitResult
// 0x0160 (0x0160 - 0x0000)
struct FHitResult final
{
public:
	int32                                         FaceIndex;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    Location;                                          // 0x0010(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactPoint;                                       // 0x0028(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Normal;                                            // 0x0040(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ImpactNormal;                                      // 0x0058(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    TraceStart;                                        // 0x0070(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    TraceEnd;                                          // 0x0088(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    OccDetPoint;                                       // 0x00A0(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    RelativeImpactPointLocation;                       // 0x00B8(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationDepth;                                  // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MyItem;                                            // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item;                                              // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ElementIndex;                                      // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bBlockingHit : 1;                                  // 0x00DD(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsTouchEnter : 1;                                 // 0x00DD(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartPenetrating : 1;                             // 0x00DD(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPhysicalMaterial>       PhysMaterial;                                      // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActorInstanceHandle                   HitObjectHandle;                                   // 0x00E8(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0108(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MyBoneName;                                        // 0x0114(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitTraceStart;                                    // 0x0120(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitTraceEnd;                                      // 0x0138(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThroughPortals;                                    // 0x0150(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FHitResult) == 0x000008, "Wrong alignment on FHitResult");
//(sizeof(FHitResult) == 0x000160, "Wrong size on FHitResult");
//(offsetof(FHitResult, FaceIndex) == 0x000000, "Member 'FHitResult::FaceIndex' has a wrong offset!");
//(offsetof(FHitResult, Time) == 0x000004, "Member 'FHitResult::Time' has a wrong offset!");
//(offsetof(FHitResult, Distance) == 0x000008, "Member 'FHitResult::Distance' has a wrong offset!");
//(offsetof(FHitResult, Location) == 0x000010, "Member 'FHitResult::Location' has a wrong offset!");
//(offsetof(FHitResult, ImpactPoint) == 0x000028, "Member 'FHitResult::ImpactPoint' has a wrong offset!");
//(offsetof(FHitResult, Normal) == 0x000040, "Member 'FHitResult::Normal' has a wrong offset!");
//(offsetof(FHitResult, ImpactNormal) == 0x000058, "Member 'FHitResult::ImpactNormal' has a wrong offset!");
//(offsetof(FHitResult, TraceStart) == 0x000070, "Member 'FHitResult::TraceStart' has a wrong offset!");
//(offsetof(FHitResult, TraceEnd) == 0x000088, "Member 'FHitResult::TraceEnd' has a wrong offset!");
//(offsetof(FHitResult, OccDetPoint) == 0x0000A0, "Member 'FHitResult::OccDetPoint' has a wrong offset!");
//(offsetof(FHitResult, RelativeImpactPointLocation) == 0x0000B8, "Member 'FHitResult::RelativeImpactPointLocation' has a wrong offset!");
//(offsetof(FHitResult, PenetrationDepth) == 0x0000D0, "Member 'FHitResult::PenetrationDepth' has a wrong offset!");
//(offsetof(FHitResult, MyItem) == 0x0000D4, "Member 'FHitResult::MyItem' has a wrong offset!");
//(offsetof(FHitResult, Item) == 0x0000D8, "Member 'FHitResult::Item' has a wrong offset!");
//(offsetof(FHitResult, ElementIndex) == 0x0000DC, "Member 'FHitResult::ElementIndex' has a wrong offset!");
//(offsetof(FHitResult, PhysMaterial) == 0x0000E0, "Member 'FHitResult::PhysMaterial' has a wrong offset!");
//(offsetof(FHitResult, HitObjectHandle) == 0x0000E8, "Member 'FHitResult::HitObjectHandle' has a wrong offset!");
//(offsetof(FHitResult, Component) == 0x000100, "Member 'FHitResult::Component' has a wrong offset!");
//(offsetof(FHitResult, BoneName) == 0x000108, "Member 'FHitResult::BoneName' has a wrong offset!");
//(offsetof(FHitResult, MyBoneName) == 0x000114, "Member 'FHitResult::MyBoneName' has a wrong offset!");
//(offsetof(FHitResult, InitTraceStart) == 0x000120, "Member 'FHitResult::InitTraceStart' has a wrong offset!");
//(offsetof(FHitResult, InitTraceEnd) == 0x000138, "Member 'FHitResult::InitTraceEnd' has a wrong offset!");
//(offsetof(FHitResult, ThroughPortals) == 0x000150, "Member 'FHitResult::ThroughPortals' has a wrong offset!");

// ScriptStruct Engine.LaunchOnTestSettings
// 0x0020 (0x0020 - 0x0000)
struct FLaunchOnTestSettings final
{
public:
	struct FFilePath                              LaunchOnTestmap;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeviceID;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FLaunchOnTestSettings) == 0x000008, "Wrong alignment on FLaunchOnTestSettings");
//(sizeof(FLaunchOnTestSettings) == 0x000020, "Wrong size on FLaunchOnTestSettings");
//(offsetof(FLaunchOnTestSettings, LaunchOnTestmap) == 0x000000, "Member 'FLaunchOnTestSettings::LaunchOnTestmap' has a wrong offset!");
//(offsetof(FLaunchOnTestSettings, DeviceID) == 0x000010, "Member 'FLaunchOnTestSettings::DeviceID' has a wrong offset!");

// ScriptStruct Engine.Vector_NetQuantize100
// 0x0000 (0x0018 - 0x0018)
struct FVector_NetQuantize100 final : public FVector
{
};
//(alignof(FVector_NetQuantize100) == 0x000008, "Wrong alignment on FVector_NetQuantize100");
//(sizeof(FVector_NetQuantize100) == 0x000018, "Wrong size on FVector_NetQuantize100");

// ScriptStruct Engine.RepAttachment
// 0x0068 (0x0068 - 0x0000)
struct FRepAttachment final
{
public:
	class AActor*                                 AttachParent;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 LocationOffset;                                    // 0x0008(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 RelativeScale3D;                                   // 0x0020(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttachComponent;                                   // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRepAttachment) == 0x000008, "Wrong alignment on FRepAttachment");
//(sizeof(FRepAttachment) == 0x000068, "Wrong size on FRepAttachment");
//(offsetof(FRepAttachment, AttachParent) == 0x000000, "Member 'FRepAttachment::AttachParent' has a wrong offset!");
//(offsetof(FRepAttachment, LocationOffset) == 0x000008, "Member 'FRepAttachment::LocationOffset' has a wrong offset!");
//(offsetof(FRepAttachment, RelativeScale3D) == 0x000020, "Member 'FRepAttachment::RelativeScale3D' has a wrong offset!");
//(offsetof(FRepAttachment, RotationOffset) == 0x000038, "Member 'FRepAttachment::RotationOffset' has a wrong offset!");
//(offsetof(FRepAttachment, AttachSocket) == 0x000050, "Member 'FRepAttachment::AttachSocket' has a wrong offset!");
//(offsetof(FRepAttachment, AttachComponent) == 0x000060, "Member 'FRepAttachment::AttachComponent' has a wrong offset!");

// ScriptStruct Engine.KShapeElem
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FKShapeElem
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RestOffset;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x4];                                       // 0x0018(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bContributeToMass : 1;                             // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	ECollisionEnabled                             CollisionEnabled;                                  // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E[0x12];                                      // 0x001E(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Group;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FKShapeElem) == 0x000008, "Wrong alignment on FKShapeElem");
//(sizeof(FKShapeElem) == 0x000038, "Wrong size on FKShapeElem");
//(offsetof(FKShapeElem, RestOffset) == 0x000008, "Member 'FKShapeElem::RestOffset' has a wrong offset!");
//(offsetof(FKShapeElem, Name) == 0x00000C, "Member 'FKShapeElem::Name' has a wrong offset!");
//(offsetof(FKShapeElem, CollisionEnabled) == 0x00001D, "Member 'FKShapeElem::CollisionEnabled' has a wrong offset!");
//(offsetof(FKShapeElem, Group) == 0x000030, "Member 'FKShapeElem::Group' has a wrong offset!");

// ScriptStruct Engine.KSphereElem
// 0x0020 (0x0058 - 0x0038)
struct FKSphereElem final : public FKShapeElem
{
public:
	struct FVector                                Center;                                            // 0x0038(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FKSphereElem) == 0x000008, "Wrong alignment on FKSphereElem");
//(sizeof(FKSphereElem) == 0x000058, "Wrong size on FKSphereElem");
//(offsetof(FKSphereElem, Center) == 0x000038, "Member 'FKSphereElem::Center' has a wrong offset!");
//(offsetof(FKSphereElem, Radius) == 0x000050, "Member 'FKSphereElem::Radius' has a wrong offset!");

// ScriptStruct Engine.KBoxElem
// 0x0040 (0x0078 - 0x0038)
struct FKBoxElem final : public FKShapeElem
{
public:
	struct FVector                                Center;                                            // 0x0038(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FKBoxElem) == 0x000008, "Wrong alignment on FKBoxElem");
//(sizeof(FKBoxElem) == 0x000078, "Wrong size on FKBoxElem");
//(offsetof(FKBoxElem, Center) == 0x000038, "Member 'FKBoxElem::Center' has a wrong offset!");
//(offsetof(FKBoxElem, Rotation) == 0x000050, "Member 'FKBoxElem::Rotation' has a wrong offset!");
//(offsetof(FKBoxElem, X) == 0x000068, "Member 'FKBoxElem::X' has a wrong offset!");
//(offsetof(FKBoxElem, Y) == 0x00006C, "Member 'FKBoxElem::Y' has a wrong offset!");
//(offsetof(FKBoxElem, Z) == 0x000070, "Member 'FKBoxElem::Z' has a wrong offset!");

// ScriptStruct Engine.KSphylElem
// 0x0038 (0x0070 - 0x0038)
struct FKSphylElem final : public FKShapeElem
{
public:
	struct FVector                                Center;                                            // 0x0038(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FKSphylElem) == 0x000008, "Wrong alignment on FKSphylElem");
//(sizeof(FKSphylElem) == 0x000070, "Wrong size on FKSphylElem");
//(offsetof(FKSphylElem, Center) == 0x000038, "Member 'FKSphylElem::Center' has a wrong offset!");
//(offsetof(FKSphylElem, Rotation) == 0x000050, "Member 'FKSphylElem::Rotation' has a wrong offset!");
//(offsetof(FKSphylElem, Radius) == 0x000068, "Member 'FKSphylElem::Radius' has a wrong offset!");
//(offsetof(FKSphylElem, Length) == 0x00006C, "Member 'FKSphylElem::Length' has a wrong offset!");

// ScriptStruct Engine.KCylinderElem
// 0x0038 (0x0070 - 0x0038)
struct FKCylinderElem final : public FKShapeElem
{
public:
	struct FVector                                Center;                                            // 0x0038(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FKCylinderElem) == 0x000008, "Wrong alignment on FKCylinderElem");
//(sizeof(FKCylinderElem) == 0x000070, "Wrong size on FKCylinderElem");
//(offsetof(FKCylinderElem, Center) == 0x000038, "Member 'FKCylinderElem::Center' has a wrong offset!");
//(offsetof(FKCylinderElem, Rotation) == 0x000050, "Member 'FKCylinderElem::Rotation' has a wrong offset!");
//(offsetof(FKCylinderElem, Radius) == 0x000068, "Member 'FKCylinderElem::Radius' has a wrong offset!");
//(offsetof(FKCylinderElem, Height) == 0x00006C, "Member 'FKCylinderElem::Height' has a wrong offset!");

// ScriptStruct Engine.KConvexElem
// 0x00C8 (0x0100 - 0x0038)
struct FKConvexElem final : public FKShapeElem
{
public:
	TArray<struct FVector>                        VertexData;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 IndexData;                                         // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBox                                   ElemBox;                                           // 0x0058(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0090(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FKConvexElem) == 0x000010, "Wrong alignment on FKConvexElem");
//(sizeof(FKConvexElem) == 0x000100, "Wrong size on FKConvexElem");
//(offsetof(FKConvexElem, VertexData) == 0x000038, "Member 'FKConvexElem::VertexData' has a wrong offset!");
//(offsetof(FKConvexElem, IndexData) == 0x000048, "Member 'FKConvexElem::IndexData' has a wrong offset!");
//(offsetof(FKConvexElem, ElemBox) == 0x000058, "Member 'FKConvexElem::ElemBox' has a wrong offset!");
//(offsetof(FKConvexElem, Transform) == 0x000090, "Member 'FKConvexElem::Transform' has a wrong offset!");

// ScriptStruct Engine.KTaperedCapsuleElem
// 0x0040 (0x0078 - 0x0038)
struct FKTaperedCapsuleElem final : public FKShapeElem
{
public:
	struct FVector                                Center;                                            // 0x0038(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius0;                                           // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius1;                                           // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FKTaperedCapsuleElem) == 0x000008, "Wrong alignment on FKTaperedCapsuleElem");
//(sizeof(FKTaperedCapsuleElem) == 0x000078, "Wrong size on FKTaperedCapsuleElem");
//(offsetof(FKTaperedCapsuleElem, Center) == 0x000038, "Member 'FKTaperedCapsuleElem::Center' has a wrong offset!");
//(offsetof(FKTaperedCapsuleElem, Rotation) == 0x000050, "Member 'FKTaperedCapsuleElem::Rotation' has a wrong offset!");
//(offsetof(FKTaperedCapsuleElem, Radius0) == 0x000068, "Member 'FKTaperedCapsuleElem::Radius0' has a wrong offset!");
//(offsetof(FKTaperedCapsuleElem, Radius1) == 0x00006C, "Member 'FKTaperedCapsuleElem::Radius1' has a wrong offset!");
//(offsetof(FKTaperedCapsuleElem, Length) == 0x000070, "Member 'FKTaperedCapsuleElem::Length' has a wrong offset!");

// ScriptStruct Engine.KLevelSetElem
// 0x0078 (0x00B0 - 0x0038)
struct FKLevelSetElem final : public FKShapeElem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FKLevelSetElem) == 0x000010, "Wrong alignment on FKLevelSetElem");
//(sizeof(FKLevelSetElem) == 0x0000B0, "Wrong size on FKLevelSetElem");
//(offsetof(FKLevelSetElem, Transform) == 0x000040, "Member 'FKLevelSetElem::Transform' has a wrong offset!");

// ScriptStruct Engine.KSkinnedLevelSetElem
// 0x0010 (0x0048 - 0x0038)
struct FKSkinnedLevelSetElem final : public FKShapeElem
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FKSkinnedLevelSetElem) == 0x000008, "Wrong alignment on FKSkinnedLevelSetElem");
//(sizeof(FKSkinnedLevelSetElem) == 0x000048, "Wrong size on FKSkinnedLevelSetElem");

// ScriptStruct Engine.KAggregateGeom
// 0x0088 (0x0088 - 0x0000)
struct FKAggregateGeom final
{
public:
	TArray<struct FKSphereElem>                   SphereElems;                                       // 0x0000(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKBoxElem>                      BoxElems;                                          // 0x0010(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKSphylElem>                    SphylElems;                                        // 0x0020(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKCylinderElem>                 CylinderElems;                                     // 0x0030(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKConvexElem>                   ConvexElems;                                       // 0x0040(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKTaperedCapsuleElem>           TaperedCapsuleElems;                               // 0x0050(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKLevelSetElem>                 LevelSetElems;                                     // 0x0060(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKSkinnedLevelSetElem>          SkinnedLevelSetElems;                              // 0x0070(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FKAggregateGeom) == 0x000008, "Wrong alignment on FKAggregateGeom");
//(sizeof(FKAggregateGeom) == 0x000088, "Wrong size on FKAggregateGeom");
//(offsetof(FKAggregateGeom, SphereElems) == 0x000000, "Member 'FKAggregateGeom::SphereElems' has a wrong offset!");
//(offsetof(FKAggregateGeom, BoxElems) == 0x000010, "Member 'FKAggregateGeom::BoxElems' has a wrong offset!");
//(offsetof(FKAggregateGeom, SphylElems) == 0x000020, "Member 'FKAggregateGeom::SphylElems' has a wrong offset!");
//(offsetof(FKAggregateGeom, CylinderElems) == 0x000030, "Member 'FKAggregateGeom::CylinderElems' has a wrong offset!");
//(offsetof(FKAggregateGeom, ConvexElems) == 0x000040, "Member 'FKAggregateGeom::ConvexElems' has a wrong offset!");
//(offsetof(FKAggregateGeom, TaperedCapsuleElems) == 0x000050, "Member 'FKAggregateGeom::TaperedCapsuleElems' has a wrong offset!");
//(offsetof(FKAggregateGeom, LevelSetElems) == 0x000060, "Member 'FKAggregateGeom::LevelSetElems' has a wrong offset!");
//(offsetof(FKAggregateGeom, SkinnedLevelSetElems) == 0x000070, "Member 'FKAggregateGeom::SkinnedLevelSetElems' has a wrong offset!");

// ScriptStruct Engine.AnimBlueprintFunction
// 0x0080 (0x0080 - 0x0000)
struct FAnimBlueprintFunction final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Group;                                             // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutputPoseNodeIndex;                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           InputPoseNames;                                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 InputPoseNodeIndices;                              // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x38];                                      // 0x0040(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bImplemented;                                      // 0x0078(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimBlueprintFunction) == 0x000008, "Wrong alignment on FAnimBlueprintFunction");
//(sizeof(FAnimBlueprintFunction) == 0x000080, "Wrong size on FAnimBlueprintFunction");
//(offsetof(FAnimBlueprintFunction, Name) == 0x000000, "Member 'FAnimBlueprintFunction::Name' has a wrong offset!");
//(offsetof(FAnimBlueprintFunction, Group) == 0x00000C, "Member 'FAnimBlueprintFunction::Group' has a wrong offset!");
//(offsetof(FAnimBlueprintFunction, OutputPoseNodeIndex) == 0x000018, "Member 'FAnimBlueprintFunction::OutputPoseNodeIndex' has a wrong offset!");
//(offsetof(FAnimBlueprintFunction, InputPoseNames) == 0x000020, "Member 'FAnimBlueprintFunction::InputPoseNames' has a wrong offset!");
//(offsetof(FAnimBlueprintFunction, InputPoseNodeIndices) == 0x000030, "Member 'FAnimBlueprintFunction::InputPoseNodeIndices' has a wrong offset!");
//(offsetof(FAnimBlueprintFunction, bImplemented) == 0x000078, "Member 'FAnimBlueprintFunction::bImplemented' has a wrong offset!");

// ScriptStruct Engine.ClusteredActorData
// 0x0058 (0x0058 - 0x0000)
struct FClusteredActorData final
{
public:
	TSet<TWeakObjectPtr<class UPrimitiveComponent>> Components;                                        // 0x0000(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bWasReplicatingMovement;                           // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FClusteredActorData) == 0x000008, "Wrong alignment on FClusteredActorData");
//(sizeof(FClusteredActorData) == 0x000058, "Wrong size on FClusteredActorData");
//(offsetof(FClusteredActorData, Components) == 0x000000, "Member 'FClusteredActorData::Components' has a wrong offset!");
//(offsetof(FClusteredActorData, bWasReplicatingMovement) == 0x000050, "Member 'FClusteredActorData::bWasReplicatingMovement' has a wrong offset!");

// ScriptStruct Engine.InstancedStaticMeshMappingInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FInstancedStaticMeshMappingInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FInstancedStaticMeshMappingInfo) == 0x000008, "Wrong alignment on FInstancedStaticMeshMappingInfo");
//(sizeof(FInstancedStaticMeshMappingInfo) == 0x000008, "Wrong size on FInstancedStaticMeshMappingInfo");

// ScriptStruct Engine.LightingChannels
// 0x0001 (0x0001 - 0x0000)
struct FLightingChannels final
{
public:
	uint8                                         bChannel0 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bChannel1 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bChannel2 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
//(alignof(FLightingChannels) == 0x000001, "Wrong alignment on FLightingChannels");
//(sizeof(FLightingChannels) == 0x000001, "Wrong size on FLightingChannels");

// ScriptStruct Engine.BuildPromotionNewProjectSettings
// 0x0020 (0x0020 - 0x0000)
struct FBuildPromotionNewProjectSettings final
{
public:
	struct FDirectoryPath                         NewProjectFolderOverride;                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewProjectNameOverride;                            // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBuildPromotionNewProjectSettings) == 0x000008, "Wrong alignment on FBuildPromotionNewProjectSettings");
//(sizeof(FBuildPromotionNewProjectSettings) == 0x000020, "Wrong size on FBuildPromotionNewProjectSettings");
//(offsetof(FBuildPromotionNewProjectSettings, NewProjectFolderOverride) == 0x000000, "Member 'FBuildPromotionNewProjectSettings::NewProjectFolderOverride' has a wrong offset!");
//(offsetof(FBuildPromotionNewProjectSettings, NewProjectNameOverride) == 0x000010, "Member 'FBuildPromotionNewProjectSettings::NewProjectNameOverride' has a wrong offset!");

// ScriptStruct Engine.CurveEdEntry
// 0x0038 (0x0038 - 0x0000)
struct FCurveEdEntry final
{
public:
	class UObject*                                CurveObject;                                       // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 CurveColor;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurveName;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bHideCurve;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bColorCurve;                                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bFloatingPointColorCurve;                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bClamp;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampLow;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampHigh;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCurveEdEntry) == 0x000008, "Wrong alignment on FCurveEdEntry");
//(sizeof(FCurveEdEntry) == 0x000038, "Wrong size on FCurveEdEntry");
//(offsetof(FCurveEdEntry, CurveObject) == 0x000000, "Member 'FCurveEdEntry::CurveObject' has a wrong offset!");
//(offsetof(FCurveEdEntry, CurveColor) == 0x000008, "Member 'FCurveEdEntry::CurveColor' has a wrong offset!");
//(offsetof(FCurveEdEntry, CurveName) == 0x000010, "Member 'FCurveEdEntry::CurveName' has a wrong offset!");
//(offsetof(FCurveEdEntry, bHideCurve) == 0x000020, "Member 'FCurveEdEntry::bHideCurve' has a wrong offset!");
//(offsetof(FCurveEdEntry, bColorCurve) == 0x000024, "Member 'FCurveEdEntry::bColorCurve' has a wrong offset!");
//(offsetof(FCurveEdEntry, bFloatingPointColorCurve) == 0x000028, "Member 'FCurveEdEntry::bFloatingPointColorCurve' has a wrong offset!");
//(offsetof(FCurveEdEntry, bClamp) == 0x00002C, "Member 'FCurveEdEntry::bClamp' has a wrong offset!");
//(offsetof(FCurveEdEntry, ClampLow) == 0x000030, "Member 'FCurveEdEntry::ClampLow' has a wrong offset!");
//(offsetof(FCurveEdEntry, ClampHigh) == 0x000034, "Member 'FCurveEdEntry::ClampHigh' has a wrong offset!");

// ScriptStruct Engine.CustomPrimitiveData
// 0x0010 (0x0010 - 0x0000)
struct FCustomPrimitiveData final
{
public:
	TArray<float>                                 Data;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FCustomPrimitiveData) == 0x000008, "Wrong alignment on FCustomPrimitiveData");
//(sizeof(FCustomPrimitiveData) == 0x000010, "Wrong size on FCustomPrimitiveData");
//(offsetof(FCustomPrimitiveData, Data) == 0x000000, "Member 'FCustomPrimitiveData::Data' has a wrong offset!");

// ScriptStruct Engine.InstancedStaticMeshRandomSeed
// 0x0008 (0x0008 - 0x0000)
struct FInstancedStaticMeshRandomSeed final
{
public:
	int32                                         StartInstanceIndex;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomSeed;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FInstancedStaticMeshRandomSeed) == 0x000004, "Wrong alignment on FInstancedStaticMeshRandomSeed");
//(sizeof(FInstancedStaticMeshRandomSeed) == 0x000008, "Wrong size on FInstancedStaticMeshRandomSeed");
//(offsetof(FInstancedStaticMeshRandomSeed, StartInstanceIndex) == 0x000000, "Member 'FInstancedStaticMeshRandomSeed::StartInstanceIndex' has a wrong offset!");
//(offsetof(FInstancedStaticMeshRandomSeed, RandomSeed) == 0x000004, "Member 'FInstancedStaticMeshRandomSeed::RandomSeed' has a wrong offset!");

// ScriptStruct Engine.ComponentReference
// 0x0008 (0x0030 - 0x0028)
struct FComponentReference final : public FBaseComponentReference
{
public:
	TWeakObjectPtr<class AActor>                  OtherActor;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FComponentReference) == 0x000008, "Wrong alignment on FComponentReference");
//(sizeof(FComponentReference) == 0x000030, "Wrong size on FComponentReference");
//(offsetof(FComponentReference, OtherActor) == 0x000028, "Member 'FComponentReference::OtherActor' has a wrong offset!");

// ScriptStruct Engine.CachedAnimStateData
// 0x0024 (0x0024 - 0x0000)
struct FCachedAnimStateData final
{
public:
	class FName                                   StateMachineName;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateName;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0xC];                                       // 0x0018(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCachedAnimStateData) == 0x000004, "Wrong alignment on FCachedAnimStateData");
//(sizeof(FCachedAnimStateData) == 0x000024, "Wrong size on FCachedAnimStateData");
//(offsetof(FCachedAnimStateData, StateMachineName) == 0x000000, "Member 'FCachedAnimStateData::StateMachineName' has a wrong offset!");
//(offsetof(FCachedAnimStateData, StateName) == 0x00000C, "Member 'FCachedAnimStateData::StateName' has a wrong offset!");

// ScriptStruct Engine.CurveTableRowHandle
// 0x0018 (0x0018 - 0x0000)
struct FCurveTableRowHandle final
{
public:
	class UCurveTable*                            CurveTable;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCurveTableRowHandle) == 0x000008, "Wrong alignment on FCurveTableRowHandle");
//(sizeof(FCurveTableRowHandle) == 0x000018, "Wrong size on FCurveTableRowHandle");
//(offsetof(FCurveTableRowHandle, CurveTable) == 0x000000, "Member 'FCurveTableRowHandle::CurveTable' has a wrong offset!");
//(offsetof(FCurveTableRowHandle, RowName) == 0x000008, "Member 'FCurveTableRowHandle::RowName' has a wrong offset!");

// ScriptStruct Engine.SubtitleCue
// 0x0020 (0x0020 - 0x0000)
struct FSubtitleCue final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSubtitleCue) == 0x000008, "Wrong alignment on FSubtitleCue");
//(sizeof(FSubtitleCue) == 0x000020, "Wrong size on FSubtitleCue");
//(offsetof(FSubtitleCue, Text) == 0x000000, "Member 'FSubtitleCue::Text' has a wrong offset!");
//(offsetof(FSubtitleCue, Time) == 0x000018, "Member 'FSubtitleCue::Time' has a wrong offset!");

// ScriptStruct Engine.PhysicsPredictionSettings
// 0x000C (0x000C - 0x0000)
struct FPhysicsPredictionSettings final
{
public:
	bool                                          bEnablePhysicsPrediction;                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePhysicsResimulation;                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResimulationErrorThreshold;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSupportedLatencyPrediction;                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPhysicsPredictionSettings) == 0x000004, "Wrong alignment on FPhysicsPredictionSettings");
//(sizeof(FPhysicsPredictionSettings) == 0x00000C, "Wrong size on FPhysicsPredictionSettings");
//(offsetof(FPhysicsPredictionSettings, bEnablePhysicsPrediction) == 0x000000, "Member 'FPhysicsPredictionSettings::bEnablePhysicsPrediction' has a wrong offset!");
//(offsetof(FPhysicsPredictionSettings, bEnablePhysicsResimulation) == 0x000001, "Member 'FPhysicsPredictionSettings::bEnablePhysicsResimulation' has a wrong offset!");
//(offsetof(FPhysicsPredictionSettings, ResimulationErrorThreshold) == 0x000004, "Member 'FPhysicsPredictionSettings::ResimulationErrorThreshold' has a wrong offset!");
//(offsetof(FPhysicsPredictionSettings, MaxSupportedLatencyPrediction) == 0x000008, "Member 'FPhysicsPredictionSettings::MaxSupportedLatencyPrediction' has a wrong offset!");

// ScriptStruct Engine.ResponseChannel
// 0x0010 (0x0010 - 0x0000)
struct FResponseChannel final
{
public:
	class FName                                   Channel;                                           // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Response;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FResponseChannel) == 0x000004, "Wrong alignment on FResponseChannel");
//(sizeof(FResponseChannel) == 0x000010, "Wrong size on FResponseChannel");
//(offsetof(FResponseChannel, Channel) == 0x000000, "Member 'FResponseChannel::Channel' has a wrong offset!");
//(offsetof(FResponseChannel, Response) == 0x00000C, "Member 'FResponseChannel::Response' has a wrong offset!");

// ScriptStruct Engine.CustomProfile
// 0x0020 (0x0020 - 0x0000)
struct FCustomProfile final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FResponseChannel>               CustomResponses;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FCustomProfile) == 0x000008, "Wrong alignment on FCustomProfile");
//(sizeof(FCustomProfile) == 0x000020, "Wrong size on FCustomProfile");
//(offsetof(FCustomProfile, Name) == 0x000000, "Member 'FCustomProfile::Name' has a wrong offset!");
//(offsetof(FCustomProfile, CustomResponses) == 0x000010, "Member 'FCustomProfile::CustomResponses' has a wrong offset!");

// ScriptStruct Engine.ActorComponentTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FActorComponentTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FActorComponentTickFunction) == 0x000008, "Wrong alignment on FActorComponentTickFunction");
//(sizeof(FActorComponentTickFunction) == 0x000038, "Wrong size on FActorComponentTickFunction");

// ScriptStruct Engine.GPUSpriteResourceData
// 0x0240 (0x0240 - 0x0000)
struct FGPUSpriteResourceData final
{
public:
	TArray<struct FColor>                         QuantizedColorSamples;                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         QuantizedMiscSamples;                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         QuantizedSimulationAttrSamples;                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector4                               ColorScale;                                        // 0x0030(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorBias;                                         // 0x0050(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               MiscScale;                                         // 0x0070(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               MiscBias;                                          // 0x0090(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               SimulationAttrCurveScale;                          // 0x00B0(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               SimulationAttrCurveBias;                           // 0x00D0(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               SubImageSize;                                      // 0x00F0(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               SizeBySpeed;                                       // 0x0110(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConstantAcceleration;                              // 0x0130(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OrbitOffsetBase;                                   // 0x0148(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OrbitOffsetRange;                                  // 0x0160(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OrbitFrequencyBase;                                // 0x0178(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OrbitFrequencyRange;                               // 0x0190(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OrbitPhaseBase;                                    // 0x01A8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OrbitPhaseRange;                                   // 0x01C0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalVectorFieldScale;                            // 0x01D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalVectorFieldTightness;                        // 0x01DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerParticleVectorFieldScale;                       // 0x01E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerParticleVectorFieldBias;                        // 0x01E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragCoefficientScale;                              // 0x01E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragCoefficientBias;                               // 0x01EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResilienceScale;                                   // 0x01F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResilienceBias;                                    // 0x01F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadiusScale;                              // 0x01F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadiusBias;                               // 0x01FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionTimeBias;                                 // 0x0200(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRandomSpread;                             // 0x0204(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRandomDistribution;                       // 0x0208(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OneMinusFriction;                                  // 0x020C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRateScale;                                 // 0x0210(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMotionBlurAmount;                            // 0x0214(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleScreenAlignment                      ScreenAlignment;                                   // 0x0218(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleAxisLock                             LockAxisFlag;                                      // 0x0219(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A[0x6];                                      // 0x021A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PivotOffset;                                       // 0x0220(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseVelocityForMotionBlur : 1;                     // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRemoveHMDRoll : 1;                                // 0x0230(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinFacingCameraBlendDistance;                      // 0x0234(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFacingCameraBlendDistance;                      // 0x0238(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FGPUSpriteResourceData) == 0x000010, "Wrong alignment on FGPUSpriteResourceData");
//(sizeof(FGPUSpriteResourceData) == 0x000240, "Wrong size on FGPUSpriteResourceData");
//(offsetof(FGPUSpriteResourceData, QuantizedColorSamples) == 0x000000, "Member 'FGPUSpriteResourceData::QuantizedColorSamples' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, QuantizedMiscSamples) == 0x000010, "Member 'FGPUSpriteResourceData::QuantizedMiscSamples' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, QuantizedSimulationAttrSamples) == 0x000020, "Member 'FGPUSpriteResourceData::QuantizedSimulationAttrSamples' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, ColorScale) == 0x000030, "Member 'FGPUSpriteResourceData::ColorScale' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, ColorBias) == 0x000050, "Member 'FGPUSpriteResourceData::ColorBias' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, MiscScale) == 0x000070, "Member 'FGPUSpriteResourceData::MiscScale' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, MiscBias) == 0x000090, "Member 'FGPUSpriteResourceData::MiscBias' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, SimulationAttrCurveScale) == 0x0000B0, "Member 'FGPUSpriteResourceData::SimulationAttrCurveScale' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, SimulationAttrCurveBias) == 0x0000D0, "Member 'FGPUSpriteResourceData::SimulationAttrCurveBias' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, SubImageSize) == 0x0000F0, "Member 'FGPUSpriteResourceData::SubImageSize' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, SizeBySpeed) == 0x000110, "Member 'FGPUSpriteResourceData::SizeBySpeed' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, ConstantAcceleration) == 0x000130, "Member 'FGPUSpriteResourceData::ConstantAcceleration' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, OrbitOffsetBase) == 0x000148, "Member 'FGPUSpriteResourceData::OrbitOffsetBase' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, OrbitOffsetRange) == 0x000160, "Member 'FGPUSpriteResourceData::OrbitOffsetRange' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, OrbitFrequencyBase) == 0x000178, "Member 'FGPUSpriteResourceData::OrbitFrequencyBase' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, OrbitFrequencyRange) == 0x000190, "Member 'FGPUSpriteResourceData::OrbitFrequencyRange' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, OrbitPhaseBase) == 0x0001A8, "Member 'FGPUSpriteResourceData::OrbitPhaseBase' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, OrbitPhaseRange) == 0x0001C0, "Member 'FGPUSpriteResourceData::OrbitPhaseRange' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, GlobalVectorFieldScale) == 0x0001D8, "Member 'FGPUSpriteResourceData::GlobalVectorFieldScale' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, GlobalVectorFieldTightness) == 0x0001DC, "Member 'FGPUSpriteResourceData::GlobalVectorFieldTightness' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, PerParticleVectorFieldScale) == 0x0001E0, "Member 'FGPUSpriteResourceData::PerParticleVectorFieldScale' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, PerParticleVectorFieldBias) == 0x0001E4, "Member 'FGPUSpriteResourceData::PerParticleVectorFieldBias' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, DragCoefficientScale) == 0x0001E8, "Member 'FGPUSpriteResourceData::DragCoefficientScale' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, DragCoefficientBias) == 0x0001EC, "Member 'FGPUSpriteResourceData::DragCoefficientBias' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, ResilienceScale) == 0x0001F0, "Member 'FGPUSpriteResourceData::ResilienceScale' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, ResilienceBias) == 0x0001F4, "Member 'FGPUSpriteResourceData::ResilienceBias' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, CollisionRadiusScale) == 0x0001F8, "Member 'FGPUSpriteResourceData::CollisionRadiusScale' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, CollisionRadiusBias) == 0x0001FC, "Member 'FGPUSpriteResourceData::CollisionRadiusBias' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, CollisionTimeBias) == 0x000200, "Member 'FGPUSpriteResourceData::CollisionTimeBias' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, CollisionRandomSpread) == 0x000204, "Member 'FGPUSpriteResourceData::CollisionRandomSpread' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, CollisionRandomDistribution) == 0x000208, "Member 'FGPUSpriteResourceData::CollisionRandomDistribution' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, OneMinusFriction) == 0x00020C, "Member 'FGPUSpriteResourceData::OneMinusFriction' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, RotationRateScale) == 0x000210, "Member 'FGPUSpriteResourceData::RotationRateScale' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, CameraMotionBlurAmount) == 0x000214, "Member 'FGPUSpriteResourceData::CameraMotionBlurAmount' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, ScreenAlignment) == 0x000218, "Member 'FGPUSpriteResourceData::ScreenAlignment' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, LockAxisFlag) == 0x000219, "Member 'FGPUSpriteResourceData::LockAxisFlag' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, PivotOffset) == 0x000220, "Member 'FGPUSpriteResourceData::PivotOffset' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, MinFacingCameraBlendDistance) == 0x000234, "Member 'FGPUSpriteResourceData::MinFacingCameraBlendDistance' has a wrong offset!");
//(offsetof(FGPUSpriteResourceData, MaxFacingCameraBlendDistance) == 0x000238, "Member 'FGPUSpriteResourceData::MaxFacingCameraBlendDistance' has a wrong offset!");

// ScriptStruct Engine.WeightedBlendable
// 0x0010 (0x0010 - 0x0000)
struct FWeightedBlendable final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Object;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FWeightedBlendable) == 0x000008, "Wrong alignment on FWeightedBlendable");
//(sizeof(FWeightedBlendable) == 0x000010, "Wrong size on FWeightedBlendable");
//(offsetof(FWeightedBlendable, Weight) == 0x000000, "Member 'FWeightedBlendable::Weight' has a wrong offset!");
//(offsetof(FWeightedBlendable, Object) == 0x000008, "Member 'FWeightedBlendable::Object' has a wrong offset!");

// ScriptStruct Engine.WeightedBlendables
// 0x0010 (0x0010 - 0x0000)
struct FWeightedBlendables final
{
public:
	TArray<struct FWeightedBlendable>             Array;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FWeightedBlendables) == 0x000008, "Wrong alignment on FWeightedBlendables");
//(sizeof(FWeightedBlendables) == 0x000010, "Wrong size on FWeightedBlendables");
//(offsetof(FWeightedBlendables, Array) == 0x000000, "Member 'FWeightedBlendables::Array' has a wrong offset!");

// ScriptStruct Engine.PostProcessSettings
// 0x0970 (0x0970 - 0x0000)
struct FPostProcessSettings final
{
public:
	uint8                                         bOverride_TemperatureType : 1;                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_WhiteTemp : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_WhiteTint : 1;                           // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorSaturation : 1;                     // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorContrast : 1;                       // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGamma : 1;                          // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGain : 1;                           // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorOffset : 1;                         // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorSaturationShadows : 1;              // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorContrastShadows : 1;                // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGammaShadows : 1;                   // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGainShadows : 1;                    // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorOffsetShadows : 1;                  // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorSaturationMidtones : 1;             // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorContrastMidtones : 1;               // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGammaMidtones : 1;                  // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGainMidtones : 1;                   // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorOffsetMidtones : 1;                 // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorSaturationHighlights : 1;           // 0x0002(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorContrastHighlights : 1;             // 0x0002(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGammaHighlights : 1;                // 0x0002(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGainHighlights : 1;                 // 0x0002(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorOffsetHighlights : 1;               // 0x0002(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorCorrectionShadowsMax : 1;           // 0x0002(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorCorrectionHighlightsMin : 1;        // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorCorrectionHighlightsMax : 1;        // 0x0003(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BlueCorrection : 1;                      // 0x0003(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ExpandGamut : 1;                         // 0x0003(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ToneCurveAmount : 1;                     // 0x0003(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmInverseable : 1;                     // 0x0003(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmSlope : 1;                           // 0x0003(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmToe : 1;                             // 0x0003(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmShoulder : 1;                        // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmBlackClip : 1;                       // 0x0004(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmWhiteClip : 1;                       // 0x0004(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SceneColorTint : 1;                      // 0x0004(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SceneFringeIntensity : 1;                // 0x0004(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ChromaticAberrationStartOffset : 1;      // 0x0004(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientCubemapTint : 1;                  // 0x0004(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientCubemapIntensity : 1;             // 0x0004(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OverrideAmbientCubemapSampleLevel : 1;   // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomMethod : 1;                         // 0x0005(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomIntensity : 1;                      // 0x0005(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomThreshold : 1;                      // 0x0005(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom1Tint : 1;                          // 0x0005(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom1Size : 1;                          // 0x0005(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom2Size : 1;                          // 0x0005(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom2Tint : 1;                          // 0x0005(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom3Tint : 1;                          // 0x0006(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom3Size : 1;                          // 0x0006(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom4Tint : 1;                          // 0x0006(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom4Size : 1;                          // 0x0006(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom5Tint : 1;                          // 0x0006(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom5Size : 1;                          // 0x0006(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom6Tint : 1;                          // 0x0006(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom6Size : 1;                          // 0x0006(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom1Tint : 1;                // 0x0007(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom1Size : 1;                // 0x0007(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom2Size : 1;                // 0x0007(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom2Tint : 1;                // 0x0007(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom3Tint : 1;                // 0x0007(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom3Size : 1;                // 0x0007(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom4Tint : 1;                // 0x0007(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom4Size : 1;                // 0x0007(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom5Tint : 1;                // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom5Size : 1;                // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom6Tint : 1;                // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AdditionalBloom6Size : 1;                // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomSizeScale : 1;                      // 0x0008(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomConvolutionTexture : 1;             // 0x0008(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomConvolutionScatterDispersion : 1;   // 0x0008(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomConvolutionSize : 1;                // 0x0008(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomConvolutionCenterUV : 1;            // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomConvolutionPreFilter : 1;           // 0x0009(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomConvolutionPreFilterMin : 1;        // 0x0009(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomConvolutionPreFilterMax : 1;        // 0x0009(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomConvolutionPreFilterMult : 1;       // 0x0009(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomConvolutionBufferScale : 1;         // 0x0009(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomDirtMaskIntensity : 1;              // 0x0009(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomDirtMaskTint : 1;                   // 0x0009(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomDirtMask : 1;                       // 0x000A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_CameraShutterSpeed : 1;                  // 0x000A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_CameraISO : 1;                           // 0x000A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureMethod : 1;                  // 0x000A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureLowPercent : 1;              // 0x000A(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureHighPercent : 1;             // 0x000A(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureMinBrightness : 1;           // 0x000A(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureMaxBrightness : 1;           // 0x000A(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureCharacterBrightnessEnable : 1; // 0x000B(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureCharacterMinBrightness : 1;  // 0x000B(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureCharacterMaxBrightness : 1;  // 0x000B(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureCalibrationConstant : 1;     // 0x000B(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureSpeedUp : 1;                 // 0x000B(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureSpeedDown : 1;               // 0x000B(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureBias : 1;                    // 0x000B(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureBiasCurve : 1;               // 0x000B(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureMarvelStyleAmbient : 1;      // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureMarvelStyleEmissive : 1;     // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureAllPixelEmissive : 1;        // 0x000C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureMarvelStyleAmbientCurve : 1; // 0x000C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureEmissiveCurve : 1;           // 0x000C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_CharacterLocalExposureHighlight : 1;     // 0x000C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_CharacterLocalExposureShadow : 1;        // 0x000C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_CharacterLocalExposureLevel : 1;         // 0x000C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureMeterMask : 1;               // 0x000D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureApplyPhysicalCameraExposure : 1; // 0x000D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HistogramLogMin : 1;                     // 0x000D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HistogramLogMax : 1;                     // 0x000D(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LocalExposureContrastScale : 1;          // 0x000D(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LocalExposureHighlightContrastScale : 1; // 0x000D(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LocalExposureShadowContrastScale : 1;    // 0x000D(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LocalExposureDetailStrength : 1;         // 0x000D(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LocalExposureBlurredLuminanceBlend : 1;  // 0x000E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LocalExposureBlurredLuminanceKernelSizePercent : 1; // 0x000E(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LocalExposureMiddleGreyBias : 1;         // 0x000E(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareIntensity : 1;                  // 0x000E(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareTint : 1;                       // 0x000E(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareTints : 1;                      // 0x000E(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareBokehSize : 1;                  // 0x000E(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareBokehShape : 1;                 // 0x000E(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareThreshold : 1;                  // 0x000F(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_VignetteIntensity : 1;                   // 0x000F(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Sharpen : 1;                             // 0x000F(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GrainIntensity : 1;                      // 0x000F(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GrainJitter : 1;                         // 0x000F(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmGrainIntensity : 1;                  // 0x000F(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmGrainIntensityShadows : 1;           // 0x000F(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmGrainIntensityMidtones : 1;          // 0x000F(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmGrainIntensityHighlights : 1;        // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmGrainShadowsMax : 1;                 // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmGrainHighlightsMin : 1;              // 0x0010(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmGrainHighlightsMax : 1;              // 0x0010(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmGrainTexelSize : 1;                  // 0x0010(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmGrainTexture : 1;                    // 0x0010(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionType : 1;                // 0x0010(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionIntensity : 1;           // 0x0010(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionStaticFraction : 1;      // 0x0011(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionRadius : 1;              // 0x0011(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionFadeDistance : 1;        // 0x0011(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionFadeRadius : 1;          // 0x0011(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionDistance : 1;            // 0x0011(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionRadiusInWS : 1;          // 0x0011(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionPower : 1;               // 0x0011(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionBias : 1;                // 0x0011(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionQuality : 1;             // 0x0012(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionMipBlend : 1;            // 0x0012(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionMipScale : 1;            // 0x0012(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionMipThreshold : 1;        // 0x0012(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionTemporalBlendWeight : 1; // 0x0012(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_12_5 : 3;                                   // 0x0012(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverride_RayTracingAO : 1;                        // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingAOSamplesPerPixel : 1;         // 0x0014(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingAOIntensity : 1;               // 0x0014(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingAORadius : 1;                  // 0x0014(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_14_4 : 4;                                   // 0x0014(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverride_LPVIntensity : 1;                        // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVDirectionalOcclusionIntensity : 1;    // 0x0018(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVDirectionalOcclusionRadius : 1;       // 0x0018(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVDiffuseOcclusionExponent : 1;         // 0x0018(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVSpecularOcclusionExponent : 1;        // 0x0018(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVDiffuseOcclusionIntensity : 1;        // 0x0018(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVSpecularOcclusionIntensity : 1;       // 0x0018(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVSize : 1;                             // 0x0018(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVSecondaryOcclusionIntensity : 1;      // 0x0019(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVSecondaryBounceIntensity : 1;         // 0x0019(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVGeometryVolumeBias : 1;               // 0x0019(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVVplInjectionBias : 1;                 // 0x0019(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVEmissiveInjectionIntensity : 1;       // 0x0019(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVFadeRange : 1;                        // 0x0019(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVDirectionalOcclusionFadeRange : 1;    // 0x0019(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_IndirectLightingColor : 1;               // 0x0019(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_IndirectLightingIntensity : 1;           // 0x001A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGradingIntensity : 1;               // 0x001A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGradingLUT : 1;                     // 0x001A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldFocalDistance : 1;           // 0x001A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldFstop : 1;                   // 0x001A(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldMinFstop : 1;                // 0x001A(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldBladeCount : 1;              // 0x001A(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldSensorWidth : 1;             // 0x001A(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldSqueezeFactor : 1;           // 0x001B(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldDepthBlurRadius : 1;         // 0x001B(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldDepthBlurAmount : 1;         // 0x001B(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldFocalRegion : 1;             // 0x001B(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldNearTransitionRegion : 1;    // 0x001B(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldFarTransitionRegion : 1;     // 0x001B(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldScale : 1;                   // 0x001B(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldNearBlurSize : 1;            // 0x001B(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldFarBlurSize : 1;             // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MobileHQGaussian : 1;                    // 0x001C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldOcclusion : 1;               // 0x001C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldSkyFocusDistance : 1;        // 0x001C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldVignetteSize : 1;            // 0x001C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ChessboardTranslucency : 1;              // 0x001C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_EnableMVPExpandCharacterFillDepth : 1;   // 0x001C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MVPExpandCharacterFillDepthZTest : 1;    // 0x001C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MVPExpandCharacterFillDepthAnistro : 1;  // 0x001D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MVPEffectMaskTexture : 1;                // 0x001D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MVPExpandCharacterFillDepthSpeed : 1;    // 0x001D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_1D_3 : 5;                                   // 0x001D(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverride_CasSharpening : 1;                       // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CasSharpening;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnableCasSharpening : 1;                 // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         EnableCasSharpening : 1;                           // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenTintGIColor : 1;                    // 0x0028(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LumenTintGIColorMarvelStyle;                       // 0x002C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LumenTintGIColorMarvelStyleHair;                   // 0x003C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LumenTintGIColorMarvelStyleSubsurface;             // 0x004C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LumenTintGIColorTwoSideFoliage;                    // 0x005C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableChessboardTranslucency : 1;                  // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnableMVPExpandCharacterFillDepth;                 // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MVPExpandCharacterFillDepthZTest : 1;              // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MVPExpandCharacterFillDepthAnistro;                // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MVPExpandCharacterFillDepthTexture;                // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MVPExpandCharacterFillDepthSpeed;                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MotionBlurAmount : 1;                    // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MotionBlurMax : 1;                       // 0x008C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MotionBlurTargetFPS : 1;                 // 0x008C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MotionBlurPerObjectSize : 1;             // 0x008C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScreenPercentage : 1;                    // 0x008C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ReflectionMethod : 1;                    // 0x008C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenReflectionQuality : 1;              // 0x008C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScreenSpaceReflectionIntensity : 1;      // 0x008C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScreenSpaceReflectionQuality : 1;        // 0x008D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScreenSpaceReflectionMaxRoughness : 1;   // 0x008D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScreenSpaceReflectionRoughnessScale : 1; // 0x008D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_8D_3 : 5;                                   // 0x008D(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverride_ReflectionsType : 1;                     // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingReflectionsMaxRoughness : 1;   // 0x0090(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingReflectionsMaxBounces : 1;     // 0x0090(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingReflectionsSamplesPerPixel : 1; // 0x0090(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingReflectionsShadows : 1;        // 0x0090(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingReflectionsTranslucency : 1;   // 0x0090(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_TranslucencyType : 1;                    // 0x0090(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingTranslucencyMaxRoughness : 1;  // 0x0090(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingTranslucencyRefractionRays : 1; // 0x0091(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingTranslucencySamplesPerPixel : 1; // 0x0091(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingTranslucencyShadows : 1;       // 0x0091(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingTranslucencyRefraction : 1;    // 0x0091(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DynamicGlobalIlluminationMethod : 1;     // 0x0091(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenSceneLightingQuality : 1;           // 0x0091(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenSceneDetail : 1;                    // 0x0091(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenSceneViewDistance : 1;              // 0x0091(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenSceneLightingUpdateSpeed : 1;       // 0x0092(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenSceneNumberOfSkipFrames : 1;        // 0x0092(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenSceneNumberOfMeshCardThreshold : 1; // 0x0092(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenFinalGatherQuality : 1;             // 0x0092(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenFinalGatherLightingUpdateSpeed : 1; // 0x0092(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenFinalGatherBentNormalIgnoreFoliage : 1; // 0x0092(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenMaxTraceDistance : 1;               // 0x0092(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenDiffuseColorBoost : 1;              // 0x0092(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenSkylightLeaking : 1;                // 0x0093(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenFullSkylightLeakingDistance : 1;    // 0x0093(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_93_2 : 6;                                   // 0x0093(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bOverride_LumenRayLightingMode : 1;                // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenFrontLayerTranslucencyReflections : 1; // 0x0094(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_94_2 : 6;                                   // 0x0094(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverride_LumenMaxReflectionBounces : 1;           // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenReflectionDimThreshold : 1;         // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LumenReflectionDimScale : 1;             // 0x0098(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_98_3 : 5;                                   // 0x0098(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverride_LumenSurfaceCacheResolution : 1;         // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_9C_1 : 7;                                   // 0x009C(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverride_RayTracingGI : 1;                        // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingGIMaxBounces : 1;              // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayTracingGISamplesPerPixel : 1;         // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingMaxBounces : 1;               // 0x00A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingSamplesPerPixel : 1;          // 0x00A0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingMaxPathExposure : 1;          // 0x00A0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingEnableReferenceDOF : 1;       // 0x00A0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingEnableReferenceAtmosphere : 1; // 0x00A0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingEnableDenoiser : 1;           // 0x00A1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingIncludeEmissive : 1;          // 0x00A1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingIncludeIndirectEmissive : 1;  // 0x00A1(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingIncludeDiffuse : 1;           // 0x00A1(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingIncludeIndirectDiffuse : 1;   // 0x00A1(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingIncludeSpecular : 1;          // 0x00A1(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingIncludeIndirectSpecular : 1;  // 0x00A1(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingIncludeVolume : 1;            // 0x00A1(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PathTracingIncludeIndirectVolume : 1;    // 0x00A2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScalableShadow : 1;                      // 0x00A2(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_A2_2 : 6;                                   // 0x00A2(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_A3[0x1];                                       // 0x00A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverride_SkyLightColor : 1;                       // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SkyLightIntensityMultiplier : 1;         // 0x00A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DistanceFieldAOIntensity : 1;            // 0x00A4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MinDistanceFieldAO : 1;                  // 0x00A4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SSRMaxBlurRadius : 1;                    // 0x00A4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SkyLightTranslucencyMultiplier : 1;      // 0x00A4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ShadowRadiusThreshold : 1;               // 0x00A4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ToonOutlineColors : 1;                   // 0x00A4(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_TeamOutlineColors : 1;                   // 0x00A5(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_NiagaraOutlineColors : 1;                // 0x00A5(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_NiagaraOutlineRadius : 1;                // 0x00A5(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ToonOutlineColor0;                                 // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ToonOutlineColor1;                                 // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ToonOutlineColor2;                                 // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ToonOutlineColor3;                                 // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4f                              ToonOutlineParameter;                              // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RimlightShellExpansionScale;                       // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ScreenSpaceToonOutlineColor;                       // 0x0104(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0xC];                                      // 0x0114(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4f                              ScreenSpaceToonOutlineParameter;                   // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4f                              TeamOutlineColor0;                                 // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4f                              TeamOutlineColor1;                                 // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4f                              TeamOutlineColor2;                                 // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4f                              TeamOutlineColor3;                                 // 0x0160(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4f                              TeamOutlineColor4;                                 // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4f                              TeamOutlineColor5;                                 // 0x0180(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4f                              TeamOutlineColor6;                                 // 0x0190(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4f                              TeamOutlineColor7;                                 // 0x01A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4f                              TeamOutlineColor8;                                 // 0x01B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4f                              TeamOutlineParameter;                              // 0x01C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SceneCaptureAAMethod : 1;                // 0x01D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EAntiAliasingMethod                           SceneCaptureAAMethod;                              // 0x01D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMobileHQGaussian : 1;                             // 0x01D2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EBloomMethod                                  BloomMethod;                                       // 0x01D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoExposureMethod                           AutoExposureMethod;                                // 0x01D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETemperatureMethod                            TemperatureType;                                   // 0x01D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D6[0x2];                                      // 0x01D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WhiteTemp;                                         // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhiteTint;                                         // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorSaturation;                                   // 0x01E0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorContrast;                                     // 0x0200(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorGamma;                                        // 0x0220(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorGain;                                         // 0x0240(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorOffset;                                       // 0x0260(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorSaturationShadows;                            // 0x0280(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorContrastShadows;                              // 0x02A0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorGammaShadows;                                 // 0x02C0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorGainShadows;                                  // 0x02E0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorOffsetShadows;                                // 0x0300(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorSaturationMidtones;                           // 0x0320(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorContrastMidtones;                             // 0x0340(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorGammaMidtones;                                // 0x0360(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorGainMidtones;                                 // 0x0380(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorOffsetMidtones;                               // 0x03A0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorSaturationHighlights;                         // 0x03C0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorContrastHighlights;                           // 0x03E0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorGammaHighlights;                              // 0x0400(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorGainHighlights;                               // 0x0420(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               ColorOffsetHighlights;                             // 0x0440(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorCorrectionHighlightsMin;                      // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorCorrectionHighlightsMax;                      // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorCorrectionShadowsMax;                         // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlueCorrection;                                    // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpandGamut;                                       // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToneCurveAmount;                                   // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FilmInverseable : 1;                               // 0x0478(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_479[0x3];                                      // 0x0479(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FilmSlope;                                         // 0x047C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmToe;                                           // 0x0480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmShoulder;                                      // 0x0484(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmBlackClip;                                     // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmWhiteClip;                                     // 0x048C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SceneColorTint;                                    // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SceneFringeIntensity;                              // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChromaticAberrationStartOffset;                    // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomIntensity;                                    // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomThreshold;                                    // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomSizeScale;                                    // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom1Size;                                        // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom2Size;                                        // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom3Size;                                        // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom4Size;                                        // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom5Size;                                        // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom6Size;                                        // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom1Tint;                                        // 0x04CC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom2Tint;                                        // 0x04DC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom3Tint;                                        // 0x04EC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom4Tint;                                        // 0x04FC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom5Tint;                                        // 0x050C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom6Tint;                                        // 0x051C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalBloom1Size;                              // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalBloom2Size;                              // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalBloom3Size;                              // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalBloom4Size;                              // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalBloom5Size;                              // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalBloom6Size;                              // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AdditionalBloom1Tint;                              // 0x0544(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AdditionalBloom2Tint;                              // 0x0554(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AdditionalBloom3Tint;                              // 0x0564(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AdditionalBloom4Tint;                              // 0x0574(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AdditionalBloom5Tint;                              // 0x0584(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AdditionalBloom6Tint;                              // 0x0594(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomConvolutionScatterDispersion;                 // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomConvolutionSize;                              // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5AC[0x4];                                      // 0x05AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             BloomConvolutionTexture;                           // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BloomConvolutionCenterUV;                          // 0x05B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomConvolutionPreFilterMin;                      // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomConvolutionPreFilterMax;                      // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomConvolutionPreFilterMult;                     // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomConvolutionBufferScale;                       // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               BloomDirtMask;                                     // 0x05D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomDirtMaskIntensity;                            // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BloomDirtMaskTint;                                 // 0x05E4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicGlobalIlluminationMethod              DynamicGlobalIlluminationMethod;                   // 0x05F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           IndirectLightingColor;                             // 0x05F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndirectLightingIntensity;                         // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenSceneLightingQuality;                         // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenSceneDetail;                                  // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenSceneViewDistance;                            // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenSceneLightingUpdateSpeed;                     // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LumenSceneNumberOfSkipFrames;                      // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LumenSceneNumberOfMeshCardThreshold;               // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenFinalGatherQuality;                           // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenFinalGatherLightingUpdateSpeed;               // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LumenFinalGatherBentNormalIgnoreFoliage : 1;       // 0x062C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_62D[0x3];                                      // 0x062D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LumenMaxTraceDistance;                             // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenDiffuseColorBoost;                            // 0x0634(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenSkylightLeaking;                              // 0x0638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenFullSkylightLeakingDistance;                  // 0x063C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenSurfaceCacheResolution;                       // 0x0640(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERayTracingGlobalIlluminationType             RayTracingGIType;                                  // 0x0644(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_645[0x3];                                      // 0x0645(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RayTracingGIMaxBounces;                            // 0x0648(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RayTracingGISamplesPerPixel;                       // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ScalableShadow : 1;                                // 0x0650(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_651[0x3];                                      // 0x0651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SkyLightColor;                                     // 0x0654(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyLightIntensityMultiplier;                       // 0x0664(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyLightTranslucencyMultiplier;                    // 0x0668(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFieldAOIntensity;                          // 0x066C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceFieldAO;                                // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SSRMaxBlurRadius;                                  // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowRadiusThreshold;                             // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReflectionMethod                             ReflectionMethod;                                  // 0x067C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReflectionsType                              ReflectionsType;                                   // 0x067D(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67E[0x2];                                      // 0x067E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LumenReflectionQuality;                            // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELumenRayLightingModeOverride                 LumenRayLightingMode;                              // 0x0684(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LumenFrontLayerTranslucencyReflections : 1;        // 0x0685(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_686[0x2];                                      // 0x0686(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LumenMaxReflectionBounces;                         // 0x0688(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenReflectionDimThreshold;                       // 0x068C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LumenReflectionDimScale;                           // 0x0690(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSpaceReflectionIntensity;                    // 0x0694(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSpaceReflectionQuality;                      // 0x0698(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSpaceReflectionMaxRoughness;                 // 0x069C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayTracingReflectionsMaxRoughness;                 // 0x06A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RayTracingReflectionsMaxBounces;                   // 0x06A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RayTracingReflectionsSamplesPerPixel;              // 0x06A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReflectedAndRefractedRayTracedShadows        RayTracingReflectionsShadows;                      // 0x06AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RayTracingReflectionsTranslucency : 1;             // 0x06AD(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6AE[0x2];                                      // 0x06AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           AmbientCubemapTint;                                // 0x06B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientCubemapIntensity;                           // 0x06C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C4[0x4];                                      // 0x06C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureCube*                           AmbientCubemap;                                    // 0x06C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideAmbientCubemapSampleLevel;                 // 0x06D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShutterSpeed;                                // 0x06D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraISO;                                         // 0x06D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFstop;                                 // 0x06DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldMinFstop;                              // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DepthOfFieldBladeCount;                            // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureBias;                                  // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureBiasBackup;                            // 0x06EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AutoExposureBiasBackup : 1;              // 0x06F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_6F0_1 : 7;                                  // 0x06F0(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_6F1[0x3];                                      // 0x06F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         AutoExposureApplyPhysicalCameraExposure : 1;       // 0x06F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         AutoExposureMarvelStyleAmbient : 1;                // 0x06F4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         AutoExposureMarvelStyleEmissive : 1;               // 0x06F4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         AutoExposureAllPixelEmissive : 1;                  // 0x06F4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6F5[0x3];                                      // 0x06F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AutoExposureMarvelStyleAmbientCurve;               // 0x06F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Interp, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AutoExposureEmissiveCurve;                         // 0x0700(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Interp, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterLocalExposureHighlight;                   // 0x0708(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterLocalExposureShadow;                      // 0x070C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterLocalExposureLevel;                       // 0x0710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_714[0x4];                                      // 0x0714(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AutoExposureBiasCurve;                             // 0x0718(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               AutoExposureMeterMask;                             // 0x0720(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureLowPercent;                            // 0x0728(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureHighPercent;                           // 0x072C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureMinBrightness;                         // 0x0730(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureMaxBrightness;                         // 0x0734(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AutoExposureCharacterBrightnessEnable : 1;         // 0x0738(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_739[0x3];                                      // 0x0739(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoExposureCharacterMinBrightness;                // 0x073C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureCharacterMaxBrightness;                // 0x0740(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureSpeedUp;                               // 0x0744(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureSpeedDown;                             // 0x0748(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HistogramLogMin;                                   // 0x074C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HistogramLogMax;                                   // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureCalibrationConstant;                   // 0x0754(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalExposureContrastScale;                        // 0x0758(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalExposureHighlightContrastScale;               // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalExposureShadowContrastScale;                  // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalExposureDetailStrength;                       // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalExposureBlurredLuminanceBlend;                // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalExposureBlurredLuminanceKernelSizePercent;    // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalExposureMiddleGreyBias;                       // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensFlareIntensity;                                // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LensFlareTint;                                     // 0x0778(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensFlareBokehSize;                                // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensFlareThreshold;                                // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               LensFlareBokehShape;                               // 0x0790(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LensFlareTints[0x8];                               // 0x0798(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VignetteIntensity;                                 // 0x0818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sharpen;                                           // 0x081C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrainJitter;                                       // 0x0820(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrainIntensity;                                    // 0x0824(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmGrainIntensity;                                // 0x0828(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmGrainIntensityShadows;                         // 0x082C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmGrainIntensityMidtones;                        // 0x0830(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmGrainIntensityHighlights;                      // 0x0834(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmGrainShadowsMax;                               // 0x0838(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmGrainHighlightsMin;                            // 0x083C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmGrainHighlightsMax;                            // 0x0840(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmGrainTexelSize;                                // 0x0844(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FilmGrainTexture;                                  // 0x0848(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAmbientOcclusionType                         AmbientOcclusionType;                              // 0x0850(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_851[0x3];                                      // 0x0851(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmbientOcclusionIntensity;                         // 0x0854(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionStaticFraction;                    // 0x0858(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionRadius;                            // 0x085C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AmbientOcclusionRadiusInWS : 1;                    // 0x0860(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_861[0x3];                                      // 0x0861(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmbientOcclusionFadeDistance;                      // 0x0864(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionFadeRadius;                        // 0x0868(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionDistance;                          // 0x086C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionPower;                             // 0x0870(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionBias;                              // 0x0874(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionQuality;                           // 0x0878(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionMipBlend;                          // 0x087C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionMipScale;                          // 0x0880(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionMipThreshold;                      // 0x0884(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionTemporalBlendWeight;               // 0x0888(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RayTracingAO : 1;                                  // 0x088C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_88D[0x3];                                      // 0x088D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RayTracingAOSamplesPerPixel;                       // 0x0890(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayTracingAOIntensity;                             // 0x0894(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayTracingAORadius;                                // 0x0898(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorGradingIntensity;                             // 0x089C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               ColorGradingLUT;                                   // 0x08A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldSensorWidth;                           // 0x08A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldSqueezeFactor;                         // 0x08AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFocalDistance;                         // 0x08B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurAmount;                       // 0x08B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurRadius;                       // 0x08B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFocalRegion;                           // 0x08BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldNearTransitionRegion;                  // 0x08C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFarTransitionRegion;                   // 0x08C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldScale;                                 // 0x08C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldNearBlurSize;                          // 0x08CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFarBlurSize;                           // 0x08D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldOcclusion;                             // 0x08D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldSkyFocusDistance;                      // 0x08D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldVignetteSize;                          // 0x08DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionBlurAmount;                                  // 0x08E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionBlurMax;                                     // 0x08E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MotionBlurTargetFPS;                               // 0x08E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionBlurPerObjectSize;                           // 0x08EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVIntensity;                                      // 0x08F0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVVplInjectionBias;                               // 0x08F4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVSize;                                           // 0x08F8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVSecondaryOcclusionIntensity;                    // 0x08FC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVSecondaryBounceIntensity;                       // 0x0900(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVGeometryVolumeBias;                             // 0x0904(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVEmissiveInjectionIntensity;                     // 0x0908(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVDirectionalOcclusionIntensity;                  // 0x090C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVDirectionalOcclusionRadius;                     // 0x0910(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVDiffuseOcclusionExponent;                       // 0x0914(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVSpecularOcclusionExponent;                      // 0x0918(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVDiffuseOcclusionIntensity;                      // 0x091C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVSpecularOcclusionIntensity;                     // 0x0920(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETranslucencyType                             TranslucencyType;                                  // 0x0924(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_925[0x3];                                      // 0x0925(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RayTracingTranslucencyMaxRoughness;                // 0x0928(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RayTracingTranslucencyRefractionRays;              // 0x092C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RayTracingTranslucencySamplesPerPixel;             // 0x0930(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReflectedAndRefractedRayTracedShadows        RayTracingTranslucencyShadows;                     // 0x0934(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RayTracingTranslucencyRefraction : 1;              // 0x0935(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_936[0x2];                                      // 0x0936(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PathTracingMaxBounces;                             // 0x0938(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathTracingSamplesPerPixel;                        // 0x093C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathTracingMaxPathExposure;                        // 0x0940(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PathTracingEnableReferenceDOF : 1;                 // 0x0944(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PathTracingEnableReferenceAtmosphere : 1;          // 0x0944(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PathTracingEnableDenoiser : 1;                     // 0x0944(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PathTracingIncludeEmissive : 1;                    // 0x0944(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PathTracingIncludeIndirectEmissive : 1;            // 0x0944(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PathTracingIncludeDiffuse : 1;                     // 0x0944(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PathTracingIncludeIndirectDiffuse : 1;             // 0x0944(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PathTracingIncludeSpecular : 1;                    // 0x0944(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PathTracingIncludeIndirectSpecular : 1;            // 0x0945(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PathTracingIncludeVolume : 1;                      // 0x0945(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PathTracingIncludeIndirectVolume : 1;              // 0x0945(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_946[0x2];                                      // 0x0946(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LPVFadeRange;                                      // 0x0948(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVDirectionalOcclusionFadeRange;                  // 0x094C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenPercentage;                                  // 0x0950(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_954[0x4];                                      // 0x0954(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeightedBlendables                    WeightedBlendables;                                // 0x0958(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_968[0x8];                                      // 0x0968(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPostProcessSettings) == 0x000010, "Wrong alignment on FPostProcessSettings");
//(sizeof(FPostProcessSettings) == 0x000970, "Wrong size on FPostProcessSettings");
//(offsetof(FPostProcessSettings, CasSharpening) == 0x000024, "Member 'FPostProcessSettings::CasSharpening' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenTintGIColorMarvelStyle) == 0x00002C, "Member 'FPostProcessSettings::LumenTintGIColorMarvelStyle' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenTintGIColorMarvelStyleHair) == 0x00003C, "Member 'FPostProcessSettings::LumenTintGIColorMarvelStyleHair' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenTintGIColorMarvelStyleSubsurface) == 0x00004C, "Member 'FPostProcessSettings::LumenTintGIColorMarvelStyleSubsurface' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenTintGIColorTwoSideFoliage) == 0x00005C, "Member 'FPostProcessSettings::LumenTintGIColorTwoSideFoliage' has a wrong offset!");
//(offsetof(FPostProcessSettings, EnableMVPExpandCharacterFillDepth) == 0x000070, "Member 'FPostProcessSettings::EnableMVPExpandCharacterFillDepth' has a wrong offset!");
//(offsetof(FPostProcessSettings, MVPExpandCharacterFillDepthAnistro) == 0x000078, "Member 'FPostProcessSettings::MVPExpandCharacterFillDepthAnistro' has a wrong offset!");
//(offsetof(FPostProcessSettings, MVPExpandCharacterFillDepthTexture) == 0x000080, "Member 'FPostProcessSettings::MVPExpandCharacterFillDepthTexture' has a wrong offset!");
//(offsetof(FPostProcessSettings, MVPExpandCharacterFillDepthSpeed) == 0x000088, "Member 'FPostProcessSettings::MVPExpandCharacterFillDepthSpeed' has a wrong offset!");
//(offsetof(FPostProcessSettings, ToonOutlineColor0) == 0x0000A8, "Member 'FPostProcessSettings::ToonOutlineColor0' has a wrong offset!");
//(offsetof(FPostProcessSettings, ToonOutlineColor1) == 0x0000B8, "Member 'FPostProcessSettings::ToonOutlineColor1' has a wrong offset!");
//(offsetof(FPostProcessSettings, ToonOutlineColor2) == 0x0000C8, "Member 'FPostProcessSettings::ToonOutlineColor2' has a wrong offset!");
//(offsetof(FPostProcessSettings, ToonOutlineColor3) == 0x0000D8, "Member 'FPostProcessSettings::ToonOutlineColor3' has a wrong offset!");
//(offsetof(FPostProcessSettings, ToonOutlineParameter) == 0x0000F0, "Member 'FPostProcessSettings::ToonOutlineParameter' has a wrong offset!");
//(offsetof(FPostProcessSettings, RimlightShellExpansionScale) == 0x000100, "Member 'FPostProcessSettings::RimlightShellExpansionScale' has a wrong offset!");
//(offsetof(FPostProcessSettings, ScreenSpaceToonOutlineColor) == 0x000104, "Member 'FPostProcessSettings::ScreenSpaceToonOutlineColor' has a wrong offset!");
//(offsetof(FPostProcessSettings, ScreenSpaceToonOutlineParameter) == 0x000120, "Member 'FPostProcessSettings::ScreenSpaceToonOutlineParameter' has a wrong offset!");
//(offsetof(FPostProcessSettings, TeamOutlineColor0) == 0x000130, "Member 'FPostProcessSettings::TeamOutlineColor0' has a wrong offset!");
//(offsetof(FPostProcessSettings, TeamOutlineColor1) == 0x000140, "Member 'FPostProcessSettings::TeamOutlineColor1' has a wrong offset!");
//(offsetof(FPostProcessSettings, TeamOutlineColor2) == 0x000150, "Member 'FPostProcessSettings::TeamOutlineColor2' has a wrong offset!");
//(offsetof(FPostProcessSettings, TeamOutlineColor3) == 0x000160, "Member 'FPostProcessSettings::TeamOutlineColor3' has a wrong offset!");
//(offsetof(FPostProcessSettings, TeamOutlineColor4) == 0x000170, "Member 'FPostProcessSettings::TeamOutlineColor4' has a wrong offset!");
//(offsetof(FPostProcessSettings, TeamOutlineColor5) == 0x000180, "Member 'FPostProcessSettings::TeamOutlineColor5' has a wrong offset!");
//(offsetof(FPostProcessSettings, TeamOutlineColor6) == 0x000190, "Member 'FPostProcessSettings::TeamOutlineColor6' has a wrong offset!");
//(offsetof(FPostProcessSettings, TeamOutlineColor7) == 0x0001A0, "Member 'FPostProcessSettings::TeamOutlineColor7' has a wrong offset!");
//(offsetof(FPostProcessSettings, TeamOutlineColor8) == 0x0001B0, "Member 'FPostProcessSettings::TeamOutlineColor8' has a wrong offset!");
//(offsetof(FPostProcessSettings, TeamOutlineParameter) == 0x0001C0, "Member 'FPostProcessSettings::TeamOutlineParameter' has a wrong offset!");
//(offsetof(FPostProcessSettings, SceneCaptureAAMethod) == 0x0001D1, "Member 'FPostProcessSettings::SceneCaptureAAMethod' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomMethod) == 0x0001D3, "Member 'FPostProcessSettings::BloomMethod' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureMethod) == 0x0001D4, "Member 'FPostProcessSettings::AutoExposureMethod' has a wrong offset!");
//(offsetof(FPostProcessSettings, TemperatureType) == 0x0001D5, "Member 'FPostProcessSettings::TemperatureType' has a wrong offset!");
//(offsetof(FPostProcessSettings, WhiteTemp) == 0x0001D8, "Member 'FPostProcessSettings::WhiteTemp' has a wrong offset!");
//(offsetof(FPostProcessSettings, WhiteTint) == 0x0001DC, "Member 'FPostProcessSettings::WhiteTint' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorSaturation) == 0x0001E0, "Member 'FPostProcessSettings::ColorSaturation' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorContrast) == 0x000200, "Member 'FPostProcessSettings::ColorContrast' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorGamma) == 0x000220, "Member 'FPostProcessSettings::ColorGamma' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorGain) == 0x000240, "Member 'FPostProcessSettings::ColorGain' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorOffset) == 0x000260, "Member 'FPostProcessSettings::ColorOffset' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorSaturationShadows) == 0x000280, "Member 'FPostProcessSettings::ColorSaturationShadows' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorContrastShadows) == 0x0002A0, "Member 'FPostProcessSettings::ColorContrastShadows' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorGammaShadows) == 0x0002C0, "Member 'FPostProcessSettings::ColorGammaShadows' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorGainShadows) == 0x0002E0, "Member 'FPostProcessSettings::ColorGainShadows' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorOffsetShadows) == 0x000300, "Member 'FPostProcessSettings::ColorOffsetShadows' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorSaturationMidtones) == 0x000320, "Member 'FPostProcessSettings::ColorSaturationMidtones' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorContrastMidtones) == 0x000340, "Member 'FPostProcessSettings::ColorContrastMidtones' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorGammaMidtones) == 0x000360, "Member 'FPostProcessSettings::ColorGammaMidtones' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorGainMidtones) == 0x000380, "Member 'FPostProcessSettings::ColorGainMidtones' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorOffsetMidtones) == 0x0003A0, "Member 'FPostProcessSettings::ColorOffsetMidtones' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorSaturationHighlights) == 0x0003C0, "Member 'FPostProcessSettings::ColorSaturationHighlights' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorContrastHighlights) == 0x0003E0, "Member 'FPostProcessSettings::ColorContrastHighlights' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorGammaHighlights) == 0x000400, "Member 'FPostProcessSettings::ColorGammaHighlights' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorGainHighlights) == 0x000420, "Member 'FPostProcessSettings::ColorGainHighlights' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorOffsetHighlights) == 0x000440, "Member 'FPostProcessSettings::ColorOffsetHighlights' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorCorrectionHighlightsMin) == 0x000460, "Member 'FPostProcessSettings::ColorCorrectionHighlightsMin' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorCorrectionHighlightsMax) == 0x000464, "Member 'FPostProcessSettings::ColorCorrectionHighlightsMax' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorCorrectionShadowsMax) == 0x000468, "Member 'FPostProcessSettings::ColorCorrectionShadowsMax' has a wrong offset!");
//(offsetof(FPostProcessSettings, BlueCorrection) == 0x00046C, "Member 'FPostProcessSettings::BlueCorrection' has a wrong offset!");
//(offsetof(FPostProcessSettings, ExpandGamut) == 0x000470, "Member 'FPostProcessSettings::ExpandGamut' has a wrong offset!");
//(offsetof(FPostProcessSettings, ToneCurveAmount) == 0x000474, "Member 'FPostProcessSettings::ToneCurveAmount' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmSlope) == 0x00047C, "Member 'FPostProcessSettings::FilmSlope' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmToe) == 0x000480, "Member 'FPostProcessSettings::FilmToe' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmShoulder) == 0x000484, "Member 'FPostProcessSettings::FilmShoulder' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmBlackClip) == 0x000488, "Member 'FPostProcessSettings::FilmBlackClip' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmWhiteClip) == 0x00048C, "Member 'FPostProcessSettings::FilmWhiteClip' has a wrong offset!");
//(offsetof(FPostProcessSettings, SceneColorTint) == 0x000490, "Member 'FPostProcessSettings::SceneColorTint' has a wrong offset!");
//(offsetof(FPostProcessSettings, SceneFringeIntensity) == 0x0004A0, "Member 'FPostProcessSettings::SceneFringeIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, ChromaticAberrationStartOffset) == 0x0004A4, "Member 'FPostProcessSettings::ChromaticAberrationStartOffset' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomIntensity) == 0x0004A8, "Member 'FPostProcessSettings::BloomIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomThreshold) == 0x0004AC, "Member 'FPostProcessSettings::BloomThreshold' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomSizeScale) == 0x0004B0, "Member 'FPostProcessSettings::BloomSizeScale' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom1Size) == 0x0004B4, "Member 'FPostProcessSettings::Bloom1Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom2Size) == 0x0004B8, "Member 'FPostProcessSettings::Bloom2Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom3Size) == 0x0004BC, "Member 'FPostProcessSettings::Bloom3Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom4Size) == 0x0004C0, "Member 'FPostProcessSettings::Bloom4Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom5Size) == 0x0004C4, "Member 'FPostProcessSettings::Bloom5Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom6Size) == 0x0004C8, "Member 'FPostProcessSettings::Bloom6Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom1Tint) == 0x0004CC, "Member 'FPostProcessSettings::Bloom1Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom2Tint) == 0x0004DC, "Member 'FPostProcessSettings::Bloom2Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom3Tint) == 0x0004EC, "Member 'FPostProcessSettings::Bloom3Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom4Tint) == 0x0004FC, "Member 'FPostProcessSettings::Bloom4Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom5Tint) == 0x00050C, "Member 'FPostProcessSettings::Bloom5Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, Bloom6Tint) == 0x00051C, "Member 'FPostProcessSettings::Bloom6Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom1Size) == 0x00052C, "Member 'FPostProcessSettings::AdditionalBloom1Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom2Size) == 0x000530, "Member 'FPostProcessSettings::AdditionalBloom2Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom3Size) == 0x000534, "Member 'FPostProcessSettings::AdditionalBloom3Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom4Size) == 0x000538, "Member 'FPostProcessSettings::AdditionalBloom4Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom5Size) == 0x00053C, "Member 'FPostProcessSettings::AdditionalBloom5Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom6Size) == 0x000540, "Member 'FPostProcessSettings::AdditionalBloom6Size' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom1Tint) == 0x000544, "Member 'FPostProcessSettings::AdditionalBloom1Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom2Tint) == 0x000554, "Member 'FPostProcessSettings::AdditionalBloom2Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom3Tint) == 0x000564, "Member 'FPostProcessSettings::AdditionalBloom3Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom4Tint) == 0x000574, "Member 'FPostProcessSettings::AdditionalBloom4Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom5Tint) == 0x000584, "Member 'FPostProcessSettings::AdditionalBloom5Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, AdditionalBloom6Tint) == 0x000594, "Member 'FPostProcessSettings::AdditionalBloom6Tint' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomConvolutionScatterDispersion) == 0x0005A4, "Member 'FPostProcessSettings::BloomConvolutionScatterDispersion' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomConvolutionSize) == 0x0005A8, "Member 'FPostProcessSettings::BloomConvolutionSize' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomConvolutionTexture) == 0x0005B0, "Member 'FPostProcessSettings::BloomConvolutionTexture' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomConvolutionCenterUV) == 0x0005B8, "Member 'FPostProcessSettings::BloomConvolutionCenterUV' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomConvolutionPreFilterMin) == 0x0005C8, "Member 'FPostProcessSettings::BloomConvolutionPreFilterMin' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomConvolutionPreFilterMax) == 0x0005CC, "Member 'FPostProcessSettings::BloomConvolutionPreFilterMax' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomConvolutionPreFilterMult) == 0x0005D0, "Member 'FPostProcessSettings::BloomConvolutionPreFilterMult' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomConvolutionBufferScale) == 0x0005D4, "Member 'FPostProcessSettings::BloomConvolutionBufferScale' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomDirtMask) == 0x0005D8, "Member 'FPostProcessSettings::BloomDirtMask' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomDirtMaskIntensity) == 0x0005E0, "Member 'FPostProcessSettings::BloomDirtMaskIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, BloomDirtMaskTint) == 0x0005E4, "Member 'FPostProcessSettings::BloomDirtMaskTint' has a wrong offset!");
//(offsetof(FPostProcessSettings, DynamicGlobalIlluminationMethod) == 0x0005F4, "Member 'FPostProcessSettings::DynamicGlobalIlluminationMethod' has a wrong offset!");
//(offsetof(FPostProcessSettings, IndirectLightingColor) == 0x0005F8, "Member 'FPostProcessSettings::IndirectLightingColor' has a wrong offset!");
//(offsetof(FPostProcessSettings, IndirectLightingIntensity) == 0x000608, "Member 'FPostProcessSettings::IndirectLightingIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenSceneLightingQuality) == 0x00060C, "Member 'FPostProcessSettings::LumenSceneLightingQuality' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenSceneDetail) == 0x000610, "Member 'FPostProcessSettings::LumenSceneDetail' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenSceneViewDistance) == 0x000614, "Member 'FPostProcessSettings::LumenSceneViewDistance' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenSceneLightingUpdateSpeed) == 0x000618, "Member 'FPostProcessSettings::LumenSceneLightingUpdateSpeed' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenSceneNumberOfSkipFrames) == 0x00061C, "Member 'FPostProcessSettings::LumenSceneNumberOfSkipFrames' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenSceneNumberOfMeshCardThreshold) == 0x000620, "Member 'FPostProcessSettings::LumenSceneNumberOfMeshCardThreshold' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenFinalGatherQuality) == 0x000624, "Member 'FPostProcessSettings::LumenFinalGatherQuality' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenFinalGatherLightingUpdateSpeed) == 0x000628, "Member 'FPostProcessSettings::LumenFinalGatherLightingUpdateSpeed' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenMaxTraceDistance) == 0x000630, "Member 'FPostProcessSettings::LumenMaxTraceDistance' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenDiffuseColorBoost) == 0x000634, "Member 'FPostProcessSettings::LumenDiffuseColorBoost' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenSkylightLeaking) == 0x000638, "Member 'FPostProcessSettings::LumenSkylightLeaking' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenFullSkylightLeakingDistance) == 0x00063C, "Member 'FPostProcessSettings::LumenFullSkylightLeakingDistance' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenSurfaceCacheResolution) == 0x000640, "Member 'FPostProcessSettings::LumenSurfaceCacheResolution' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingGIType) == 0x000644, "Member 'FPostProcessSettings::RayTracingGIType' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingGIMaxBounces) == 0x000648, "Member 'FPostProcessSettings::RayTracingGIMaxBounces' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingGISamplesPerPixel) == 0x00064C, "Member 'FPostProcessSettings::RayTracingGISamplesPerPixel' has a wrong offset!");
//(offsetof(FPostProcessSettings, SkyLightColor) == 0x000654, "Member 'FPostProcessSettings::SkyLightColor' has a wrong offset!");
//(offsetof(FPostProcessSettings, SkyLightIntensityMultiplier) == 0x000664, "Member 'FPostProcessSettings::SkyLightIntensityMultiplier' has a wrong offset!");
//(offsetof(FPostProcessSettings, SkyLightTranslucencyMultiplier) == 0x000668, "Member 'FPostProcessSettings::SkyLightTranslucencyMultiplier' has a wrong offset!");
//(offsetof(FPostProcessSettings, DistanceFieldAOIntensity) == 0x00066C, "Member 'FPostProcessSettings::DistanceFieldAOIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, MinDistanceFieldAO) == 0x000670, "Member 'FPostProcessSettings::MinDistanceFieldAO' has a wrong offset!");
//(offsetof(FPostProcessSettings, SSRMaxBlurRadius) == 0x000674, "Member 'FPostProcessSettings::SSRMaxBlurRadius' has a wrong offset!");
//(offsetof(FPostProcessSettings, ShadowRadiusThreshold) == 0x000678, "Member 'FPostProcessSettings::ShadowRadiusThreshold' has a wrong offset!");
//(offsetof(FPostProcessSettings, ReflectionMethod) == 0x00067C, "Member 'FPostProcessSettings::ReflectionMethod' has a wrong offset!");
//(offsetof(FPostProcessSettings, ReflectionsType) == 0x00067D, "Member 'FPostProcessSettings::ReflectionsType' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenReflectionQuality) == 0x000680, "Member 'FPostProcessSettings::LumenReflectionQuality' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenRayLightingMode) == 0x000684, "Member 'FPostProcessSettings::LumenRayLightingMode' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenMaxReflectionBounces) == 0x000688, "Member 'FPostProcessSettings::LumenMaxReflectionBounces' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenReflectionDimThreshold) == 0x00068C, "Member 'FPostProcessSettings::LumenReflectionDimThreshold' has a wrong offset!");
//(offsetof(FPostProcessSettings, LumenReflectionDimScale) == 0x000690, "Member 'FPostProcessSettings::LumenReflectionDimScale' has a wrong offset!");
//(offsetof(FPostProcessSettings, ScreenSpaceReflectionIntensity) == 0x000694, "Member 'FPostProcessSettings::ScreenSpaceReflectionIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, ScreenSpaceReflectionQuality) == 0x000698, "Member 'FPostProcessSettings::ScreenSpaceReflectionQuality' has a wrong offset!");
//(offsetof(FPostProcessSettings, ScreenSpaceReflectionMaxRoughness) == 0x00069C, "Member 'FPostProcessSettings::ScreenSpaceReflectionMaxRoughness' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingReflectionsMaxRoughness) == 0x0006A0, "Member 'FPostProcessSettings::RayTracingReflectionsMaxRoughness' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingReflectionsMaxBounces) == 0x0006A4, "Member 'FPostProcessSettings::RayTracingReflectionsMaxBounces' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingReflectionsSamplesPerPixel) == 0x0006A8, "Member 'FPostProcessSettings::RayTracingReflectionsSamplesPerPixel' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingReflectionsShadows) == 0x0006AC, "Member 'FPostProcessSettings::RayTracingReflectionsShadows' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientCubemapTint) == 0x0006B0, "Member 'FPostProcessSettings::AmbientCubemapTint' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientCubemapIntensity) == 0x0006C0, "Member 'FPostProcessSettings::AmbientCubemapIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientCubemap) == 0x0006C8, "Member 'FPostProcessSettings::AmbientCubemap' has a wrong offset!");
//(offsetof(FPostProcessSettings, OverrideAmbientCubemapSampleLevel) == 0x0006D0, "Member 'FPostProcessSettings::OverrideAmbientCubemapSampleLevel' has a wrong offset!");
//(offsetof(FPostProcessSettings, CameraShutterSpeed) == 0x0006D4, "Member 'FPostProcessSettings::CameraShutterSpeed' has a wrong offset!");
//(offsetof(FPostProcessSettings, CameraISO) == 0x0006D8, "Member 'FPostProcessSettings::CameraISO' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldFstop) == 0x0006DC, "Member 'FPostProcessSettings::DepthOfFieldFstop' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldMinFstop) == 0x0006E0, "Member 'FPostProcessSettings::DepthOfFieldMinFstop' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldBladeCount) == 0x0006E4, "Member 'FPostProcessSettings::DepthOfFieldBladeCount' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureBias) == 0x0006E8, "Member 'FPostProcessSettings::AutoExposureBias' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureBiasBackup) == 0x0006EC, "Member 'FPostProcessSettings::AutoExposureBiasBackup' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureMarvelStyleAmbientCurve) == 0x0006F8, "Member 'FPostProcessSettings::AutoExposureMarvelStyleAmbientCurve' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureEmissiveCurve) == 0x000700, "Member 'FPostProcessSettings::AutoExposureEmissiveCurve' has a wrong offset!");
//(offsetof(FPostProcessSettings, CharacterLocalExposureHighlight) == 0x000708, "Member 'FPostProcessSettings::CharacterLocalExposureHighlight' has a wrong offset!");
//(offsetof(FPostProcessSettings, CharacterLocalExposureShadow) == 0x00070C, "Member 'FPostProcessSettings::CharacterLocalExposureShadow' has a wrong offset!");
//(offsetof(FPostProcessSettings, CharacterLocalExposureLevel) == 0x000710, "Member 'FPostProcessSettings::CharacterLocalExposureLevel' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureBiasCurve) == 0x000718, "Member 'FPostProcessSettings::AutoExposureBiasCurve' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureMeterMask) == 0x000720, "Member 'FPostProcessSettings::AutoExposureMeterMask' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureLowPercent) == 0x000728, "Member 'FPostProcessSettings::AutoExposureLowPercent' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureHighPercent) == 0x00072C, "Member 'FPostProcessSettings::AutoExposureHighPercent' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureMinBrightness) == 0x000730, "Member 'FPostProcessSettings::AutoExposureMinBrightness' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureMaxBrightness) == 0x000734, "Member 'FPostProcessSettings::AutoExposureMaxBrightness' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureCharacterMinBrightness) == 0x00073C, "Member 'FPostProcessSettings::AutoExposureCharacterMinBrightness' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureCharacterMaxBrightness) == 0x000740, "Member 'FPostProcessSettings::AutoExposureCharacterMaxBrightness' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureSpeedUp) == 0x000744, "Member 'FPostProcessSettings::AutoExposureSpeedUp' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureSpeedDown) == 0x000748, "Member 'FPostProcessSettings::AutoExposureSpeedDown' has a wrong offset!");
//(offsetof(FPostProcessSettings, HistogramLogMin) == 0x00074C, "Member 'FPostProcessSettings::HistogramLogMin' has a wrong offset!");
//(offsetof(FPostProcessSettings, HistogramLogMax) == 0x000750, "Member 'FPostProcessSettings::HistogramLogMax' has a wrong offset!");
//(offsetof(FPostProcessSettings, AutoExposureCalibrationConstant) == 0x000754, "Member 'FPostProcessSettings::AutoExposureCalibrationConstant' has a wrong offset!");
//(offsetof(FPostProcessSettings, LocalExposureContrastScale) == 0x000758, "Member 'FPostProcessSettings::LocalExposureContrastScale' has a wrong offset!");
//(offsetof(FPostProcessSettings, LocalExposureHighlightContrastScale) == 0x00075C, "Member 'FPostProcessSettings::LocalExposureHighlightContrastScale' has a wrong offset!");
//(offsetof(FPostProcessSettings, LocalExposureShadowContrastScale) == 0x000760, "Member 'FPostProcessSettings::LocalExposureShadowContrastScale' has a wrong offset!");
//(offsetof(FPostProcessSettings, LocalExposureDetailStrength) == 0x000764, "Member 'FPostProcessSettings::LocalExposureDetailStrength' has a wrong offset!");
//(offsetof(FPostProcessSettings, LocalExposureBlurredLuminanceBlend) == 0x000768, "Member 'FPostProcessSettings::LocalExposureBlurredLuminanceBlend' has a wrong offset!");
//(offsetof(FPostProcessSettings, LocalExposureBlurredLuminanceKernelSizePercent) == 0x00076C, "Member 'FPostProcessSettings::LocalExposureBlurredLuminanceKernelSizePercent' has a wrong offset!");
//(offsetof(FPostProcessSettings, LocalExposureMiddleGreyBias) == 0x000770, "Member 'FPostProcessSettings::LocalExposureMiddleGreyBias' has a wrong offset!");
//(offsetof(FPostProcessSettings, LensFlareIntensity) == 0x000774, "Member 'FPostProcessSettings::LensFlareIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, LensFlareTint) == 0x000778, "Member 'FPostProcessSettings::LensFlareTint' has a wrong offset!");
//(offsetof(FPostProcessSettings, LensFlareBokehSize) == 0x000788, "Member 'FPostProcessSettings::LensFlareBokehSize' has a wrong offset!");
//(offsetof(FPostProcessSettings, LensFlareThreshold) == 0x00078C, "Member 'FPostProcessSettings::LensFlareThreshold' has a wrong offset!");
//(offsetof(FPostProcessSettings, LensFlareBokehShape) == 0x000790, "Member 'FPostProcessSettings::LensFlareBokehShape' has a wrong offset!");
//(offsetof(FPostProcessSettings, LensFlareTints) == 0x000798, "Member 'FPostProcessSettings::LensFlareTints' has a wrong offset!");
//(offsetof(FPostProcessSettings, VignetteIntensity) == 0x000818, "Member 'FPostProcessSettings::VignetteIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, Sharpen) == 0x00081C, "Member 'FPostProcessSettings::Sharpen' has a wrong offset!");
//(offsetof(FPostProcessSettings, GrainJitter) == 0x000820, "Member 'FPostProcessSettings::GrainJitter' has a wrong offset!");
//(offsetof(FPostProcessSettings, GrainIntensity) == 0x000824, "Member 'FPostProcessSettings::GrainIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmGrainIntensity) == 0x000828, "Member 'FPostProcessSettings::FilmGrainIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmGrainIntensityShadows) == 0x00082C, "Member 'FPostProcessSettings::FilmGrainIntensityShadows' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmGrainIntensityMidtones) == 0x000830, "Member 'FPostProcessSettings::FilmGrainIntensityMidtones' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmGrainIntensityHighlights) == 0x000834, "Member 'FPostProcessSettings::FilmGrainIntensityHighlights' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmGrainShadowsMax) == 0x000838, "Member 'FPostProcessSettings::FilmGrainShadowsMax' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmGrainHighlightsMin) == 0x00083C, "Member 'FPostProcessSettings::FilmGrainHighlightsMin' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmGrainHighlightsMax) == 0x000840, "Member 'FPostProcessSettings::FilmGrainHighlightsMax' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmGrainTexelSize) == 0x000844, "Member 'FPostProcessSettings::FilmGrainTexelSize' has a wrong offset!");
//(offsetof(FPostProcessSettings, FilmGrainTexture) == 0x000848, "Member 'FPostProcessSettings::FilmGrainTexture' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionType) == 0x000850, "Member 'FPostProcessSettings::AmbientOcclusionType' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionIntensity) == 0x000854, "Member 'FPostProcessSettings::AmbientOcclusionIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionStaticFraction) == 0x000858, "Member 'FPostProcessSettings::AmbientOcclusionStaticFraction' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionRadius) == 0x00085C, "Member 'FPostProcessSettings::AmbientOcclusionRadius' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionFadeDistance) == 0x000864, "Member 'FPostProcessSettings::AmbientOcclusionFadeDistance' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionFadeRadius) == 0x000868, "Member 'FPostProcessSettings::AmbientOcclusionFadeRadius' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionDistance) == 0x00086C, "Member 'FPostProcessSettings::AmbientOcclusionDistance' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionPower) == 0x000870, "Member 'FPostProcessSettings::AmbientOcclusionPower' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionBias) == 0x000874, "Member 'FPostProcessSettings::AmbientOcclusionBias' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionQuality) == 0x000878, "Member 'FPostProcessSettings::AmbientOcclusionQuality' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionMipBlend) == 0x00087C, "Member 'FPostProcessSettings::AmbientOcclusionMipBlend' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionMipScale) == 0x000880, "Member 'FPostProcessSettings::AmbientOcclusionMipScale' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionMipThreshold) == 0x000884, "Member 'FPostProcessSettings::AmbientOcclusionMipThreshold' has a wrong offset!");
//(offsetof(FPostProcessSettings, AmbientOcclusionTemporalBlendWeight) == 0x000888, "Member 'FPostProcessSettings::AmbientOcclusionTemporalBlendWeight' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingAOSamplesPerPixel) == 0x000890, "Member 'FPostProcessSettings::RayTracingAOSamplesPerPixel' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingAOIntensity) == 0x000894, "Member 'FPostProcessSettings::RayTracingAOIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingAORadius) == 0x000898, "Member 'FPostProcessSettings::RayTracingAORadius' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorGradingIntensity) == 0x00089C, "Member 'FPostProcessSettings::ColorGradingIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, ColorGradingLUT) == 0x0008A0, "Member 'FPostProcessSettings::ColorGradingLUT' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldSensorWidth) == 0x0008A8, "Member 'FPostProcessSettings::DepthOfFieldSensorWidth' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldSqueezeFactor) == 0x0008AC, "Member 'FPostProcessSettings::DepthOfFieldSqueezeFactor' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldFocalDistance) == 0x0008B0, "Member 'FPostProcessSettings::DepthOfFieldFocalDistance' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldDepthBlurAmount) == 0x0008B4, "Member 'FPostProcessSettings::DepthOfFieldDepthBlurAmount' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldDepthBlurRadius) == 0x0008B8, "Member 'FPostProcessSettings::DepthOfFieldDepthBlurRadius' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldFocalRegion) == 0x0008BC, "Member 'FPostProcessSettings::DepthOfFieldFocalRegion' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldNearTransitionRegion) == 0x0008C0, "Member 'FPostProcessSettings::DepthOfFieldNearTransitionRegion' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldFarTransitionRegion) == 0x0008C4, "Member 'FPostProcessSettings::DepthOfFieldFarTransitionRegion' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldScale) == 0x0008C8, "Member 'FPostProcessSettings::DepthOfFieldScale' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldNearBlurSize) == 0x0008CC, "Member 'FPostProcessSettings::DepthOfFieldNearBlurSize' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldFarBlurSize) == 0x0008D0, "Member 'FPostProcessSettings::DepthOfFieldFarBlurSize' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldOcclusion) == 0x0008D4, "Member 'FPostProcessSettings::DepthOfFieldOcclusion' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldSkyFocusDistance) == 0x0008D8, "Member 'FPostProcessSettings::DepthOfFieldSkyFocusDistance' has a wrong offset!");
//(offsetof(FPostProcessSettings, DepthOfFieldVignetteSize) == 0x0008DC, "Member 'FPostProcessSettings::DepthOfFieldVignetteSize' has a wrong offset!");
//(offsetof(FPostProcessSettings, MotionBlurAmount) == 0x0008E0, "Member 'FPostProcessSettings::MotionBlurAmount' has a wrong offset!");
//(offsetof(FPostProcessSettings, MotionBlurMax) == 0x0008E4, "Member 'FPostProcessSettings::MotionBlurMax' has a wrong offset!");
//(offsetof(FPostProcessSettings, MotionBlurTargetFPS) == 0x0008E8, "Member 'FPostProcessSettings::MotionBlurTargetFPS' has a wrong offset!");
//(offsetof(FPostProcessSettings, MotionBlurPerObjectSize) == 0x0008EC, "Member 'FPostProcessSettings::MotionBlurPerObjectSize' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVIntensity) == 0x0008F0, "Member 'FPostProcessSettings::LPVIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVVplInjectionBias) == 0x0008F4, "Member 'FPostProcessSettings::LPVVplInjectionBias' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVSize) == 0x0008F8, "Member 'FPostProcessSettings::LPVSize' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVSecondaryOcclusionIntensity) == 0x0008FC, "Member 'FPostProcessSettings::LPVSecondaryOcclusionIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVSecondaryBounceIntensity) == 0x000900, "Member 'FPostProcessSettings::LPVSecondaryBounceIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVGeometryVolumeBias) == 0x000904, "Member 'FPostProcessSettings::LPVGeometryVolumeBias' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVEmissiveInjectionIntensity) == 0x000908, "Member 'FPostProcessSettings::LPVEmissiveInjectionIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVDirectionalOcclusionIntensity) == 0x00090C, "Member 'FPostProcessSettings::LPVDirectionalOcclusionIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVDirectionalOcclusionRadius) == 0x000910, "Member 'FPostProcessSettings::LPVDirectionalOcclusionRadius' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVDiffuseOcclusionExponent) == 0x000914, "Member 'FPostProcessSettings::LPVDiffuseOcclusionExponent' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVSpecularOcclusionExponent) == 0x000918, "Member 'FPostProcessSettings::LPVSpecularOcclusionExponent' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVDiffuseOcclusionIntensity) == 0x00091C, "Member 'FPostProcessSettings::LPVDiffuseOcclusionIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVSpecularOcclusionIntensity) == 0x000920, "Member 'FPostProcessSettings::LPVSpecularOcclusionIntensity' has a wrong offset!");
//(offsetof(FPostProcessSettings, TranslucencyType) == 0x000924, "Member 'FPostProcessSettings::TranslucencyType' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingTranslucencyMaxRoughness) == 0x000928, "Member 'FPostProcessSettings::RayTracingTranslucencyMaxRoughness' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingTranslucencyRefractionRays) == 0x00092C, "Member 'FPostProcessSettings::RayTracingTranslucencyRefractionRays' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingTranslucencySamplesPerPixel) == 0x000930, "Member 'FPostProcessSettings::RayTracingTranslucencySamplesPerPixel' has a wrong offset!");
//(offsetof(FPostProcessSettings, RayTracingTranslucencyShadows) == 0x000934, "Member 'FPostProcessSettings::RayTracingTranslucencyShadows' has a wrong offset!");
//(offsetof(FPostProcessSettings, PathTracingMaxBounces) == 0x000938, "Member 'FPostProcessSettings::PathTracingMaxBounces' has a wrong offset!");
//(offsetof(FPostProcessSettings, PathTracingSamplesPerPixel) == 0x00093C, "Member 'FPostProcessSettings::PathTracingSamplesPerPixel' has a wrong offset!");
//(offsetof(FPostProcessSettings, PathTracingMaxPathExposure) == 0x000940, "Member 'FPostProcessSettings::PathTracingMaxPathExposure' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVFadeRange) == 0x000948, "Member 'FPostProcessSettings::LPVFadeRange' has a wrong offset!");
//(offsetof(FPostProcessSettings, LPVDirectionalOcclusionFadeRange) == 0x00094C, "Member 'FPostProcessSettings::LPVDirectionalOcclusionFadeRange' has a wrong offset!");
//(offsetof(FPostProcessSettings, ScreenPercentage) == 0x000950, "Member 'FPostProcessSettings::ScreenPercentage' has a wrong offset!");
//(offsetof(FPostProcessSettings, WeightedBlendables) == 0x000958, "Member 'FPostProcessSettings::WeightedBlendables' has a wrong offset!");

// ScriptStruct Engine.MinimalViewInfo
// 0x0A50 (0x0A50 - 0x0000)
struct FMinimalViewInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredFOV;                                        // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrthoWidth;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrthoNearClipPlane;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrthoFarClipPlane;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerspectiveNearClipPlane;                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AspectRatio;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x8];                                       // 0x004C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bConstrainAspectRatio : 1;                         // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFieldOfViewForLOD : 1;                         // 0x0054(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ECameraProjectionMode                         ProjectionMode;                                    // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PostProcessBlendWeight;                            // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0060(0x0970)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector2D                              OffCenterProjectionOffset;                         // 0x09D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E0[0x70];                                     // 0x09E0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMinimalViewInfo) == 0x000010, "Wrong alignment on FMinimalViewInfo");
//(sizeof(FMinimalViewInfo) == 0x000A50, "Wrong size on FMinimalViewInfo");
//(offsetof(FMinimalViewInfo, Location) == 0x000000, "Member 'FMinimalViewInfo::Location' has a wrong offset!");
//(offsetof(FMinimalViewInfo, Rotation) == 0x000018, "Member 'FMinimalViewInfo::Rotation' has a wrong offset!");
//(offsetof(FMinimalViewInfo, FOV) == 0x000030, "Member 'FMinimalViewInfo::FOV' has a wrong offset!");
//(offsetof(FMinimalViewInfo, DesiredFOV) == 0x000034, "Member 'FMinimalViewInfo::DesiredFOV' has a wrong offset!");
//(offsetof(FMinimalViewInfo, OrthoWidth) == 0x000038, "Member 'FMinimalViewInfo::OrthoWidth' has a wrong offset!");
//(offsetof(FMinimalViewInfo, OrthoNearClipPlane) == 0x00003C, "Member 'FMinimalViewInfo::OrthoNearClipPlane' has a wrong offset!");
//(offsetof(FMinimalViewInfo, OrthoFarClipPlane) == 0x000040, "Member 'FMinimalViewInfo::OrthoFarClipPlane' has a wrong offset!");
//(offsetof(FMinimalViewInfo, PerspectiveNearClipPlane) == 0x000044, "Member 'FMinimalViewInfo::PerspectiveNearClipPlane' has a wrong offset!");
//(offsetof(FMinimalViewInfo, AspectRatio) == 0x000048, "Member 'FMinimalViewInfo::AspectRatio' has a wrong offset!");
//(offsetof(FMinimalViewInfo, ProjectionMode) == 0x000058, "Member 'FMinimalViewInfo::ProjectionMode' has a wrong offset!");
//(offsetof(FMinimalViewInfo, PostProcessBlendWeight) == 0x00005C, "Member 'FMinimalViewInfo::PostProcessBlendWeight' has a wrong offset!");
//(offsetof(FMinimalViewInfo, PostProcessSettings) == 0x000060, "Member 'FMinimalViewInfo::PostProcessSettings' has a wrong offset!");
//(offsetof(FMinimalViewInfo, OffCenterProjectionOffset) == 0x0009D0, "Member 'FMinimalViewInfo::OffCenterProjectionOffset' has a wrong offset!");

// ScriptStruct Engine.TViewTarget
// 0x0A70 (0x0A70 - 0x0000)
struct FTViewTarget final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       POV;                                               // 0x0010(0x0A50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class APlayerState*                           PlayerState;                                       // 0x0A60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A68[0x8];                                      // 0x0A68(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTViewTarget) == 0x000010, "Wrong alignment on FTViewTarget");
//(sizeof(FTViewTarget) == 0x000A70, "Wrong size on FTViewTarget");
//(offsetof(FTViewTarget, Target) == 0x000000, "Member 'FTViewTarget::Target' has a wrong offset!");
//(offsetof(FTViewTarget, POV) == 0x000010, "Member 'FTViewTarget::POV' has a wrong offset!");
//(offsetof(FTViewTarget, PlayerState) == 0x000A60, "Member 'FTViewTarget::PlayerState' has a wrong offset!");

// ScriptStruct Engine.HLODProxyMesh
// 0x0030 (0x0030 - 0x0000)
struct FHLODProxyMesh final
{
public:
	TLazyObjectPtr<class ALODActor>               LODActor;                                          // 0x0000(0x0018)(IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            StaticMesh;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   Key;                                               // 0x0020(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FHLODProxyMesh) == 0x000008, "Wrong alignment on FHLODProxyMesh");
//(sizeof(FHLODProxyMesh) == 0x000030, "Wrong size on FHLODProxyMesh");
//(offsetof(FHLODProxyMesh, LODActor) == 0x000000, "Member 'FHLODProxyMesh::LODActor' has a wrong offset!");
//(offsetof(FHLODProxyMesh, StaticMesh) == 0x000018, "Member 'FHLODProxyMesh::StaticMesh' has a wrong offset!");
//(offsetof(FHLODProxyMesh, Key) == 0x000020, "Member 'FHLODProxyMesh::Key' has a wrong offset!");

// ScriptStruct Engine.InterpControlPoint
// 0x0028 (0x0028 - 0x0000)
struct FInterpControlPoint final
{
public:
	struct FVector                                PositionControlPoint;                              // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPositionIsRelative;                               // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0xF];                                       // 0x0019(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FInterpControlPoint) == 0x000008, "Wrong alignment on FInterpControlPoint");
//(sizeof(FInterpControlPoint) == 0x000028, "Wrong size on FInterpControlPoint");
//(offsetof(FInterpControlPoint, PositionControlPoint) == 0x000000, "Member 'FInterpControlPoint::PositionControlPoint' has a wrong offset!");
//(offsetof(FInterpControlPoint, bPositionIsRelative) == 0x000018, "Member 'FInterpControlPoint::bPositionIsRelative' has a wrong offset!");

// ScriptStruct Engine.MaterialLayersFunctions
// 0x00E8 (0x0108 - 0x0020)
struct FMaterialLayersFunctions final : public FMaterialLayersFunctionsRuntimeData
{
public:
	struct FMaterialLayersFunctionsEditorOnlyData EditorOnly;                                        // 0x0020(0x0078)(Edit, NativeAccessSpecifierPublic)
	TArray<bool>                                  LayerStates;                                       // 0x0098(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<class FText>                           LayerNames;                                        // 0x00A8(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<bool>                                  RestrictToLayerRelatives;                          // 0x00B8(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<bool>                                  RestrictToBlendRelatives;                          // 0x00C8(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          LayerGuids;                                        // 0x00D8(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<EMaterialLayerLinkState>               LayerLinkStates;                                   // 0x00E8(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          DeletedParentLayerGuids;                           // 0x00F8(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
};
//(alignof(FMaterialLayersFunctions) == 0x000008, "Wrong alignment on FMaterialLayersFunctions");
//(sizeof(FMaterialLayersFunctions) == 0x000108, "Wrong size on FMaterialLayersFunctions");
//(offsetof(FMaterialLayersFunctions, EditorOnly) == 0x000020, "Member 'FMaterialLayersFunctions::EditorOnly' has a wrong offset!");
//(offsetof(FMaterialLayersFunctions, LayerStates) == 0x000098, "Member 'FMaterialLayersFunctions::LayerStates' has a wrong offset!");
//(offsetof(FMaterialLayersFunctions, LayerNames) == 0x0000A8, "Member 'FMaterialLayersFunctions::LayerNames' has a wrong offset!");
//(offsetof(FMaterialLayersFunctions, RestrictToLayerRelatives) == 0x0000B8, "Member 'FMaterialLayersFunctions::RestrictToLayerRelatives' has a wrong offset!");
//(offsetof(FMaterialLayersFunctions, RestrictToBlendRelatives) == 0x0000C8, "Member 'FMaterialLayersFunctions::RestrictToBlendRelatives' has a wrong offset!");
//(offsetof(FMaterialLayersFunctions, LayerGuids) == 0x0000D8, "Member 'FMaterialLayersFunctions::LayerGuids' has a wrong offset!");
//(offsetof(FMaterialLayersFunctions, LayerLinkStates) == 0x0000E8, "Member 'FMaterialLayersFunctions::LayerLinkStates' has a wrong offset!");
//(offsetof(FMaterialLayersFunctions, DeletedParentLayerGuids) == 0x0000F8, "Member 'FMaterialLayersFunctions::DeletedParentLayerGuids' has a wrong offset!");

// ScriptStruct Engine.StaticMaterialLayersParameter
// 0x0108 (0x0130 - 0x0028)
struct FStaticMaterialLayersParameter final : public FStaticParameterBase
{
public:
	struct FMaterialLayersFunctions               Value;                                             // 0x0028(0x0108)(NativeAccessSpecifierPublic)
};
//(alignof(FStaticMaterialLayersParameter) == 0x000008, "Wrong alignment on FStaticMaterialLayersParameter");
//(sizeof(FStaticMaterialLayersParameter) == 0x000130, "Wrong size on FStaticMaterialLayersParameter");
//(offsetof(FStaticMaterialLayersParameter, Value) == 0x000028, "Member 'FStaticMaterialLayersParameter::Value' has a wrong offset!");

// ScriptStruct Engine.DoubleVectorParameterValue
// 0x0050 (0x0050 - 0x0000)
struct FDoubleVectorParameterValue final
{
public:
	struct FMaterialParameterInfo                 ParameterInfo;                                     // 0x0000(0x0014)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4d                              ParameterValue;                                    // 0x0020(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDoubleVectorParameterValue) == 0x000010, "Wrong alignment on FDoubleVectorParameterValue");
//(sizeof(FDoubleVectorParameterValue) == 0x000050, "Wrong size on FDoubleVectorParameterValue");
//(offsetof(FDoubleVectorParameterValue, ParameterInfo) == 0x000000, "Member 'FDoubleVectorParameterValue::ParameterInfo' has a wrong offset!");
//(offsetof(FDoubleVectorParameterValue, ParameterValue) == 0x000020, "Member 'FDoubleVectorParameterValue::ParameterValue' has a wrong offset!");
//(offsetof(FDoubleVectorParameterValue, ExpressionGUID) == 0x000040, "Member 'FDoubleVectorParameterValue::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.DebugFloatHistory
// 0x0020 (0x0020 - 0x0000)
struct FDebugFloatHistory final
{
public:
	TArray<float>                                 Samples;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         MaxSamples;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAdjustMinMax;                                 // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDebugFloatHistory) == 0x000008, "Wrong alignment on FDebugFloatHistory");
//(sizeof(FDebugFloatHistory) == 0x000020, "Wrong size on FDebugFloatHistory");
//(offsetof(FDebugFloatHistory, Samples) == 0x000000, "Member 'FDebugFloatHistory::Samples' has a wrong offset!");
//(offsetof(FDebugFloatHistory, MaxSamples) == 0x000010, "Member 'FDebugFloatHistory::MaxSamples' has a wrong offset!");
//(offsetof(FDebugFloatHistory, MinValue) == 0x000014, "Member 'FDebugFloatHistory::MinValue' has a wrong offset!");
//(offsetof(FDebugFloatHistory, MaxValue) == 0x000018, "Member 'FDebugFloatHistory::MaxValue' has a wrong offset!");
//(offsetof(FDebugFloatHistory, bAutoAdjustMinMax) == 0x00001C, "Member 'FDebugFloatHistory::bAutoAdjustMinMax' has a wrong offset!");

// ScriptStruct Engine.ScaleTrack
// 0x0020 (0x0020 - 0x0000)
struct FScaleTrack final
{
public:
	TArray<struct FVector3f>                      ScaleKeys;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Times;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FScaleTrack) == 0x000008, "Wrong alignment on FScaleTrack");
//(sizeof(FScaleTrack) == 0x000020, "Wrong size on FScaleTrack");
//(offsetof(FScaleTrack, ScaleKeys) == 0x000000, "Member 'FScaleTrack::ScaleKeys' has a wrong offset!");
//(offsetof(FScaleTrack, Times) == 0x000010, "Member 'FScaleTrack::Times' has a wrong offset!");

// ScriptStruct Engine.EmptyPayload
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FEmptyPayload
{
};
#pragma pack(pop)
//(alignof(FEmptyPayload) == 0x000001, "Wrong alignment on FEmptyPayload");
//(sizeof(FEmptyPayload) == 0x000001, "Wrong size on FEmptyPayload");

// ScriptStruct Engine.SoftComponentReference
// 0x0030 (0x0058 - 0x0028)
struct FSoftComponentReference final : public FBaseComponentReference
{
public:
	TSoftObjectPtr<class AActor>                  OtherActor;                                        // 0x0028(0x0030)(Edit, BlueprintVisible, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoftComponentReference) == 0x000008, "Wrong alignment on FSoftComponentReference");
//(sizeof(FSoftComponentReference) == 0x000058, "Wrong size on FSoftComponentReference");
//(offsetof(FSoftComponentReference, OtherActor) == 0x000028, "Member 'FSoftComponentReference::OtherActor' has a wrong offset!");

// ScriptStruct Engine.NavigationSegmentLink
// 0x0060 (0x00A0 - 0x0040)
struct FNavigationSegmentLink final : public FNavigationLinkBase
{
public:
	struct FVector                                LeftStart;                                         // 0x0040(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEnd;                                           // 0x0058(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightStart;                                        // 0x0070(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEnd;                                          // 0x0088(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNavigationSegmentLink) == 0x000008, "Wrong alignment on FNavigationSegmentLink");
//(sizeof(FNavigationSegmentLink) == 0x0000A0, "Wrong size on FNavigationSegmentLink");
//(offsetof(FNavigationSegmentLink, LeftStart) == 0x000040, "Member 'FNavigationSegmentLink::LeftStart' has a wrong offset!");
//(offsetof(FNavigationSegmentLink, LeftEnd) == 0x000058, "Member 'FNavigationSegmentLink::LeftEnd' has a wrong offset!");
//(offsetof(FNavigationSegmentLink, RightStart) == 0x000070, "Member 'FNavigationSegmentLink::RightStart' has a wrong offset!");
//(offsetof(FNavigationSegmentLink, RightEnd) == 0x000088, "Member 'FNavigationSegmentLink::RightEnd' has a wrong offset!");

// ScriptStruct Engine.LatentActionInfo
// 0x0020 (0x0020 - 0x0000)
struct FLatentActionInfo final
{
public:
	int32                                         Linkage;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UUID;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExecutionFunction;                                 // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CallbackTarget;                                    // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FLatentActionInfo) == 0x000008, "Wrong alignment on FLatentActionInfo");
//(sizeof(FLatentActionInfo) == 0x000020, "Wrong size on FLatentActionInfo");
//(offsetof(FLatentActionInfo, Linkage) == 0x000000, "Member 'FLatentActionInfo::Linkage' has a wrong offset!");
//(offsetof(FLatentActionInfo, UUID) == 0x000004, "Member 'FLatentActionInfo::UUID' has a wrong offset!");
//(offsetof(FLatentActionInfo, ExecutionFunction) == 0x000008, "Member 'FLatentActionInfo::ExecutionFunction' has a wrong offset!");
//(offsetof(FLatentActionInfo, CallbackTarget) == 0x000018, "Member 'FLatentActionInfo::CallbackTarget' has a wrong offset!");

// ScriptStruct Engine.ClusterNode
// 0x0040 (0x0040 - 0x0000)
struct FClusterNode final
{
public:
	struct FVector3f                              BoundMin;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstChild;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              BoundMax;                                          // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastChild;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstInstance;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastInstance;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              MinInstanceScale;                                  // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              MaxInstanceScale;                                  // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FClusterNode) == 0x000004, "Wrong alignment on FClusterNode");
//(sizeof(FClusterNode) == 0x000040, "Wrong size on FClusterNode");
//(offsetof(FClusterNode, BoundMin) == 0x000000, "Member 'FClusterNode::BoundMin' has a wrong offset!");
//(offsetof(FClusterNode, FirstChild) == 0x00000C, "Member 'FClusterNode::FirstChild' has a wrong offset!");
//(offsetof(FClusterNode, BoundMax) == 0x000010, "Member 'FClusterNode::BoundMax' has a wrong offset!");
//(offsetof(FClusterNode, LastChild) == 0x00001C, "Member 'FClusterNode::LastChild' has a wrong offset!");
//(offsetof(FClusterNode, FirstInstance) == 0x000020, "Member 'FClusterNode::FirstInstance' has a wrong offset!");
//(offsetof(FClusterNode, LastInstance) == 0x000024, "Member 'FClusterNode::LastInstance' has a wrong offset!");
//(offsetof(FClusterNode, MinInstanceScale) == 0x000028, "Member 'FClusterNode::MinInstanceScale' has a wrong offset!");
//(offsetof(FClusterNode, MaxInstanceScale) == 0x000034, "Member 'FClusterNode::MaxInstanceScale' has a wrong offset!");

// ScriptStruct Engine.Vector_NetQuantize10
// 0x0000 (0x0018 - 0x0018)
struct FVector_NetQuantize10 final : public FVector
{
};
//(alignof(FVector_NetQuantize10) == 0x000008, "Wrong alignment on FVector_NetQuantize10");
//(sizeof(FVector_NetQuantize10) == 0x000018, "Wrong size on FVector_NetQuantize10");

// ScriptStruct Engine.TTTrackId
// 0x0008 (0x0008 - 0x0000)
struct FTTTrackId final
{
public:
	int32                                         TrackType;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrackIndex;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTTTrackId) == 0x000004, "Wrong alignment on FTTTrackId");
//(sizeof(FTTTrackId) == 0x000008, "Wrong size on FTTTrackId");
//(offsetof(FTTTrackId, TrackType) == 0x000000, "Member 'FTTTrackId::TrackType' has a wrong offset!");
//(offsetof(FTTTrackId, TrackIndex) == 0x000004, "Member 'FTTTrackId::TrackIndex' has a wrong offset!");

// ScriptStruct Engine.TimerHandle
// 0x0018 (0x0018 - 0x0000)
struct FTimerHandle final
{
public:
	uint64                                        Handle;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTimerHandle) == 0x000008, "Wrong alignment on FTimerHandle");
//(sizeof(FTimerHandle) == 0x000018, "Wrong size on FTimerHandle");
//(offsetof(FTimerHandle, Handle) == 0x000000, "Member 'FTimerHandle::Handle' has a wrong offset!");

// ScriptStruct Engine.GenericStruct
// 0x0004 (0x0004 - 0x0000)
struct FGenericStruct final
{
public:
	int32                                         Data;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FGenericStruct) == 0x000004, "Wrong alignment on FGenericStruct");
//(sizeof(FGenericStruct) == 0x000004, "Wrong size on FGenericStruct");
//(offsetof(FGenericStruct, Data) == 0x000000, "Member 'FGenericStruct::Data' has a wrong offset!");

// ScriptStruct Engine.MaterialProxySettings
// 0x00A0 (0x00A0 - 0x0000)
struct FMaterialProxySettings final
{
public:
	ETextureSizingType                            TextureSizingType;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              TextureSize;                                       // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTexelDensityPerMeter;                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshMaxScreenSizePercent;                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MeshMinDrawDistance;                               // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GutterSpace;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicConstant;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoughnessConstant;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnisotropyConstant;                                // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecularConstant;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpacityConstant;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpacityMaskConstant;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionConstant;                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialMergeType                            MaterialMergeType;                                 // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAllowTwoSidedMaterial : 1;                        // 0x0042(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNormalMap : 1;                                    // 0x0042(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTangentMap : 1;                                   // 0x0042(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMetallicMap : 1;                                  // 0x0042(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRoughnessMap : 1;                                 // 0x0042(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAnisotropyMap : 1;                                // 0x0042(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSpecularMap : 1;                                  // 0x0042(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEmissiveMap : 1;                                  // 0x0042(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOpacityMap : 1;                                   // 0x0043(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOpacityMaskMap : 1;                               // 0x0043(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAmbientOcclusionMap : 1;                          // 0x0043(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FIntPoint                              DiffuseTextureSize;                                // 0x0044(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              NormalTextureSize;                                 // 0x004C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              TangentTextureSize;                                // 0x0054(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              MetallicTextureSize;                               // 0x005C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              RoughnessTextureSize;                              // 0x0064(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              AnisotropyTextureSize;                             // 0x006C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              SpecularTextureSize;                               // 0x0074(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              EmissiveTextureSize;                               // 0x007C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              OpacityTextureSize;                                // 0x0084(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              OpacityMaskTextureSize;                            // 0x008C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              AmbientOcclusionTextureSize;                       // 0x0094(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMaterialProxySettings) == 0x000008, "Wrong alignment on FMaterialProxySettings");
//(sizeof(FMaterialProxySettings) == 0x0000A0, "Wrong size on FMaterialProxySettings");
//(offsetof(FMaterialProxySettings, TextureSizingType) == 0x000000, "Member 'FMaterialProxySettings::TextureSizingType' has a wrong offset!");
//(offsetof(FMaterialProxySettings, TextureSize) == 0x000004, "Member 'FMaterialProxySettings::TextureSize' has a wrong offset!");
//(offsetof(FMaterialProxySettings, TargetTexelDensityPerMeter) == 0x00000C, "Member 'FMaterialProxySettings::TargetTexelDensityPerMeter' has a wrong offset!");
//(offsetof(FMaterialProxySettings, MeshMaxScreenSizePercent) == 0x000010, "Member 'FMaterialProxySettings::MeshMaxScreenSizePercent' has a wrong offset!");
//(offsetof(FMaterialProxySettings, MeshMinDrawDistance) == 0x000018, "Member 'FMaterialProxySettings::MeshMinDrawDistance' has a wrong offset!");
//(offsetof(FMaterialProxySettings, GutterSpace) == 0x000020, "Member 'FMaterialProxySettings::GutterSpace' has a wrong offset!");
//(offsetof(FMaterialProxySettings, MetallicConstant) == 0x000024, "Member 'FMaterialProxySettings::MetallicConstant' has a wrong offset!");
//(offsetof(FMaterialProxySettings, RoughnessConstant) == 0x000028, "Member 'FMaterialProxySettings::RoughnessConstant' has a wrong offset!");
//(offsetof(FMaterialProxySettings, AnisotropyConstant) == 0x00002C, "Member 'FMaterialProxySettings::AnisotropyConstant' has a wrong offset!");
//(offsetof(FMaterialProxySettings, SpecularConstant) == 0x000030, "Member 'FMaterialProxySettings::SpecularConstant' has a wrong offset!");
//(offsetof(FMaterialProxySettings, OpacityConstant) == 0x000034, "Member 'FMaterialProxySettings::OpacityConstant' has a wrong offset!");
//(offsetof(FMaterialProxySettings, OpacityMaskConstant) == 0x000038, "Member 'FMaterialProxySettings::OpacityMaskConstant' has a wrong offset!");
//(offsetof(FMaterialProxySettings, AmbientOcclusionConstant) == 0x00003C, "Member 'FMaterialProxySettings::AmbientOcclusionConstant' has a wrong offset!");
//(offsetof(FMaterialProxySettings, MaterialMergeType) == 0x000040, "Member 'FMaterialProxySettings::MaterialMergeType' has a wrong offset!");
//(offsetof(FMaterialProxySettings, BlendMode) == 0x000041, "Member 'FMaterialProxySettings::BlendMode' has a wrong offset!");
//(offsetof(FMaterialProxySettings, DiffuseTextureSize) == 0x000044, "Member 'FMaterialProxySettings::DiffuseTextureSize' has a wrong offset!");
//(offsetof(FMaterialProxySettings, NormalTextureSize) == 0x00004C, "Member 'FMaterialProxySettings::NormalTextureSize' has a wrong offset!");
//(offsetof(FMaterialProxySettings, TangentTextureSize) == 0x000054, "Member 'FMaterialProxySettings::TangentTextureSize' has a wrong offset!");
//(offsetof(FMaterialProxySettings, MetallicTextureSize) == 0x00005C, "Member 'FMaterialProxySettings::MetallicTextureSize' has a wrong offset!");
//(offsetof(FMaterialProxySettings, RoughnessTextureSize) == 0x000064, "Member 'FMaterialProxySettings::RoughnessTextureSize' has a wrong offset!");
//(offsetof(FMaterialProxySettings, AnisotropyTextureSize) == 0x00006C, "Member 'FMaterialProxySettings::AnisotropyTextureSize' has a wrong offset!");
//(offsetof(FMaterialProxySettings, SpecularTextureSize) == 0x000074, "Member 'FMaterialProxySettings::SpecularTextureSize' has a wrong offset!");
//(offsetof(FMaterialProxySettings, EmissiveTextureSize) == 0x00007C, "Member 'FMaterialProxySettings::EmissiveTextureSize' has a wrong offset!");
//(offsetof(FMaterialProxySettings, OpacityTextureSize) == 0x000084, "Member 'FMaterialProxySettings::OpacityTextureSize' has a wrong offset!");
//(offsetof(FMaterialProxySettings, OpacityMaskTextureSize) == 0x00008C, "Member 'FMaterialProxySettings::OpacityMaskTextureSize' has a wrong offset!");
//(offsetof(FMaterialProxySettings, AmbientOcclusionTextureSize) == 0x000094, "Member 'FMaterialProxySettings::AmbientOcclusionTextureSize' has a wrong offset!");

// ScriptStruct Engine.MeshProxySettings
// 0x0100 (0x0100 - 0x0000)
struct FMeshProxySettings final
{
public:
	int32                                         ScreenSize;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoxelSize;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaterialProxySettings                 MaterialSettings;                                  // 0x0008(0x00A0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MergeDistance;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 UnresolvedGeometryColor;                           // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRayCastDist;                                    // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HardAngleThreshold;                                // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMapResolution;                                // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProxyNormalComputationMethod                 NormalCalculationMethod;                           // 0x00BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELandscapeCullingPrecision                    LandscapeCullingPrecision;                         // 0x00BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCalculateCorrectLODModel : 1;                     // 0x00BE(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideVoxelSize : 1;                            // 0x00BE(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideTransferDistance : 1;                     // 0x00BE(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseHardAngleThreshold : 1;                        // 0x00BE(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bComputeLightMapResolution : 1;                    // 0x00BE(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRecalculateNormals : 1;                           // 0x00BE(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseLandscapeCulling : 1;                          // 0x00BE(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportRayTracing : 1;                            // 0x00BE(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowDistanceField : 1;                           // 0x00BF(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReuseMeshLightmapUVs : 1;                         // 0x00BF(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroupIdenticalMeshesForBaking : 1;                // 0x00BF(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCreateCollision : 1;                              // 0x00BF(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowVertexColors : 1;                            // 0x00BF(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateLightmapUVs : 1;                          // 0x00BF(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FMeshNaniteSettings                    NaniteSettings;                                    // 0x00C0(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
//(alignof(FMeshProxySettings) == 0x000008, "Wrong alignment on FMeshProxySettings");
//(sizeof(FMeshProxySettings) == 0x000100, "Wrong size on FMeshProxySettings");
//(offsetof(FMeshProxySettings, ScreenSize) == 0x000000, "Member 'FMeshProxySettings::ScreenSize' has a wrong offset!");
//(offsetof(FMeshProxySettings, VoxelSize) == 0x000004, "Member 'FMeshProxySettings::VoxelSize' has a wrong offset!");
//(offsetof(FMeshProxySettings, MaterialSettings) == 0x000008, "Member 'FMeshProxySettings::MaterialSettings' has a wrong offset!");
//(offsetof(FMeshProxySettings, MergeDistance) == 0x0000A8, "Member 'FMeshProxySettings::MergeDistance' has a wrong offset!");
//(offsetof(FMeshProxySettings, UnresolvedGeometryColor) == 0x0000AC, "Member 'FMeshProxySettings::UnresolvedGeometryColor' has a wrong offset!");
//(offsetof(FMeshProxySettings, MaxRayCastDist) == 0x0000B0, "Member 'FMeshProxySettings::MaxRayCastDist' has a wrong offset!");
//(offsetof(FMeshProxySettings, HardAngleThreshold) == 0x0000B4, "Member 'FMeshProxySettings::HardAngleThreshold' has a wrong offset!");
//(offsetof(FMeshProxySettings, LightMapResolution) == 0x0000B8, "Member 'FMeshProxySettings::LightMapResolution' has a wrong offset!");
//(offsetof(FMeshProxySettings, NormalCalculationMethod) == 0x0000BC, "Member 'FMeshProxySettings::NormalCalculationMethod' has a wrong offset!");
//(offsetof(FMeshProxySettings, LandscapeCullingPrecision) == 0x0000BD, "Member 'FMeshProxySettings::LandscapeCullingPrecision' has a wrong offset!");
//(offsetof(FMeshProxySettings, NaniteSettings) == 0x0000C0, "Member 'FMeshProxySettings::NaniteSettings' has a wrong offset!");

// ScriptStruct Engine.EndPhysicsTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FEndPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FEndPhysicsTickFunction) == 0x000008, "Wrong alignment on FEndPhysicsTickFunction");
//(sizeof(FEndPhysicsTickFunction) == 0x000038, "Wrong size on FEndPhysicsTickFunction");

// ScriptStruct Engine.InstancedStaticMeshLightMapInstanceData
// 0x0070 (0x0070 - 0x0000)
struct FInstancedStaticMeshLightMapInstanceData final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          MapBuildDataIds;                                   // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FInstancedStaticMeshLightMapInstanceData) == 0x000010, "Wrong alignment on FInstancedStaticMeshLightMapInstanceData");
//(sizeof(FInstancedStaticMeshLightMapInstanceData) == 0x000070, "Wrong size on FInstancedStaticMeshLightMapInstanceData");
//(offsetof(FInstancedStaticMeshLightMapInstanceData, Transform) == 0x000000, "Member 'FInstancedStaticMeshLightMapInstanceData::Transform' has a wrong offset!");
//(offsetof(FInstancedStaticMeshLightMapInstanceData, MapBuildDataIds) == 0x000060, "Member 'FInstancedStaticMeshLightMapInstanceData::MapBuildDataIds' has a wrong offset!");

// ScriptStruct Engine.CollisionResponseContainer
// 0x0020 (0x0020 - 0x0000)
struct FCollisionResponseContainer final
{
public:
	ECollisionResponse                            WorldStatic;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            WorldDynamic;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Pawn;                                              // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Visibility;                                        // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Camera;                                            // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            PhysicsBody;                                       // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Vehicle;                                           // 0x0006(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Destructible;                                      // 0x0007(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            EngineTraceChannel1;                               // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel1;                                 // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel2;                                 // 0x000A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel3;                                 // 0x000B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel4;                                 // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel5;                                 // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel6;                                 // 0x000E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel7;                                 // 0x000F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel8;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel9;                                 // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel10;                                // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel11;                                // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel12;                                // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel13;                                // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel14;                                // 0x0016(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel15;                                // 0x0017(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel16;                                // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel17;                                // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel18;                                // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel19;                                // 0x001B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel20;                                // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel21;                                // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel22;                                // 0x001E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel23;                                // 0x001F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCollisionResponseContainer) == 0x000001, "Wrong alignment on FCollisionResponseContainer");
//(sizeof(FCollisionResponseContainer) == 0x000020, "Wrong size on FCollisionResponseContainer");
//(offsetof(FCollisionResponseContainer, WorldStatic) == 0x000000, "Member 'FCollisionResponseContainer::WorldStatic' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, WorldDynamic) == 0x000001, "Member 'FCollisionResponseContainer::WorldDynamic' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, Pawn) == 0x000002, "Member 'FCollisionResponseContainer::Pawn' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, Visibility) == 0x000003, "Member 'FCollisionResponseContainer::Visibility' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, Camera) == 0x000004, "Member 'FCollisionResponseContainer::Camera' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, PhysicsBody) == 0x000005, "Member 'FCollisionResponseContainer::PhysicsBody' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, Vehicle) == 0x000006, "Member 'FCollisionResponseContainer::Vehicle' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, Destructible) == 0x000007, "Member 'FCollisionResponseContainer::Destructible' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, EngineTraceChannel1) == 0x000008, "Member 'FCollisionResponseContainer::EngineTraceChannel1' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel1) == 0x000009, "Member 'FCollisionResponseContainer::GameTraceChannel1' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel2) == 0x00000A, "Member 'FCollisionResponseContainer::GameTraceChannel2' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel3) == 0x00000B, "Member 'FCollisionResponseContainer::GameTraceChannel3' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel4) == 0x00000C, "Member 'FCollisionResponseContainer::GameTraceChannel4' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel5) == 0x00000D, "Member 'FCollisionResponseContainer::GameTraceChannel5' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel6) == 0x00000E, "Member 'FCollisionResponseContainer::GameTraceChannel6' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel7) == 0x00000F, "Member 'FCollisionResponseContainer::GameTraceChannel7' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel8) == 0x000010, "Member 'FCollisionResponseContainer::GameTraceChannel8' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel9) == 0x000011, "Member 'FCollisionResponseContainer::GameTraceChannel9' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel10) == 0x000012, "Member 'FCollisionResponseContainer::GameTraceChannel10' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel11) == 0x000013, "Member 'FCollisionResponseContainer::GameTraceChannel11' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel12) == 0x000014, "Member 'FCollisionResponseContainer::GameTraceChannel12' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel13) == 0x000015, "Member 'FCollisionResponseContainer::GameTraceChannel13' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel14) == 0x000016, "Member 'FCollisionResponseContainer::GameTraceChannel14' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel15) == 0x000017, "Member 'FCollisionResponseContainer::GameTraceChannel15' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel16) == 0x000018, "Member 'FCollisionResponseContainer::GameTraceChannel16' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel17) == 0x000019, "Member 'FCollisionResponseContainer::GameTraceChannel17' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel18) == 0x00001A, "Member 'FCollisionResponseContainer::GameTraceChannel18' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel19) == 0x00001B, "Member 'FCollisionResponseContainer::GameTraceChannel19' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel20) == 0x00001C, "Member 'FCollisionResponseContainer::GameTraceChannel20' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel21) == 0x00001D, "Member 'FCollisionResponseContainer::GameTraceChannel21' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel22) == 0x00001E, "Member 'FCollisionResponseContainer::GameTraceChannel22' has a wrong offset!");
//(offsetof(FCollisionResponseContainer, GameTraceChannel23) == 0x00001F, "Member 'FCollisionResponseContainer::GameTraceChannel23' has a wrong offset!");

// ScriptStruct Engine.CollisionResponse
// 0x0030 (0x0030 - 0x0000)
struct FCollisionResponse final
{
public:
	struct FCollisionResponseContainer            ResponseToChannels;                                // 0x0000(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FResponseChannel>               ResponseArray;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
};
//(alignof(FCollisionResponse) == 0x000008, "Wrong alignment on FCollisionResponse");
//(sizeof(FCollisionResponse) == 0x000030, "Wrong size on FCollisionResponse");
//(offsetof(FCollisionResponse, ResponseToChannels) == 0x000000, "Member 'FCollisionResponse::ResponseToChannels' has a wrong offset!");
//(offsetof(FCollisionResponse, ResponseArray) == 0x000020, "Member 'FCollisionResponse::ResponseArray' has a wrong offset!");

// ScriptStruct Engine.DecalChannels
// 0x0001 (0x0001 - 0x0000)
struct FDecalChannels final
{
public:
	uint8                                         bChannel0 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bChannel1 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bChannel2 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bChannel3 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
//(alignof(FDecalChannels) == 0x000001, "Wrong alignment on FDecalChannels");
//(sizeof(FDecalChannels) == 0x000001, "Wrong size on FDecalChannels");

// ScriptStruct Engine.InertializationPoseDiff
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FInertializationPoseDiff final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FInertializationPoseDiff) == 0x000008, "Wrong alignment on FInertializationPoseDiff");
//(sizeof(FInertializationPoseDiff) == 0x000040, "Wrong size on FInertializationPoseDiff");

// ScriptStruct Engine.WalkableSlopeOverride
// 0x0010 (0x0010 - 0x0000)
struct FWalkableSlopeOverride final
{
public:
	EWalkableSlopeBehavior                        WalkableSlopeBehavior;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkableSlopeAngle;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FWalkableSlopeOverride) == 0x000004, "Wrong alignment on FWalkableSlopeOverride");
//(sizeof(FWalkableSlopeOverride) == 0x000010, "Wrong size on FWalkableSlopeOverride");
//(offsetof(FWalkableSlopeOverride, WalkableSlopeBehavior) == 0x000000, "Member 'FWalkableSlopeOverride::WalkableSlopeBehavior' has a wrong offset!");
//(offsetof(FWalkableSlopeOverride, WalkableSlopeAngle) == 0x000004, "Member 'FWalkableSlopeOverride::WalkableSlopeAngle' has a wrong offset!");

// ScriptStruct Engine.BodyInstance
// 0x0198 (0x01B0 - 0x0018)
struct FBodyInstance final : public FBodyInstanceCore
{
public:
	uint8                                         Pad_18[0x6];                                       // 0x0018(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	ECollisionChannel                             ObjectType;                                        // 0x001E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ECollisionEnabled                             CollisionEnabled;                                  // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21[0x38];                                      // 0x0021(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	ESleepFamily                                  SleepFamily;                                       // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDOFMode                                      DOFMode;                                           // 0x005A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BitPad_5B_0 : 1;                                   // 0x005B(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bSkipSyncUpdateGameAC : 1;                         // 0x005B(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseCCD : 1;                                       // 0x005B(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreAnalyticCollisions : 1;                     // 0x005B(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNotifyRigidBodyCollision : 1;                     // 0x005B(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_5B_5 : 1;                                   // 0x005B(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bKinematicKinematicPairs : 1;                      // 0x005B(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSmoothEdgeCollisions : 1;                         // 0x005B(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreChildrenMass : 1;                           // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityScale;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationDepth;                                  // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationMinPushOutScale;                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationMaxPushOutScale;                        // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLockTranslation : 1;                              // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockRotation : 1;                                 // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockXTranslation : 1;                             // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockYTranslation : 1;                             // 0x0070(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockZTranslation : 1;                             // 0x0070(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockXRotation : 1;                                // 0x0070(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockYRotation : 1;                                // 0x0070(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockZRotation : 1;                                // 0x0070(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideMaxAngularVelocity : 1;                   // 0x0071(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_71_1 : 2;                                   // 0x0071(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bOverrideMaxDepenetrationVelocity : 1;             // 0x0071(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverrideWalkableSlopeOnInstance : 1;              // 0x0071(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInterpolateWhenSubStepping : 1;                   // 0x0071(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_71_6 : 1;                                   // 0x0071(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bInertiaConditioning : 1;                          // 0x0071(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_72[0x1E];                                      // 0x0072(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionProfileName;                              // 0x0090(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         ContactPointNum;                                   // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PositionSolverIterationCount;                      // 0x009D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VelocitySolverIterationCount;                      // 0x009E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F[0x1];                                       // 0x009F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionResponse                     CollisionResponses;                                // 0x00A0(0x0030)(Edit, NativeAccessSpecifierPrivate)
	float                                         MaxDepenetrationVelocity;                          // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MassInKgOverride;                                  // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearDamping;                                     // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CustomDOFPlaneNormal;                              // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                COMNudge;                                          // 0x0100(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MassScale;                                         // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InertiaTensorScale;                                // 0x0120(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWalkableSlopeOverride                 WalkableSlopeOverride;                             // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	class UPhysicalMaterial*                      PhysMaterialOverride;                              // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAngularVelocity;                                // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomSleepThresholdMultiplier;                    // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StabilizationThresholdMultiplier;                  // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsBlendWeight;                                // 0x016C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170[0x40];                                     // 0x0170(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBodyInstance) == 0x000008, "Wrong alignment on FBodyInstance");
//(sizeof(FBodyInstance) == 0x0001B0, "Wrong size on FBodyInstance");
//(offsetof(FBodyInstance, ObjectType) == 0x00001E, "Member 'FBodyInstance::ObjectType' has a wrong offset!");
//(offsetof(FBodyInstance, CollisionEnabled) == 0x000020, "Member 'FBodyInstance::CollisionEnabled' has a wrong offset!");
//(offsetof(FBodyInstance, SleepFamily) == 0x000059, "Member 'FBodyInstance::SleepFamily' has a wrong offset!");
//(offsetof(FBodyInstance, DOFMode) == 0x00005A, "Member 'FBodyInstance::DOFMode' has a wrong offset!");
//(offsetof(FBodyInstance, GravityScale) == 0x000060, "Member 'FBodyInstance::GravityScale' has a wrong offset!");
//(offsetof(FBodyInstance, PenetrationDepth) == 0x000064, "Member 'FBodyInstance::PenetrationDepth' has a wrong offset!");
//(offsetof(FBodyInstance, PenetrationMinPushOutScale) == 0x000068, "Member 'FBodyInstance::PenetrationMinPushOutScale' has a wrong offset!");
//(offsetof(FBodyInstance, PenetrationMaxPushOutScale) == 0x00006C, "Member 'FBodyInstance::PenetrationMaxPushOutScale' has a wrong offset!");
//(offsetof(FBodyInstance, CollisionProfileName) == 0x000090, "Member 'FBodyInstance::CollisionProfileName' has a wrong offset!");
//(offsetof(FBodyInstance, ContactPointNum) == 0x00009C, "Member 'FBodyInstance::ContactPointNum' has a wrong offset!");
//(offsetof(FBodyInstance, PositionSolverIterationCount) == 0x00009D, "Member 'FBodyInstance::PositionSolverIterationCount' has a wrong offset!");
//(offsetof(FBodyInstance, VelocitySolverIterationCount) == 0x00009E, "Member 'FBodyInstance::VelocitySolverIterationCount' has a wrong offset!");
//(offsetof(FBodyInstance, CollisionResponses) == 0x0000A0, "Member 'FBodyInstance::CollisionResponses' has a wrong offset!");
//(offsetof(FBodyInstance, MaxDepenetrationVelocity) == 0x0000D0, "Member 'FBodyInstance::MaxDepenetrationVelocity' has a wrong offset!");
//(offsetof(FBodyInstance, MassInKgOverride) == 0x0000D4, "Member 'FBodyInstance::MassInKgOverride' has a wrong offset!");
//(offsetof(FBodyInstance, LinearDamping) == 0x0000E0, "Member 'FBodyInstance::LinearDamping' has a wrong offset!");
//(offsetof(FBodyInstance, AngularDamping) == 0x0000E4, "Member 'FBodyInstance::AngularDamping' has a wrong offset!");
//(offsetof(FBodyInstance, CustomDOFPlaneNormal) == 0x0000E8, "Member 'FBodyInstance::CustomDOFPlaneNormal' has a wrong offset!");
//(offsetof(FBodyInstance, COMNudge) == 0x000100, "Member 'FBodyInstance::COMNudge' has a wrong offset!");
//(offsetof(FBodyInstance, MassScale) == 0x000118, "Member 'FBodyInstance::MassScale' has a wrong offset!");
//(offsetof(FBodyInstance, InertiaTensorScale) == 0x000120, "Member 'FBodyInstance::InertiaTensorScale' has a wrong offset!");
//(offsetof(FBodyInstance, WalkableSlopeOverride) == 0x000148, "Member 'FBodyInstance::WalkableSlopeOverride' has a wrong offset!");
//(offsetof(FBodyInstance, PhysMaterialOverride) == 0x000158, "Member 'FBodyInstance::PhysMaterialOverride' has a wrong offset!");
//(offsetof(FBodyInstance, MaxAngularVelocity) == 0x000160, "Member 'FBodyInstance::MaxAngularVelocity' has a wrong offset!");
//(offsetof(FBodyInstance, CustomSleepThresholdMultiplier) == 0x000164, "Member 'FBodyInstance::CustomSleepThresholdMultiplier' has a wrong offset!");
//(offsetof(FBodyInstance, StabilizationThresholdMultiplier) == 0x000168, "Member 'FBodyInstance::StabilizationThresholdMultiplier' has a wrong offset!");
//(offsetof(FBodyInstance, PhysicsBlendWeight) == 0x00016C, "Member 'FBodyInstance::PhysicsBlendWeight' has a wrong offset!");

// ScriptStruct Engine.SimpleMemberReference
// 0x0028 (0x0028 - 0x0000)
struct FSimpleMemberReference final
{
public:
	class UObject*                                MemberParent;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemberName;                                        // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  MemberGuid;                                        // 0x0014(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSimpleMemberReference) == 0x000008, "Wrong alignment on FSimpleMemberReference");
//(sizeof(FSimpleMemberReference) == 0x000028, "Wrong size on FSimpleMemberReference");
//(offsetof(FSimpleMemberReference, MemberParent) == 0x000000, "Member 'FSimpleMemberReference::MemberParent' has a wrong offset!");
//(offsetof(FSimpleMemberReference, MemberName) == 0x000008, "Member 'FSimpleMemberReference::MemberName' has a wrong offset!");
//(offsetof(FSimpleMemberReference, MemberGuid) == 0x000014, "Member 'FSimpleMemberReference::MemberGuid' has a wrong offset!");

// ScriptStruct Engine.EdGraphPinType
// 0x0070 (0x0070 - 0x0000)
struct FEdGraphPinType final
{
public:
	class FName                                   PinCategory;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PinSubCategory;                                    // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 PinSubCategoryObject;                              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSimpleMemberReference                 PinSubCategoryMemberReference;                     // 0x0020(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FEdGraphTerminalType                   PinValueType;                                      // 0x0048(0x0024)(NoDestructor, NativeAccessSpecifierPublic)
	EPinContainerType                             ContainerType;                                     // 0x006C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsArray : 1;                                      // 0x006D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsReference : 1;                                  // 0x006D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsConst : 1;                                      // 0x006D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsWeakPointer : 1;                                // 0x006D(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsUObjectWrapper : 1;                             // 0x006D(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSerializeAsSinglePrecisionFloat : 1;              // 0x006D(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FEdGraphPinType) == 0x000008, "Wrong alignment on FEdGraphPinType");
//(sizeof(FEdGraphPinType) == 0x000070, "Wrong size on FEdGraphPinType");
//(offsetof(FEdGraphPinType, PinCategory) == 0x000000, "Member 'FEdGraphPinType::PinCategory' has a wrong offset!");
//(offsetof(FEdGraphPinType, PinSubCategory) == 0x00000C, "Member 'FEdGraphPinType::PinSubCategory' has a wrong offset!");
//(offsetof(FEdGraphPinType, PinSubCategoryObject) == 0x000018, "Member 'FEdGraphPinType::PinSubCategoryObject' has a wrong offset!");
//(offsetof(FEdGraphPinType, PinSubCategoryMemberReference) == 0x000020, "Member 'FEdGraphPinType::PinSubCategoryMemberReference' has a wrong offset!");
//(offsetof(FEdGraphPinType, PinValueType) == 0x000048, "Member 'FEdGraphPinType::PinValueType' has a wrong offset!");
//(offsetof(FEdGraphPinType, ContainerType) == 0x00006C, "Member 'FEdGraphPinType::ContainerType' has a wrong offset!");

// ScriptStruct Engine.BPVariableMetaDataEntry
// 0x0020 (0x0020 - 0x0000)
struct FBPVariableMetaDataEntry final
{
public:
	class FName                                   DataKey;                                           // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DataValue;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBPVariableMetaDataEntry) == 0x000008, "Wrong alignment on FBPVariableMetaDataEntry");
//(sizeof(FBPVariableMetaDataEntry) == 0x000020, "Wrong size on FBPVariableMetaDataEntry");
//(offsetof(FBPVariableMetaDataEntry, DataKey) == 0x000000, "Member 'FBPVariableMetaDataEntry::DataKey' has a wrong offset!");
//(offsetof(FBPVariableMetaDataEntry, DataValue) == 0x000010, "Member 'FBPVariableMetaDataEntry::DataValue' has a wrong offset!");

// ScriptStruct Engine.BPVariableDescription
// 0x00F0 (0x00F0 - 0x0000)
struct FBPVariableDescription final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  VarGuid;                                           // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEdGraphPinType                        VarType;                                           // 0x0020(0x0070)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 FriendlyName;                                      // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Category;                                          // 0x00A0(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint64                                        PropertyFlags;                                     // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RepNotifyFunc;                                     // 0x00C0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELifetimeCondition                            ReplicationCondition;                              // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBPVariableMetaDataEntry>       MetaDataArray;                                     // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 DefaultValue;                                      // 0x00E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBPVariableDescription) == 0x000008, "Wrong alignment on FBPVariableDescription");
//(sizeof(FBPVariableDescription) == 0x0000F0, "Wrong size on FBPVariableDescription");
//(offsetof(FBPVariableDescription, VarName) == 0x000000, "Member 'FBPVariableDescription::VarName' has a wrong offset!");
//(offsetof(FBPVariableDescription, VarGuid) == 0x00000C, "Member 'FBPVariableDescription::VarGuid' has a wrong offset!");
//(offsetof(FBPVariableDescription, VarType) == 0x000020, "Member 'FBPVariableDescription::VarType' has a wrong offset!");
//(offsetof(FBPVariableDescription, FriendlyName) == 0x000090, "Member 'FBPVariableDescription::FriendlyName' has a wrong offset!");
//(offsetof(FBPVariableDescription, Category) == 0x0000A0, "Member 'FBPVariableDescription::Category' has a wrong offset!");
//(offsetof(FBPVariableDescription, PropertyFlags) == 0x0000B8, "Member 'FBPVariableDescription::PropertyFlags' has a wrong offset!");
//(offsetof(FBPVariableDescription, RepNotifyFunc) == 0x0000C0, "Member 'FBPVariableDescription::RepNotifyFunc' has a wrong offset!");
//(offsetof(FBPVariableDescription, ReplicationCondition) == 0x0000CC, "Member 'FBPVariableDescription::ReplicationCondition' has a wrong offset!");
//(offsetof(FBPVariableDescription, MetaDataArray) == 0x0000D0, "Member 'FBPVariableDescription::MetaDataArray' has a wrong offset!");
//(offsetof(FBPVariableDescription, DefaultValue) == 0x0000E0, "Member 'FBPVariableDescription::DefaultValue' has a wrong offset!");

// ScriptStruct Engine.TableRowBase
// 0x0020 (0x0020 - 0x0000)
struct FTableRowBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Delivery;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BaseComment;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTableRowBase) == 0x000008, "Wrong alignment on FTableRowBase");
//(sizeof(FTableRowBase) == 0x000020, "Wrong size on FTableRowBase");
//(offsetof(FTableRowBase, Delivery) == 0x000008, "Member 'FTableRowBase::Delivery' has a wrong offset!");
//(offsetof(FTableRowBase, BaseComment) == 0x000010, "Member 'FTableRowBase::BaseComment' has a wrong offset!");

// ScriptStruct Engine.MirrorTableRow
// 0x0020 (0x0040 - 0x0020)
struct FMirrorTableRow final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MirroredName;                                      // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMirrorRowType                                MirrorEntryType;                                   // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMirrorTableRow) == 0x000008, "Wrong alignment on FMirrorTableRow");
//(sizeof(FMirrorTableRow) == 0x000040, "Wrong size on FMirrorTableRow");
//(offsetof(FMirrorTableRow, Name) == 0x000020, "Member 'FMirrorTableRow::Name' has a wrong offset!");
//(offsetof(FMirrorTableRow, MirroredName) == 0x00002C, "Member 'FMirrorTableRow::MirroredName' has a wrong offset!");
//(offsetof(FMirrorTableRow, MirrorEntryType) == 0x000038, "Member 'FMirrorTableRow::MirrorEntryType' has a wrong offset!");

// ScriptStruct Engine.CustomPrimitiveMaterialsData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCustomPrimitiveMaterialsData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCustomPrimitiveMaterialsData) == 0x000008, "Wrong alignment on FCustomPrimitiveMaterialsData");
//(sizeof(FCustomPrimitiveMaterialsData) == 0x000018, "Wrong size on FCustomPrimitiveMaterialsData");

// ScriptStruct Engine.CustomDefine
// 0x0020 (0x0020 - 0x0000)
struct FCustomDefine final
{
public:
	class FString                                 DefineName;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefineValue;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCustomDefine) == 0x000008, "Wrong alignment on FCustomDefine");
//(sizeof(FCustomDefine) == 0x000020, "Wrong size on FCustomDefine");
//(offsetof(FCustomDefine, DefineName) == 0x000000, "Member 'FCustomDefine::DefineName' has a wrong offset!");
//(offsetof(FCustomDefine, DefineValue) == 0x000010, "Member 'FCustomDefine::DefineValue' has a wrong offset!");

// ScriptStruct Engine.AnimationTrackPayload
// 0x000C (0x000C - 0x0000)
struct FAnimationTrackPayload : public FEmptyPayload
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimationTrackPayload) == 0x000004, "Wrong alignment on FAnimationTrackPayload");
//(sizeof(FAnimationTrackPayload) == 0x00000C, "Wrong size on FAnimationTrackPayload");
//(offsetof(FAnimationTrackPayload, Name) == 0x000000, "Member 'FAnimationTrackPayload::Name' has a wrong offset!");

// ScriptStruct Engine.AnimNode_TransitionPoseEvaluator
// 0x00A0 (0x00C8 - 0x0028)
struct FAnimNode_TransitionPoseEvaluator final : public FAnimNode_Base
{
public:
	uint8                                         Pad_28[0x80];                                      // 0x0028(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FramesToCachePose;                                 // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EEvaluatorDataSource                          DataSource;                                        // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEvaluatorMode                                EvaluatorMode;                                     // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x16];                                      // 0x00B2(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_TransitionPoseEvaluator) == 0x000008, "Wrong alignment on FAnimNode_TransitionPoseEvaluator");
//(sizeof(FAnimNode_TransitionPoseEvaluator) == 0x0000C8, "Wrong size on FAnimNode_TransitionPoseEvaluator");
//(offsetof(FAnimNode_TransitionPoseEvaluator, FramesToCachePose) == 0x0000A8, "Member 'FAnimNode_TransitionPoseEvaluator::FramesToCachePose' has a wrong offset!");
//(offsetof(FAnimNode_TransitionPoseEvaluator, DataSource) == 0x0000B0, "Member 'FAnimNode_TransitionPoseEvaluator::DataSource' has a wrong offset!");
//(offsetof(FAnimNode_TransitionPoseEvaluator, EvaluatorMode) == 0x0000B1, "Member 'FAnimNode_TransitionPoseEvaluator::EvaluatorMode' has a wrong offset!");

// ScriptStruct Engine.HardwareDeviceIdentifier
// 0x0020 (0x0020 - 0x0000)
struct FHardwareDeviceIdentifier final
{
public:
	class FName                                   InputClassName;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HardwareDeviceIdentifier;                          // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHardwareDevicePrimaryType                    PrimaryDeviceType;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SupportedFeaturesMask;                             // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FHardwareDeviceIdentifier) == 0x000004, "Wrong alignment on FHardwareDeviceIdentifier");
//(sizeof(FHardwareDeviceIdentifier) == 0x000020, "Wrong size on FHardwareDeviceIdentifier");
//(offsetof(FHardwareDeviceIdentifier, InputClassName) == 0x000000, "Member 'FHardwareDeviceIdentifier::InputClassName' has a wrong offset!");
//(offsetof(FHardwareDeviceIdentifier, HardwareDeviceIdentifier) == 0x00000C, "Member 'FHardwareDeviceIdentifier::HardwareDeviceIdentifier' has a wrong offset!");
//(offsetof(FHardwareDeviceIdentifier, PrimaryDeviceType) == 0x000018, "Member 'FHardwareDeviceIdentifier::PrimaryDeviceType' has a wrong offset!");
//(offsetof(FHardwareDeviceIdentifier, SupportedFeaturesMask) == 0x00001C, "Member 'FHardwareDeviceIdentifier::SupportedFeaturesMask' has a wrong offset!");

// ScriptStruct Engine.RepMovement
// 0x0070 (0x0070 - 0x0000)
struct FRepMovement final
{
public:
	struct FVector                                LinearVelocity;                                    // 0x0000(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocity;                                   // 0x0018(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0048(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bSimulatedPhysicSleep : 1;                         // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRepPhysics : 1;                                   // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ServerFrame;                                       // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ServerPhysicsHandle;                               // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVectorQuantization                           LocationQuantizationLevel;                         // 0x006C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVectorQuantization                           VelocityQuantizationLevel;                         // 0x006D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotatorQuantization                          RotationQuantizationLevel;                         // 0x006E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F[0x1];                                       // 0x006F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRepMovement) == 0x000008, "Wrong alignment on FRepMovement");
//(sizeof(FRepMovement) == 0x000070, "Wrong size on FRepMovement");
//(offsetof(FRepMovement, LinearVelocity) == 0x000000, "Member 'FRepMovement::LinearVelocity' has a wrong offset!");
//(offsetof(FRepMovement, AngularVelocity) == 0x000018, "Member 'FRepMovement::AngularVelocity' has a wrong offset!");
//(offsetof(FRepMovement, Location) == 0x000030, "Member 'FRepMovement::Location' has a wrong offset!");
//(offsetof(FRepMovement, Rotation) == 0x000048, "Member 'FRepMovement::Rotation' has a wrong offset!");
//(offsetof(FRepMovement, ServerFrame) == 0x000064, "Member 'FRepMovement::ServerFrame' has a wrong offset!");
//(offsetof(FRepMovement, ServerPhysicsHandle) == 0x000068, "Member 'FRepMovement::ServerPhysicsHandle' has a wrong offset!");
//(offsetof(FRepMovement, LocationQuantizationLevel) == 0x00006C, "Member 'FRepMovement::LocationQuantizationLevel' has a wrong offset!");
//(offsetof(FRepMovement, VelocityQuantizationLevel) == 0x00006D, "Member 'FRepMovement::VelocityQuantizationLevel' has a wrong offset!");
//(offsetof(FRepMovement, RotationQuantizationLevel) == 0x00006E, "Member 'FRepMovement::RotationQuantizationLevel' has a wrong offset!");

// ScriptStruct Engine.GPUSpriteLocalVectorFieldInfo
// 0x00D0 (0x00D0 - 0x0000)
struct FGPUSpriteLocalVectorFieldInfo final
{
public:
	class UVectorField*                           Field;                                             // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MinInitialRotation;                                // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MaxInitialRotation;                                // 0x0088(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotationRate;                                      // 0x00A0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tightness;                                         // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreComponentTransform : 1;                     // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTileX : 1;                                        // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTileY : 1;                                        // 0x00C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTileZ : 1;                                        // 0x00C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFixDT : 1;                                     // 0x00C0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FGPUSpriteLocalVectorFieldInfo) == 0x000010, "Wrong alignment on FGPUSpriteLocalVectorFieldInfo");
//(sizeof(FGPUSpriteLocalVectorFieldInfo) == 0x0000D0, "Wrong size on FGPUSpriteLocalVectorFieldInfo");
//(offsetof(FGPUSpriteLocalVectorFieldInfo, Field) == 0x000000, "Member 'FGPUSpriteLocalVectorFieldInfo::Field' has a wrong offset!");
//(offsetof(FGPUSpriteLocalVectorFieldInfo, Transform) == 0x000010, "Member 'FGPUSpriteLocalVectorFieldInfo::Transform' has a wrong offset!");
//(offsetof(FGPUSpriteLocalVectorFieldInfo, MinInitialRotation) == 0x000070, "Member 'FGPUSpriteLocalVectorFieldInfo::MinInitialRotation' has a wrong offset!");
//(offsetof(FGPUSpriteLocalVectorFieldInfo, MaxInitialRotation) == 0x000088, "Member 'FGPUSpriteLocalVectorFieldInfo::MaxInitialRotation' has a wrong offset!");
//(offsetof(FGPUSpriteLocalVectorFieldInfo, RotationRate) == 0x0000A0, "Member 'FGPUSpriteLocalVectorFieldInfo::RotationRate' has a wrong offset!");
//(offsetof(FGPUSpriteLocalVectorFieldInfo, Intensity) == 0x0000B8, "Member 'FGPUSpriteLocalVectorFieldInfo::Intensity' has a wrong offset!");
//(offsetof(FGPUSpriteLocalVectorFieldInfo, Tightness) == 0x0000BC, "Member 'FGPUSpriteLocalVectorFieldInfo::Tightness' has a wrong offset!");

// ScriptStruct Engine.AnimNodeStructData
// 0x0058 (0x0058 - 0x0000)
struct FAnimNodeStructData final
{
public:
	TMap<class FName, int32>                      NameToIndexMap;                                    // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
	int32                                         NumProperties;                                     // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNodeStructData) == 0x000008, "Wrong alignment on FAnimNodeStructData");
//(sizeof(FAnimNodeStructData) == 0x000058, "Wrong size on FAnimNodeStructData");
//(offsetof(FAnimNodeStructData, NameToIndexMap) == 0x000000, "Member 'FAnimNodeStructData::NameToIndexMap' has a wrong offset!");
//(offsetof(FAnimNodeStructData, NumProperties) == 0x000050, "Member 'FAnimNodeStructData::NumProperties' has a wrong offset!");

// ScriptStruct Engine.SingleAnimationPlayData
// 0x0018 (0x0018 - 0x0000)
struct FSingleAnimationPlayData final
{
public:
	class UAnimationAsset*                        AnimToPlay;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSavedLooping : 1;                                 // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSavedPlaying : 1;                                 // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SavedPosition;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SavedPlayRate;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSingleAnimationPlayData) == 0x000008, "Wrong alignment on FSingleAnimationPlayData");
//(sizeof(FSingleAnimationPlayData) == 0x000018, "Wrong size on FSingleAnimationPlayData");
//(offsetof(FSingleAnimationPlayData, AnimToPlay) == 0x000000, "Member 'FSingleAnimationPlayData::AnimToPlay' has a wrong offset!");
//(offsetof(FSingleAnimationPlayData, SavedPosition) == 0x00000C, "Member 'FSingleAnimationPlayData::SavedPosition' has a wrong offset!");
//(offsetof(FSingleAnimationPlayData, SavedPlayRate) == 0x000010, "Member 'FSingleAnimationPlayData::SavedPlayRate' has a wrong offset!");

// ScriptStruct Engine.AssetManagerRedirect
// 0x0020 (0x0020 - 0x0000)
struct FAssetManagerRedirect final
{
public:
	class FString                                 Old;                                               // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 New;                                               // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAssetManagerRedirect) == 0x000008, "Wrong alignment on FAssetManagerRedirect");
//(sizeof(FAssetManagerRedirect) == 0x000020, "Wrong size on FAssetManagerRedirect");
//(offsetof(FAssetManagerRedirect, Old) == 0x000000, "Member 'FAssetManagerRedirect::Old' has a wrong offset!");
//(offsetof(FAssetManagerRedirect, New) == 0x000010, "Member 'FAssetManagerRedirect::New' has a wrong offset!");

// ScriptStruct Engine.BaseMoveLogicFrame
// 0x0130 (0x0130 - 0x0000)
struct alignas(0x08) FBaseMoveLogicFrame final
{
public:
	uint8                                         Pad_0[0x130];                                      // 0x0000(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBaseMoveLogicFrame) == 0x000008, "Wrong alignment on FBaseMoveLogicFrame");
//(sizeof(FBaseMoveLogicFrame) == 0x000130, "Wrong size on FBaseMoveLogicFrame");

// ScriptStruct Engine.DebugDisplayProperty
// 0x0020 (0x0020 - 0x0000)
struct FDebugDisplayProperty final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    WithinClass;                                       // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDebugDisplayProperty) == 0x000008, "Wrong alignment on FDebugDisplayProperty");
//(sizeof(FDebugDisplayProperty) == 0x000020, "Wrong size on FDebugDisplayProperty");
//(offsetof(FDebugDisplayProperty, Obj) == 0x000000, "Member 'FDebugDisplayProperty::Obj' has a wrong offset!");
//(offsetof(FDebugDisplayProperty, WithinClass) == 0x000008, "Member 'FDebugDisplayProperty::WithinClass' has a wrong offset!");

// ScriptStruct Engine.SourceEffectChainEntry
// 0x0010 (0x0010 - 0x0000)
struct FSourceEffectChainEntry final
{
public:
	class USoundEffectSourcePreset*               Preset;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bBypass : 1;                                       // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSourceEffectChainEntry) == 0x000008, "Wrong alignment on FSourceEffectChainEntry");
//(sizeof(FSourceEffectChainEntry) == 0x000010, "Wrong size on FSourceEffectChainEntry");
//(offsetof(FSourceEffectChainEntry, Preset) == 0x000000, "Member 'FSourceEffectChainEntry::Preset' has a wrong offset!");

// ScriptStruct Engine.WorldPartitionRuntimeCellDebugInfo
// 0x0038 (0x0038 - 0x0000)
struct FWorldPartitionRuntimeCellDebugInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GridName;                                          // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         CoordX;                                            // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CoordY;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CoordZ;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FWorldPartitionRuntimeCellDebugInfo) == 0x000008, "Wrong alignment on FWorldPartitionRuntimeCellDebugInfo");
//(sizeof(FWorldPartitionRuntimeCellDebugInfo) == 0x000038, "Wrong size on FWorldPartitionRuntimeCellDebugInfo");
//(offsetof(FWorldPartitionRuntimeCellDebugInfo, Name) == 0x000000, "Member 'FWorldPartitionRuntimeCellDebugInfo::Name' has a wrong offset!");
//(offsetof(FWorldPartitionRuntimeCellDebugInfo, GridName) == 0x000010, "Member 'FWorldPartitionRuntimeCellDebugInfo::GridName' has a wrong offset!");
//(offsetof(FWorldPartitionRuntimeCellDebugInfo, CoordX) == 0x000020, "Member 'FWorldPartitionRuntimeCellDebugInfo::CoordX' has a wrong offset!");
//(offsetof(FWorldPartitionRuntimeCellDebugInfo, CoordY) == 0x000028, "Member 'FWorldPartitionRuntimeCellDebugInfo::CoordY' has a wrong offset!");
//(offsetof(FWorldPartitionRuntimeCellDebugInfo, CoordZ) == 0x000030, "Member 'FWorldPartitionRuntimeCellDebugInfo::CoordZ' has a wrong offset!");

// ScriptStruct Engine.NavLinkId
// 0x0008 (0x0008 - 0x0000)
struct FNavLinkId final
{
public:
	uint64                                        ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FNavLinkId) == 0x000008, "Wrong alignment on FNavLinkId");
//(sizeof(FNavLinkId) == 0x000008, "Wrong size on FNavLinkId");
//(offsetof(FNavLinkId, ID) == 0x000000, "Member 'FNavLinkId::ID' has a wrong offset!");

// ScriptStruct Engine.AnimGroupInstance
// 0x0088 (0x0088 - 0x0000)
struct alignas(0x08) FAnimGroupInstance final
{
public:
	uint8                                         Pad_0[0x88];                                       // 0x0000(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimGroupInstance) == 0x000008, "Wrong alignment on FAnimGroupInstance");
//(sizeof(FAnimGroupInstance) == 0x000088, "Wrong size on FAnimGroupInstance");

// ScriptStruct Engine.PerPlatformInt
// 0x0004 (0x0004 - 0x0000)
struct FPerPlatformInt final
{
public:
	int32                                         Default;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPerPlatformInt) == 0x000004, "Wrong alignment on FPerPlatformInt");
//(sizeof(FPerPlatformInt) == 0x000004, "Wrong size on FPerPlatformInt");
//(offsetof(FPerPlatformInt, Default) == 0x000000, "Member 'FPerPlatformInt::Default' has a wrong offset!");

// ScriptStruct Engine.PerQualityLevelInt
// 0x0068 (0x0068 - 0x0000)
struct FPerQualityLevelInt final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Default;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            PerQuality;                                        // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
};
//(alignof(FPerQualityLevelInt) == 0x000008, "Wrong alignment on FPerQualityLevelInt");
//(sizeof(FPerQualityLevelInt) == 0x000068, "Wrong size on FPerQualityLevelInt");
//(offsetof(FPerQualityLevelInt, Default) == 0x000010, "Member 'FPerQualityLevelInt::Default' has a wrong offset!");
//(offsetof(FPerQualityLevelInt, PerQuality) == 0x000018, "Member 'FPerQualityLevelInt::PerQuality' has a wrong offset!");

// ScriptStruct Engine.PerQualityLevelFloat
// 0x0068 (0x0068 - 0x0000)
struct FPerQualityLevelFloat final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Default;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            PerQuality;                                        // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
};
//(alignof(FPerQualityLevelFloat) == 0x000008, "Wrong alignment on FPerQualityLevelFloat");
//(sizeof(FPerQualityLevelFloat) == 0x000068, "Wrong size on FPerQualityLevelFloat");
//(offsetof(FPerQualityLevelFloat, Default) == 0x000010, "Member 'FPerQualityLevelFloat::Default' has a wrong offset!");
//(offsetof(FPerQualityLevelFloat, PerQuality) == 0x000018, "Member 'FPerQualityLevelFloat::PerQuality' has a wrong offset!");

// ScriptStruct Engine.AnimSubsystemInstance
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FAnimSubsystemInstance
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimSubsystemInstance) == 0x000008, "Wrong alignment on FAnimSubsystemInstance");
//(sizeof(FAnimSubsystemInstance) == 0x000008, "Wrong size on FAnimSubsystemInstance");

// ScriptStruct Engine.LinkedAnimLayerInstanceData
// 0x0060 (0x0060 - 0x0000)
struct FLinkedAnimLayerInstanceData final
{
public:
	class UAnimInstance*                          Instance;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TWeakObjectPtr<class UAnimInstance>> LinkedFunctions;                                   // 0x0008(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLinkedAnimLayerInstanceData) == 0x000008, "Wrong alignment on FLinkedAnimLayerInstanceData");
//(sizeof(FLinkedAnimLayerInstanceData) == 0x000060, "Wrong size on FLinkedAnimLayerInstanceData");
//(offsetof(FLinkedAnimLayerInstanceData, Instance) == 0x000000, "Member 'FLinkedAnimLayerInstanceData::Instance' has a wrong offset!");
//(offsetof(FLinkedAnimLayerInstanceData, LinkedFunctions) == 0x000008, "Member 'FLinkedAnimLayerInstanceData::LinkedFunctions' has a wrong offset!");

// ScriptStruct Engine.LinkedAnimLayerClassData
// 0x0020 (0x0020 - 0x0000)
struct FLinkedAnimLayerClassData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinkedAnimLayerInstanceData>   InstancesData;                                     // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLinkedAnimLayerClassData) == 0x000008, "Wrong alignment on FLinkedAnimLayerClassData");
//(sizeof(FLinkedAnimLayerClassData) == 0x000020, "Wrong size on FLinkedAnimLayerClassData");
//(offsetof(FLinkedAnimLayerClassData, InstancesData) == 0x000008, "Member 'FLinkedAnimLayerClassData::InstancesData' has a wrong offset!");

// ScriptStruct Engine.AnimSubsystem_SharedLinkedAnimLayers
// 0x0020 (0x0028 - 0x0008)
struct FAnimSubsystem_SharedLinkedAnimLayers final : public FAnimSubsystemInstance
{
public:
	TArray<struct FLinkedAnimLayerClassData>      ClassesData;                                       // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UAnimInstance>>      PersistentClasses;                                 // 0x0018(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
};
//(alignof(FAnimSubsystem_SharedLinkedAnimLayers) == 0x000008, "Wrong alignment on FAnimSubsystem_SharedLinkedAnimLayers");
//(sizeof(FAnimSubsystem_SharedLinkedAnimLayers) == 0x000028, "Wrong size on FAnimSubsystem_SharedLinkedAnimLayers");
//(offsetof(FAnimSubsystem_SharedLinkedAnimLayers, ClassesData) == 0x000008, "Member 'FAnimSubsystem_SharedLinkedAnimLayers::ClassesData' has a wrong offset!");
//(offsetof(FAnimSubsystem_SharedLinkedAnimLayers, PersistentClasses) == 0x000018, "Member 'FAnimSubsystem_SharedLinkedAnimLayers::PersistentClasses' has a wrong offset!");

// ScriptStruct Engine.PerPlatformFloat
// 0x0004 (0x0004 - 0x0000)
struct FPerPlatformFloat final
{
public:
	float                                         Default;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPerPlatformFloat) == 0x000004, "Wrong alignment on FPerPlatformFloat");
//(sizeof(FPerPlatformFloat) == 0x000004, "Wrong size on FPerPlatformFloat");
//(offsetof(FPerPlatformFloat, Default) == 0x000000, "Member 'FPerPlatformFloat::Default' has a wrong offset!");

// ScriptStruct Engine.KeyHandleLookupTable
// 0x0088 (0x0088 - 0x0000)
struct alignas(0x08) FKeyHandleLookupTable
{
public:
	uint8                                         Pad_0[0x88];                                       // 0x0000(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FKeyHandleLookupTable) == 0x000008, "Wrong alignment on FKeyHandleLookupTable");
//(sizeof(FKeyHandleLookupTable) == 0x000088, "Wrong size on FKeyHandleLookupTable");

// ScriptStruct Engine.LensImperfectionSettings
// 0x0020 (0x0020 - 0x0000)
struct FLensImperfectionSettings final
{
public:
	class UTexture*                               DirtMask;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirtMaskIntensity;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DirtMaskTint;                                      // 0x000C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLensImperfectionSettings) == 0x000008, "Wrong alignment on FLensImperfectionSettings");
//(sizeof(FLensImperfectionSettings) == 0x000020, "Wrong size on FLensImperfectionSettings");
//(offsetof(FLensImperfectionSettings, DirtMask) == 0x000000, "Member 'FLensImperfectionSettings::DirtMask' has a wrong offset!");
//(offsetof(FLensImperfectionSettings, DirtMaskIntensity) == 0x000008, "Member 'FLensImperfectionSettings::DirtMaskIntensity' has a wrong offset!");
//(offsetof(FLensImperfectionSettings, DirtMaskTint) == 0x00000C, "Member 'FLensImperfectionSettings::DirtMaskTint' has a wrong offset!");

// ScriptStruct Engine.PassiveSoundMixModifier
// 0x0010 (0x0010 - 0x0000)
struct FPassiveSoundMixModifier final
{
public:
	class USoundMix*                              SoundMix;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVolumeThreshold;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVolumeThreshold;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPassiveSoundMixModifier) == 0x000008, "Wrong alignment on FPassiveSoundMixModifier");
//(sizeof(FPassiveSoundMixModifier) == 0x000010, "Wrong size on FPassiveSoundMixModifier");
//(offsetof(FPassiveSoundMixModifier, SoundMix) == 0x000000, "Member 'FPassiveSoundMixModifier::SoundMix' has a wrong offset!");
//(offsetof(FPassiveSoundMixModifier, MinVolumeThreshold) == 0x000008, "Member 'FPassiveSoundMixModifier::MinVolumeThreshold' has a wrong offset!");
//(offsetof(FPassiveSoundMixModifier, MaxVolumeThreshold) == 0x00000C, "Member 'FPassiveSoundMixModifier::MaxVolumeThreshold' has a wrong offset!");

// ScriptStruct Engine.StaticMeshBudgetInfo
// 0x0018 (0x0018 - 0x0000)
struct FStaticMeshBudgetInfo final
{
public:
	class FName                                   LodGroupName;                                      // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MinimumExtent;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FStaticMeshBudgetInfo) == 0x000008, "Wrong alignment on FStaticMeshBudgetInfo");
//(sizeof(FStaticMeshBudgetInfo) == 0x000018, "Wrong size on FStaticMeshBudgetInfo");
//(offsetof(FStaticMeshBudgetInfo, LodGroupName) == 0x000000, "Member 'FStaticMeshBudgetInfo::LodGroupName' has a wrong offset!");
//(offsetof(FStaticMeshBudgetInfo, MinimumExtent) == 0x000010, "Member 'FStaticMeshBudgetInfo::MinimumExtent' has a wrong offset!");

// ScriptStruct Engine.AnimNode_Root
// 0x0010 (0x0038 - 0x0028)
struct FAnimNode_Root : public FAnimNode_Base
{
public:
	struct FPoseLink                              Result;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FAnimNode_Root) == 0x000008, "Wrong alignment on FAnimNode_Root");
//(sizeof(FAnimNode_Root) == 0x000038, "Wrong size on FAnimNode_Root");
//(offsetof(FAnimNode_Root, Result) == 0x000028, "Member 'FAnimNode_Root::Result' has a wrong offset!");

// ScriptStruct Engine.ConvolutionBloomSettings
// 0x0030 (0x0030 - 0x0000)
struct FConvolutionBloomSettings final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScatterDispersion;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CenterUV;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreFilterMin;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreFilterMax;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreFilterMult;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BufferScale;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FConvolutionBloomSettings) == 0x000008, "Wrong alignment on FConvolutionBloomSettings");
//(sizeof(FConvolutionBloomSettings) == 0x000030, "Wrong size on FConvolutionBloomSettings");
//(offsetof(FConvolutionBloomSettings, Texture) == 0x000000, "Member 'FConvolutionBloomSettings::Texture' has a wrong offset!");
//(offsetof(FConvolutionBloomSettings, ScatterDispersion) == 0x000008, "Member 'FConvolutionBloomSettings::ScatterDispersion' has a wrong offset!");
//(offsetof(FConvolutionBloomSettings, Size) == 0x00000C, "Member 'FConvolutionBloomSettings::Size' has a wrong offset!");
//(offsetof(FConvolutionBloomSettings, CenterUV) == 0x000010, "Member 'FConvolutionBloomSettings::CenterUV' has a wrong offset!");
//(offsetof(FConvolutionBloomSettings, PreFilterMin) == 0x000020, "Member 'FConvolutionBloomSettings::PreFilterMin' has a wrong offset!");
//(offsetof(FConvolutionBloomSettings, PreFilterMax) == 0x000024, "Member 'FConvolutionBloomSettings::PreFilterMax' has a wrong offset!");
//(offsetof(FConvolutionBloomSettings, PreFilterMult) == 0x000028, "Member 'FConvolutionBloomSettings::PreFilterMult' has a wrong offset!");
//(offsetof(FConvolutionBloomSettings, BufferScale) == 0x00002C, "Member 'FConvolutionBloomSettings::BufferScale' has a wrong offset!");

// ScriptStruct Engine.StaticMeshOptimizationSettings
// 0x001C (0x001C - 0x0000)
struct FStaticMeshOptimizationSettings final
{
public:
	EOptimizationType                             ReductionMethod;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NumOfTrianglesPercentage;                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDeviationPercentage;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeldingThreshold;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecalcNormals;                                    // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalsThreshold;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SilhouetteImportance;                              // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TextureImportance;                                 // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShadingImportance;                                 // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStaticMeshOptimizationSettings) == 0x000004, "Wrong alignment on FStaticMeshOptimizationSettings");
//(sizeof(FStaticMeshOptimizationSettings) == 0x00001C, "Wrong size on FStaticMeshOptimizationSettings");
//(offsetof(FStaticMeshOptimizationSettings, ReductionMethod) == 0x000000, "Member 'FStaticMeshOptimizationSettings::ReductionMethod' has a wrong offset!");
//(offsetof(FStaticMeshOptimizationSettings, NumOfTrianglesPercentage) == 0x000004, "Member 'FStaticMeshOptimizationSettings::NumOfTrianglesPercentage' has a wrong offset!");
//(offsetof(FStaticMeshOptimizationSettings, MaxDeviationPercentage) == 0x000008, "Member 'FStaticMeshOptimizationSettings::MaxDeviationPercentage' has a wrong offset!");
//(offsetof(FStaticMeshOptimizationSettings, WeldingThreshold) == 0x00000C, "Member 'FStaticMeshOptimizationSettings::WeldingThreshold' has a wrong offset!");
//(offsetof(FStaticMeshOptimizationSettings, bRecalcNormals) == 0x000010, "Member 'FStaticMeshOptimizationSettings::bRecalcNormals' has a wrong offset!");
//(offsetof(FStaticMeshOptimizationSettings, NormalsThreshold) == 0x000014, "Member 'FStaticMeshOptimizationSettings::NormalsThreshold' has a wrong offset!");
//(offsetof(FStaticMeshOptimizationSettings, SilhouetteImportance) == 0x000018, "Member 'FStaticMeshOptimizationSettings::SilhouetteImportance' has a wrong offset!");
//(offsetof(FStaticMeshOptimizationSettings, TextureImportance) == 0x000019, "Member 'FStaticMeshOptimizationSettings::TextureImportance' has a wrong offset!");
//(offsetof(FStaticMeshOptimizationSettings, ShadingImportance) == 0x00001A, "Member 'FStaticMeshOptimizationSettings::ShadingImportance' has a wrong offset!");

// ScriptStruct Engine.OverlapResult
// 0x0040 (0x0040 - 0x0000)
struct FOverlapResult final
{
public:
	struct FActorInstanceHandle                   OverlapObjectHandle;                               // 0x0000(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x4];                                       // 0x0020(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bBlockingHit : 1;                                  // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ComponentLocation;                                 // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FOverlapResult) == 0x000008, "Wrong alignment on FOverlapResult");
//(sizeof(FOverlapResult) == 0x000040, "Wrong size on FOverlapResult");
//(offsetof(FOverlapResult, OverlapObjectHandle) == 0x000000, "Member 'FOverlapResult::OverlapObjectHandle' has a wrong offset!");
//(offsetof(FOverlapResult, Component) == 0x000018, "Member 'FOverlapResult::Component' has a wrong offset!");
//(offsetof(FOverlapResult, ComponentLocation) == 0x000028, "Member 'FOverlapResult::ComponentLocation' has a wrong offset!");

// ScriptStruct Engine.ComponentSpacePoseLink
// 0x0000 (0x0010 - 0x0010)
struct FComponentSpacePoseLink final : public FPoseLinkBase
{
};
//(alignof(FComponentSpacePoseLink) == 0x000008, "Wrong alignment on FComponentSpacePoseLink");
//(sizeof(FComponentSpacePoseLink) == 0x000010, "Wrong size on FComponentSpacePoseLink");

// ScriptStruct Engine.ScenePaintMaterial
// 0x0010 (0x0010 - 0x0000)
struct FScenePaintMaterial final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScenePaintType                               PaintType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedGrow;                                         // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FScenePaintMaterial) == 0x000008, "Wrong alignment on FScenePaintMaterial");
//(sizeof(FScenePaintMaterial) == 0x000010, "Wrong size on FScenePaintMaterial");
//(offsetof(FScenePaintMaterial, Material) == 0x000000, "Member 'FScenePaintMaterial::Material' has a wrong offset!");
//(offsetof(FScenePaintMaterial, PaintType) == 0x000008, "Member 'FScenePaintMaterial::PaintType' has a wrong offset!");
//(offsetof(FScenePaintMaterial, bNeedGrow) == 0x000009, "Member 'FScenePaintMaterial::bNeedGrow' has a wrong offset!");

// ScriptStruct Engine.BoneReference
// 0x0014 (0x0014 - 0x0000)
struct FBoneReference final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x8];                                        // 0x000C(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBoneReference) == 0x000004, "Wrong alignment on FBoneReference");
//(sizeof(FBoneReference) == 0x000014, "Wrong size on FBoneReference");
//(offsetof(FBoneReference, BoneName) == 0x000000, "Member 'FBoneReference::BoneName' has a wrong offset!");

// ScriptStruct Engine.SocketReference
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FSocketReference final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x14];                                      // 0x006C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSocketReference) == 0x000010, "Wrong alignment on FSocketReference");
//(sizeof(FSocketReference) == 0x000080, "Wrong size on FSocketReference");
//(offsetof(FSocketReference, SocketName) == 0x000060, "Member 'FSocketReference::SocketName' has a wrong offset!");

// ScriptStruct Engine.BoneSocketTarget
// 0x00A0 (0x00A0 - 0x0000)
struct FBoneSocketTarget final
{
public:
	bool                                          bUseSocket;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         BoneReference;                                     // 0x0004(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSocketReference                       SocketReference;                                   // 0x0020(0x0080)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FBoneSocketTarget) == 0x000010, "Wrong alignment on FBoneSocketTarget");
//(sizeof(FBoneSocketTarget) == 0x0000A0, "Wrong size on FBoneSocketTarget");
//(offsetof(FBoneSocketTarget, bUseSocket) == 0x000000, "Member 'FBoneSocketTarget::bUseSocket' has a wrong offset!");
//(offsetof(FBoneSocketTarget, BoneReference) == 0x000004, "Member 'FBoneSocketTarget::BoneReference' has a wrong offset!");
//(offsetof(FBoneSocketTarget, SocketReference) == 0x000020, "Member 'FBoneSocketTarget::SocketReference' has a wrong offset!");

// ScriptStruct Engine.ConstraintBaseParams
// 0x0014 (0x0014 - 0x0000)
struct FConstraintBaseParams
{
public:
	float                                         Stiffness;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Restitution;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactDistance;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSoftConstraint : 1;                               // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FConstraintBaseParams) == 0x000004, "Wrong alignment on FConstraintBaseParams");
//(sizeof(FConstraintBaseParams) == 0x000014, "Wrong size on FConstraintBaseParams");
//(offsetof(FConstraintBaseParams, Stiffness) == 0x000000, "Member 'FConstraintBaseParams::Stiffness' has a wrong offset!");
//(offsetof(FConstraintBaseParams, Damping) == 0x000004, "Member 'FConstraintBaseParams::Damping' has a wrong offset!");
//(offsetof(FConstraintBaseParams, Restitution) == 0x000008, "Member 'FConstraintBaseParams::Restitution' has a wrong offset!");
//(offsetof(FConstraintBaseParams, ContactDistance) == 0x00000C, "Member 'FConstraintBaseParams::ContactDistance' has a wrong offset!");

// ScriptStruct Engine.LinearConstraint
// 0x0008 (0x001C - 0x0014)
struct FLinearConstraint final : public FConstraintBaseParams
{
public:
	float                                         Limit;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELinearConstraintMotion                       XMotion;                                           // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELinearConstraintMotion                       YMotion;                                           // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELinearConstraintMotion                       ZMotion;                                           // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLinearConstraint) == 0x000004, "Wrong alignment on FLinearConstraint");
//(sizeof(FLinearConstraint) == 0x00001C, "Wrong size on FLinearConstraint");
//(offsetof(FLinearConstraint, Limit) == 0x000014, "Member 'FLinearConstraint::Limit' has a wrong offset!");
//(offsetof(FLinearConstraint, XMotion) == 0x000018, "Member 'FLinearConstraint::XMotion' has a wrong offset!");
//(offsetof(FLinearConstraint, YMotion) == 0x000019, "Member 'FLinearConstraint::YMotion' has a wrong offset!");
//(offsetof(FLinearConstraint, ZMotion) == 0x00001A, "Member 'FLinearConstraint::ZMotion' has a wrong offset!");

// ScriptStruct Engine.ConeConstraint
// 0x000C (0x0020 - 0x0014)
struct FConeConstraint final : public FConstraintBaseParams
{
public:
	float                                         Swing1LimitDegrees;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swing2LimitDegrees;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngularConstraintMotion                      Swing1Motion;                                      // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngularConstraintMotion                      Swing2Motion;                                      // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FConeConstraint) == 0x000004, "Wrong alignment on FConeConstraint");
//(sizeof(FConeConstraint) == 0x000020, "Wrong size on FConeConstraint");
//(offsetof(FConeConstraint, Swing1LimitDegrees) == 0x000014, "Member 'FConeConstraint::Swing1LimitDegrees' has a wrong offset!");
//(offsetof(FConeConstraint, Swing2LimitDegrees) == 0x000018, "Member 'FConeConstraint::Swing2LimitDegrees' has a wrong offset!");
//(offsetof(FConeConstraint, Swing1Motion) == 0x00001C, "Member 'FConeConstraint::Swing1Motion' has a wrong offset!");
//(offsetof(FConeConstraint, Swing2Motion) == 0x00001D, "Member 'FConeConstraint::Swing2Motion' has a wrong offset!");

// ScriptStruct Engine.TwistConstraint
// 0x0008 (0x001C - 0x0014)
struct FTwistConstraint final : public FConstraintBaseParams
{
public:
	float                                         TwistLimitDegrees;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngularConstraintMotion                      TwistMotion;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTwistConstraint) == 0x000004, "Wrong alignment on FTwistConstraint");
//(sizeof(FTwistConstraint) == 0x00001C, "Wrong size on FTwistConstraint");
//(offsetof(FTwistConstraint, TwistLimitDegrees) == 0x000014, "Member 'FTwistConstraint::TwistLimitDegrees' has a wrong offset!");
//(offsetof(FTwistConstraint, TwistMotion) == 0x000018, "Member 'FTwistConstraint::TwistMotion' has a wrong offset!");

// ScriptStruct Engine.LinearDriveConstraint
// 0x0068 (0x0068 - 0x0000)
struct FLinearDriveConstraint final
{
public:
	struct FVector                                PositionTarget;                                    // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityTarget;                                    // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConstraintDrive                       XDrive;                                            // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FConstraintDrive                       YDrive;                                            // 0x0040(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FConstraintDrive                       ZDrive;                                            // 0x0050(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bEnablePositionDrive : 1;                          // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLinearDriveConstraint) == 0x000008, "Wrong alignment on FLinearDriveConstraint");
//(sizeof(FLinearDriveConstraint) == 0x000068, "Wrong size on FLinearDriveConstraint");
//(offsetof(FLinearDriveConstraint, PositionTarget) == 0x000000, "Member 'FLinearDriveConstraint::PositionTarget' has a wrong offset!");
//(offsetof(FLinearDriveConstraint, VelocityTarget) == 0x000018, "Member 'FLinearDriveConstraint::VelocityTarget' has a wrong offset!");
//(offsetof(FLinearDriveConstraint, XDrive) == 0x000030, "Member 'FLinearDriveConstraint::XDrive' has a wrong offset!");
//(offsetof(FLinearDriveConstraint, YDrive) == 0x000040, "Member 'FLinearDriveConstraint::YDrive' has a wrong offset!");
//(offsetof(FLinearDriveConstraint, ZDrive) == 0x000050, "Member 'FLinearDriveConstraint::ZDrive' has a wrong offset!");

// ScriptStruct Engine.ConstraintProfileProperties
// 0x0160 (0x0160 - 0x0000)
struct FConstraintProfileProperties final
{
public:
	float                                         ProjectionLinearTolerance;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectionAngularTolerance;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectionLinearAlpha;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectionAngularAlpha;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShockPropagationAlpha;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearBreakThreshold;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearPlasticityThreshold;                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularBreakThreshold;                             // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularPlasticityThreshold;                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactTransferScale;                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearConstraint                      LinearLimit;                                       // 0x0028(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FConeConstraint                        ConeLimit;                                         // 0x0044(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTwistConstraint                       TwistLimit;                                        // 0x0064(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bSkipSyncToGame : 1;                               // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableCollision : 1;                             // 0x0080(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bParentDominates : 1;                              // 0x0080(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableShockPropagation : 1;                       // 0x0080(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableProjection : 1;                             // 0x0080(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableMassConditioning : 1;                       // 0x0080(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAngularBreakable : 1;                             // 0x0080(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAngularPlasticity : 1;                            // 0x0080(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLinearBreakable : 1;                              // 0x0081(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLinearPlasticity : 1;                             // 0x0081(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearDriveConstraint                 LinearDrive;                                       // 0x0088(0x0068)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAngularDriveConstraint                AngularDrive;                                      // 0x00F0(0x0068)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EConstraintPlasticityType                     LinearPlasticityType;                              // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FConstraintProfileProperties) == 0x000008, "Wrong alignment on FConstraintProfileProperties");
//(sizeof(FConstraintProfileProperties) == 0x000160, "Wrong size on FConstraintProfileProperties");
//(offsetof(FConstraintProfileProperties, ProjectionLinearTolerance) == 0x000000, "Member 'FConstraintProfileProperties::ProjectionLinearTolerance' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, ProjectionAngularTolerance) == 0x000004, "Member 'FConstraintProfileProperties::ProjectionAngularTolerance' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, ProjectionLinearAlpha) == 0x000008, "Member 'FConstraintProfileProperties::ProjectionLinearAlpha' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, ProjectionAngularAlpha) == 0x00000C, "Member 'FConstraintProfileProperties::ProjectionAngularAlpha' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, ShockPropagationAlpha) == 0x000010, "Member 'FConstraintProfileProperties::ShockPropagationAlpha' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, LinearBreakThreshold) == 0x000014, "Member 'FConstraintProfileProperties::LinearBreakThreshold' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, LinearPlasticityThreshold) == 0x000018, "Member 'FConstraintProfileProperties::LinearPlasticityThreshold' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, AngularBreakThreshold) == 0x00001C, "Member 'FConstraintProfileProperties::AngularBreakThreshold' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, AngularPlasticityThreshold) == 0x000020, "Member 'FConstraintProfileProperties::AngularPlasticityThreshold' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, ContactTransferScale) == 0x000024, "Member 'FConstraintProfileProperties::ContactTransferScale' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, LinearLimit) == 0x000028, "Member 'FConstraintProfileProperties::LinearLimit' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, ConeLimit) == 0x000044, "Member 'FConstraintProfileProperties::ConeLimit' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, TwistLimit) == 0x000064, "Member 'FConstraintProfileProperties::TwistLimit' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, LinearDrive) == 0x000088, "Member 'FConstraintProfileProperties::LinearDrive' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, AngularDrive) == 0x0000F0, "Member 'FConstraintProfileProperties::AngularDrive' has a wrong offset!");
//(offsetof(FConstraintProfileProperties, LinearPlasticityType) == 0x000158, "Member 'FConstraintProfileProperties::LinearPlasticityType' has a wrong offset!");

// ScriptStruct Engine.PhysicsConstraintProfileHandle
// 0x0170 (0x0170 - 0x0000)
struct FPhysicsConstraintProfileHandle final
{
public:
	struct FConstraintProfileProperties           ProfileProperties;                                 // 0x0000(0x0160)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0160(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPhysicsConstraintProfileHandle) == 0x000008, "Wrong alignment on FPhysicsConstraintProfileHandle");
//(sizeof(FPhysicsConstraintProfileHandle) == 0x000170, "Wrong size on FPhysicsConstraintProfileHandle");
//(offsetof(FPhysicsConstraintProfileHandle, ProfileProperties) == 0x000000, "Member 'FPhysicsConstraintProfileHandle::ProfileProperties' has a wrong offset!");
//(offsetof(FPhysicsConstraintProfileHandle, ProfileName) == 0x000160, "Member 'FPhysicsConstraintProfileHandle::ProfileName' has a wrong offset!");

// ScriptStruct Engine.QuaternionAnimationAttribute
// 0x0020 (0x0020 - 0x0000)
struct FQuaternionAnimationAttribute
{
public:
	struct FQuat                                  Value;                                             // 0x0000(0x0020)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FQuaternionAnimationAttribute) == 0x000010, "Wrong alignment on FQuaternionAnimationAttribute");
//(sizeof(FQuaternionAnimationAttribute) == 0x000020, "Wrong size on FQuaternionAnimationAttribute");
//(offsetof(FQuaternionAnimationAttribute, Value) == 0x000000, "Member 'FQuaternionAnimationAttribute::Value' has a wrong offset!");

// ScriptStruct Engine.RootMotionSourceStatus
// 0x0001 (0x0001 - 0x0000)
struct FRootMotionSourceStatus final
{
public:
	uint8                                         Flags;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRootMotionSourceStatus) == 0x000001, "Wrong alignment on FRootMotionSourceStatus");
//(sizeof(FRootMotionSourceStatus) == 0x000001, "Wrong size on FRootMotionSourceStatus");
//(offsetof(FRootMotionSourceStatus, Flags) == 0x000000, "Member 'FRootMotionSourceStatus::Flags' has a wrong offset!");

// ScriptStruct Engine.RootMotionSourceNetworkState
// 0x0028 (0x0028 - 0x0000)
struct FRootMotionSourceNetworkState final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PredictionID;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRootMotionSourceStatus                Status;                                            // 0x0020(0x0001)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x1];                                       // 0x0021(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        LocalID;                                           // 0x0022(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRootMotionSourceNetworkState) == 0x000008, "Wrong alignment on FRootMotionSourceNetworkState");
//(sizeof(FRootMotionSourceNetworkState) == 0x000028, "Wrong size on FRootMotionSourceNetworkState");
//(offsetof(FRootMotionSourceNetworkState, StartTime) == 0x000008, "Member 'FRootMotionSourceNetworkState::StartTime' has a wrong offset!");
//(offsetof(FRootMotionSourceNetworkState, ElapsedTime) == 0x00000C, "Member 'FRootMotionSourceNetworkState::ElapsedTime' has a wrong offset!");
//(offsetof(FRootMotionSourceNetworkState, PredictionID) == 0x000010, "Member 'FRootMotionSourceNetworkState::PredictionID' has a wrong offset!");
//(offsetof(FRootMotionSourceNetworkState, Status) == 0x000020, "Member 'FRootMotionSourceNetworkState::Status' has a wrong offset!");
//(offsetof(FRootMotionSourceNetworkState, LocalID) == 0x000022, "Member 'FRootMotionSourceNetworkState::LocalID' has a wrong offset!");

// ScriptStruct Engine.RadialDamageParams
// 0x0014 (0x0014 - 0x0000)
struct FRadialDamageParams final
{
public:
	float                                         BaseDamage;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDamage;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageFalloff;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRadialDamageParams) == 0x000004, "Wrong alignment on FRadialDamageParams");
//(sizeof(FRadialDamageParams) == 0x000014, "Wrong size on FRadialDamageParams");
//(offsetof(FRadialDamageParams, BaseDamage) == 0x000000, "Member 'FRadialDamageParams::BaseDamage' has a wrong offset!");
//(offsetof(FRadialDamageParams, MinimumDamage) == 0x000004, "Member 'FRadialDamageParams::MinimumDamage' has a wrong offset!");
//(offsetof(FRadialDamageParams, InnerRadius) == 0x000008, "Member 'FRadialDamageParams::InnerRadius' has a wrong offset!");
//(offsetof(FRadialDamageParams, OuterRadius) == 0x00000C, "Member 'FRadialDamageParams::OuterRadius' has a wrong offset!");
//(offsetof(FRadialDamageParams, DamageFalloff) == 0x000010, "Member 'FRadialDamageParams::DamageFalloff' has a wrong offset!");

// ScriptStruct Engine.RadialDamageEvent
// 0x0040 (0x0050 - 0x0010)
struct FRadialDamageEvent final : public FDamageEvent
{
public:
	struct FRadialDamageParams                    Params;                                            // 0x0010(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Origin;                                            // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     ComponentHits;                                     // 0x0040(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
//(alignof(FRadialDamageEvent) == 0x000008, "Wrong alignment on FRadialDamageEvent");
//(sizeof(FRadialDamageEvent) == 0x000050, "Wrong size on FRadialDamageEvent");
//(offsetof(FRadialDamageEvent, Params) == 0x000010, "Member 'FRadialDamageEvent::Params' has a wrong offset!");
//(offsetof(FRadialDamageEvent, Origin) == 0x000028, "Member 'FRadialDamageEvent::Origin' has a wrong offset!");
//(offsetof(FRadialDamageEvent, ComponentHits) == 0x000040, "Member 'FRadialDamageEvent::ComponentHits' has a wrong offset!");

// ScriptStruct Engine.AnimNodeReference
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAnimNodeReference
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNodeReference) == 0x000008, "Wrong alignment on FAnimNodeReference");
//(sizeof(FAnimNodeReference) == 0x000010, "Wrong size on FAnimNodeReference");

// ScriptStruct Engine.AniNodeCacheBase
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FAniNodeCacheBase
{
};
#pragma pack(pop)
//(alignof(FAniNodeCacheBase) == 0x000001, "Wrong alignment on FAniNodeCacheBase");
//(sizeof(FAniNodeCacheBase) == 0x000001, "Wrong size on FAniNodeCacheBase");

// ScriptStruct Engine.MaterialCachedParameterEditorInfo
// 0x0038 (0x0038 - 0x0000)
struct FMaterialCachedParameterEditorInfo final
{
public:
	class FString                                 Description;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Group;                                             // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssetIndex;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0024(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMaterialCachedParameterEditorInfo) == 0x000008, "Wrong alignment on FMaterialCachedParameterEditorInfo");
//(sizeof(FMaterialCachedParameterEditorInfo) == 0x000038, "Wrong size on FMaterialCachedParameterEditorInfo");
//(offsetof(FMaterialCachedParameterEditorInfo, Description) == 0x000000, "Member 'FMaterialCachedParameterEditorInfo::Description' has a wrong offset!");
//(offsetof(FMaterialCachedParameterEditorInfo, Group) == 0x000010, "Member 'FMaterialCachedParameterEditorInfo::Group' has a wrong offset!");
//(offsetof(FMaterialCachedParameterEditorInfo, SortPriority) == 0x00001C, "Member 'FMaterialCachedParameterEditorInfo::SortPriority' has a wrong offset!");
//(offsetof(FMaterialCachedParameterEditorInfo, AssetIndex) == 0x000020, "Member 'FMaterialCachedParameterEditorInfo::AssetIndex' has a wrong offset!");
//(offsetof(FMaterialCachedParameterEditorInfo, ExpressionGUID) == 0x000024, "Member 'FMaterialCachedParameterEditorInfo::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.MaterialCachedParameterEditorEntry
// 0x0010 (0x0010 - 0x0000)
struct FMaterialCachedParameterEditorEntry final
{
public:
	TArray<struct FMaterialCachedParameterEditorInfo> EditorInfo;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialCachedParameterEditorEntry) == 0x000008, "Wrong alignment on FMaterialCachedParameterEditorEntry");
//(sizeof(FMaterialCachedParameterEditorEntry) == 0x000010, "Wrong size on FMaterialCachedParameterEditorEntry");
//(offsetof(FMaterialCachedParameterEditorEntry, EditorInfo) == 0x000000, "Member 'FMaterialCachedParameterEditorEntry::EditorInfo' has a wrong offset!");

// ScriptStruct Engine.ParameterChannelNames
// 0x0060 (0x0060 - 0x0000)
struct FParameterChannelNames final
{
public:
	class FText                                   R;                                                 // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   G;                                                 // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   B;                                                 // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   A;                                                 // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
};
//(alignof(FParameterChannelNames) == 0x000008, "Wrong alignment on FParameterChannelNames");
//(sizeof(FParameterChannelNames) == 0x000060, "Wrong size on FParameterChannelNames");
//(offsetof(FParameterChannelNames, R) == 0x000000, "Member 'FParameterChannelNames::R' has a wrong offset!");
//(offsetof(FParameterChannelNames, G) == 0x000018, "Member 'FParameterChannelNames::G' has a wrong offset!");
//(offsetof(FParameterChannelNames, B) == 0x000030, "Member 'FParameterChannelNames::B' has a wrong offset!");
//(offsetof(FParameterChannelNames, A) == 0x000048, "Member 'FParameterChannelNames::A' has a wrong offset!");

// ScriptStruct Engine.MaterialCachedExpressionEditorOnlyData
// 0x01F8 (0x01F8 - 0x0000)
struct FMaterialCachedExpressionEditorOnlyData final
{
public:
	struct FMaterialCachedParameterEntry          EditorOnlyEntries;                                 // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	struct FMaterialCachedParameterEditorEntry    EditorEntries[0x9];                                // 0x0050(0x0010)(NativeAccessSpecifierPublic)
	TArray<bool>                                  StaticSwitchValues;                                // 0x00E0(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FStaticComponentMaskValue>      StaticComponentMaskValues;                         // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      ScalarMinMaxValues;                                // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCurveLinearColor>> ScalarCurveValues;                                 // 0x0110(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCurveLinearColorAtlas>> ScalarCurveAtlasValues;                            // 0x0120(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FParameterChannelNames>         VectorChannelNameValues;                           // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  VectorUsedAsChannelMaskValues;                     // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FParameterChannelNames>         TextureChannelNameValues;                          // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FMaterialLayersFunctionsEditorOnlyData MaterialLayers;                                    // 0x0160(0x0078)(NativeAccessSpecifierPublic)
	TArray<class FString>                         AssetPaths;                                        // 0x01D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           LandscapeLayerNames;                               // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialCachedExpressionEditorOnlyData) == 0x000008, "Wrong alignment on FMaterialCachedExpressionEditorOnlyData");
//(sizeof(FMaterialCachedExpressionEditorOnlyData) == 0x0001F8, "Wrong size on FMaterialCachedExpressionEditorOnlyData");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, EditorOnlyEntries) == 0x000000, "Member 'FMaterialCachedExpressionEditorOnlyData::EditorOnlyEntries' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, EditorEntries) == 0x000050, "Member 'FMaterialCachedExpressionEditorOnlyData::EditorEntries' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, StaticSwitchValues) == 0x0000E0, "Member 'FMaterialCachedExpressionEditorOnlyData::StaticSwitchValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, StaticComponentMaskValues) == 0x0000F0, "Member 'FMaterialCachedExpressionEditorOnlyData::StaticComponentMaskValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, ScalarMinMaxValues) == 0x000100, "Member 'FMaterialCachedExpressionEditorOnlyData::ScalarMinMaxValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, ScalarCurveValues) == 0x000110, "Member 'FMaterialCachedExpressionEditorOnlyData::ScalarCurveValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, ScalarCurveAtlasValues) == 0x000120, "Member 'FMaterialCachedExpressionEditorOnlyData::ScalarCurveAtlasValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, VectorChannelNameValues) == 0x000130, "Member 'FMaterialCachedExpressionEditorOnlyData::VectorChannelNameValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, VectorUsedAsChannelMaskValues) == 0x000140, "Member 'FMaterialCachedExpressionEditorOnlyData::VectorUsedAsChannelMaskValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, TextureChannelNameValues) == 0x000150, "Member 'FMaterialCachedExpressionEditorOnlyData::TextureChannelNameValues' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, MaterialLayers) == 0x000160, "Member 'FMaterialCachedExpressionEditorOnlyData::MaterialLayers' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, AssetPaths) == 0x0001D8, "Member 'FMaterialCachedExpressionEditorOnlyData::AssetPaths' has a wrong offset!");
//(offsetof(FMaterialCachedExpressionEditorOnlyData, LandscapeLayerNames) == 0x0001E8, "Member 'FMaterialCachedExpressionEditorOnlyData::LandscapeLayerNames' has a wrong offset!");

// ScriptStruct Engine.AnimNode_AssetPlayerRelevancyBase
// 0x0000 (0x0028 - 0x0028)
struct FAnimNode_AssetPlayerRelevancyBase : public FAnimNode_Base
{
};
//(alignof(FAnimNode_AssetPlayerRelevancyBase) == 0x000008, "Wrong alignment on FAnimNode_AssetPlayerRelevancyBase");
//(sizeof(FAnimNode_AssetPlayerRelevancyBase) == 0x000028, "Wrong size on FAnimNode_AssetPlayerRelevancyBase");

// ScriptStruct Engine.TTTrackBase
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FTTTrackBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TrackName;                                         // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsExternalCurve;                                  // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTTTrackBase) == 0x000008, "Wrong alignment on FTTTrackBase");
//(sizeof(FTTTrackBase) == 0x000018, "Wrong size on FTTTrackBase");
//(offsetof(FTTTrackBase, TrackName) == 0x000008, "Member 'FTTTrackBase::TrackName' has a wrong offset!");
//(offsetof(FTTTrackBase, bIsExternalCurve) == 0x000014, "Member 'FTTTrackBase::bIsExternalCurve' has a wrong offset!");

// ScriptStruct Engine.TTPropertyTrack
// 0x0010 (0x0028 - 0x0018)
struct FTTPropertyTrack : public FTTTrackBase
{
public:
	class FName                                   PropertyName;                                      // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTTPropertyTrack) == 0x000008, "Wrong alignment on FTTPropertyTrack");
//(sizeof(FTTPropertyTrack) == 0x000028, "Wrong size on FTTPropertyTrack");
//(offsetof(FTTPropertyTrack, PropertyName) == 0x000018, "Member 'FTTPropertyTrack::PropertyName' has a wrong offset!");

// ScriptStruct Engine.TTLinearColorTrack
// 0x0008 (0x0030 - 0x0028)
struct FTTLinearColorTrack final : public FTTPropertyTrack
{
public:
	class UCurveLinearColor*                      CurveLinearColor;                                  // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTTLinearColorTrack) == 0x000008, "Wrong alignment on FTTLinearColorTrack");
//(sizeof(FTTLinearColorTrack) == 0x000030, "Wrong size on FTTLinearColorTrack");
//(offsetof(FTTLinearColorTrack, CurveLinearColor) == 0x000028, "Member 'FTTLinearColorTrack::CurveLinearColor' has a wrong offset!");

// ScriptStruct Engine.BakedFloatCustomAttribute
// 0x0001 (0x0001 - 0x0000)
struct FBakedFloatCustomAttribute final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBakedFloatCustomAttribute) == 0x000001, "Wrong alignment on FBakedFloatCustomAttribute");
//(sizeof(FBakedFloatCustomAttribute) == 0x000001, "Wrong size on FBakedFloatCustomAttribute");

// ScriptStruct Engine.AnimNode_AssetPlayerBase
// 0x0028 (0x0050 - 0x0028)
struct FAnimNode_AssetPlayerBase : public FAnimNode_AssetPlayerRelevancyBase
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendWeight;                                       // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InternalTimeAccumulator;                           // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_AssetPlayerBase) == 0x000008, "Wrong alignment on FAnimNode_AssetPlayerBase");
//(sizeof(FAnimNode_AssetPlayerBase) == 0x000050, "Wrong size on FAnimNode_AssetPlayerBase");
//(offsetof(FAnimNode_AssetPlayerBase, BlendWeight) == 0x000038, "Member 'FAnimNode_AssetPlayerBase::BlendWeight' has a wrong offset!");
//(offsetof(FAnimNode_AssetPlayerBase, InternalTimeAccumulator) == 0x00003C, "Member 'FAnimNode_AssetPlayerBase::InternalTimeAccumulator' has a wrong offset!");

// ScriptStruct Engine.SectionReference
// 0x0004 (0x0004 - 0x0000)
struct FSectionReference final
{
public:
	int32                                         SectionIndex;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSectionReference) == 0x000004, "Wrong alignment on FSectionReference");
//(sizeof(FSectionReference) == 0x000004, "Wrong size on FSectionReference");
//(offsetof(FSectionReference, SectionIndex) == 0x000000, "Member 'FSectionReference::SectionIndex' has a wrong offset!");

// ScriptStruct Engine.URL
// 0x0070 (0x0070 - 0x0000)
struct FURL final
{
public:
	class FString                                 Protocol;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Host;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Valid;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Map;                                               // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RedirectURL;                                       // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Op;                                                // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Portal;                                            // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreGameMode;                                    // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FURL) == 0x000008, "Wrong alignment on FURL");
//(sizeof(FURL) == 0x000070, "Wrong size on FURL");
//(offsetof(FURL, Protocol) == 0x000000, "Member 'FURL::Protocol' has a wrong offset!");
//(offsetof(FURL, Host) == 0x000010, "Member 'FURL::Host' has a wrong offset!");
//(offsetof(FURL, Port) == 0x000020, "Member 'FURL::Port' has a wrong offset!");
//(offsetof(FURL, Valid) == 0x000024, "Member 'FURL::Valid' has a wrong offset!");
//(offsetof(FURL, Map) == 0x000028, "Member 'FURL::Map' has a wrong offset!");
//(offsetof(FURL, RedirectURL) == 0x000038, "Member 'FURL::RedirectURL' has a wrong offset!");
//(offsetof(FURL, Op) == 0x000048, "Member 'FURL::Op' has a wrong offset!");
//(offsetof(FURL, Portal) == 0x000058, "Member 'FURL::Portal' has a wrong offset!");
//(offsetof(FURL, IgnoreGameMode) == 0x000068, "Member 'FURL::IgnoreGameMode' has a wrong offset!");

// ScriptStruct Engine.FullyLoadedPackagesInfo
// 0x0038 (0x0038 - 0x0000)
struct FFullyLoadedPackagesInfo final
{
public:
	EFullyLoadPackageType                         FullyLoadType;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Tag;                                               // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PackagesToLoad;                                    // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        LoadedObjects;                                     // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FFullyLoadedPackagesInfo) == 0x000008, "Wrong alignment on FFullyLoadedPackagesInfo");
//(sizeof(FFullyLoadedPackagesInfo) == 0x000038, "Wrong size on FFullyLoadedPackagesInfo");
//(offsetof(FFullyLoadedPackagesInfo, FullyLoadType) == 0x000000, "Member 'FFullyLoadedPackagesInfo::FullyLoadType' has a wrong offset!");
//(offsetof(FFullyLoadedPackagesInfo, Tag) == 0x000008, "Member 'FFullyLoadedPackagesInfo::Tag' has a wrong offset!");
//(offsetof(FFullyLoadedPackagesInfo, PackagesToLoad) == 0x000018, "Member 'FFullyLoadedPackagesInfo::PackagesToLoad' has a wrong offset!");
//(offsetof(FFullyLoadedPackagesInfo, LoadedObjects) == 0x000028, "Member 'FFullyLoadedPackagesInfo::LoadedObjects' has a wrong offset!");

// ScriptStruct Engine.LevelStreamingStatus
// 0x0014 (0x0014 - 0x0000)
struct FLevelStreamingStatus final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShouldBeLoaded : 1;                               // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldBeVisible : 1;                              // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        LODIndex;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FLevelStreamingStatus) == 0x000004, "Wrong alignment on FLevelStreamingStatus");
//(sizeof(FLevelStreamingStatus) == 0x000014, "Wrong size on FLevelStreamingStatus");
//(offsetof(FLevelStreamingStatus, PackageName) == 0x000000, "Member 'FLevelStreamingStatus::PackageName' has a wrong offset!");
//(offsetof(FLevelStreamingStatus, LODIndex) == 0x000010, "Member 'FLevelStreamingStatus::LODIndex' has a wrong offset!");

// ScriptStruct Engine.NamedNetDriver
// 0x0010 (0x0010 - 0x0000)
struct FNamedNetDriver final
{
public:
	class UNetDriver*                             NetDriver;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FNamedNetDriver) == 0x000008, "Wrong alignment on FNamedNetDriver");
//(sizeof(FNamedNetDriver) == 0x000010, "Wrong size on FNamedNetDriver");
//(offsetof(FNamedNetDriver, NetDriver) == 0x000000, "Member 'FNamedNetDriver::NetDriver' has a wrong offset!");

// ScriptStruct Engine.WorldContext
// 0x02F0 (0x02F0 - 0x0000)
struct FWorldContext final
{
public:
	uint8                                         Pad_0[0xD0];                                       // 0x0000(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FURL                                   LastURL;                                           // 0x00D0(0x0070)(NativeAccessSpecifierPublic)
	struct FURL                                   LastRemoteURL;                                     // 0x0140(0x0070)(NativeAccessSpecifierPublic)
	class UPendingNetGame*                        PendingNetGame;                                    // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFullyLoadedPackagesInfo>       PackagesToFullyLoad;                               // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x10];                                     // 0x01C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULevel*>                         LoadedLevelsForPendingMapChange;                   // 0x01D8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x18];                                     // 0x01E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObjectReferencer*>              ObjectReferencers;                                 // 0x0200(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FLevelStreamingStatus>          PendingLevelStreamingStatusUpdates;                // 0x0210(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UGameViewportClient*                    GameViewport;                                      // 0x0220(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameInstance*                          OwningGameInstance;                                // 0x0228(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNamedNetDriver>                ActiveNetDrivers;                                  // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0xB0];                                     // 0x0240(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FWorldContext) == 0x000008, "Wrong alignment on FWorldContext");
//(sizeof(FWorldContext) == 0x0002F0, "Wrong size on FWorldContext");
//(offsetof(FWorldContext, LastURL) == 0x0000D0, "Member 'FWorldContext::LastURL' has a wrong offset!");
//(offsetof(FWorldContext, LastRemoteURL) == 0x000140, "Member 'FWorldContext::LastRemoteURL' has a wrong offset!");
//(offsetof(FWorldContext, PendingNetGame) == 0x0001B0, "Member 'FWorldContext::PendingNetGame' has a wrong offset!");
//(offsetof(FWorldContext, PackagesToFullyLoad) == 0x0001B8, "Member 'FWorldContext::PackagesToFullyLoad' has a wrong offset!");
//(offsetof(FWorldContext, LoadedLevelsForPendingMapChange) == 0x0001D8, "Member 'FWorldContext::LoadedLevelsForPendingMapChange' has a wrong offset!");
//(offsetof(FWorldContext, ObjectReferencers) == 0x000200, "Member 'FWorldContext::ObjectReferencers' has a wrong offset!");
//(offsetof(FWorldContext, PendingLevelStreamingStatusUpdates) == 0x000210, "Member 'FWorldContext::PendingLevelStreamingStatusUpdates' has a wrong offset!");
//(offsetof(FWorldContext, GameViewport) == 0x000220, "Member 'FWorldContext::GameViewport' has a wrong offset!");
//(offsetof(FWorldContext, OwningGameInstance) == 0x000228, "Member 'FWorldContext::OwningGameInstance' has a wrong offset!");
//(offsetof(FWorldContext, ActiveNetDrivers) == 0x000230, "Member 'FWorldContext::ActiveNetDrivers' has a wrong offset!");

// ScriptStruct Engine.BlendSampleData
// 0x0060 (0x0060 - 0x0000)
struct FBlendSampleData final
{
public:
	int32                                         SampleDataIndex;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Animation;                                         // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalWeight;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightRate;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousTime;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SamplePlayRate;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x3C];                                      // 0x0024(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBlendSampleData) == 0x000008, "Wrong alignment on FBlendSampleData");
//(sizeof(FBlendSampleData) == 0x000060, "Wrong size on FBlendSampleData");
//(offsetof(FBlendSampleData, SampleDataIndex) == 0x000000, "Member 'FBlendSampleData::SampleDataIndex' has a wrong offset!");
//(offsetof(FBlendSampleData, Animation) == 0x000008, "Member 'FBlendSampleData::Animation' has a wrong offset!");
//(offsetof(FBlendSampleData, TotalWeight) == 0x000010, "Member 'FBlendSampleData::TotalWeight' has a wrong offset!");
//(offsetof(FBlendSampleData, WeightRate) == 0x000014, "Member 'FBlendSampleData::WeightRate' has a wrong offset!");
//(offsetof(FBlendSampleData, Time) == 0x000018, "Member 'FBlendSampleData::Time' has a wrong offset!");
//(offsetof(FBlendSampleData, PreviousTime) == 0x00001C, "Member 'FBlendSampleData::PreviousTime' has a wrong offset!");
//(offsetof(FBlendSampleData, SamplePlayRate) == 0x000020, "Member 'FBlendSampleData::SamplePlayRate' has a wrong offset!");

// ScriptStruct Engine.AnimNode_AssetPlayerCacheBase
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FAnimNode_AssetPlayerCacheBase : public FAniNodeCacheBase
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_AssetPlayerCacheBase) == 0x000004, "Wrong alignment on FAnimNode_AssetPlayerCacheBase");
//(sizeof(FAnimNode_AssetPlayerCacheBase) == 0x000010, "Wrong size on FAnimNode_AssetPlayerCacheBase");

// ScriptStruct Engine.PSCPoolElem
// 0x0010 (0x0010 - 0x0000)
struct FPSCPoolElem final
{
public:
	class UParticleSystemComponent*               PSC;                                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPSCPoolElem) == 0x000008, "Wrong alignment on FPSCPoolElem");
//(sizeof(FPSCPoolElem) == 0x000010, "Wrong size on FPSCPoolElem");
//(offsetof(FPSCPoolElem, PSC) == 0x000000, "Member 'FPSCPoolElem::PSC' has a wrong offset!");

// ScriptStruct Engine.PSCPool
// 0x0010 (0x0010 - 0x0000)
struct FPSCPool final
{
public:
	TArray<struct FPSCPoolElem>                   FreeElements;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
//(alignof(FPSCPool) == 0x000008, "Wrong alignment on FPSCPool");
//(sizeof(FPSCPool) == 0x000010, "Wrong size on FPSCPool");
//(offsetof(FPSCPool, FreeElements) == 0x000000, "Member 'FPSCPool::FreeElements' has a wrong offset!");

// ScriptStruct Engine.WorldPSCPool
// 0x0058 (0x0058 - 0x0000)
struct FWorldPSCPool final
{
public:
	TMap<class UParticleSystem*, struct FPSCPool> WorldParticleSystemPools;                          // 0x0000(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FWorldPSCPool) == 0x000008, "Wrong alignment on FWorldPSCPool");
//(sizeof(FWorldPSCPool) == 0x000058, "Wrong size on FWorldPSCPool");
//(offsetof(FWorldPSCPool, WorldParticleSystemPools) == 0x000000, "Member 'FWorldPSCPool::WorldParticleSystemPools' has a wrong offset!");

// ScriptStruct Engine.StatColorMapEntry
// 0x0008 (0x0008 - 0x0000)
struct FStatColorMapEntry final
{
public:
	float                                         In;                                                // 0x0000(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Out;                                               // 0x0004(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FStatColorMapEntry) == 0x000004, "Wrong alignment on FStatColorMapEntry");
//(sizeof(FStatColorMapEntry) == 0x000008, "Wrong size on FStatColorMapEntry");
//(offsetof(FStatColorMapEntry, In) == 0x000000, "Member 'FStatColorMapEntry::In' has a wrong offset!");
//(offsetof(FStatColorMapEntry, Out) == 0x000004, "Member 'FStatColorMapEntry::Out' has a wrong offset!");

// ScriptStruct Engine.BranchFilter
// 0x0010 (0x0010 - 0x0000)
struct FBranchFilter final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlendDepth;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBranchFilter) == 0x000004, "Wrong alignment on FBranchFilter");
//(sizeof(FBranchFilter) == 0x000010, "Wrong size on FBranchFilter");
//(offsetof(FBranchFilter, BoneName) == 0x000000, "Member 'FBranchFilter::BoneName' has a wrong offset!");
//(offsetof(FBranchFilter, BlendDepth) == 0x00000C, "Member 'FBranchFilter::BlendDepth' has a wrong offset!");

// ScriptStruct Engine.AnimationPotentialTransition
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FAnimationPotentialTransition final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimationPotentialTransition) == 0x000008, "Wrong alignment on FAnimationPotentialTransition");
//(sizeof(FAnimationPotentialTransition) == 0x000030, "Wrong size on FAnimationPotentialTransition");

// ScriptStruct Engine.PerBoneBlendWeight
// 0x0008 (0x0008 - 0x0000)
struct FPerBoneBlendWeight final
{
public:
	int32                                         SourceIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPerBoneBlendWeight) == 0x000004, "Wrong alignment on FPerBoneBlendWeight");
//(sizeof(FPerBoneBlendWeight) == 0x000008, "Wrong size on FPerBoneBlendWeight");
//(offsetof(FPerBoneBlendWeight, SourceIndex) == 0x000000, "Member 'FPerBoneBlendWeight::SourceIndex' has a wrong offset!");
//(offsetof(FPerBoneBlendWeight, BlendWeight) == 0x000004, "Member 'FPerBoneBlendWeight::BlendWeight' has a wrong offset!");

// ScriptStruct Engine.DataDrivenConsoleVariable
// 0x0050 (0x0050 - 0x0000)
struct FDataDrivenConsoleVariable final
{
public:
	EFDataDrivenCVarType                          Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ToolTip;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValueFloat;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultValueInt;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DefaultValueBool;                                  // 0x0030(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x1F];                                      // 0x0031(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDataDrivenConsoleVariable) == 0x000008, "Wrong alignment on FDataDrivenConsoleVariable");
//(sizeof(FDataDrivenConsoleVariable) == 0x000050, "Wrong size on FDataDrivenConsoleVariable");
//(offsetof(FDataDrivenConsoleVariable, Type) == 0x000000, "Member 'FDataDrivenConsoleVariable::Type' has a wrong offset!");
//(offsetof(FDataDrivenConsoleVariable, Name) == 0x000008, "Member 'FDataDrivenConsoleVariable::Name' has a wrong offset!");
//(offsetof(FDataDrivenConsoleVariable, ToolTip) == 0x000018, "Member 'FDataDrivenConsoleVariable::ToolTip' has a wrong offset!");
//(offsetof(FDataDrivenConsoleVariable, DefaultValueFloat) == 0x000028, "Member 'FDataDrivenConsoleVariable::DefaultValueFloat' has a wrong offset!");
//(offsetof(FDataDrivenConsoleVariable, DefaultValueInt) == 0x00002C, "Member 'FDataDrivenConsoleVariable::DefaultValueInt' has a wrong offset!");
//(offsetof(FDataDrivenConsoleVariable, DefaultValueBool) == 0x000030, "Member 'FDataDrivenConsoleVariable::DefaultValueBool' has a wrong offset!");

// ScriptStruct Engine.InputBlendPose
// 0x0010 (0x0010 - 0x0000)
struct FInputBlendPose final
{
public:
	TArray<struct FBranchFilter>                  BranchFilters;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FInputBlendPose) == 0x000008, "Wrong alignment on FInputBlendPose");
//(sizeof(FInputBlendPose) == 0x000010, "Wrong size on FInputBlendPose");
//(offsetof(FInputBlendPose, BranchFilters) == 0x000000, "Member 'FInputBlendPose::BranchFilters' has a wrong offset!");

// ScriptStruct Engine.EditorMapPerformanceTestDefinition
// 0x0030 (0x0030 - 0x0000)
struct FEditorMapPerformanceTestDefinition final
{
public:
	struct FSoftObjectPath                        PerformanceTestmap;                                // 0x0000(0x0028)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TestTimer;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FEditorMapPerformanceTestDefinition) == 0x000008, "Wrong alignment on FEditorMapPerformanceTestDefinition");
//(sizeof(FEditorMapPerformanceTestDefinition) == 0x000030, "Wrong size on FEditorMapPerformanceTestDefinition");
//(offsetof(FEditorMapPerformanceTestDefinition, PerformanceTestmap) == 0x000000, "Member 'FEditorMapPerformanceTestDefinition::PerformanceTestmap' has a wrong offset!");
//(offsetof(FEditorMapPerformanceTestDefinition, TestTimer) == 0x000028, "Member 'FEditorMapPerformanceTestDefinition::TestTimer' has a wrong offset!");

// ScriptStruct Engine.MTDResult
// 0x0020 (0x0020 - 0x0000)
struct FMTDResult final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMTDResult) == 0x000008, "Wrong alignment on FMTDResult");
//(sizeof(FMTDResult) == 0x000020, "Wrong size on FMTDResult");
//(offsetof(FMTDResult, Direction) == 0x000000, "Member 'FMTDResult::Direction' has a wrong offset!");
//(offsetof(FMTDResult, Distance) == 0x000018, "Member 'FMTDResult::Distance' has a wrong offset!");

// ScriptStruct Engine.PoseSnapshot
// 0x0040 (0x0040 - 0x0000)
struct FPoseSnapshot final
{
public:
	TArray<struct FTransform>                     LocalTransforms;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneNames;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SkeletalMeshName;                                  // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SnapshotName;                                      // 0x002C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsValid;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPoseSnapshot) == 0x000008, "Wrong alignment on FPoseSnapshot");
//(sizeof(FPoseSnapshot) == 0x000040, "Wrong size on FPoseSnapshot");
//(offsetof(FPoseSnapshot, LocalTransforms) == 0x000000, "Member 'FPoseSnapshot::LocalTransforms' has a wrong offset!");
//(offsetof(FPoseSnapshot, BoneNames) == 0x000010, "Member 'FPoseSnapshot::BoneNames' has a wrong offset!");
//(offsetof(FPoseSnapshot, SkeletalMeshName) == 0x000020, "Member 'FPoseSnapshot::SkeletalMeshName' has a wrong offset!");
//(offsetof(FPoseSnapshot, SnapshotName) == 0x00002C, "Member 'FPoseSnapshot::SnapshotName' has a wrong offset!");
//(offsetof(FPoseSnapshot, bIsValid) == 0x000038, "Member 'FPoseSnapshot::bIsValid' has a wrong offset!");

// ScriptStruct Engine.VirtualTextureBuildSettings
// 0x0008 (0x0008 - 0x0000)
struct FVirtualTextureBuildSettings final
{
public:
	int32                                         TileSize;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileBorderSize;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FVirtualTextureBuildSettings) == 0x000004, "Wrong alignment on FVirtualTextureBuildSettings");
//(sizeof(FVirtualTextureBuildSettings) == 0x000008, "Wrong size on FVirtualTextureBuildSettings");
//(offsetof(FVirtualTextureBuildSettings, TileSize) == 0x000000, "Member 'FVirtualTextureBuildSettings::TileSize' has a wrong offset!");
//(offsetof(FVirtualTextureBuildSettings, TileBorderSize) == 0x000004, "Member 'FVirtualTextureBuildSettings::TileBorderSize' has a wrong offset!");

// ScriptStruct Engine.CollectionReference
// 0x000C (0x000C - 0x0000)
struct FCollectionReference final
{
public:
	class FName                                   CollectionName;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCollectionReference) == 0x000004, "Wrong alignment on FCollectionReference");
//(sizeof(FCollectionReference) == 0x00000C, "Wrong size on FCollectionReference");
//(offsetof(FCollectionReference, CollectionName) == 0x000000, "Member 'FCollectionReference::CollectionName' has a wrong offset!");

// ScriptStruct Engine.AnimInstanceProxy
// 0x07C8 (0x07D0 - 0x0008)
#pragma pack(push, 0x1)
struct alignas(0x10) FAnimInstanceProxy : public FEvaluation_Cache_Base
{
public:
	uint8                                         Pad_8[0x7C0];                                      // 0x0008(0x07C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
#pragma pack(pop)
//(alignof(FAnimInstanceProxy) == 0x000010, "Wrong alignment on FAnimInstanceProxy");
//(sizeof(FAnimInstanceProxy) == 0x0007D0, "Wrong size on FAnimInstanceProxy");

// ScriptStruct Engine.DataCacheDuplicatedObjectData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDataCacheDuplicatedObjectData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDataCacheDuplicatedObjectData) == 0x000008, "Wrong alignment on FDataCacheDuplicatedObjectData");
//(sizeof(FDataCacheDuplicatedObjectData) == 0x000010, "Wrong size on FDataCacheDuplicatedObjectData");

// ScriptStruct Engine.InstanceCacheDataBase
// 0x0058 (0x0058 - 0x0000)
struct FInstanceCacheDataBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 SavedProperties;                                   // 0x0008(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FDataCacheDuplicatedObjectData         UniqueTransientPackage;                            // 0x0018(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FDataCacheDuplicatedObjectData> DuplicatedObjects;                                 // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        ReferencedObjects;                                 // 0x0038(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ReferencedNames;                                   // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
//(alignof(FInstanceCacheDataBase) == 0x000008, "Wrong alignment on FInstanceCacheDataBase");
//(sizeof(FInstanceCacheDataBase) == 0x000058, "Wrong size on FInstanceCacheDataBase");
//(offsetof(FInstanceCacheDataBase, SavedProperties) == 0x000008, "Member 'FInstanceCacheDataBase::SavedProperties' has a wrong offset!");
//(offsetof(FInstanceCacheDataBase, UniqueTransientPackage) == 0x000018, "Member 'FInstanceCacheDataBase::UniqueTransientPackage' has a wrong offset!");
//(offsetof(FInstanceCacheDataBase, DuplicatedObjects) == 0x000028, "Member 'FInstanceCacheDataBase::DuplicatedObjects' has a wrong offset!");
//(offsetof(FInstanceCacheDataBase, ReferencedObjects) == 0x000038, "Member 'FInstanceCacheDataBase::ReferencedObjects' has a wrong offset!");
//(offsetof(FInstanceCacheDataBase, ReferencedNames) == 0x000048, "Member 'FInstanceCacheDataBase::ReferencedNames' has a wrong offset!");

// ScriptStruct Engine.RepPropertyDebugInfo
// 0x0020 (0x0020 - 0x0000)
struct FRepPropertyDebugInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRepPropertyDebugInfo) == 0x000008, "Wrong alignment on FRepPropertyDebugInfo");
//(sizeof(FRepPropertyDebugInfo) == 0x000020, "Wrong size on FRepPropertyDebugInfo");
//(offsetof(FRepPropertyDebugInfo, Name) == 0x000000, "Member 'FRepPropertyDebugInfo::Name' has a wrong offset!");
//(offsetof(FRepPropertyDebugInfo, Value) == 0x000010, "Member 'FRepPropertyDebugInfo::Value' has a wrong offset!");

// ScriptStruct Engine.BracketPayload
// 0x0010 (0x0010 - 0x0000)
struct FBracketPayload final : public FEmptyPayload
{
public:
	class FString                                 Description;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBracketPayload) == 0x000008, "Wrong alignment on FBracketPayload");
//(sizeof(FBracketPayload) == 0x000010, "Wrong size on FBracketPayload");
//(offsetof(FBracketPayload, Description) == 0x000000, "Member 'FBracketPayload::Description' has a wrong offset!");

// ScriptStruct Engine.ReverbSettings
// 0x0020 (0x0020 - 0x0000)
struct FReverbSettings final
{
public:
	bool                                          bApplyReverb;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UReverbEffect*                          ReverbEffect;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundEffectSubmixPreset*               ReverbPluginEffect;                                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FReverbSettings) == 0x000008, "Wrong alignment on FReverbSettings");
//(sizeof(FReverbSettings) == 0x000020, "Wrong size on FReverbSettings");
//(offsetof(FReverbSettings, bApplyReverb) == 0x000000, "Member 'FReverbSettings::bApplyReverb' has a wrong offset!");
//(offsetof(FReverbSettings, ReverbEffect) == 0x000008, "Member 'FReverbSettings::ReverbEffect' has a wrong offset!");
//(offsetof(FReverbSettings, ReverbPluginEffect) == 0x000010, "Member 'FReverbSettings::ReverbPluginEffect' has a wrong offset!");
//(offsetof(FReverbSettings, Volume) == 0x000018, "Member 'FReverbSettings::Volume' has a wrong offset!");
//(offsetof(FReverbSettings, FadeTime) == 0x00001C, "Member 'FReverbSettings::FadeTime' has a wrong offset!");

// ScriptStruct Engine.AttributePayload
// 0x0050 (0x0050 - 0x0000)
struct FAttributePayload final : public FEmptyPayload
{
public:
	struct FAnimationAttributeIdentifier          Identifier;                                        // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAttributePayload) == 0x000008, "Wrong alignment on FAttributePayload");
//(sizeof(FAttributePayload) == 0x000050, "Wrong size on FAttributePayload");
//(offsetof(FAttributePayload, Identifier) == 0x000000, "Member 'FAttributePayload::Identifier' has a wrong offset!");

// ScriptStruct Engine.BeamTargetData
// 0x0010 (0x0010 - 0x0000)
struct FBeamTargetData final
{
public:
	class FName                                   TargetName;                                        // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetPercentage;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBeamTargetData) == 0x000004, "Wrong alignment on FBeamTargetData");
//(sizeof(FBeamTargetData) == 0x000010, "Wrong size on FBeamTargetData");
//(offsetof(FBeamTargetData, TargetName) == 0x000000, "Member 'FBeamTargetData::TargetName' has a wrong offset!");
//(offsetof(FBeamTargetData, TargetPercentage) == 0x00000C, "Member 'FBeamTargetData::TargetPercentage' has a wrong offset!");

// ScriptStruct Engine.ActorComponentInstanceData
// 0x0010 (0x0068 - 0x0058)
struct FActorComponentInstanceData : public FInstanceCacheDataBase
{
public:
	class UObject*                                SourceComponentTemplate;                           // 0x0058(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EComponentCreationMethod                      SourceComponentCreationMethod;                     // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SourceComponentTypeSerializedIndex;                // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
//(alignof(FActorComponentInstanceData) == 0x000008, "Wrong alignment on FActorComponentInstanceData");
//(sizeof(FActorComponentInstanceData) == 0x000068, "Wrong size on FActorComponentInstanceData");
//(offsetof(FActorComponentInstanceData, SourceComponentTemplate) == 0x000058, "Member 'FActorComponentInstanceData::SourceComponentTemplate' has a wrong offset!");
//(offsetof(FActorComponentInstanceData, SourceComponentCreationMethod) == 0x000060, "Member 'FActorComponentInstanceData::SourceComponentCreationMethod' has a wrong offset!");
//(offsetof(FActorComponentInstanceData, SourceComponentTypeSerializedIndex) == 0x000064, "Member 'FActorComponentInstanceData::SourceComponentTypeSerializedIndex' has a wrong offset!");

// ScriptStruct Engine.ParticleSystemReplayFrame
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FParticleSystemReplayFrame final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FParticleSystemReplayFrame) == 0x000008, "Wrong alignment on FParticleSystemReplayFrame");
//(sizeof(FParticleSystemReplayFrame) == 0x000010, "Wrong size on FParticleSystemReplayFrame");

// ScriptStruct Engine.DeviceTriggerTriggerVibrationData
// 0x0018 (0x0018 - 0x0000)
struct FDeviceTriggerTriggerVibrationData final
{
public:
	class UCurveFloat*                            TriggerPositionCurve;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            VibrationFrequencyCurve;                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            VibrationAmplitudeCurve;                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDeviceTriggerTriggerVibrationData) == 0x000008, "Wrong alignment on FDeviceTriggerTriggerVibrationData");
//(sizeof(FDeviceTriggerTriggerVibrationData) == 0x000018, "Wrong size on FDeviceTriggerTriggerVibrationData");
//(offsetof(FDeviceTriggerTriggerVibrationData, TriggerPositionCurve) == 0x000000, "Member 'FDeviceTriggerTriggerVibrationData::TriggerPositionCurve' has a wrong offset!");
//(offsetof(FDeviceTriggerTriggerVibrationData, VibrationFrequencyCurve) == 0x000008, "Member 'FDeviceTriggerTriggerVibrationData::VibrationFrequencyCurve' has a wrong offset!");
//(offsetof(FDeviceTriggerTriggerVibrationData, VibrationAmplitudeCurve) == 0x000010, "Member 'FDeviceTriggerTriggerVibrationData::VibrationAmplitudeCurve' has a wrong offset!");

// ScriptStruct Engine.SceneComponentInstanceData
// 0x0050 (0x00B8 - 0x0068)
struct FSceneComponentInstanceData : public FActorComponentInstanceData
{
public:
	TMap<class USceneComponent*, struct FTransform> AttachedInstanceComponents;                        // 0x0068(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
//(alignof(FSceneComponentInstanceData) == 0x000008, "Wrong alignment on FSceneComponentInstanceData");
//(sizeof(FSceneComponentInstanceData) == 0x0000B8, "Wrong size on FSceneComponentInstanceData");
//(offsetof(FSceneComponentInstanceData, AttachedInstanceComponents) == 0x000068, "Member 'FSceneComponentInstanceData::AttachedInstanceComponents' has a wrong offset!");

// ScriptStruct Engine.AnimLinkableElement
// 0x0030 (0x0030 - 0x0000)
struct FAnimLinkableElement
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           LinkedMontage;                                     // 0x0008(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotIndex;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SegmentIndex;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimLinkMethod                               LinkMethod;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimLinkMethod                               CachedLinkMethod;                                  // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SegmentBeginTime;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SegmentLength;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LinkValue;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      LinkedSequence;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
//(alignof(FAnimLinkableElement) == 0x000008, "Wrong alignment on FAnimLinkableElement");
//(sizeof(FAnimLinkableElement) == 0x000030, "Wrong size on FAnimLinkableElement");
//(offsetof(FAnimLinkableElement, LinkedMontage) == 0x000008, "Member 'FAnimLinkableElement::LinkedMontage' has a wrong offset!");
//(offsetof(FAnimLinkableElement, SlotIndex) == 0x000010, "Member 'FAnimLinkableElement::SlotIndex' has a wrong offset!");
//(offsetof(FAnimLinkableElement, SegmentIndex) == 0x000014, "Member 'FAnimLinkableElement::SegmentIndex' has a wrong offset!");
//(offsetof(FAnimLinkableElement, LinkMethod) == 0x000018, "Member 'FAnimLinkableElement::LinkMethod' has a wrong offset!");
//(offsetof(FAnimLinkableElement, CachedLinkMethod) == 0x000019, "Member 'FAnimLinkableElement::CachedLinkMethod' has a wrong offset!");
//(offsetof(FAnimLinkableElement, SegmentBeginTime) == 0x00001C, "Member 'FAnimLinkableElement::SegmentBeginTime' has a wrong offset!");
//(offsetof(FAnimLinkableElement, SegmentLength) == 0x000020, "Member 'FAnimLinkableElement::SegmentLength' has a wrong offset!");
//(offsetof(FAnimLinkableElement, LinkValue) == 0x000024, "Member 'FAnimLinkableElement::LinkValue' has a wrong offset!");
//(offsetof(FAnimLinkableElement, LinkedSequence) == 0x000028, "Member 'FAnimLinkableElement::LinkedSequence' has a wrong offset!");

// ScriptStruct Engine.CompositeSection
// 0x0058 (0x0088 - 0x0030)
struct FCompositeSection final : public FAnimLinkableElement
{
public:
	class FName                                   SectionName;                                       // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextSectionName;                                   // 0x003C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMetaData*>                  MetaData;                                          // 0x0048(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FAlphaBlend                            BlendIn;                                           // 0x0058(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FCompositeSection) == 0x000008, "Wrong alignment on FCompositeSection");
//(sizeof(FCompositeSection) == 0x000088, "Wrong size on FCompositeSection");
//(offsetof(FCompositeSection, SectionName) == 0x000030, "Member 'FCompositeSection::SectionName' has a wrong offset!");
//(offsetof(FCompositeSection, NextSectionName) == 0x00003C, "Member 'FCompositeSection::NextSectionName' has a wrong offset!");
//(offsetof(FCompositeSection, MetaData) == 0x000048, "Member 'FCompositeSection::MetaData' has a wrong offset!");
//(offsetof(FCompositeSection, BlendIn) == 0x000058, "Member 'FCompositeSection::BlendIn' has a wrong offset!");

// ScriptStruct Engine.ActorContainerID
// 0x0010 (0x0010 - 0x0000)
struct FActorContainerID final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FActorContainerID) == 0x000004, "Wrong alignment on FActorContainerID");
//(sizeof(FActorContainerID) == 0x000010, "Wrong size on FActorContainerID");
//(offsetof(FActorContainerID, Guid) == 0x000000, "Member 'FActorContainerID::Guid' has a wrong offset!");

// ScriptStruct Engine.WorldPartitionResolveData
// 0x0020 (0x0020 - 0x0000)
struct FWorldPartitionResolveData final
{
public:
	struct FActorContainerID                      ContainerID;                                       // 0x0000(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SourceWorldAssetPath;                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FWorldPartitionResolveData) == 0x000008, "Wrong alignment on FWorldPartitionResolveData");
//(sizeof(FWorldPartitionResolveData) == 0x000020, "Wrong size on FWorldPartitionResolveData");
//(offsetof(FWorldPartitionResolveData, ContainerID) == 0x000000, "Member 'FWorldPartitionResolveData::ContainerID' has a wrong offset!");
//(offsetof(FWorldPartitionResolveData, SourceWorldAssetPath) == 0x000010, "Member 'FWorldPartitionResolveData::SourceWorldAssetPath' has a wrong offset!");

// ScriptStruct Engine.SpatialHashStreamingGridLayerCell
// 0x0010 (0x0010 - 0x0000)
struct FSpatialHashStreamingGridLayerCell final
{
public:
	TArray<class UWorldPartitionRuntimeCell*>     GridCells;                                         // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FSpatialHashStreamingGridLayerCell) == 0x000008, "Wrong alignment on FSpatialHashStreamingGridLayerCell");
//(sizeof(FSpatialHashStreamingGridLayerCell) == 0x000010, "Wrong size on FSpatialHashStreamingGridLayerCell");
//(offsetof(FSpatialHashStreamingGridLayerCell, GridCells) == 0x000000, "Member 'FSpatialHashStreamingGridLayerCell::GridCells' has a wrong offset!");

// ScriptStruct Engine.SpatialHashStreamingGridLevel
// 0x0060 (0x0060 - 0x0000)
struct FSpatialHashStreamingGridLevel final
{
public:
	TArray<struct FSpatialHashStreamingGridLayerCell> LayerCells;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int64, int32>                            LayerCellsMapping;                                 // 0x0010(0x0050)(NativeAccessSpecifierPublic)
};
//(alignof(FSpatialHashStreamingGridLevel) == 0x000008, "Wrong alignment on FSpatialHashStreamingGridLevel");
//(sizeof(FSpatialHashStreamingGridLevel) == 0x000060, "Wrong size on FSpatialHashStreamingGridLevel");
//(offsetof(FSpatialHashStreamingGridLevel, LayerCells) == 0x000000, "Member 'FSpatialHashStreamingGridLevel::LayerCells' has a wrong offset!");
//(offsetof(FSpatialHashStreamingGridLevel, LayerCellsMapping) == 0x000010, "Member 'FSpatialHashStreamingGridLevel::LayerCellsMapping' has a wrong offset!");

// ScriptStruct Engine.SpatialHashStreamingGrid
// 0x00C0 (0x00C0 - 0x0000)
struct FSpatialHashStreamingGrid final
{
public:
	class FName                                   GridName;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Origin;                                            // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellSize;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadingRange;                                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockOnSlowStreaming;                             // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DebugColor;                                        // 0x0034(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpatialHashStreamingGridLevel> GridLevels;                                        // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBox                                   WorldBounds;                                       // 0x0058(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bClientOnlyVisible;                                // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHLODLayer*                             HLODLayer;                                         // 0x0098(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSpatialHashStreamingGrid) == 0x000008, "Wrong alignment on FSpatialHashStreamingGrid");
//(sizeof(FSpatialHashStreamingGrid) == 0x0000C0, "Wrong size on FSpatialHashStreamingGrid");
//(offsetof(FSpatialHashStreamingGrid, GridName) == 0x000000, "Member 'FSpatialHashStreamingGrid::GridName' has a wrong offset!");
//(offsetof(FSpatialHashStreamingGrid, Origin) == 0x000010, "Member 'FSpatialHashStreamingGrid::Origin' has a wrong offset!");
//(offsetof(FSpatialHashStreamingGrid, CellSize) == 0x000028, "Member 'FSpatialHashStreamingGrid::CellSize' has a wrong offset!");
//(offsetof(FSpatialHashStreamingGrid, LoadingRange) == 0x00002C, "Member 'FSpatialHashStreamingGrid::LoadingRange' has a wrong offset!");
//(offsetof(FSpatialHashStreamingGrid, bBlockOnSlowStreaming) == 0x000030, "Member 'FSpatialHashStreamingGrid::bBlockOnSlowStreaming' has a wrong offset!");
//(offsetof(FSpatialHashStreamingGrid, DebugColor) == 0x000034, "Member 'FSpatialHashStreamingGrid::DebugColor' has a wrong offset!");
//(offsetof(FSpatialHashStreamingGrid, GridLevels) == 0x000048, "Member 'FSpatialHashStreamingGrid::GridLevels' has a wrong offset!");
//(offsetof(FSpatialHashStreamingGrid, WorldBounds) == 0x000058, "Member 'FSpatialHashStreamingGrid::WorldBounds' has a wrong offset!");
//(offsetof(FSpatialHashStreamingGrid, bClientOnlyVisible) == 0x000090, "Member 'FSpatialHashStreamingGrid::bClientOnlyVisible' has a wrong offset!");
//(offsetof(FSpatialHashStreamingGrid, HLODLayer) == 0x000098, "Member 'FSpatialHashStreamingGrid::HLODLayer' has a wrong offset!");

// ScriptStruct Engine.ActorDataLayer
// 0x000C (0x000C - 0x0000)
struct FActorDataLayer final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FActorDataLayer) == 0x000004, "Wrong alignment on FActorDataLayer");
//(sizeof(FActorDataLayer) == 0x00000C, "Wrong size on FActorDataLayer");
//(offsetof(FActorDataLayer, Name) == 0x000000, "Member 'FActorDataLayer::Name' has a wrong offset!");

// ScriptStruct Engine.SoundGroup
// 0x0020 (0x0020 - 0x0000)
struct FSoundGroup final
{
public:
	ESoundGroup                                   SoundGroup;                                        // 0x0000(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x0008(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysDecompressOnLoad : 1;                       // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecompressedDuration;                              // 0x001C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoundGroup) == 0x000008, "Wrong alignment on FSoundGroup");
//(sizeof(FSoundGroup) == 0x000020, "Wrong size on FSoundGroup");
//(offsetof(FSoundGroup, SoundGroup) == 0x000000, "Member 'FSoundGroup::SoundGroup' has a wrong offset!");
//(offsetof(FSoundGroup, DisplayName) == 0x000008, "Member 'FSoundGroup::DisplayName' has a wrong offset!");
//(offsetof(FSoundGroup, DecompressedDuration) == 0x00001C, "Member 'FSoundGroup::DecompressedDuration' has a wrong offset!");

// ScriptStruct Engine.ColorGradePerRangeSettings
// 0x00A0 (0x00A0 - 0x0000)
struct FColorGradePerRangeSettings final
{
public:
	struct FVector4                               Saturation;                                        // 0x0000(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               Contrast;                                          // 0x0020(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               Gamma;                                             // 0x0040(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               Gain;                                              // 0x0060(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               Offset;                                            // 0x0080(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FColorGradePerRangeSettings) == 0x000010, "Wrong alignment on FColorGradePerRangeSettings");
//(sizeof(FColorGradePerRangeSettings) == 0x0000A0, "Wrong size on FColorGradePerRangeSettings");
//(offsetof(FColorGradePerRangeSettings, Saturation) == 0x000000, "Member 'FColorGradePerRangeSettings::Saturation' has a wrong offset!");
//(offsetof(FColorGradePerRangeSettings, Contrast) == 0x000020, "Member 'FColorGradePerRangeSettings::Contrast' has a wrong offset!");
//(offsetof(FColorGradePerRangeSettings, Gamma) == 0x000040, "Member 'FColorGradePerRangeSettings::Gamma' has a wrong offset!");
//(offsetof(FColorGradePerRangeSettings, Gain) == 0x000060, "Member 'FColorGradePerRangeSettings::Gain' has a wrong offset!");
//(offsetof(FColorGradePerRangeSettings, Offset) == 0x000080, "Member 'FColorGradePerRangeSettings::Offset' has a wrong offset!");

// ScriptStruct Engine.ISMComponentDescriptorBase
// 0x01F8 (0x01F8 - 0x0000)
struct FISMComponentDescriptorBase
{
public:
	uint32                                        Hash;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UInstancedStaticMeshComponent> ComponentClass;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComponentMobility                            Mobility;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERuntimeVirtualTextureMainPassType            VirtualTextureRenderPassType;                      // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightmapType                                 LightmapType;                                      // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightingChannels                      LightingChannels;                                  // 0x0013(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RayTracingGroupId;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERayTracingGroupCullingPriority               RayTracingGroupCullingPriority;                    // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHasCustomNavigableGeometry                   bHasCustomNavigableGeometry;                       // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERendererStencilMask                          CustomDepthStencilWriteMask;                       // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBodyInstance                          BodyInstance;                                      // 0x0020(0x01B0)(Edit, NativeAccessSpecifierPublic)
	int32                                         InstanceStartCullDistance;                         // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceEndCullDistance;                           // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstanceLODDistanceScale;                          // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VirtualTextureCullMips;                            // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TranslucencySortPriority;                          // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverriddenLightMapRes;                             // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomDepthStencilValue;                           // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCastShadow : 1;                                   // 0x01EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastDynamicShadow : 1;                            // 0x01EC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastStaticShadow : 1;                             // 0x01EC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastContactShadow : 1;                            // 0x01EC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastShadowAsTwoSided : 1;                         // 0x01EC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectDynamicIndirectLighting : 1;                // 0x01EC(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectDistanceFieldLighting : 1;                  // 0x01EC(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReceivesDecals : 1;                               // 0x01EC(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideLightMapRes : 1;                          // 0x01ED(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseAsOccluder : 1;                                // 0x01ED(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableDensityScaling : 1;                         // 0x01ED(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableDiscardOnLoad : 1;                          // 0x01ED(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRenderCustomDepth : 1;                            // 0x01ED(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVisibleInRayTracing : 1;                          // 0x01ED(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHiddenInGame : 1;                                 // 0x01ED(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsEditorOnly : 1;                                 // 0x01ED(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVisible : 1;                                      // 0x01EE(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEvaluateWorldPositionOffset : 1;                  // 0x01EE(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReverseCulling : 1;                               // 0x01EE(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDefaultCollision : 1;                          // 0x01EE(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateOverlapEvents : 1;                        // 0x01EE(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EF[0x1];                                      // 0x01EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WorldPositionOffsetDisableDistance;                // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShadowCacheInvalidationBehavior              ShadowCacheInvalidationBehavior;                   // 0x01F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetailMode                                   DetailMode;                                        // 0x01F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F6[0x2];                                      // 0x01F6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FISMComponentDescriptorBase) == 0x000008, "Wrong alignment on FISMComponentDescriptorBase");
//(sizeof(FISMComponentDescriptorBase) == 0x0001F8, "Wrong size on FISMComponentDescriptorBase");
//(offsetof(FISMComponentDescriptorBase, Hash) == 0x000000, "Member 'FISMComponentDescriptorBase::Hash' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, ComponentClass) == 0x000008, "Member 'FISMComponentDescriptorBase::ComponentClass' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, Mobility) == 0x000010, "Member 'FISMComponentDescriptorBase::Mobility' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, VirtualTextureRenderPassType) == 0x000011, "Member 'FISMComponentDescriptorBase::VirtualTextureRenderPassType' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, LightmapType) == 0x000012, "Member 'FISMComponentDescriptorBase::LightmapType' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, LightingChannels) == 0x000013, "Member 'FISMComponentDescriptorBase::LightingChannels' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, RayTracingGroupId) == 0x000014, "Member 'FISMComponentDescriptorBase::RayTracingGroupId' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, RayTracingGroupCullingPriority) == 0x000018, "Member 'FISMComponentDescriptorBase::RayTracingGroupCullingPriority' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, bHasCustomNavigableGeometry) == 0x000019, "Member 'FISMComponentDescriptorBase::bHasCustomNavigableGeometry' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, CustomDepthStencilWriteMask) == 0x00001A, "Member 'FISMComponentDescriptorBase::CustomDepthStencilWriteMask' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, BodyInstance) == 0x000020, "Member 'FISMComponentDescriptorBase::BodyInstance' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, InstanceStartCullDistance) == 0x0001D0, "Member 'FISMComponentDescriptorBase::InstanceStartCullDistance' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, InstanceEndCullDistance) == 0x0001D4, "Member 'FISMComponentDescriptorBase::InstanceEndCullDistance' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, InstanceLODDistanceScale) == 0x0001D8, "Member 'FISMComponentDescriptorBase::InstanceLODDistanceScale' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, VirtualTextureCullMips) == 0x0001DC, "Member 'FISMComponentDescriptorBase::VirtualTextureCullMips' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, TranslucencySortPriority) == 0x0001E0, "Member 'FISMComponentDescriptorBase::TranslucencySortPriority' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, OverriddenLightMapRes) == 0x0001E4, "Member 'FISMComponentDescriptorBase::OverriddenLightMapRes' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, CustomDepthStencilValue) == 0x0001E8, "Member 'FISMComponentDescriptorBase::CustomDepthStencilValue' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, WorldPositionOffsetDisableDistance) == 0x0001F0, "Member 'FISMComponentDescriptorBase::WorldPositionOffsetDisableDistance' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, ShadowCacheInvalidationBehavior) == 0x0001F4, "Member 'FISMComponentDescriptorBase::ShadowCacheInvalidationBehavior' has a wrong offset!");
//(offsetof(FISMComponentDescriptorBase, DetailMode) == 0x0001F5, "Member 'FISMComponentDescriptorBase::DetailMode' has a wrong offset!");

// ScriptStruct Engine.ISMComponentDescriptor
// 0x0030 (0x0228 - 0x01F8)
struct FISMComponentDescriptor final : public FISMComponentDescriptorBase
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x01F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             OverrideMaterials;                                 // 0x0200(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OverlayMaterial;                                   // 0x0210(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URuntimeVirtualTexture*>         RuntimeVirtualTextures;                            // 0x0218(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FISMComponentDescriptor) == 0x000008, "Wrong alignment on FISMComponentDescriptor");
//(sizeof(FISMComponentDescriptor) == 0x000228, "Wrong size on FISMComponentDescriptor");
//(offsetof(FISMComponentDescriptor, StaticMesh) == 0x0001F8, "Member 'FISMComponentDescriptor::StaticMesh' has a wrong offset!");
//(offsetof(FISMComponentDescriptor, OverrideMaterials) == 0x000200, "Member 'FISMComponentDescriptor::OverrideMaterials' has a wrong offset!");
//(offsetof(FISMComponentDescriptor, OverlayMaterial) == 0x000210, "Member 'FISMComponentDescriptor::OverlayMaterial' has a wrong offset!");
//(offsetof(FISMComponentDescriptor, RuntimeVirtualTextures) == 0x000218, "Member 'FISMComponentDescriptor::RuntimeVirtualTextures' has a wrong offset!");

// ScriptStruct Engine.QuartzTransportTimeStamp
// 0x0010 (0x0010 - 0x0000)
struct FQuartzTransportTimeStamp final
{
public:
	int32                                         Bars;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Beat;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeatFraction;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Seconds;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FQuartzTransportTimeStamp) == 0x000004, "Wrong alignment on FQuartzTransportTimeStamp");
//(sizeof(FQuartzTransportTimeStamp) == 0x000010, "Wrong size on FQuartzTransportTimeStamp");
//(offsetof(FQuartzTransportTimeStamp, Bars) == 0x000000, "Member 'FQuartzTransportTimeStamp::Bars' has a wrong offset!");
//(offsetof(FQuartzTransportTimeStamp, Beat) == 0x000004, "Member 'FQuartzTransportTimeStamp::Beat' has a wrong offset!");
//(offsetof(FQuartzTransportTimeStamp, BeatFraction) == 0x000008, "Member 'FQuartzTransportTimeStamp::BeatFraction' has a wrong offset!");
//(offsetof(FQuartzTransportTimeStamp, Seconds) == 0x00000C, "Member 'FQuartzTransportTimeStamp::Seconds' has a wrong offset!");

// ScriptStruct Engine.WorldPartitionRuntimeSpatialHashGridPreviewer
// 0x0001 (0x0001 - 0x0000)
struct FWorldPartitionRuntimeSpatialHashGridPreviewer final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FWorldPartitionRuntimeSpatialHashGridPreviewer) == 0x000001, "Wrong alignment on FWorldPartitionRuntimeSpatialHashGridPreviewer");
//(sizeof(FWorldPartitionRuntimeSpatialHashGridPreviewer) == 0x000001, "Wrong size on FWorldPartitionRuntimeSpatialHashGridPreviewer");

// ScriptStruct Engine.AnimNode_ApplyMSAdditiveCache
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FAnimNode_ApplyMSAdditiveCache final : public FAniNodeCacheBase
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_ApplyMSAdditiveCache) == 0x000004, "Wrong alignment on FAnimNode_ApplyMSAdditiveCache");
//(sizeof(FAnimNode_ApplyMSAdditiveCache) == 0x000004, "Wrong size on FAnimNode_ApplyMSAdditiveCache");

// ScriptStruct Engine.CachedPoseIndices
// 0x0010 (0x0010 - 0x0000)
struct FCachedPoseIndices final
{
public:
	TArray<int32>                                 OrderedSavedPoseNodeIndices;                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FCachedPoseIndices) == 0x000008, "Wrong alignment on FCachedPoseIndices");
//(sizeof(FCachedPoseIndices) == 0x000010, "Wrong size on FCachedPoseIndices");
//(offsetof(FCachedPoseIndices, OrderedSavedPoseNodeIndices) == 0x000000, "Member 'FCachedPoseIndices::OrderedSavedPoseNodeIndices' has a wrong offset!");

// ScriptStruct Engine.CameraExposureSettings
// 0x0040 (0x0040 - 0x0000)
struct FCameraExposureSettings final
{
public:
	EAutoExposureMethod                           Method;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowPercent;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighPercent;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBrightness;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBrightness;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedUp;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedDown;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bias;                                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BiasCurve;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               MeterMask;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HistogramLogMin;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HistogramLogMax;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CalibrationConstant;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ApplyPhysicalCameraExposure : 1;                   // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCameraExposureSettings) == 0x000008, "Wrong alignment on FCameraExposureSettings");
//(sizeof(FCameraExposureSettings) == 0x000040, "Wrong size on FCameraExposureSettings");
//(offsetof(FCameraExposureSettings, Method) == 0x000000, "Member 'FCameraExposureSettings::Method' has a wrong offset!");
//(offsetof(FCameraExposureSettings, LowPercent) == 0x000004, "Member 'FCameraExposureSettings::LowPercent' has a wrong offset!");
//(offsetof(FCameraExposureSettings, HighPercent) == 0x000008, "Member 'FCameraExposureSettings::HighPercent' has a wrong offset!");
//(offsetof(FCameraExposureSettings, MinBrightness) == 0x00000C, "Member 'FCameraExposureSettings::MinBrightness' has a wrong offset!");
//(offsetof(FCameraExposureSettings, MaxBrightness) == 0x000010, "Member 'FCameraExposureSettings::MaxBrightness' has a wrong offset!");
//(offsetof(FCameraExposureSettings, SpeedUp) == 0x000014, "Member 'FCameraExposureSettings::SpeedUp' has a wrong offset!");
//(offsetof(FCameraExposureSettings, SpeedDown) == 0x000018, "Member 'FCameraExposureSettings::SpeedDown' has a wrong offset!");
//(offsetof(FCameraExposureSettings, Bias) == 0x00001C, "Member 'FCameraExposureSettings::Bias' has a wrong offset!");
//(offsetof(FCameraExposureSettings, BiasCurve) == 0x000020, "Member 'FCameraExposureSettings::BiasCurve' has a wrong offset!");
//(offsetof(FCameraExposureSettings, MeterMask) == 0x000028, "Member 'FCameraExposureSettings::MeterMask' has a wrong offset!");
//(offsetof(FCameraExposureSettings, HistogramLogMin) == 0x000030, "Member 'FCameraExposureSettings::HistogramLogMin' has a wrong offset!");
//(offsetof(FCameraExposureSettings, HistogramLogMax) == 0x000034, "Member 'FCameraExposureSettings::HistogramLogMax' has a wrong offset!");
//(offsetof(FCameraExposureSettings, CalibrationConstant) == 0x000038, "Member 'FCameraExposureSettings::CalibrationConstant' has a wrong offset!");

// ScriptStruct Engine.LatentActionManager
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FLatentActionManager final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLatentActionManager) == 0x000008, "Wrong alignment on FLatentActionManager");
//(sizeof(FLatentActionManager) == 0x000068, "Wrong size on FLatentActionManager");

// ScriptStruct Engine.SoftISMComponentDescriptor
// 0x0080 (0x0278 - 0x01F8)
struct FSoftISMComponentDescriptor final : public FISMComponentDescriptorBase
{
public:
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x01F8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UMaterialInterface>> OverrideMaterials;                                 // 0x0228(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      OverlayMaterial;                                   // 0x0238(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class URuntimeVirtualTexture>> RuntimeVirtualTextures;                            // 0x0268(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FSoftISMComponentDescriptor) == 0x000008, "Wrong alignment on FSoftISMComponentDescriptor");
//(sizeof(FSoftISMComponentDescriptor) == 0x000278, "Wrong size on FSoftISMComponentDescriptor");
//(offsetof(FSoftISMComponentDescriptor, StaticMesh) == 0x0001F8, "Member 'FSoftISMComponentDescriptor::StaticMesh' has a wrong offset!");
//(offsetof(FSoftISMComponentDescriptor, OverrideMaterials) == 0x000228, "Member 'FSoftISMComponentDescriptor::OverrideMaterials' has a wrong offset!");
//(offsetof(FSoftISMComponentDescriptor, OverlayMaterial) == 0x000238, "Member 'FSoftISMComponentDescriptor::OverlayMaterial' has a wrong offset!");
//(offsetof(FSoftISMComponentDescriptor, RuntimeVirtualTextures) == 0x000268, "Member 'FSoftISMComponentDescriptor::RuntimeVirtualTextures' has a wrong offset!");

// ScriptStruct Engine.NamedFloat
// 0x0010 (0x0010 - 0x0000)
struct FNamedFloat final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNamedFloat) == 0x000004, "Wrong alignment on FNamedFloat");
//(sizeof(FNamedFloat) == 0x000010, "Wrong size on FNamedFloat");
//(offsetof(FNamedFloat, Value) == 0x000000, "Member 'FNamedFloat::Value' has a wrong offset!");
//(offsetof(FNamedFloat, Name) == 0x000004, "Member 'FNamedFloat::Name' has a wrong offset!");

// ScriptStruct Engine.NamedVector
// 0x0028 (0x0028 - 0x0000)
struct FNamedVector final
{
public:
	struct FVector                                Value;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FNamedVector) == 0x000008, "Wrong alignment on FNamedVector");
//(sizeof(FNamedVector) == 0x000028, "Wrong size on FNamedVector");
//(offsetof(FNamedVector, Value) == 0x000000, "Member 'FNamedVector::Value' has a wrong offset!");
//(offsetof(FNamedVector, Name) == 0x000018, "Member 'FNamedVector::Name' has a wrong offset!");

// ScriptStruct Engine.MovementProperties
// 0x0001 (0x0001 - 0x0000)
struct FMovementProperties
{
public:
	uint8                                         bCanCrouch : 1;                                    // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanJump : 1;                                      // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanWalk : 1;                                      // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanSwim : 1;                                      // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanFly : 1;                                       // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
//(alignof(FMovementProperties) == 0x000001, "Wrong alignment on FMovementProperties");
//(sizeof(FMovementProperties) == 0x000001, "Wrong size on FMovementProperties");

// ScriptStruct Engine.NavAgentProperties
// 0x003F (0x0040 - 0x0001)
struct FNavAgentProperties : public FMovementProperties
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AgentRadius;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentHeight;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentStepHeight;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavWalkingSearchHeightScale;                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         PreferredNavData;                                  // 0x0018(0x0028)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNavAgentProperties) == 0x000008, "Wrong alignment on FNavAgentProperties");
//(sizeof(FNavAgentProperties) == 0x000040, "Wrong size on FNavAgentProperties");
//(offsetof(FNavAgentProperties, AgentRadius) == 0x000004, "Member 'FNavAgentProperties::AgentRadius' has a wrong offset!");
//(offsetof(FNavAgentProperties, AgentHeight) == 0x000008, "Member 'FNavAgentProperties::AgentHeight' has a wrong offset!");
//(offsetof(FNavAgentProperties, AgentStepHeight) == 0x00000C, "Member 'FNavAgentProperties::AgentStepHeight' has a wrong offset!");
//(offsetof(FNavAgentProperties, NavWalkingSearchHeightScale) == 0x000010, "Member 'FNavAgentProperties::NavWalkingSearchHeightScale' has a wrong offset!");
//(offsetof(FNavAgentProperties, PreferredNavData) == 0x000018, "Member 'FNavAgentProperties::PreferredNavData' has a wrong offset!");

// ScriptStruct Engine.NavDataConfig
// 0x0058 (0x0098 - 0x0040)
struct FNavDataConfig final : public FNavAgentProperties
{
public:
	class FName                                   Name;                                              // 0x0040(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultQueryExtent;                                // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   NavDataClass;                                      // 0x0068(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
//(alignof(FNavDataConfig) == 0x000008, "Wrong alignment on FNavDataConfig");
//(sizeof(FNavDataConfig) == 0x000098, "Wrong size on FNavDataConfig");
//(offsetof(FNavDataConfig, Name) == 0x000040, "Member 'FNavDataConfig::Name' has a wrong offset!");
//(offsetof(FNavDataConfig, Color) == 0x00004C, "Member 'FNavDataConfig::Color' has a wrong offset!");
//(offsetof(FNavDataConfig, DefaultQueryExtent) == 0x000050, "Member 'FNavDataConfig::DefaultQueryExtent' has a wrong offset!");
//(offsetof(FNavDataConfig, NavDataClass) == 0x000068, "Member 'FNavDataConfig::NavDataClass' has a wrong offset!");

// ScriptStruct Engine.NamedColor
// 0x0010 (0x0010 - 0x0000)
struct FNamedColor final
{
public:
	struct FColor                                 Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNamedColor) == 0x000004, "Wrong alignment on FNamedColor");
//(sizeof(FNamedColor) == 0x000010, "Wrong size on FNamedColor");
//(offsetof(FNamedColor, Value) == 0x000000, "Member 'FNamedColor::Value' has a wrong offset!");
//(offsetof(FNamedColor, Name) == 0x000004, "Member 'FNamedColor::Name' has a wrong offset!");

// ScriptStruct Engine.QuartzPulseOverrideStep
// 0x0008 (0x0008 - 0x0000)
struct FQuartzPulseOverrideStep final
{
public:
	int32                                         NumberOfPulses;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuartzCommandQuantization                    PulseDuration;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FQuartzPulseOverrideStep) == 0x000004, "Wrong alignment on FQuartzPulseOverrideStep");
//(sizeof(FQuartzPulseOverrideStep) == 0x000008, "Wrong size on FQuartzPulseOverrideStep");
//(offsetof(FQuartzPulseOverrideStep, NumberOfPulses) == 0x000000, "Member 'FQuartzPulseOverrideStep::NumberOfPulses' has a wrong offset!");
//(offsetof(FQuartzPulseOverrideStep, PulseDuration) == 0x000004, "Member 'FQuartzPulseOverrideStep::PulseDuration' has a wrong offset!");

// ScriptStruct Engine.NamedTransform
// 0x0070 (0x0070 - 0x0000)
struct FNamedTransform final
{
public:
	struct FTransform                             Value;                                             // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0060(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FNamedTransform) == 0x000010, "Wrong alignment on FNamedTransform");
//(sizeof(FNamedTransform) == 0x000070, "Wrong size on FNamedTransform");
//(offsetof(FNamedTransform, Value) == 0x000000, "Member 'FNamedTransform::Value' has a wrong offset!");
//(offsetof(FNamedTransform, Name) == 0x000060, "Member 'FNamedTransform::Name' has a wrong offset!");

// ScriptStruct Engine.LocalSpacePose
// 0x0020 (0x0020 - 0x0000)
struct FLocalSpacePose final
{
public:
	TArray<struct FTransform>                     Transforms;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Names;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FLocalSpacePose) == 0x000008, "Wrong alignment on FLocalSpacePose");
//(sizeof(FLocalSpacePose) == 0x000020, "Wrong size on FLocalSpacePose");
//(offsetof(FLocalSpacePose, Transforms) == 0x000000, "Member 'FLocalSpacePose::Transforms' has a wrong offset!");
//(offsetof(FLocalSpacePose, Names) == 0x000010, "Member 'FLocalSpacePose::Names' has a wrong offset!");

// ScriptStruct Engine.ComponentSpacePose
// 0x0020 (0x0020 - 0x0000)
struct FComponentSpacePose final
{
public:
	TArray<struct FTransform>                     Transforms;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Names;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FComponentSpacePose) == 0x000008, "Wrong alignment on FComponentSpacePose");
//(sizeof(FComponentSpacePose) == 0x000020, "Wrong size on FComponentSpacePose");
//(offsetof(FComponentSpacePose, Transforms) == 0x000000, "Member 'FComponentSpacePose::Transforms' has a wrong offset!");
//(offsetof(FComponentSpacePose, Names) == 0x000010, "Member 'FComponentSpacePose::Names' has a wrong offset!");

// ScriptStruct Engine.AnimExecutionContext
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAnimExecutionContext
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimExecutionContext) == 0x000008, "Wrong alignment on FAnimExecutionContext");
//(sizeof(FAnimExecutionContext) == 0x000010, "Wrong size on FAnimExecutionContext");

// ScriptStruct Engine.AnimUpdateContext
// 0x0000 (0x0010 - 0x0010)
struct FAnimUpdateContext final : public FAnimExecutionContext
{
};
//(alignof(FAnimUpdateContext) == 0x000008, "Wrong alignment on FAnimUpdateContext");
//(sizeof(FAnimUpdateContext) == 0x000010, "Wrong size on FAnimUpdateContext");

// ScriptStruct Engine.AnimationErrorStats
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FAnimationErrorStats final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimationErrorStats) == 0x000004, "Wrong alignment on FAnimationErrorStats");
//(sizeof(FAnimationErrorStats) == 0x000010, "Wrong size on FAnimationErrorStats");

// ScriptStruct Engine.SkeletalMeshOptimizationSettings
// 0x003C (0x003C - 0x0000)
struct FSkeletalMeshOptimizationSettings final
{
public:
	ESkeletalMeshTerminationCriterion             TerminationCriterion;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NumOfTrianglesPercentage;                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NumOfVertPercentage;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxNumOfTriangles;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxNumOfVerts;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDeviationPercentage;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkeletalMeshOptimizationType                 ReductionMethod;                                   // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkeletalMeshOptimizationImportance           SilhouetteImportance;                              // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkeletalMeshOptimizationImportance           TextureImportance;                                 // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkeletalMeshOptimizationImportance           ShadingImportance;                                 // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkeletalMeshOptimizationImportance           SkinningImportance;                                // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRemapMorphTargets : 1;                            // 0x001D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRecalcNormals : 1;                                // 0x001D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeldingThreshold;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalsThreshold;                                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBonesPerVertex;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnforceBoneBoundaries : 1;                        // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMergeCoincidentVertBones : 1;                     // 0x002C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeImportance;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLockEdges : 1;                                    // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockColorBounaries : 1;                           // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseLOD;                                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSkeletalMeshOptimizationSettings) == 0x000004, "Wrong alignment on FSkeletalMeshOptimizationSettings");
//(sizeof(FSkeletalMeshOptimizationSettings) == 0x00003C, "Wrong size on FSkeletalMeshOptimizationSettings");
//(offsetof(FSkeletalMeshOptimizationSettings, TerminationCriterion) == 0x000000, "Member 'FSkeletalMeshOptimizationSettings::TerminationCriterion' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, NumOfTrianglesPercentage) == 0x000004, "Member 'FSkeletalMeshOptimizationSettings::NumOfTrianglesPercentage' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, NumOfVertPercentage) == 0x000008, "Member 'FSkeletalMeshOptimizationSettings::NumOfVertPercentage' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, MaxNumOfTriangles) == 0x00000C, "Member 'FSkeletalMeshOptimizationSettings::MaxNumOfTriangles' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, MaxNumOfVerts) == 0x000010, "Member 'FSkeletalMeshOptimizationSettings::MaxNumOfVerts' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, MaxDeviationPercentage) == 0x000014, "Member 'FSkeletalMeshOptimizationSettings::MaxDeviationPercentage' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, ReductionMethod) == 0x000018, "Member 'FSkeletalMeshOptimizationSettings::ReductionMethod' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, SilhouetteImportance) == 0x000019, "Member 'FSkeletalMeshOptimizationSettings::SilhouetteImportance' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, TextureImportance) == 0x00001A, "Member 'FSkeletalMeshOptimizationSettings::TextureImportance' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, ShadingImportance) == 0x00001B, "Member 'FSkeletalMeshOptimizationSettings::ShadingImportance' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, SkinningImportance) == 0x00001C, "Member 'FSkeletalMeshOptimizationSettings::SkinningImportance' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, WeldingThreshold) == 0x000020, "Member 'FSkeletalMeshOptimizationSettings::WeldingThreshold' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, NormalsThreshold) == 0x000024, "Member 'FSkeletalMeshOptimizationSettings::NormalsThreshold' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, MaxBonesPerVertex) == 0x000028, "Member 'FSkeletalMeshOptimizationSettings::MaxBonesPerVertex' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, VolumeImportance) == 0x000030, "Member 'FSkeletalMeshOptimizationSettings::VolumeImportance' has a wrong offset!");
//(offsetof(FSkeletalMeshOptimizationSettings, BaseLOD) == 0x000038, "Member 'FSkeletalMeshOptimizationSettings::BaseLOD' has a wrong offset!");

// ScriptStruct Engine.HLODInstancingKey
// 0x0010 (0x0010 - 0x0000)
struct FHLODInstancingKey final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FHLODInstancingKey) == 0x000008, "Wrong alignment on FHLODInstancingKey");
//(sizeof(FHLODInstancingKey) == 0x000010, "Wrong size on FHLODInstancingKey");
//(offsetof(FHLODInstancingKey, StaticMesh) == 0x000000, "Member 'FHLODInstancingKey::StaticMesh' has a wrong offset!");
//(offsetof(FHLODInstancingKey, Material) == 0x000008, "Member 'FHLODInstancingKey::Material' has a wrong offset!");

// ScriptStruct Engine.AnimCompressedCurveIndexedName
// 0x0020 (0x0020 - 0x0000)
struct FAnimCompressedCurveIndexedName final
{
public:
	class FName                                   CurveName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x14];                                       // 0x000C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimCompressedCurveIndexedName) == 0x000004, "Wrong alignment on FAnimCompressedCurveIndexedName");
//(sizeof(FAnimCompressedCurveIndexedName) == 0x000020, "Wrong size on FAnimCompressedCurveIndexedName");
//(offsetof(FAnimCompressedCurveIndexedName, CurveName) == 0x000000, "Member 'FAnimCompressedCurveIndexedName::CurveName' has a wrong offset!");

// ScriptStruct Engine.LayerActorStats
// 0x0010 (0x0010 - 0x0000)
struct FLayerActorStats final
{
public:
	TSubclassOf<class UObject>                    Type;                                              // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Total;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLayerActorStats) == 0x000008, "Wrong alignment on FLayerActorStats");
//(sizeof(FLayerActorStats) == 0x000010, "Wrong size on FLayerActorStats");
//(offsetof(FLayerActorStats, Type) == 0x000000, "Member 'FLayerActorStats::Type' has a wrong offset!");
//(offsetof(FLayerActorStats, Total) == 0x000008, "Member 'FLayerActorStats::Total' has a wrong offset!");

// ScriptStruct Engine.AnimCurveType
// 0x0002 (0x0002 - 0x0000)
struct FAnimCurveType final
{
public:
	bool                                          bMaterial;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMorphtarget;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimCurveType) == 0x000001, "Wrong alignment on FAnimCurveType");
//(sizeof(FAnimCurveType) == 0x000002, "Wrong size on FAnimCurveType");
//(offsetof(FAnimCurveType, bMaterial) == 0x000000, "Member 'FAnimCurveType::bMaterial' has a wrong offset!");
//(offsetof(FAnimCurveType, bMorphtarget) == 0x000001, "Member 'FAnimCurveType::bMorphtarget' has a wrong offset!");

// ScriptStruct Engine.CurveMetaData
// 0x0018 (0x0018 - 0x0000)
struct FCurveMetaData final
{
public:
	TArray<struct FBoneReference>                 LinkedBones;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         MaxLOD;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimCurveType                         Type;                                              // 0x0011(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCurveMetaData) == 0x000008, "Wrong alignment on FCurveMetaData");
//(sizeof(FCurveMetaData) == 0x000018, "Wrong size on FCurveMetaData");
//(offsetof(FCurveMetaData, LinkedBones) == 0x000000, "Member 'FCurveMetaData::LinkedBones' has a wrong offset!");
//(offsetof(FCurveMetaData, MaxLOD) == 0x000010, "Member 'FCurveMetaData::MaxLOD' has a wrong offset!");
//(offsetof(FCurveMetaData, Type) == 0x000011, "Member 'FCurveMetaData::Type' has a wrong offset!");

// ScriptStruct Engine.RootMotionMovementParams
// 0x0070 (0x0070 - 0x0000)
struct FRootMotionMovementParams final
{
public:
	bool                                          bHasRootMotion;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendWeight;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RootMotionTransform;                               // 0x0010(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FRootMotionMovementParams) == 0x000010, "Wrong alignment on FRootMotionMovementParams");
//(sizeof(FRootMotionMovementParams) == 0x000070, "Wrong size on FRootMotionMovementParams");
//(offsetof(FRootMotionMovementParams, bHasRootMotion) == 0x000000, "Member 'FRootMotionMovementParams::bHasRootMotion' has a wrong offset!");
//(offsetof(FRootMotionMovementParams, BlendWeight) == 0x000004, "Member 'FRootMotionMovementParams::BlendWeight' has a wrong offset!");
//(offsetof(FRootMotionMovementParams, RootMotionTransform) == 0x000010, "Member 'FRootMotionMovementParams::RootMotionTransform' has a wrong offset!");

// ScriptStruct Engine.AnimCurveBase
// 0x0010 (0x0010 - 0x0000)
struct FAnimCurveBase
{
public:
	class FName                                   CurveName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurveTypeFlags;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FAnimCurveBase) == 0x000004, "Wrong alignment on FAnimCurveBase");
//(sizeof(FAnimCurveBase) == 0x000010, "Wrong size on FAnimCurveBase");
//(offsetof(FAnimCurveBase, CurveName) == 0x000000, "Member 'FAnimCurveBase::CurveName' has a wrong offset!");
//(offsetof(FAnimCurveBase, CurveTypeFlags) == 0x00000C, "Member 'FAnimCurveBase::CurveTypeFlags' has a wrong offset!");

// ScriptStruct Engine.FloatCurve
// 0x0080 (0x0090 - 0x0010)
struct FFloatCurve final : public FAnimCurveBase
{
public:
	struct FRichCurve                             FloatCurve;                                        // 0x0010(0x0080)(NativeAccessSpecifierPublic)
};
//(alignof(FFloatCurve) == 0x000008, "Wrong alignment on FFloatCurve");
//(sizeof(FFloatCurve) == 0x000090, "Wrong size on FFloatCurve");
//(offsetof(FFloatCurve, FloatCurve) == 0x000010, "Member 'FFloatCurve::FloatCurve' has a wrong offset!");

// ScriptStruct Engine.PropertyAccessCopy
// 0x0010 (0x0010 - 0x0000)
struct FPropertyAccessCopy final
{
public:
	int32                                         AccessIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DestAccessStartIndex;                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DestAccessEndIndex;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPropertyAccessCopyType                       Type;                                              // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPropertyAccessCopy) == 0x000004, "Wrong alignment on FPropertyAccessCopy");
//(sizeof(FPropertyAccessCopy) == 0x000010, "Wrong size on FPropertyAccessCopy");
//(offsetof(FPropertyAccessCopy, AccessIndex) == 0x000000, "Member 'FPropertyAccessCopy::AccessIndex' has a wrong offset!");
//(offsetof(FPropertyAccessCopy, DestAccessStartIndex) == 0x000004, "Member 'FPropertyAccessCopy::DestAccessStartIndex' has a wrong offset!");
//(offsetof(FPropertyAccessCopy, DestAccessEndIndex) == 0x000008, "Member 'FPropertyAccessCopy::DestAccessEndIndex' has a wrong offset!");
//(offsetof(FPropertyAccessCopy, Type) == 0x00000C, "Member 'FPropertyAccessCopy::Type' has a wrong offset!");

// ScriptStruct Engine.VectorCurve
// 0x0180 (0x0190 - 0x0010)
struct FVectorCurve final : public FAnimCurveBase
{
public:
	struct FRichCurve                             FloatCurves[0x3];                                  // 0x0010(0x0080)(NativeAccessSpecifierPublic)
};
//(alignof(FVectorCurve) == 0x000008, "Wrong alignment on FVectorCurve");
//(sizeof(FVectorCurve) == 0x000190, "Wrong size on FVectorCurve");
//(offsetof(FVectorCurve, FloatCurves) == 0x000010, "Member 'FVectorCurve::FloatCurves' has a wrong offset!");

// ScriptStruct Engine.TransformCurve
// 0x04B0 (0x04C0 - 0x0010)
struct FTransformCurve final : public FAnimCurveBase
{
public:
	struct FVectorCurve                           TranslationCurve;                                  // 0x0010(0x0190)(NativeAccessSpecifierPublic)
	struct FVectorCurve                           RotationCurve;                                     // 0x01A0(0x0190)(NativeAccessSpecifierPublic)
	struct FVectorCurve                           ScaleCurve;                                        // 0x0330(0x0190)(NativeAccessSpecifierPublic)
};
//(alignof(FTransformCurve) == 0x000008, "Wrong alignment on FTransformCurve");
//(sizeof(FTransformCurve) == 0x0004C0, "Wrong size on FTransformCurve");
//(offsetof(FTransformCurve, TranslationCurve) == 0x000010, "Member 'FTransformCurve::TranslationCurve' has a wrong offset!");
//(offsetof(FTransformCurve, RotationCurve) == 0x0001A0, "Member 'FTransformCurve::RotationCurve' has a wrong offset!");
//(offsetof(FTransformCurve, ScaleCurve) == 0x000330, "Member 'FTransformCurve::ScaleCurve' has a wrong offset!");

// ScriptStruct Engine.EncounteredStateMachineStack
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FEncounteredStateMachineStack final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FEncounteredStateMachineStack) == 0x000008, "Wrong alignment on FEncounteredStateMachineStack");
//(sizeof(FEncounteredStateMachineStack) == 0x000030, "Wrong size on FEncounteredStateMachineStack");

// ScriptStruct Engine.CachedFloatCurve
// 0x000C (0x000C - 0x0000)
struct FCachedFloatCurve final
{
public:
	class FName                                   CurveName;                                         // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCachedFloatCurve) == 0x000004, "Wrong alignment on FCachedFloatCurve");
//(sizeof(FCachedFloatCurve) == 0x00000C, "Wrong size on FCachedFloatCurve");
//(offsetof(FCachedFloatCurve, CurveName) == 0x000000, "Member 'FCachedFloatCurve::CurveName' has a wrong offset!");

// ScriptStruct Engine.RawCurveTracks
// 0x0040 (0x0040 - 0x0000)
struct FRawCurveTracks final
{
public:
	TArray<struct FFloatCurve>                    FloatCurves;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x30];                                      // 0x0010(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRawCurveTracks) == 0x000008, "Wrong alignment on FRawCurveTracks");
//(sizeof(FRawCurveTracks) == 0x000040, "Wrong size on FRawCurveTracks");
//(offsetof(FRawCurveTracks, FloatCurves) == 0x000000, "Member 'FRawCurveTracks::FloatCurves' has a wrong offset!");

// ScriptStruct Engine.AnimationTrackAddedPayload
// 0x0004 (0x0010 - 0x000C)
struct FAnimationTrackAddedPayload final : public FAnimationTrackPayload
{
public:
	int32                                         TrackIndex;                                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimationTrackAddedPayload) == 0x000004, "Wrong alignment on FAnimationTrackAddedPayload");
//(sizeof(FAnimationTrackAddedPayload) == 0x000010, "Wrong size on FAnimationTrackAddedPayload");
//(offsetof(FAnimationTrackAddedPayload, TrackIndex) == 0x00000C, "Member 'FAnimationTrackAddedPayload::TrackIndex' has a wrong offset!");

// ScriptStruct Engine.BlendProfileBoneEntry
// 0x0018 (0x0018 - 0x0000)
struct FBlendProfileBoneEntry final
{
public:
	struct FBoneReference                         BoneReference;                                     // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BlendScale;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBlendProfileBoneEntry) == 0x000004, "Wrong alignment on FBlendProfileBoneEntry");
//(sizeof(FBlendProfileBoneEntry) == 0x000018, "Wrong size on FBlendProfileBoneEntry");
//(offsetof(FBlendProfileBoneEntry, BoneReference) == 0x000000, "Member 'FBlendProfileBoneEntry::BoneReference' has a wrong offset!");
//(offsetof(FBlendProfileBoneEntry, BlendScale) == 0x000014, "Member 'FBlendProfileBoneEntry::BlendScale' has a wrong offset!");

// ScriptStruct Engine.SequenceLengthChangedPayload
// 0x0018 (0x0018 - 0x0000)
struct FSequenceLengthChangedPayload final : public FEmptyPayload
{
public:
	float                                         PreviousLength;                                    // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         T0;                                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         T1;                                                // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           PreviousNumberOfFrames;                            // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           Frame0;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           Frame1;                                            // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSequenceLengthChangedPayload) == 0x000004, "Wrong alignment on FSequenceLengthChangedPayload");
//(sizeof(FSequenceLengthChangedPayload) == 0x000018, "Wrong size on FSequenceLengthChangedPayload");
//(offsetof(FSequenceLengthChangedPayload, PreviousLength) == 0x000000, "Member 'FSequenceLengthChangedPayload::PreviousLength' has a wrong offset!");
//(offsetof(FSequenceLengthChangedPayload, T0) == 0x000004, "Member 'FSequenceLengthChangedPayload::T0' has a wrong offset!");
//(offsetof(FSequenceLengthChangedPayload, T1) == 0x000008, "Member 'FSequenceLengthChangedPayload::T1' has a wrong offset!");
//(offsetof(FSequenceLengthChangedPayload, PreviousNumberOfFrames) == 0x00000C, "Member 'FSequenceLengthChangedPayload::PreviousNumberOfFrames' has a wrong offset!");
//(offsetof(FSequenceLengthChangedPayload, Frame0) == 0x000010, "Member 'FSequenceLengthChangedPayload::Frame0' has a wrong offset!");
//(offsetof(FSequenceLengthChangedPayload, Frame1) == 0x000014, "Member 'FSequenceLengthChangedPayload::Frame1' has a wrong offset!");

// ScriptStruct Engine.FrameRateChangedPayload
// 0x0008 (0x0008 - 0x0000)
struct FFrameRateChangedPayload final : public FEmptyPayload
{
public:
	struct FFrameRate                             PreviousFrameRate;                                 // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FFrameRateChangedPayload) == 0x000004, "Wrong alignment on FFrameRateChangedPayload");
//(sizeof(FFrameRateChangedPayload) == 0x000008, "Wrong size on FFrameRateChangedPayload");
//(offsetof(FFrameRateChangedPayload, PreviousFrameRate) == 0x000000, "Member 'FFrameRateChangedPayload::PreviousFrameRate' has a wrong offset!");

// ScriptStruct Engine.AnimationCurveIdentifier
// 0x0010 (0x0010 - 0x0000)
struct FAnimationCurveIdentifier final
{
public:
	class FName                                   CurveName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERawCurveTrackTypes                           CurveType;                                         // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformCurveChannel                        Channel;                                           // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVectorCurveChannel                           Axis;                                              // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimationCurveIdentifier) == 0x000004, "Wrong alignment on FAnimationCurveIdentifier");
//(sizeof(FAnimationCurveIdentifier) == 0x000010, "Wrong size on FAnimationCurveIdentifier");
//(offsetof(FAnimationCurveIdentifier, CurveName) == 0x000000, "Member 'FAnimationCurveIdentifier::CurveName' has a wrong offset!");
//(offsetof(FAnimationCurveIdentifier, CurveType) == 0x00000C, "Member 'FAnimationCurveIdentifier::CurveType' has a wrong offset!");
//(offsetof(FAnimationCurveIdentifier, Channel) == 0x00000D, "Member 'FAnimationCurveIdentifier::Channel' has a wrong offset!");
//(offsetof(FAnimationCurveIdentifier, Axis) == 0x00000E, "Member 'FAnimationCurveIdentifier::Axis' has a wrong offset!");

// ScriptStruct Engine.CurvePayload
// 0x0010 (0x0010 - 0x0000)
struct FCurvePayload : public FEmptyPayload
{
public:
	struct FAnimationCurveIdentifier              Identifier;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCurvePayload) == 0x000004, "Wrong alignment on FCurvePayload");
//(sizeof(FCurvePayload) == 0x000010, "Wrong size on FCurvePayload");
//(offsetof(FCurvePayload, Identifier) == 0x000000, "Member 'FCurvePayload::Identifier' has a wrong offset!");

// ScriptStruct Engine.CurveScaledPayload
// 0x0008 (0x0018 - 0x0010)
struct FCurveScaledPayload final : public FCurvePayload
{
public:
	float                                         Factor;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Origin;                                            // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCurveScaledPayload) == 0x000004, "Wrong alignment on FCurveScaledPayload");
//(sizeof(FCurveScaledPayload) == 0x000018, "Wrong size on FCurveScaledPayload");
//(offsetof(FCurveScaledPayload, Factor) == 0x000010, "Member 'FCurveScaledPayload::Factor' has a wrong offset!");
//(offsetof(FCurveScaledPayload, Origin) == 0x000014, "Member 'FCurveScaledPayload::Origin' has a wrong offset!");

// ScriptStruct Engine.RepCheckTotalInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FRepCheckTotalInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRepCheckTotalInfo) == 0x000008, "Wrong alignment on FRepCheckTotalInfo");
//(sizeof(FRepCheckTotalInfo) == 0x000010, "Wrong size on FRepCheckTotalInfo");

// ScriptStruct Engine.CurveRenamedPayload
// 0x0010 (0x0020 - 0x0010)
struct FCurveRenamedPayload final : public FCurvePayload
{
public:
	struct FAnimationCurveIdentifier              NewIdentifier;                                     // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCurveRenamedPayload) == 0x000004, "Wrong alignment on FCurveRenamedPayload");
//(sizeof(FCurveRenamedPayload) == 0x000020, "Wrong size on FCurveRenamedPayload");
//(offsetof(FCurveRenamedPayload, NewIdentifier) == 0x000010, "Member 'FCurveRenamedPayload::NewIdentifier' has a wrong offset!");

// ScriptStruct Engine.PropertyAccessIndirectionChain
// 0x0028 (0x0028 - 0x0000)
struct FPropertyAccessIndirectionChain final
{
public:
	TFieldPath<struct FProperty>                  Property;                                          // 0x0000(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IndirectionStartIndex;                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IndirectionEndIndex;                               // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FPropertyAccessIndirectionChain) == 0x000008, "Wrong alignment on FPropertyAccessIndirectionChain");
//(sizeof(FPropertyAccessIndirectionChain) == 0x000028, "Wrong size on FPropertyAccessIndirectionChain");
//(offsetof(FPropertyAccessIndirectionChain, Property) == 0x000000, "Member 'FPropertyAccessIndirectionChain::Property' has a wrong offset!");
//(offsetof(FPropertyAccessIndirectionChain, IndirectionStartIndex) == 0x000020, "Member 'FPropertyAccessIndirectionChain::IndirectionStartIndex' has a wrong offset!");
//(offsetof(FPropertyAccessIndirectionChain, IndirectionEndIndex) == 0x000024, "Member 'FPropertyAccessIndirectionChain::IndirectionEndIndex' has a wrong offset!");

// ScriptStruct Engine.CurveFlagsChangedPayload
// 0x0004 (0x0014 - 0x0010)
struct FCurveFlagsChangedPayload final : public FCurvePayload
{
public:
	int32                                         OldFlags;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCurveFlagsChangedPayload) == 0x000004, "Wrong alignment on FCurveFlagsChangedPayload");
//(sizeof(FCurveFlagsChangedPayload) == 0x000014, "Wrong size on FCurveFlagsChangedPayload");
//(offsetof(FCurveFlagsChangedPayload, OldFlags) == 0x000010, "Member 'FCurveFlagsChangedPayload::OldFlags' has a wrong offset!");

// ScriptStruct Engine.InertializationBoneDiff
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FInertializationBoneDiff final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FInertializationBoneDiff) == 0x000008, "Wrong alignment on FInertializationBoneDiff");
//(sizeof(FInertializationBoneDiff) == 0x000060, "Wrong size on FInertializationBoneDiff");

// ScriptStruct Engine.AnimNodeConstantData
// 0x0018 (0x0018 - 0x0000)
struct FAnimNodeConstantData final
{
public:
	TScriptInterface<class IAnimClassInterface>   AnimClassInterface;                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NodeIndex;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNodeConstantData) == 0x000008, "Wrong alignment on FAnimNodeConstantData");
//(sizeof(FAnimNodeConstantData) == 0x000018, "Wrong size on FAnimNodeConstantData");
//(offsetof(FAnimNodeConstantData, AnimClassInterface) == 0x000000, "Member 'FAnimNodeConstantData::AnimClassInterface' has a wrong offset!");
//(offsetof(FAnimNodeConstantData, NodeIndex) == 0x000010, "Member 'FAnimNodeConstantData::NodeIndex' has a wrong offset!");

// ScriptStruct Engine.SlotEvaluationPose
// 0x0088 (0x0088 - 0x0000)
struct alignas(0x08) FSlotEvaluationPose final
{
public:
	EAdditiveAnimationType                        AdditiveType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x80];                                       // 0x0008(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSlotEvaluationPose) == 0x000008, "Wrong alignment on FSlotEvaluationPose");
//(sizeof(FSlotEvaluationPose) == 0x000088, "Wrong size on FSlotEvaluationPose");
//(offsetof(FSlotEvaluationPose, AdditiveType) == 0x000000, "Member 'FSlotEvaluationPose::AdditiveType' has a wrong offset!");
//(offsetof(FSlotEvaluationPose, Weight) == 0x000004, "Member 'FSlotEvaluationPose::Weight' has a wrong offset!");

// ScriptStruct Engine.AnimSubsystem
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FAnimSubsystem
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimSubsystem) == 0x000008, "Wrong alignment on FAnimSubsystem");
//(sizeof(FAnimSubsystem) == 0x000008, "Wrong size on FAnimSubsystem");

// ScriptStruct Engine.PlayerMuteList
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FPlayerMuteList final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasVoiceHandshakeCompleted;                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VoiceChannelIdx;                                   // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPlayerMuteList) == 0x000008, "Wrong alignment on FPlayerMuteList");
//(sizeof(FPlayerMuteList) == 0x000058, "Wrong size on FPlayerMuteList");
//(offsetof(FPlayerMuteList, bHasVoiceHandshakeCompleted) == 0x000050, "Member 'FPlayerMuteList::bHasVoiceHandshakeCompleted' has a wrong offset!");
//(offsetof(FPlayerMuteList, VoiceChannelIdx) == 0x000054, "Member 'FPlayerMuteList::VoiceChannelIdx' has a wrong offset!");

// ScriptStruct Engine.FunctionExpressionOutput
// 0x0038 (0x0038 - 0x0000)
struct FFunctionExpressionOutput final
{
public:
	class UMaterialExpressionFunctionOutput*      ExpressionOutput;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionOutputId;                                // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExpressionOutput                      Output;                                            // 0x0018(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FFunctionExpressionOutput) == 0x000008, "Wrong alignment on FFunctionExpressionOutput");
//(sizeof(FFunctionExpressionOutput) == 0x000038, "Wrong size on FFunctionExpressionOutput");
//(offsetof(FFunctionExpressionOutput, ExpressionOutput) == 0x000000, "Member 'FFunctionExpressionOutput::ExpressionOutput' has a wrong offset!");
//(offsetof(FFunctionExpressionOutput, ExpressionOutputId) == 0x000008, "Member 'FFunctionExpressionOutput::ExpressionOutputId' has a wrong offset!");
//(offsetof(FFunctionExpressionOutput, Output) == 0x000018, "Member 'FFunctionExpressionOutput::Output' has a wrong offset!");

// ScriptStruct Engine.AnimSubsystem_BlendSpaceGraph
// 0x0010 (0x0018 - 0x0008)
struct FAnimSubsystem_BlendSpaceGraph final : public FAnimSubsystem
{
public:
	TArray<class UBlendSpace*>                    BlendSpaces;                                       // 0x0008(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
};
//(alignof(FAnimSubsystem_BlendSpaceGraph) == 0x000008, "Wrong alignment on FAnimSubsystem_BlendSpaceGraph");
//(sizeof(FAnimSubsystem_BlendSpaceGraph) == 0x000018, "Wrong size on FAnimSubsystem_BlendSpaceGraph");
//(offsetof(FAnimSubsystem_BlendSpaceGraph, BlendSpaces) == 0x000008, "Member 'FAnimSubsystem_BlendSpaceGraph::BlendSpaces' has a wrong offset!");

// ScriptStruct Engine.ClothPhysicsProperties_Legacy
// 0x0050 (0x0050 - 0x0000)
struct FClothPhysicsProperties_Legacy final
{
public:
	float                                         VerticalResistance;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalResistance;                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BendResistance;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShearResistance;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetherStiffness;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetherLimit;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drag;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StiffnessFrequency;                                // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MassScale;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaBlend;                                      // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelfCollisionThickness;                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelfCollisionSquashScale;                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelfCollisionStiffness;                            // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SolverFrequency;                                   // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiberCompression;                                  // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiberExpansion;                                    // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiberResistance;                                   // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FClothPhysicsProperties_Legacy) == 0x000004, "Wrong alignment on FClothPhysicsProperties_Legacy");
//(sizeof(FClothPhysicsProperties_Legacy) == 0x000050, "Wrong size on FClothPhysicsProperties_Legacy");
//(offsetof(FClothPhysicsProperties_Legacy, VerticalResistance) == 0x000000, "Member 'FClothPhysicsProperties_Legacy::VerticalResistance' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, HorizontalResistance) == 0x000004, "Member 'FClothPhysicsProperties_Legacy::HorizontalResistance' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, BendResistance) == 0x000008, "Member 'FClothPhysicsProperties_Legacy::BendResistance' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, ShearResistance) == 0x00000C, "Member 'FClothPhysicsProperties_Legacy::ShearResistance' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, Friction) == 0x000010, "Member 'FClothPhysicsProperties_Legacy::Friction' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, Damping) == 0x000014, "Member 'FClothPhysicsProperties_Legacy::Damping' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, TetherStiffness) == 0x000018, "Member 'FClothPhysicsProperties_Legacy::TetherStiffness' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, TetherLimit) == 0x00001C, "Member 'FClothPhysicsProperties_Legacy::TetherLimit' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, Drag) == 0x000020, "Member 'FClothPhysicsProperties_Legacy::Drag' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, StiffnessFrequency) == 0x000024, "Member 'FClothPhysicsProperties_Legacy::StiffnessFrequency' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, GravityScale) == 0x000028, "Member 'FClothPhysicsProperties_Legacy::GravityScale' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, MassScale) == 0x00002C, "Member 'FClothPhysicsProperties_Legacy::MassScale' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, InertiaBlend) == 0x000030, "Member 'FClothPhysicsProperties_Legacy::InertiaBlend' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, SelfCollisionThickness) == 0x000034, "Member 'FClothPhysicsProperties_Legacy::SelfCollisionThickness' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, SelfCollisionSquashScale) == 0x000038, "Member 'FClothPhysicsProperties_Legacy::SelfCollisionSquashScale' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, SelfCollisionStiffness) == 0x00003C, "Member 'FClothPhysicsProperties_Legacy::SelfCollisionStiffness' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, SolverFrequency) == 0x000040, "Member 'FClothPhysicsProperties_Legacy::SolverFrequency' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, FiberCompression) == 0x000044, "Member 'FClothPhysicsProperties_Legacy::FiberCompression' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, FiberExpansion) == 0x000048, "Member 'FClothPhysicsProperties_Legacy::FiberExpansion' has a wrong offset!");
//(offsetof(FClothPhysicsProperties_Legacy, FiberResistance) == 0x00004C, "Member 'FClothPhysicsProperties_Legacy::FiberResistance' has a wrong offset!");

// ScriptStruct Engine.ClothingAssetData_Legacy
// 0x0078 (0x0078 - 0x0000)
struct FClothingAssetData_Legacy final
{
public:
	class FName                                   AssetName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ApexFileName;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClothPropertiesChanged;                           // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClothPhysicsProperties_Legacy         PhysicsProperties;                                 // 0x0024(0x0050)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FClothingAssetData_Legacy) == 0x000008, "Wrong alignment on FClothingAssetData_Legacy");
//(sizeof(FClothingAssetData_Legacy) == 0x000078, "Wrong size on FClothingAssetData_Legacy");
//(offsetof(FClothingAssetData_Legacy, AssetName) == 0x000000, "Member 'FClothingAssetData_Legacy::AssetName' has a wrong offset!");
//(offsetof(FClothingAssetData_Legacy, ApexFileName) == 0x000010, "Member 'FClothingAssetData_Legacy::ApexFileName' has a wrong offset!");
//(offsetof(FClothingAssetData_Legacy, bClothPropertiesChanged) == 0x000020, "Member 'FClothingAssetData_Legacy::bClothPropertiesChanged' has a wrong offset!");
//(offsetof(FClothingAssetData_Legacy, PhysicsProperties) == 0x000024, "Member 'FClothingAssetData_Legacy::PhysicsProperties' has a wrong offset!");

// ScriptStruct Engine.X20TabulatedBlend
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FX20TabulatedBlend final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FX20TabulatedBlend) == 0x000008, "Wrong alignment on FX20TabulatedBlend");
//(sizeof(FX20TabulatedBlend) == 0x000038, "Wrong size on FX20TabulatedBlend");

// ScriptStruct Engine.AnimTimelineEvent
// 0x0058 (0x0058 - 0x0000)
struct FAnimTimelineEvent final
{
public:
	EUAnimTimelineVersion                         Version;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NotifyName;                                        // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTimeOffset;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTriggerTimeOffset;                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TrackIndex;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 NotifyColor;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    NotifyClass;                                       // 0x0028(0x0008)(ZeroConstructor, Deprecated, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimNotify*                            NotifyObject;                                      // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimNotifyState*                       NotifyStateClass;                                  // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Identity;                                          // 0x0048(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimTimelineEvent) == 0x000008, "Wrong alignment on FAnimTimelineEvent");
//(sizeof(FAnimTimelineEvent) == 0x000058, "Wrong size on FAnimTimelineEvent");
//(offsetof(FAnimTimelineEvent, Version) == 0x000000, "Member 'FAnimTimelineEvent::Version' has a wrong offset!");
//(offsetof(FAnimTimelineEvent, NotifyName) == 0x000004, "Member 'FAnimTimelineEvent::NotifyName' has a wrong offset!");
//(offsetof(FAnimTimelineEvent, StartTime) == 0x000010, "Member 'FAnimTimelineEvent::StartTime' has a wrong offset!");
//(offsetof(FAnimTimelineEvent, TriggerTimeOffset) == 0x000014, "Member 'FAnimTimelineEvent::TriggerTimeOffset' has a wrong offset!");
//(offsetof(FAnimTimelineEvent, EndTriggerTimeOffset) == 0x000018, "Member 'FAnimTimelineEvent::EndTriggerTimeOffset' has a wrong offset!");
//(offsetof(FAnimTimelineEvent, TrackIndex) == 0x00001C, "Member 'FAnimTimelineEvent::TrackIndex' has a wrong offset!");
//(offsetof(FAnimTimelineEvent, NotifyColor) == 0x000020, "Member 'FAnimTimelineEvent::NotifyColor' has a wrong offset!");
//(offsetof(FAnimTimelineEvent, NotifyClass) == 0x000028, "Member 'FAnimTimelineEvent::NotifyClass' has a wrong offset!");
//(offsetof(FAnimTimelineEvent, NotifyObject) == 0x000030, "Member 'FAnimTimelineEvent::NotifyObject' has a wrong offset!");
//(offsetof(FAnimTimelineEvent, NotifyStateClass) == 0x000038, "Member 'FAnimTimelineEvent::NotifyStateClass' has a wrong offset!");
//(offsetof(FAnimTimelineEvent, Duration) == 0x000040, "Member 'FAnimTimelineEvent::Duration' has a wrong offset!");
//(offsetof(FAnimTimelineEvent, Identity) == 0x000048, "Member 'FAnimTimelineEvent::Identity' has a wrong offset!");

// ScriptStruct Engine.ParticleEmitterReplayFrame
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FParticleEmitterReplayFrame final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FParticleEmitterReplayFrame) == 0x000008, "Wrong alignment on FParticleEmitterReplayFrame");
//(sizeof(FParticleEmitterReplayFrame) == 0x000010, "Wrong size on FParticleEmitterReplayFrame");

// ScriptStruct Engine.InputScaleBiasClampState
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FInputScaleBiasClampState final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FInputScaleBiasClampState) == 0x000004, "Wrong alignment on FInputScaleBiasClampState");
//(sizeof(FInputScaleBiasClampState) == 0x000008, "Wrong size on FInputScaleBiasClampState");

// ScriptStruct Engine.AnimTimelineNotifyTrack
// 0x0030 (0x0030 - 0x0000)
struct FAnimTimelineNotifyTrack final
{
public:
	EUAnimTimelineVersion                         Version;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TrackName;                                         // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TrackColor;                                        // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimTimelineEvent>             Notifies;                                          // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FAnimTimelineNotifyTrack) == 0x000008, "Wrong alignment on FAnimTimelineNotifyTrack");
//(sizeof(FAnimTimelineNotifyTrack) == 0x000030, "Wrong size on FAnimTimelineNotifyTrack");
//(offsetof(FAnimTimelineNotifyTrack, Version) == 0x000000, "Member 'FAnimTimelineNotifyTrack::Version' has a wrong offset!");
//(offsetof(FAnimTimelineNotifyTrack, TrackName) == 0x000004, "Member 'FAnimTimelineNotifyTrack::TrackName' has a wrong offset!");
//(offsetof(FAnimTimelineNotifyTrack, TrackColor) == 0x000010, "Member 'FAnimTimelineNotifyTrack::TrackColor' has a wrong offset!");
//(offsetof(FAnimTimelineNotifyTrack, Notifies) == 0x000020, "Member 'FAnimTimelineNotifyTrack::Notifies' has a wrong offset!");

// ScriptStruct Engine.AnimTimelineSection
// 0x0020 (0x0020 - 0x0000)
struct FAnimTimelineSection final
{
public:
	EUAnimTimelineVersion                         Version;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SectionName;                                       // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextSectionName;                                   // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimTimelineSection) == 0x000004, "Wrong alignment on FAnimTimelineSection");
//(sizeof(FAnimTimelineSection) == 0x000020, "Wrong size on FAnimTimelineSection");
//(offsetof(FAnimTimelineSection, Version) == 0x000000, "Member 'FAnimTimelineSection::Version' has a wrong offset!");
//(offsetof(FAnimTimelineSection, SectionName) == 0x000004, "Member 'FAnimTimelineSection::SectionName' has a wrong offset!");
//(offsetof(FAnimTimelineSection, NextSectionName) == 0x000010, "Member 'FAnimTimelineSection::NextSectionName' has a wrong offset!");
//(offsetof(FAnimTimelineSection, Time) == 0x00001C, "Member 'FAnimTimelineSection::Time' has a wrong offset!");

// ScriptStruct Engine.PerBoneBlendWeights
// 0x0010 (0x0010 - 0x0000)
struct FPerBoneBlendWeights final
{
public:
	TArray<struct FPerBoneBlendWeight>            BoneBlendWeights;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FPerBoneBlendWeights) == 0x000008, "Wrong alignment on FPerBoneBlendWeights");
//(sizeof(FPerBoneBlendWeights) == 0x000010, "Wrong size on FPerBoneBlendWeights");
//(offsetof(FPerBoneBlendWeights, BoneBlendWeights) == 0x000000, "Member 'FPerBoneBlendWeights::BoneBlendWeights' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshClothBuildParams
// 0x0060 (0x0060 - 0x0000)
struct FSkeletalMeshClothBuildParams final
{
public:
	TWeakObjectPtr<class UClothingAssetBase>      TargetAsset;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetLod;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemapParameters;                                  // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AssetName;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceSection;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveFromMesh;                                   // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPhysicsAsset>           PhysicsAsset;                                      // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSkeletalMeshClothBuildParams) == 0x000008, "Wrong alignment on FSkeletalMeshClothBuildParams");
//(sizeof(FSkeletalMeshClothBuildParams) == 0x000060, "Wrong size on FSkeletalMeshClothBuildParams");
//(offsetof(FSkeletalMeshClothBuildParams, TargetAsset) == 0x000000, "Member 'FSkeletalMeshClothBuildParams::TargetAsset' has a wrong offset!");
//(offsetof(FSkeletalMeshClothBuildParams, TargetLod) == 0x000008, "Member 'FSkeletalMeshClothBuildParams::TargetLod' has a wrong offset!");
//(offsetof(FSkeletalMeshClothBuildParams, bRemapParameters) == 0x00000C, "Member 'FSkeletalMeshClothBuildParams::bRemapParameters' has a wrong offset!");
//(offsetof(FSkeletalMeshClothBuildParams, AssetName) == 0x000010, "Member 'FSkeletalMeshClothBuildParams::AssetName' has a wrong offset!");
//(offsetof(FSkeletalMeshClothBuildParams, LODIndex) == 0x000020, "Member 'FSkeletalMeshClothBuildParams::LODIndex' has a wrong offset!");
//(offsetof(FSkeletalMeshClothBuildParams, SourceSection) == 0x000024, "Member 'FSkeletalMeshClothBuildParams::SourceSection' has a wrong offset!");
//(offsetof(FSkeletalMeshClothBuildParams, bRemoveFromMesh) == 0x000028, "Member 'FSkeletalMeshClothBuildParams::bRemoveFromMesh' has a wrong offset!");
//(offsetof(FSkeletalMeshClothBuildParams, PhysicsAsset) == 0x000030, "Member 'FSkeletalMeshClothBuildParams::PhysicsAsset' has a wrong offset!");

// ScriptStruct Engine.AnimNotifyEvent
// 0x00B0 (0x00E0 - 0x0030)
struct FAnimNotifyEvent final : public FAnimLinkableElement
{
public:
	float                                         TriggerTimeOffset;                                 // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTriggerTimeOffset;                              // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerWeightThreshold;                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotifyName;                                        // 0x003C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimNotify*                            Notify;                                            // 0x0048(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimNotifyState*                       NotifyStateClass;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimLinkableElement                   EndLink;                                           // 0x0060(0x0030)(NativeAccessSpecifierPublic)
	bool                                          bConvertedFromBranchingPoint;                      // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMontageNotifyTickType                        MontageTickType;                                   // 0x0091(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x2];                                       // 0x0092(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NotifyTriggerChance;                               // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotifyFilterType                             NotifyFilterType;                                  // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NotifyFilterLOD;                                   // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnDedicatedServer;                         // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnlyWhenOwnerIsViewTarget;                 // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnlyWhenMeshIsRendered;                    // 0x00A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnFollower;                                // 0x00A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	//struct FGameplayTag                           IgnoreLevelMode;                                   // 0x00A4(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	//struct FGameplayTag                           RequireLevelMode;                                  // 0x00B0(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrackIndex;                                        // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x1C];                                      // 0x00C4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNotifyEvent) == 0x000008, "Wrong alignment on FAnimNotifyEvent");
//(sizeof(FAnimNotifyEvent) == 0x0000E0, "Wrong size on FAnimNotifyEvent");
//(offsetof(FAnimNotifyEvent, TriggerTimeOffset) == 0x000030, "Member 'FAnimNotifyEvent::TriggerTimeOffset' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, EndTriggerTimeOffset) == 0x000034, "Member 'FAnimNotifyEvent::EndTriggerTimeOffset' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, TriggerWeightThreshold) == 0x000038, "Member 'FAnimNotifyEvent::TriggerWeightThreshold' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, NotifyName) == 0x00003C, "Member 'FAnimNotifyEvent::NotifyName' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, Notify) == 0x000048, "Member 'FAnimNotifyEvent::Notify' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, NotifyStateClass) == 0x000050, "Member 'FAnimNotifyEvent::NotifyStateClass' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, Duration) == 0x000058, "Member 'FAnimNotifyEvent::Duration' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, EndLink) == 0x000060, "Member 'FAnimNotifyEvent::EndLink' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, bConvertedFromBranchingPoint) == 0x000090, "Member 'FAnimNotifyEvent::bConvertedFromBranchingPoint' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, MontageTickType) == 0x000091, "Member 'FAnimNotifyEvent::MontageTickType' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, NotifyTriggerChance) == 0x000094, "Member 'FAnimNotifyEvent::NotifyTriggerChance' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, NotifyFilterType) == 0x000098, "Member 'FAnimNotifyEvent::NotifyFilterType' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, NotifyFilterLOD) == 0x00009C, "Member 'FAnimNotifyEvent::NotifyFilterLOD' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, bTriggerOnDedicatedServer) == 0x0000A0, "Member 'FAnimNotifyEvent::bTriggerOnDedicatedServer' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, bTriggerOnlyWhenOwnerIsViewTarget) == 0x0000A1, "Member 'FAnimNotifyEvent::bTriggerOnlyWhenOwnerIsViewTarget' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, bTriggerOnlyWhenMeshIsRendered) == 0x0000A2, "Member 'FAnimNotifyEvent::bTriggerOnlyWhenMeshIsRendered' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, bTriggerOnFollower) == 0x0000A3, "Member 'FAnimNotifyEvent::bTriggerOnFollower' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, IgnoreLevelMode) == 0x0000A4, "Member 'FAnimNotifyEvent::IgnoreLevelMode' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, RequireLevelMode) == 0x0000B0, "Member 'FAnimNotifyEvent::RequireLevelMode' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, TrackIndex) == 0x0000BC, "Member 'FAnimNotifyEvent::TrackIndex' has a wrong offset!");
//(offsetof(FAnimNotifyEvent, SkinID) == 0x0000C0, "Member 'FAnimNotifyEvent::SkinID' has a wrong offset!");

// ScriptStruct Engine.AnimSyncMarker
// 0x0010 (0x0010 - 0x0000)
struct FAnimSyncMarker final
{
public:
	class FName                                   MarkerName;                                        // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimSyncMarker) == 0x000004, "Wrong alignment on FAnimSyncMarker");
//(sizeof(FAnimSyncMarker) == 0x000010, "Wrong size on FAnimSyncMarker");
//(offsetof(FAnimSyncMarker, MarkerName) == 0x000000, "Member 'FAnimSyncMarker::MarkerName' has a wrong offset!");
//(offsetof(FAnimSyncMarker, Time) == 0x00000C, "Member 'FAnimSyncMarker::Time' has a wrong offset!");

// ScriptStruct Engine.AnimNotifyTrack
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FAnimNotifyTrack final
{
public:
	class FName                                   TrackName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TrackColor;                                        // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x24];                                      // 0x001C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNotifyTrack) == 0x000008, "Wrong alignment on FAnimNotifyTrack");
//(sizeof(FAnimNotifyTrack) == 0x000040, "Wrong size on FAnimNotifyTrack");
//(offsetof(FAnimNotifyTrack, TrackName) == 0x000000, "Member 'FAnimNotifyTrack::TrackName' has a wrong offset!");
//(offsetof(FAnimNotifyTrack, TrackColor) == 0x00000C, "Member 'FAnimNotifyTrack::TrackColor' has a wrong offset!");

// ScriptStruct Engine.MarkerSyncData
// 0x0020 (0x0020 - 0x0000)
struct FMarkerSyncData final
{
public:
	TArray<struct FAnimSyncMarker>                AuthoredSyncMarkers;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMarkerSyncData) == 0x000008, "Wrong alignment on FMarkerSyncData");
//(sizeof(FMarkerSyncData) == 0x000020, "Wrong size on FMarkerSyncData");
//(offsetof(FMarkerSyncData, AuthoredSyncMarkers) == 0x000000, "Member 'FMarkerSyncData::AuthoredSyncMarkers' has a wrong offset!");

// ScriptStruct Engine.TrackToSkeletonMap
// 0x0004 (0x0004 - 0x0000)
struct FTrackToSkeletonMap final
{
public:
	int32                                         BoneTreeIndex;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTrackToSkeletonMap) == 0x000004, "Wrong alignment on FTrackToSkeletonMap");
//(sizeof(FTrackToSkeletonMap) == 0x000004, "Wrong size on FTrackToSkeletonMap");
//(offsetof(FTrackToSkeletonMap, BoneTreeIndex) == 0x000000, "Member 'FTrackToSkeletonMap::BoneTreeIndex' has a wrong offset!");

// ScriptStruct Engine.CachedAnimationData
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FCachedAnimationData final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCachedAnimationData) == 0x000008, "Wrong alignment on FCachedAnimationData");
//(sizeof(FCachedAnimationData) == 0x000068, "Wrong size on FCachedAnimationData");

// ScriptStruct Engine.RawAnimSequenceTrack
// 0x0030 (0x0030 - 0x0000)
struct FRawAnimSequenceTrack final
{
public:
	TArray<struct FVector3f>                      PosKeys;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuat4f>                        RotKeys;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3f>                      ScaleKeys;                                         // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FRawAnimSequenceTrack) == 0x000008, "Wrong alignment on FRawAnimSequenceTrack");
//(sizeof(FRawAnimSequenceTrack) == 0x000030, "Wrong size on FRawAnimSequenceTrack");
//(offsetof(FRawAnimSequenceTrack, PosKeys) == 0x000000, "Member 'FRawAnimSequenceTrack::PosKeys' has a wrong offset!");
//(offsetof(FRawAnimSequenceTrack, RotKeys) == 0x000010, "Member 'FRawAnimSequenceTrack::RotKeys' has a wrong offset!");
//(offsetof(FRawAnimSequenceTrack, ScaleKeys) == 0x000020, "Member 'FRawAnimSequenceTrack::ScaleKeys' has a wrong offset!");

// ScriptStruct Engine.PrimaryAssetRules
// 0x000C (0x000C - 0x0000)
struct FPrimaryAssetRules final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChunkId;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyRecursively;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPrimaryAssetCookRule                         CookRule;                                          // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPrimaryAssetRules) == 0x000004, "Wrong alignment on FPrimaryAssetRules");
//(sizeof(FPrimaryAssetRules) == 0x00000C, "Wrong size on FPrimaryAssetRules");
//(offsetof(FPrimaryAssetRules, Priority) == 0x000000, "Member 'FPrimaryAssetRules::Priority' has a wrong offset!");
//(offsetof(FPrimaryAssetRules, ChunkId) == 0x000004, "Member 'FPrimaryAssetRules::ChunkId' has a wrong offset!");
//(offsetof(FPrimaryAssetRules, bApplyRecursively) == 0x000008, "Member 'FPrimaryAssetRules::bApplyRecursively' has a wrong offset!");
//(offsetof(FPrimaryAssetRules, CookRule) == 0x000009, "Member 'FPrimaryAssetRules::CookRule' has a wrong offset!");

// ScriptStruct Engine.PrimaryAssetRulesOverride
// 0x0024 (0x0024 - 0x0000)
struct FPrimaryAssetRulesOverride final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0018)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetRules                     Rules;                                             // 0x0018(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FPrimaryAssetRulesOverride) == 0x000004, "Wrong alignment on FPrimaryAssetRulesOverride");
//(sizeof(FPrimaryAssetRulesOverride) == 0x000024, "Wrong size on FPrimaryAssetRulesOverride");
//(offsetof(FPrimaryAssetRulesOverride, PrimaryAssetId) == 0x000000, "Member 'FPrimaryAssetRulesOverride::PrimaryAssetId' has a wrong offset!");
//(offsetof(FPrimaryAssetRulesOverride, Rules) == 0x000018, "Member 'FPrimaryAssetRulesOverride::Rules' has a wrong offset!");

// ScriptStruct Engine.CachedAnimRelevancyData
// 0x0024 (0x0024 - 0x0000)
struct FCachedAnimRelevancyData final
{
public:
	class FName                                   StateMachineName;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateName;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0xC];                                       // 0x0018(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCachedAnimRelevancyData) == 0x000004, "Wrong alignment on FCachedAnimRelevancyData");
//(sizeof(FCachedAnimRelevancyData) == 0x000024, "Wrong size on FCachedAnimRelevancyData");
//(offsetof(FCachedAnimRelevancyData, StateMachineName) == 0x000000, "Member 'FCachedAnimRelevancyData::StateMachineName' has a wrong offset!");
//(offsetof(FCachedAnimRelevancyData, StateName) == 0x00000C, "Member 'FCachedAnimRelevancyData::StateName' has a wrong offset!");

// ScriptStruct Engine.PrimaryAssetRulesCustomOverride
// 0x0040 (0x0040 - 0x0000)
struct FPrimaryAssetRulesCustomOverride final
{
public:
	struct FPrimaryAssetType                      PrimaryAssetType;                                  // 0x0000(0x000C)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDirectoryPath                         FilterDirectory;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FilterString;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetRules                     Rules;                                             // 0x0030(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPrimaryAssetRulesCustomOverride) == 0x000008, "Wrong alignment on FPrimaryAssetRulesCustomOverride");
//(sizeof(FPrimaryAssetRulesCustomOverride) == 0x000040, "Wrong size on FPrimaryAssetRulesCustomOverride");
//(offsetof(FPrimaryAssetRulesCustomOverride, PrimaryAssetType) == 0x000000, "Member 'FPrimaryAssetRulesCustomOverride::PrimaryAssetType' has a wrong offset!");
//(offsetof(FPrimaryAssetRulesCustomOverride, FilterDirectory) == 0x000010, "Member 'FPrimaryAssetRulesCustomOverride::FilterDirectory' has a wrong offset!");
//(offsetof(FPrimaryAssetRulesCustomOverride, FilterString) == 0x000020, "Member 'FPrimaryAssetRulesCustomOverride::FilterString' has a wrong offset!");
//(offsetof(FPrimaryAssetRulesCustomOverride, Rules) == 0x000030, "Member 'FPrimaryAssetRulesCustomOverride::Rules' has a wrong offset!");

// ScriptStruct Engine.BatchTickFunction
// 0x0038 (0x0068 - 0x0030)
struct FBatchTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBatchTickFunction) == 0x000008, "Wrong alignment on FBatchTickFunction");
//(sizeof(FBatchTickFunction) == 0x000068, "Wrong size on FBatchTickFunction");

// ScriptStruct Engine.BlendSpaceBlendProfile
// 0x0010 (0x0010 - 0x0000)
struct FBlendSpaceBlendProfile final
{
public:
	class UBlendProfile*                          BlendProfile;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetWeightInterpolationSpeedPerSec;              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBlendSpaceBlendProfile) == 0x000008, "Wrong alignment on FBlendSpaceBlendProfile");
//(sizeof(FBlendSpaceBlendProfile) == 0x000010, "Wrong size on FBlendSpaceBlendProfile");
//(offsetof(FBlendSpaceBlendProfile, BlendProfile) == 0x000000, "Member 'FBlendSpaceBlendProfile::BlendProfile' has a wrong offset!");
//(offsetof(FBlendSpaceBlendProfile, TargetWeightInterpolationSpeedPerSec) == 0x000008, "Member 'FBlendSpaceBlendProfile::TargetWeightInterpolationSpeedPerSec' has a wrong offset!");

// ScriptStruct Engine.InterpolationParameter
// 0x0010 (0x0010 - 0x0000)
struct FInterpolationParameter final
{
public:
	float                                         InterpolationTime;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DampingRatio;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFilterInterpolationType                      InterpolationType;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FInterpolationParameter) == 0x000004, "Wrong alignment on FInterpolationParameter");
//(sizeof(FInterpolationParameter) == 0x000010, "Wrong size on FInterpolationParameter");
//(offsetof(FInterpolationParameter, InterpolationTime) == 0x000000, "Member 'FInterpolationParameter::InterpolationTime' has a wrong offset!");
//(offsetof(FInterpolationParameter, DampingRatio) == 0x000004, "Member 'FInterpolationParameter::DampingRatio' has a wrong offset!");
//(offsetof(FInterpolationParameter, MaxSpeed) == 0x000008, "Member 'FInterpolationParameter::MaxSpeed' has a wrong offset!");
//(offsetof(FInterpolationParameter, InterpolationType) == 0x00000C, "Member 'FInterpolationParameter::InterpolationType' has a wrong offset!");

// ScriptStruct Engine.StateMachineStateDebugData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FStateMachineStateDebugData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStateMachineStateDebugData) == 0x000004, "Wrong alignment on FStateMachineStateDebugData");
//(sizeof(FStateMachineStateDebugData) == 0x000010, "Wrong size on FStateMachineStateDebugData");

// ScriptStruct Engine.BlendParameter
// 0x0020 (0x0020 - 0x0000)
struct FBlendParameter final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridNum;                                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapToGrid;                                       // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWrapInput;                                        // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBlendParameter) == 0x000008, "Wrong alignment on FBlendParameter");
//(sizeof(FBlendParameter) == 0x000020, "Wrong size on FBlendParameter");
//(offsetof(FBlendParameter, DisplayName) == 0x000000, "Member 'FBlendParameter::DisplayName' has a wrong offset!");
//(offsetof(FBlendParameter, Min) == 0x000010, "Member 'FBlendParameter::Min' has a wrong offset!");
//(offsetof(FBlendParameter, Max) == 0x000014, "Member 'FBlendParameter::Max' has a wrong offset!");
//(offsetof(FBlendParameter, GridNum) == 0x000018, "Member 'FBlendParameter::GridNum' has a wrong offset!");
//(offsetof(FBlendParameter, bSnapToGrid) == 0x00001C, "Member 'FBlendParameter::bSnapToGrid' has a wrong offset!");
//(offsetof(FBlendParameter, bWrapInput) == 0x00001D, "Member 'FBlendParameter::bWrapInput' has a wrong offset!");

// ScriptStruct Engine.MeshMergingSettings
// 0x0108 (0x0108 - 0x0000)
struct FMeshMergingSettings final
{
public:
	int32                                         TargetLightMapResolution;                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUVOutput                                     OutputUVs[0x8];                                    // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMaterialProxySettings                 MaterialSettings;                                  // 0x0010(0x00A0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         GutterSize;                                        // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshLODSelectionType                         LODSelectionType;                                  // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpecificLOD;                                       // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGenerateLightMapUV : 1;                           // 0x00BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bComputedLightMapResolution : 1;                   // 0x00BC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPivotPointAtZero : 1;                             // 0x00BC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMergePhysicsData : 1;                             // 0x00BC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMergeMeshSockets : 1;                             // 0x00BC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMergeMaterials : 1;                               // 0x00BC(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBakeVertexDataToMesh : 1;                         // 0x00BC(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseVertexDataForBakingMaterial : 1;               // 0x00BC(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseTextureBinning : 1;                            // 0x00BD(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReuseMeshLightmapUVs : 1;                         // 0x00BD(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMergeEquivalentMaterials : 1;                     // 0x00BD(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseLandscapeCulling : 1;                          // 0x00BD(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIncludeImposters : 1;                             // 0x00BD(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportRayTracing : 1;                            // 0x00BD(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowDistanceField : 1;                           // 0x00BD(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeshNaniteSettings                    NaniteSettings;                                    // 0x00C0(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMeshMergingSettings) == 0x000008, "Wrong alignment on FMeshMergingSettings");
//(sizeof(FMeshMergingSettings) == 0x000108, "Wrong size on FMeshMergingSettings");
//(offsetof(FMeshMergingSettings, TargetLightMapResolution) == 0x000000, "Member 'FMeshMergingSettings::TargetLightMapResolution' has a wrong offset!");
//(offsetof(FMeshMergingSettings, OutputUVs) == 0x000004, "Member 'FMeshMergingSettings::OutputUVs' has a wrong offset!");
//(offsetof(FMeshMergingSettings, MaterialSettings) == 0x000010, "Member 'FMeshMergingSettings::MaterialSettings' has a wrong offset!");
//(offsetof(FMeshMergingSettings, GutterSize) == 0x0000B0, "Member 'FMeshMergingSettings::GutterSize' has a wrong offset!");
//(offsetof(FMeshMergingSettings, LODSelectionType) == 0x0000B4, "Member 'FMeshMergingSettings::LODSelectionType' has a wrong offset!");
//(offsetof(FMeshMergingSettings, SpecificLOD) == 0x0000B8, "Member 'FMeshMergingSettings::SpecificLOD' has a wrong offset!");
//(offsetof(FMeshMergingSettings, NaniteSettings) == 0x0000C0, "Member 'FMeshMergingSettings::NaniteSettings' has a wrong offset!");

// ScriptStruct Engine.MarvelPerBoneBlendRatio
// 0x001C (0x001C - 0x0000)
struct FMarvelPerBoneBlendRatio final
{
public:
	struct FBoneReference                         BoneReference;                                     // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WeightRatio;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x4];                                       // 0x0018(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMarvelPerBoneBlendRatio) == 0x000004, "Wrong alignment on FMarvelPerBoneBlendRatio");
//(sizeof(FMarvelPerBoneBlendRatio) == 0x00001C, "Wrong size on FMarvelPerBoneBlendRatio");
//(offsetof(FMarvelPerBoneBlendRatio, BoneReference) == 0x000000, "Member 'FMarvelPerBoneBlendRatio::BoneReference' has a wrong offset!");
//(offsetof(FMarvelPerBoneBlendRatio, WeightRatio) == 0x000014, "Member 'FMarvelPerBoneBlendRatio::WeightRatio' has a wrong offset!");

// ScriptStruct Engine.BlendSample
// 0x0038 (0x0038 - 0x0000)
struct FBlendSample final
{
public:
	class UAnimSequence*                          Animation;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SampleValue;                                       // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RateScale;                                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMarvelPerBoneBlendRatio>       MarvelPerBoneAdjust;                               // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FBlendSample) == 0x000008, "Wrong alignment on FBlendSample");
//(sizeof(FBlendSample) == 0x000038, "Wrong size on FBlendSample");
//(offsetof(FBlendSample, Animation) == 0x000000, "Member 'FBlendSample::Animation' has a wrong offset!");
//(offsetof(FBlendSample, SampleValue) == 0x000008, "Member 'FBlendSample::SampleValue' has a wrong offset!");
//(offsetof(FBlendSample, RateScale) == 0x000020, "Member 'FBlendSample::RateScale' has a wrong offset!");
//(offsetof(FBlendSample, MarvelPerBoneAdjust) == 0x000028, "Member 'FBlendSample::MarvelPerBoneAdjust' has a wrong offset!");

// ScriptStruct Engine.AnimNode_CustomProperty
// 0x0048 (0x0070 - 0x0028)
struct FAnimNode_CustomProperty : public FAnimNode_Base
{
public:
	TArray<class FName>                           SourcePropertyNames;                               // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           DestPropertyNames;                                 // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UObject*                                TargetInstance;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_CustomProperty) == 0x000008, "Wrong alignment on FAnimNode_CustomProperty");
//(sizeof(FAnimNode_CustomProperty) == 0x000070, "Wrong size on FAnimNode_CustomProperty");
//(offsetof(FAnimNode_CustomProperty, SourcePropertyNames) == 0x000028, "Member 'FAnimNode_CustomProperty::SourcePropertyNames' has a wrong offset!");
//(offsetof(FAnimNode_CustomProperty, DestPropertyNames) == 0x000038, "Member 'FAnimNode_CustomProperty::DestPropertyNames' has a wrong offset!");
//(offsetof(FAnimNode_CustomProperty, TargetInstance) == 0x000048, "Member 'FAnimNode_CustomProperty::TargetInstance' has a wrong offset!");

// ScriptStruct Engine.AnimNode_LinkedAnimGraph
// 0x0060 (0x00D0 - 0x0070)
struct FAnimNode_LinkedAnimGraph : public FAnimNode_CustomProperty
{
public:
	TArray<struct FPoseLink>                      InputPoses;                                        // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           InputPoseNames;                                    // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              InstanceClass;                                     // 0x0090(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendProfile*                          PendingBlendOutProfile;                            // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendProfile*                          PendingBlendInProfile;                             // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bReceiveNotifiesFromLinkedInstances : 1;           // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPropagateNotifiesToLinkedInstances : 1;           // 0x00C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_LinkedAnimGraph) == 0x000008, "Wrong alignment on FAnimNode_LinkedAnimGraph");
//(sizeof(FAnimNode_LinkedAnimGraph) == 0x0000D0, "Wrong size on FAnimNode_LinkedAnimGraph");
//(offsetof(FAnimNode_LinkedAnimGraph, InputPoses) == 0x000070, "Member 'FAnimNode_LinkedAnimGraph::InputPoses' has a wrong offset!");
//(offsetof(FAnimNode_LinkedAnimGraph, InputPoseNames) == 0x000080, "Member 'FAnimNode_LinkedAnimGraph::InputPoseNames' has a wrong offset!");
//(offsetof(FAnimNode_LinkedAnimGraph, InstanceClass) == 0x000090, "Member 'FAnimNode_LinkedAnimGraph::InstanceClass' has a wrong offset!");
//(offsetof(FAnimNode_LinkedAnimGraph, PendingBlendOutProfile) == 0x0000B0, "Member 'FAnimNode_LinkedAnimGraph::PendingBlendOutProfile' has a wrong offset!");
//(offsetof(FAnimNode_LinkedAnimGraph, PendingBlendInProfile) == 0x0000C0, "Member 'FAnimNode_LinkedAnimGraph::PendingBlendInProfile' has a wrong offset!");

// ScriptStruct Engine.AnimNode_LinkedAnimLayer
// 0x0018 (0x00E8 - 0x00D0)
struct FAnimNode_LinkedAnimLayer final : public FAnimNode_LinkedAnimGraph
{
public:
	TSubclassOf<class IAnimLayerInterface>        Interface;                                         // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Layer;                                             // 0x00D8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_LinkedAnimLayer) == 0x000008, "Wrong alignment on FAnimNode_LinkedAnimLayer");
//(sizeof(FAnimNode_LinkedAnimLayer) == 0x0000E8, "Wrong size on FAnimNode_LinkedAnimLayer");
//(offsetof(FAnimNode_LinkedAnimLayer, Interface) == 0x0000D0, "Member 'FAnimNode_LinkedAnimLayer::Interface' has a wrong offset!");
//(offsetof(FAnimNode_LinkedAnimLayer, Layer) == 0x0000D8, "Member 'FAnimNode_LinkedAnimLayer::Layer' has a wrong offset!");

// ScriptStruct Engine.WeightedBlendSample
// 0x0008 (0x0008 - 0x0000)
struct FWeightedBlendSample final
{
public:
	int32                                         SampleIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleWeight;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FWeightedBlendSample) == 0x000004, "Wrong alignment on FWeightedBlendSample");
//(sizeof(FWeightedBlendSample) == 0x000008, "Wrong size on FWeightedBlendSample");
//(offsetof(FWeightedBlendSample, SampleIndex) == 0x000000, "Member 'FWeightedBlendSample::SampleIndex' has a wrong offset!");
//(offsetof(FWeightedBlendSample, SampleWeight) == 0x000004, "Member 'FWeightedBlendSample::SampleWeight' has a wrong offset!");

// ScriptStruct Engine.EditorElement
// 0x0018 (0x0018 - 0x0000)
struct FEditorElement final
{
public:
	int32                                         Indices[0x3];                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weights[0x3];                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FEditorElement) == 0x000004, "Wrong alignment on FEditorElement");
//(sizeof(FEditorElement) == 0x000018, "Wrong size on FEditorElement");
//(offsetof(FEditorElement, Indices) == 0x000000, "Member 'FEditorElement::Indices' has a wrong offset!");
//(offsetof(FEditorElement, Weights) == 0x00000C, "Member 'FEditorElement::Weights' has a wrong offset!");

// ScriptStruct Engine.QuartzQuantizationBoundary
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FQuartzQuantizationBoundary final
{
public:
	EQuartzCommandQuantization                    Quantization;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Multiplier;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuarztQuantizationReference                  CountingReferencePoint;                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireOnClockStart;                                 // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelCommandIfClockIsNotRunning;                 // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetClockOnQueued;                               // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResumeClockOnQueued;                              // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x13];                                       // 0x000D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FQuartzQuantizationBoundary) == 0x000008, "Wrong alignment on FQuartzQuantizationBoundary");
//(sizeof(FQuartzQuantizationBoundary) == 0x000020, "Wrong size on FQuartzQuantizationBoundary");
//(offsetof(FQuartzQuantizationBoundary, Quantization) == 0x000000, "Member 'FQuartzQuantizationBoundary::Quantization' has a wrong offset!");
//(offsetof(FQuartzQuantizationBoundary, Multiplier) == 0x000004, "Member 'FQuartzQuantizationBoundary::Multiplier' has a wrong offset!");
//(offsetof(FQuartzQuantizationBoundary, CountingReferencePoint) == 0x000008, "Member 'FQuartzQuantizationBoundary::CountingReferencePoint' has a wrong offset!");
//(offsetof(FQuartzQuantizationBoundary, bFireOnClockStart) == 0x000009, "Member 'FQuartzQuantizationBoundary::bFireOnClockStart' has a wrong offset!");
//(offsetof(FQuartzQuantizationBoundary, bCancelCommandIfClockIsNotRunning) == 0x00000A, "Member 'FQuartzQuantizationBoundary::bCancelCommandIfClockIsNotRunning' has a wrong offset!");
//(offsetof(FQuartzQuantizationBoundary, bResetClockOnQueued) == 0x00000B, "Member 'FQuartzQuantizationBoundary::bResetClockOnQueued' has a wrong offset!");
//(offsetof(FQuartzQuantizationBoundary, bResumeClockOnQueued) == 0x00000C, "Member 'FQuartzQuantizationBoundary::bResumeClockOnQueued' has a wrong offset!");

// ScriptStruct Engine.GridBlendSample
// 0x001C (0x001C - 0x0000)
struct FGridBlendSample final
{
public:
	struct FEditorElement                         GridElement;                                       // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FGridBlendSample) == 0x000004, "Wrong alignment on FGridBlendSample");
//(sizeof(FGridBlendSample) == 0x00001C, "Wrong size on FGridBlendSample");
//(offsetof(FGridBlendSample, GridElement) == 0x000000, "Member 'FGridBlendSample::GridElement' has a wrong offset!");
//(offsetof(FGridBlendSample, BlendWeight) == 0x000018, "Member 'FGridBlendSample::BlendWeight' has a wrong offset!");

// ScriptStruct Engine.PerBoneInterpolation
// 0x0018 (0x0018 - 0x0000)
struct FPerBoneInterpolation final
{
public:
	struct FBoneReference                         BoneReference;                                     // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InterpolationSpeedPerSec;                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPerBoneInterpolation) == 0x000004, "Wrong alignment on FPerBoneInterpolation");
//(sizeof(FPerBoneInterpolation) == 0x000018, "Wrong size on FPerBoneInterpolation");
//(offsetof(FPerBoneInterpolation, BoneReference) == 0x000000, "Member 'FPerBoneInterpolation::BoneReference' has a wrong offset!");
//(offsetof(FPerBoneInterpolation, InterpolationSpeedPerSec) == 0x000014, "Member 'FPerBoneInterpolation::InterpolationSpeedPerSec' has a wrong offset!");

// ScriptStruct Engine.AnimationActiveTransitionEntry
// 0x00C8 (0x00C8 - 0x0000)
struct FAnimationActiveTransitionEntry final
{
public:
	uint8                                         Pad_0[0xB8];                                       // 0x0000(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendProfile*                          BlendProfile;                                      // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimationActiveTransitionEntry) == 0x000008, "Wrong alignment on FAnimationActiveTransitionEntry");
//(sizeof(FAnimationActiveTransitionEntry) == 0x0000C8, "Wrong size on FAnimationActiveTransitionEntry");
//(offsetof(FAnimationActiveTransitionEntry, BlendProfile) == 0x0000B8, "Member 'FAnimationActiveTransitionEntry::BlendProfile' has a wrong offset!");

// ScriptStruct Engine.CompilerNativizationOptions
// 0x0080 (0x0080 - 0x0000)
struct FCompilerNativizationOptions final
{
public:
	class FName                                   PlatformName;                                      // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ServerOnlyPlatform;                                // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClientOnlyPlatform;                                // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExcludeMonolithicHeaders;                         // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExcludedModules;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<struct FSoftObjectPath>                  ExcludedAssets;                                    // 0x0020(0x0050)(NativeAccessSpecifierPublic)
	TArray<class FString>                         ExcludedFolderPaths;                               // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FCompilerNativizationOptions) == 0x000008, "Wrong alignment on FCompilerNativizationOptions");
//(sizeof(FCompilerNativizationOptions) == 0x000080, "Wrong size on FCompilerNativizationOptions");
//(offsetof(FCompilerNativizationOptions, PlatformName) == 0x000000, "Member 'FCompilerNativizationOptions::PlatformName' has a wrong offset!");
//(offsetof(FCompilerNativizationOptions, ServerOnlyPlatform) == 0x00000C, "Member 'FCompilerNativizationOptions::ServerOnlyPlatform' has a wrong offset!");
//(offsetof(FCompilerNativizationOptions, ClientOnlyPlatform) == 0x00000D, "Member 'FCompilerNativizationOptions::ClientOnlyPlatform' has a wrong offset!");
//(offsetof(FCompilerNativizationOptions, bExcludeMonolithicHeaders) == 0x00000E, "Member 'FCompilerNativizationOptions::bExcludeMonolithicHeaders' has a wrong offset!");
//(offsetof(FCompilerNativizationOptions, ExcludedModules) == 0x000010, "Member 'FCompilerNativizationOptions::ExcludedModules' has a wrong offset!");
//(offsetof(FCompilerNativizationOptions, ExcludedAssets) == 0x000020, "Member 'FCompilerNativizationOptions::ExcludedAssets' has a wrong offset!");
//(offsetof(FCompilerNativizationOptions, ExcludedFolderPaths) == 0x000070, "Member 'FCompilerNativizationOptions::ExcludedFolderPaths' has a wrong offset!");

// ScriptStruct Engine.RawDistributionFloat
// 0x0010 (0x0030 - 0x0020)
struct FRawDistributionFloat final : public FRawDistribution
{
public:
	float                                         MinValue;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxValue;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDistributionFloat*                     Distribution;                                      // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRawDistributionFloat) == 0x000008, "Wrong alignment on FRawDistributionFloat");
//(sizeof(FRawDistributionFloat) == 0x000030, "Wrong size on FRawDistributionFloat");
//(offsetof(FRawDistributionFloat, MinValue) == 0x000020, "Member 'FRawDistributionFloat::MinValue' has a wrong offset!");
//(offsetof(FRawDistributionFloat, MaxValue) == 0x000024, "Member 'FRawDistributionFloat::MaxValue' has a wrong offset!");
//(offsetof(FRawDistributionFloat, Distribution) == 0x000028, "Member 'FRawDistributionFloat::Distribution' has a wrong offset!");

// ScriptStruct Engine.RawDistributionVector
// 0x0040 (0x0060 - 0x0020)
struct FRawDistributionVector final : public FRawDistribution
{
public:
	float                                         MinValue;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxValue;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                MinValueVec;                                       // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                MaxValueVec;                                       // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDistributionVector*                    Distribution;                                      // 0x0058(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRawDistributionVector) == 0x000008, "Wrong alignment on FRawDistributionVector");
//(sizeof(FRawDistributionVector) == 0x000060, "Wrong size on FRawDistributionVector");
//(offsetof(FRawDistributionVector, MinValue) == 0x000020, "Member 'FRawDistributionVector::MinValue' has a wrong offset!");
//(offsetof(FRawDistributionVector, MaxValue) == 0x000024, "Member 'FRawDistributionVector::MaxValue' has a wrong offset!");
//(offsetof(FRawDistributionVector, MinValueVec) == 0x000028, "Member 'FRawDistributionVector::MinValueVec' has a wrong offset!");
//(offsetof(FRawDistributionVector, MaxValueVec) == 0x000040, "Member 'FRawDistributionVector::MaxValueVec' has a wrong offset!");
//(offsetof(FRawDistributionVector, Distribution) == 0x000058, "Member 'FRawDistributionVector::Distribution' has a wrong offset!");

// ScriptStruct Engine.GPUSpriteEmitterInfo
// 0x0350 (0x0350 - 0x0000)
struct FGPUSpriteEmitterInfo final
{
public:
	class UParticleModuleRequired*                RequiredModule;                                    // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleModuleSpawn*                   SpawnModule;                                       // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleModuleSpawnPerUnit*            SpawnPerUnitModule;                                // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleModule*>                SpawnModules;                                      // 0x0018(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGPUSpriteLocalVectorFieldInfo         LocalVectorField;                                  // 0x0030(0x00D0)(NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatDistribution                     VectorFieldScale;                                  // 0x0100(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatDistribution                     DragCoefficient;                                   // 0x0120(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatDistribution                     PointAttractorStrength;                            // 0x0140(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatDistribution                     Resilience;                                        // 0x0160(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConstantAcceleration;                              // 0x0180(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointAttractorPosition;                            // 0x0198(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointAttractorRadiusSq;                            // 0x01B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OrbitOffsetBase;                                   // 0x01B8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OrbitOffsetRange;                                  // 0x01D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InvMaxSize;                                        // 0x01E8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvRotationRateScale;                              // 0x01F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLifetime;                                       // 0x01FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxParticleCount;                                  // 0x0200(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleScreenAlignment                      ScreenAlignment;                                   // 0x0204(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleAxisLock                             LockAxisFlag;                                      // 0x0205(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_206[0x2];                                      // 0x0206(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnableCollision : 1;                              // 0x0208(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EParticleCollisionMode                        CollisionMode;                                     // 0x020C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D[0x3];                                      // 0x020D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseVelocityForMotionBlur : 1;                     // 0x0210(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRemoveHMDRoll : 1;                                // 0x0210(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinFacingCameraBlendDistance;                      // 0x0214(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFacingCameraBlendDistance;                      // 0x0218(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 DynamicColor;                                      // 0x0220(0x0060)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DynamicAlpha;                                      // 0x0280(0x0030)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 DynamicColorScale;                                 // 0x02B0(0x0060)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DynamicAlphaScale;                                 // 0x0310(0x0030)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FGPUSpriteEmitterInfo) == 0x000010, "Wrong alignment on FGPUSpriteEmitterInfo");
//(sizeof(FGPUSpriteEmitterInfo) == 0x000350, "Wrong size on FGPUSpriteEmitterInfo");
//(offsetof(FGPUSpriteEmitterInfo, RequiredModule) == 0x000000, "Member 'FGPUSpriteEmitterInfo::RequiredModule' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, SpawnModule) == 0x000008, "Member 'FGPUSpriteEmitterInfo::SpawnModule' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, SpawnPerUnitModule) == 0x000010, "Member 'FGPUSpriteEmitterInfo::SpawnPerUnitModule' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, SpawnModules) == 0x000018, "Member 'FGPUSpriteEmitterInfo::SpawnModules' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, LocalVectorField) == 0x000030, "Member 'FGPUSpriteEmitterInfo::LocalVectorField' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, VectorFieldScale) == 0x000100, "Member 'FGPUSpriteEmitterInfo::VectorFieldScale' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, DragCoefficient) == 0x000120, "Member 'FGPUSpriteEmitterInfo::DragCoefficient' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, PointAttractorStrength) == 0x000140, "Member 'FGPUSpriteEmitterInfo::PointAttractorStrength' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, Resilience) == 0x000160, "Member 'FGPUSpriteEmitterInfo::Resilience' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, ConstantAcceleration) == 0x000180, "Member 'FGPUSpriteEmitterInfo::ConstantAcceleration' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, PointAttractorPosition) == 0x000198, "Member 'FGPUSpriteEmitterInfo::PointAttractorPosition' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, PointAttractorRadiusSq) == 0x0001B0, "Member 'FGPUSpriteEmitterInfo::PointAttractorRadiusSq' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, OrbitOffsetBase) == 0x0001B8, "Member 'FGPUSpriteEmitterInfo::OrbitOffsetBase' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, OrbitOffsetRange) == 0x0001D0, "Member 'FGPUSpriteEmitterInfo::OrbitOffsetRange' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, InvMaxSize) == 0x0001E8, "Member 'FGPUSpriteEmitterInfo::InvMaxSize' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, InvRotationRateScale) == 0x0001F8, "Member 'FGPUSpriteEmitterInfo::InvRotationRateScale' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, MaxLifetime) == 0x0001FC, "Member 'FGPUSpriteEmitterInfo::MaxLifetime' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, MaxParticleCount) == 0x000200, "Member 'FGPUSpriteEmitterInfo::MaxParticleCount' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, ScreenAlignment) == 0x000204, "Member 'FGPUSpriteEmitterInfo::ScreenAlignment' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, LockAxisFlag) == 0x000205, "Member 'FGPUSpriteEmitterInfo::LockAxisFlag' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, CollisionMode) == 0x00020C, "Member 'FGPUSpriteEmitterInfo::CollisionMode' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, MinFacingCameraBlendDistance) == 0x000214, "Member 'FGPUSpriteEmitterInfo::MinFacingCameraBlendDistance' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, MaxFacingCameraBlendDistance) == 0x000218, "Member 'FGPUSpriteEmitterInfo::MaxFacingCameraBlendDistance' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, DynamicColor) == 0x000220, "Member 'FGPUSpriteEmitterInfo::DynamicColor' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, DynamicAlpha) == 0x000280, "Member 'FGPUSpriteEmitterInfo::DynamicAlpha' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, DynamicColorScale) == 0x0002B0, "Member 'FGPUSpriteEmitterInfo::DynamicColorScale' has a wrong offset!");
//(offsetof(FGPUSpriteEmitterInfo, DynamicAlphaScale) == 0x000310, "Member 'FGPUSpriteEmitterInfo::DynamicAlphaScale' has a wrong offset!");

// ScriptStruct Engine.BlueprintMacroCosmeticInfo
// 0x0001 (0x0001 - 0x0000)
struct FBlueprintMacroCosmeticInfo final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBlueprintMacroCosmeticInfo) == 0x000001, "Wrong alignment on FBlueprintMacroCosmeticInfo");
//(sizeof(FBlueprintMacroCosmeticInfo) == 0x000001, "Wrong size on FBlueprintMacroCosmeticInfo");

// ScriptStruct Engine.BakedStateExitTransition
// 0x0038 (0x0038 - 0x0000)
struct FBakedStateExitTransition final
{
public:
	int32                                         CanTakeDelegateIndex;                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomResultNodeIndex;                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransitionIndex;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesiredTransitionReturnValue;                     // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticRemainingTimeRule;                       // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutomaticRuleTriggerTime;                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SyncGroupNameToRequireValidMarkersRule;            // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PoseEvaluatorLinks;                                // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bOptimizable;                                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBakedStateExitTransition) == 0x000008, "Wrong alignment on FBakedStateExitTransition");
//(sizeof(FBakedStateExitTransition) == 0x000038, "Wrong size on FBakedStateExitTransition");
//(offsetof(FBakedStateExitTransition, CanTakeDelegateIndex) == 0x000000, "Member 'FBakedStateExitTransition::CanTakeDelegateIndex' has a wrong offset!");
//(offsetof(FBakedStateExitTransition, CustomResultNodeIndex) == 0x000004, "Member 'FBakedStateExitTransition::CustomResultNodeIndex' has a wrong offset!");
//(offsetof(FBakedStateExitTransition, TransitionIndex) == 0x000008, "Member 'FBakedStateExitTransition::TransitionIndex' has a wrong offset!");
//(offsetof(FBakedStateExitTransition, bDesiredTransitionReturnValue) == 0x00000C, "Member 'FBakedStateExitTransition::bDesiredTransitionReturnValue' has a wrong offset!");
//(offsetof(FBakedStateExitTransition, bAutomaticRemainingTimeRule) == 0x00000D, "Member 'FBakedStateExitTransition::bAutomaticRemainingTimeRule' has a wrong offset!");
//(offsetof(FBakedStateExitTransition, AutomaticRuleTriggerTime) == 0x000010, "Member 'FBakedStateExitTransition::AutomaticRuleTriggerTime' has a wrong offset!");
//(offsetof(FBakedStateExitTransition, SyncGroupNameToRequireValidMarkersRule) == 0x000014, "Member 'FBakedStateExitTransition::SyncGroupNameToRequireValidMarkersRule' has a wrong offset!");
//(offsetof(FBakedStateExitTransition, PoseEvaluatorLinks) == 0x000020, "Member 'FBakedStateExitTransition::PoseEvaluatorLinks' has a wrong offset!");
//(offsetof(FBakedStateExitTransition, bOptimizable) == 0x000030, "Member 'FBakedStateExitTransition::bOptimizable' has a wrong offset!");

// ScriptStruct Engine.BakedAnimationState
// 0x0080 (0x0080 - 0x0000)
struct FBakedAnimationState final
{
public:
	class FName                                   StateName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBakedStateExitTransition>      Transitions;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StateRootNodeIndex;                                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartNotify;                                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndNotify;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FullyBlendedNotify;                                // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAConduit;                                       // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EntryRuleNodeIndex;                                // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PlayerNodeIndices;                                 // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 LayerNodeIndices;                                  // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAlwaysResetOnEntry;                               // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransitionOptimizable;                            // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         RelevantPropNames;                                 // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 RelevantFirstPropNameLens;                         // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FBakedAnimationState) == 0x000008, "Wrong alignment on FBakedAnimationState");
//(sizeof(FBakedAnimationState) == 0x000080, "Wrong size on FBakedAnimationState");
//(offsetof(FBakedAnimationState, StateName) == 0x000000, "Member 'FBakedAnimationState::StateName' has a wrong offset!");
//(offsetof(FBakedAnimationState, Transitions) == 0x000010, "Member 'FBakedAnimationState::Transitions' has a wrong offset!");
//(offsetof(FBakedAnimationState, StateRootNodeIndex) == 0x000020, "Member 'FBakedAnimationState::StateRootNodeIndex' has a wrong offset!");
//(offsetof(FBakedAnimationState, StartNotify) == 0x000024, "Member 'FBakedAnimationState::StartNotify' has a wrong offset!");
//(offsetof(FBakedAnimationState, EndNotify) == 0x000028, "Member 'FBakedAnimationState::EndNotify' has a wrong offset!");
//(offsetof(FBakedAnimationState, FullyBlendedNotify) == 0x00002C, "Member 'FBakedAnimationState::FullyBlendedNotify' has a wrong offset!");
//(offsetof(FBakedAnimationState, bIsAConduit) == 0x000030, "Member 'FBakedAnimationState::bIsAConduit' has a wrong offset!");
//(offsetof(FBakedAnimationState, EntryRuleNodeIndex) == 0x000034, "Member 'FBakedAnimationState::EntryRuleNodeIndex' has a wrong offset!");
//(offsetof(FBakedAnimationState, PlayerNodeIndices) == 0x000038, "Member 'FBakedAnimationState::PlayerNodeIndices' has a wrong offset!");
//(offsetof(FBakedAnimationState, LayerNodeIndices) == 0x000048, "Member 'FBakedAnimationState::LayerNodeIndices' has a wrong offset!");
//(offsetof(FBakedAnimationState, bAlwaysResetOnEntry) == 0x000058, "Member 'FBakedAnimationState::bAlwaysResetOnEntry' has a wrong offset!");
//(offsetof(FBakedAnimationState, bTransitionOptimizable) == 0x000059, "Member 'FBakedAnimationState::bTransitionOptimizable' has a wrong offset!");
//(offsetof(FBakedAnimationState, RelevantPropNames) == 0x000060, "Member 'FBakedAnimationState::RelevantPropNames' has a wrong offset!");
//(offsetof(FBakedAnimationState, RelevantFirstPropNameLens) == 0x000070, "Member 'FBakedAnimationState::RelevantFirstPropNameLens' has a wrong offset!");

// ScriptStruct Engine.AnimationStateBase
// 0x000C (0x000C - 0x0000)
struct FAnimationStateBase
{
public:
	class FName                                   StateName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimationStateBase) == 0x000004, "Wrong alignment on FAnimationStateBase");
//(sizeof(FAnimationStateBase) == 0x00000C, "Wrong size on FAnimationStateBase");
//(offsetof(FAnimationStateBase, StateName) == 0x000000, "Member 'FAnimationStateBase::StateName' has a wrong offset!");

// ScriptStruct Engine.AnimationTransitionBetweenStates
// 0x0044 (0x0050 - 0x000C)
struct FAnimationTransitionBetweenStates final : public FAnimationStateBase
{
public:
	int32                                         PreviousState;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextState;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrossfadeDuration;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CrossfadeDurationPropertyName;                     // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartNotify;                                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndNotify;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterruptNotify;                                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendMode;                                         // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CustomCurve;                                       // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendProfile*                          BlendProfile;                                      // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransitionLogicType                          LogicType;                                         // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimationTransitionBetweenStates) == 0x000008, "Wrong alignment on FAnimationTransitionBetweenStates");
//(sizeof(FAnimationTransitionBetweenStates) == 0x000050, "Wrong size on FAnimationTransitionBetweenStates");
//(offsetof(FAnimationTransitionBetweenStates, PreviousState) == 0x00000C, "Member 'FAnimationTransitionBetweenStates::PreviousState' has a wrong offset!");
//(offsetof(FAnimationTransitionBetweenStates, NextState) == 0x000010, "Member 'FAnimationTransitionBetweenStates::NextState' has a wrong offset!");
//(offsetof(FAnimationTransitionBetweenStates, CrossfadeDuration) == 0x000014, "Member 'FAnimationTransitionBetweenStates::CrossfadeDuration' has a wrong offset!");
//(offsetof(FAnimationTransitionBetweenStates, CrossfadeDurationPropertyName) == 0x000018, "Member 'FAnimationTransitionBetweenStates::CrossfadeDurationPropertyName' has a wrong offset!");
//(offsetof(FAnimationTransitionBetweenStates, StartNotify) == 0x000024, "Member 'FAnimationTransitionBetweenStates::StartNotify' has a wrong offset!");
//(offsetof(FAnimationTransitionBetweenStates, EndNotify) == 0x000028, "Member 'FAnimationTransitionBetweenStates::EndNotify' has a wrong offset!");
//(offsetof(FAnimationTransitionBetweenStates, InterruptNotify) == 0x00002C, "Member 'FAnimationTransitionBetweenStates::InterruptNotify' has a wrong offset!");
//(offsetof(FAnimationTransitionBetweenStates, BlendMode) == 0x000030, "Member 'FAnimationTransitionBetweenStates::BlendMode' has a wrong offset!");
//(offsetof(FAnimationTransitionBetweenStates, CustomCurve) == 0x000038, "Member 'FAnimationTransitionBetweenStates::CustomCurve' has a wrong offset!");
//(offsetof(FAnimationTransitionBetweenStates, BlendProfile) == 0x000040, "Member 'FAnimationTransitionBetweenStates::BlendProfile' has a wrong offset!");
//(offsetof(FAnimationTransitionBetweenStates, LogicType) == 0x000048, "Member 'FAnimationTransitionBetweenStates::LogicType' has a wrong offset!");

// ScriptStruct Engine.BakedAnimationStateMachine
// 0x0030 (0x0030 - 0x0000)
struct FBakedAnimationStateMachine final
{
public:
	class FName                                   MachineName;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialState;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBakedAnimationState>           States;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAnimationTransitionBetweenStates> Transitions;                                       // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FBakedAnimationStateMachine) == 0x000008, "Wrong alignment on FBakedAnimationStateMachine");
//(sizeof(FBakedAnimationStateMachine) == 0x000030, "Wrong size on FBakedAnimationStateMachine");
//(offsetof(FBakedAnimationStateMachine, MachineName) == 0x000000, "Member 'FBakedAnimationStateMachine::MachineName' has a wrong offset!");
//(offsetof(FBakedAnimationStateMachine, InitialState) == 0x00000C, "Member 'FBakedAnimationStateMachine::InitialState' has a wrong offset!");
//(offsetof(FBakedAnimationStateMachine, States) == 0x000010, "Member 'FBakedAnimationStateMachine::States' has a wrong offset!");
//(offsetof(FBakedAnimationStateMachine, Transitions) == 0x000020, "Member 'FBakedAnimationStateMachine::Transitions' has a wrong offset!");

// ScriptStruct Engine.AlphaBlendArgs
// 0x0010 (0x0010 - 0x0000)
struct FAlphaBlendArgs final
{
public:
	class UCurveFloat*                            CustomCurve;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendOption;                                       // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAlphaBlendArgs) == 0x000008, "Wrong alignment on FAlphaBlendArgs");
//(sizeof(FAlphaBlendArgs) == 0x000010, "Wrong size on FAlphaBlendArgs");
//(offsetof(FAlphaBlendArgs, CustomCurve) == 0x000000, "Member 'FAlphaBlendArgs::CustomCurve' has a wrong offset!");
//(offsetof(FAlphaBlendArgs, BlendTime) == 0x000008, "Member 'FAlphaBlendArgs::BlendTime' has a wrong offset!");
//(offsetof(FAlphaBlendArgs, BlendOption) == 0x00000C, "Member 'FAlphaBlendArgs::BlendOption' has a wrong offset!");

// ScriptStruct Engine.BPInterfaceDescription
// 0x0018 (0x0018 - 0x0000)
struct FBPInterfaceDescription final
{
public:
	TSubclassOf<class IInterface>                 Interface;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UEdGraph*>                       Graphs;                                            // 0x0008(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FBPInterfaceDescription) == 0x000008, "Wrong alignment on FBPInterfaceDescription");
//(sizeof(FBPInterfaceDescription) == 0x000018, "Wrong size on FBPInterfaceDescription");
//(offsetof(FBPInterfaceDescription, Interface) == 0x000000, "Member 'FBPInterfaceDescription::Interface' has a wrong offset!");
//(offsetof(FBPInterfaceDescription, Graphs) == 0x000008, "Member 'FBPInterfaceDescription::Graphs' has a wrong offset!");

// ScriptStruct Engine.AnimNode_UseCachedPose
// 0x0020 (0x0048 - 0x0028)
struct FAnimNode_UseCachedPose final : public FAnimNode_Base
{
public:
	struct FPoseLink                              LinkToCachingNode;                                 // 0x0028(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   CachePoseName;                                     // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_UseCachedPose) == 0x000008, "Wrong alignment on FAnimNode_UseCachedPose");
//(sizeof(FAnimNode_UseCachedPose) == 0x000048, "Wrong size on FAnimNode_UseCachedPose");
//(offsetof(FAnimNode_UseCachedPose, LinkToCachingNode) == 0x000028, "Member 'FAnimNode_UseCachedPose::LinkToCachingNode' has a wrong offset!");
//(offsetof(FAnimNode_UseCachedPose, CachePoseName) == 0x000038, "Member 'FAnimNode_UseCachedPose::CachePoseName' has a wrong offset!");

// ScriptStruct Engine.EditedDocumentInfo
// 0x0048 (0x0048 - 0x0000)
struct FEditedDocumentInfo final
{
public:
	struct FSoftObjectPath                        EditedObjectPath;                                  // 0x0000(0x0028)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SavedViewOffset;                                   // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SavedZoomAmount;                                   // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                EditedObject;                                      // 0x0040(0x0008)(ZeroConstructor, Deprecated, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FEditedDocumentInfo) == 0x000008, "Wrong alignment on FEditedDocumentInfo");
//(sizeof(FEditedDocumentInfo) == 0x000048, "Wrong size on FEditedDocumentInfo");
//(offsetof(FEditedDocumentInfo, EditedObjectPath) == 0x000000, "Member 'FEditedDocumentInfo::EditedObjectPath' has a wrong offset!");
//(offsetof(FEditedDocumentInfo, SavedViewOffset) == 0x000028, "Member 'FEditedDocumentInfo::SavedViewOffset' has a wrong offset!");
//(offsetof(FEditedDocumentInfo, SavedZoomAmount) == 0x000038, "Member 'FEditedDocumentInfo::SavedZoomAmount' has a wrong offset!");
//(offsetof(FEditedDocumentInfo, EditedObject) == 0x000040, "Member 'FEditedDocumentInfo::EditedObject' has a wrong offset!");

// ScriptStruct Engine.ConstraintInstanceBase
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FConstraintInstanceBase
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FConstraintInstanceBase) == 0x000008, "Wrong alignment on FConstraintInstanceBase");
//(sizeof(FConstraintInstanceBase) == 0x000038, "Wrong size on FConstraintInstanceBase");

// ScriptStruct Engine.Bookmark2DJumpToSettings
// 0x0001 (0x0001 - 0x0000)
struct FBookmark2DJumpToSettings final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBookmark2DJumpToSettings) == 0x000001, "Wrong alignment on FBookmark2DJumpToSettings");
//(sizeof(FBookmark2DJumpToSettings) == 0x000001, "Wrong size on FBookmark2DJumpToSettings");

// ScriptStruct Engine.SubsurfaceProfileStruct
// 0x009C (0x009C - 0x0000)
struct FSubsurfaceProfileStruct final
{
public:
	struct FLinearColor                           SurfaceAlbedo;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MeanFreePathColor;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeanFreePathDistance;                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldUnitScale;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBurley;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMeanFreePath;                               // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Tint;                                              // 0x002C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScatterRadius;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SubsurfaceColor;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FalloffColor;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BoundaryColorBleed;                                // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtinctionScale;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalScale;                                       // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScatteringDistribution;                            // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IOR;                                               // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roughness0;                                        // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roughness1;                                        // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LobeMix;                                           // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TransmissionTintColor;                             // 0x008C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSubsurfaceProfileStruct) == 0x000004, "Wrong alignment on FSubsurfaceProfileStruct");
//(sizeof(FSubsurfaceProfileStruct) == 0x00009C, "Wrong size on FSubsurfaceProfileStruct");
//(offsetof(FSubsurfaceProfileStruct, SurfaceAlbedo) == 0x000000, "Member 'FSubsurfaceProfileStruct::SurfaceAlbedo' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, MeanFreePathColor) == 0x000010, "Member 'FSubsurfaceProfileStruct::MeanFreePathColor' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, MeanFreePathDistance) == 0x000020, "Member 'FSubsurfaceProfileStruct::MeanFreePathDistance' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, WorldUnitScale) == 0x000024, "Member 'FSubsurfaceProfileStruct::WorldUnitScale' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, bEnableBurley) == 0x000028, "Member 'FSubsurfaceProfileStruct::bEnableBurley' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, bEnableMeanFreePath) == 0x000029, "Member 'FSubsurfaceProfileStruct::bEnableMeanFreePath' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, Tint) == 0x00002C, "Member 'FSubsurfaceProfileStruct::Tint' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, ScatterRadius) == 0x00003C, "Member 'FSubsurfaceProfileStruct::ScatterRadius' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, SubsurfaceColor) == 0x000040, "Member 'FSubsurfaceProfileStruct::SubsurfaceColor' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, FalloffColor) == 0x000050, "Member 'FSubsurfaceProfileStruct::FalloffColor' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, BoundaryColorBleed) == 0x000060, "Member 'FSubsurfaceProfileStruct::BoundaryColorBleed' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, ExtinctionScale) == 0x000070, "Member 'FSubsurfaceProfileStruct::ExtinctionScale' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, NormalScale) == 0x000074, "Member 'FSubsurfaceProfileStruct::NormalScale' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, ScatteringDistribution) == 0x000078, "Member 'FSubsurfaceProfileStruct::ScatteringDistribution' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, IOR) == 0x00007C, "Member 'FSubsurfaceProfileStruct::IOR' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, Roughness0) == 0x000080, "Member 'FSubsurfaceProfileStruct::Roughness0' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, Roughness1) == 0x000084, "Member 'FSubsurfaceProfileStruct::Roughness1' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, LobeMix) == 0x000088, "Member 'FSubsurfaceProfileStruct::LobeMix' has a wrong offset!");
//(offsetof(FSubsurfaceProfileStruct, TransmissionTintColor) == 0x00008C, "Member 'FSubsurfaceProfileStruct::TransmissionTintColor' has a wrong offset!");

// ScriptStruct Engine.GeomSelection
// 0x000C (0x000C - 0x0000)
struct FGeomSelection final
{
public:
	int32                                         Type;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectionIndex;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FGeomSelection) == 0x000004, "Wrong alignment on FGeomSelection");
//(sizeof(FGeomSelection) == 0x00000C, "Wrong size on FGeomSelection");
//(offsetof(FGeomSelection, Type) == 0x000000, "Member 'FGeomSelection::Type' has a wrong offset!");
//(offsetof(FGeomSelection, Index) == 0x000004, "Member 'FGeomSelection::Index' has a wrong offset!");
//(offsetof(FGeomSelection, SelectionIndex) == 0x000008, "Member 'FGeomSelection::SelectionIndex' has a wrong offset!");

// ScriptStruct Engine.RepCheckRowMsg
// 0x0010 (0x0010 - 0x0000)
struct FRepCheckRowMsg final
{
public:
	TArray<class FString>                         Data;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FRepCheckRowMsg) == 0x000008, "Wrong alignment on FRepCheckRowMsg");
//(sizeof(FRepCheckRowMsg) == 0x000010, "Wrong size on FRepCheckRowMsg");
//(offsetof(FRepCheckRowMsg, Data) == 0x000000, "Member 'FRepCheckRowMsg::Data' has a wrong offset!");

// ScriptStruct Engine.UpdateLevelStreamingLevelStatus
// 0x0014 (0x0014 - 0x0000)
struct FUpdateLevelStreamingLevelStatus final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewShouldBeLoaded;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewShouldBeVisible;                               // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewShouldBlockOnLoad;                             // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewShouldBlockOnUnload;                           // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FUpdateLevelStreamingLevelStatus) == 0x000004, "Wrong alignment on FUpdateLevelStreamingLevelStatus");
//(sizeof(FUpdateLevelStreamingLevelStatus) == 0x000014, "Wrong size on FUpdateLevelStreamingLevelStatus");
//(offsetof(FUpdateLevelStreamingLevelStatus, PackageName) == 0x000000, "Member 'FUpdateLevelStreamingLevelStatus::PackageName' has a wrong offset!");
//(offsetof(FUpdateLevelStreamingLevelStatus, LODIndex) == 0x00000C, "Member 'FUpdateLevelStreamingLevelStatus::LODIndex' has a wrong offset!");
//(offsetof(FUpdateLevelStreamingLevelStatus, bNewShouldBeLoaded) == 0x000010, "Member 'FUpdateLevelStreamingLevelStatus::bNewShouldBeLoaded' has a wrong offset!");
//(offsetof(FUpdateLevelStreamingLevelStatus, bNewShouldBeVisible) == 0x000011, "Member 'FUpdateLevelStreamingLevelStatus::bNewShouldBeVisible' has a wrong offset!");
//(offsetof(FUpdateLevelStreamingLevelStatus, bNewShouldBlockOnLoad) == 0x000012, "Member 'FUpdateLevelStreamingLevelStatus::bNewShouldBlockOnLoad' has a wrong offset!");
//(offsetof(FUpdateLevelStreamingLevelStatus, bNewShouldBlockOnUnload) == 0x000013, "Member 'FUpdateLevelStreamingLevelStatus::bNewShouldBlockOnUnload' has a wrong offset!");

// ScriptStruct Engine.IntegerAnimationAttribute
// 0x0004 (0x0004 - 0x0000)
struct FIntegerAnimationAttribute
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FIntegerAnimationAttribute) == 0x000004, "Wrong alignment on FIntegerAnimationAttribute");
//(sizeof(FIntegerAnimationAttribute) == 0x000004, "Wrong size on FIntegerAnimationAttribute");
//(offsetof(FIntegerAnimationAttribute, Value) == 0x000000, "Member 'FIntegerAnimationAttribute::Value' has a wrong offset!");

// ScriptStruct Engine.StringAnimationAttribute
// 0x0010 (0x0010 - 0x0000)
struct FStringAnimationAttribute final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FStringAnimationAttribute) == 0x000008, "Wrong alignment on FStringAnimationAttribute");
//(sizeof(FStringAnimationAttribute) == 0x000010, "Wrong size on FStringAnimationAttribute");
//(offsetof(FStringAnimationAttribute, Value) == 0x000000, "Member 'FStringAnimationAttribute::Value' has a wrong offset!");

// ScriptStruct Engine.CameraCacheEntry
// 0x0A60 (0x0A60 - 0x0000)
struct FCameraCacheEntry final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       POV;                                               // 0x0010(0x0A50)(NativeAccessSpecifierPublic)
};
//(alignof(FCameraCacheEntry) == 0x000010, "Wrong alignment on FCameraCacheEntry");
//(sizeof(FCameraCacheEntry) == 0x000A60, "Wrong size on FCameraCacheEntry");
//(offsetof(FCameraCacheEntry, Timestamp) == 0x000000, "Member 'FCameraCacheEntry::Timestamp' has a wrong offset!");
//(offsetof(FCameraCacheEntry, POV) == 0x000010, "Member 'FCameraCacheEntry::POV' has a wrong offset!");

// ScriptStruct Engine.TransformAnimationAttribute
// 0x0060 (0x0060 - 0x0000)
struct FTransformAnimationAttribute
{
public:
	struct FTransform                             Value;                                             // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTransformAnimationAttribute) == 0x000010, "Wrong alignment on FTransformAnimationAttribute");
//(sizeof(FTransformAnimationAttribute) == 0x000060, "Wrong size on FTransformAnimationAttribute");
//(offsetof(FTransformAnimationAttribute, Value) == 0x000000, "Member 'FTransformAnimationAttribute::Value' has a wrong offset!");

// ScriptStruct Engine.TimelineFloatTrack
// 0x0050 (0x0050 - 0x0000)
struct FTimelineFloatTrack final
{
public:
	class UCurveFloat*                            FloatCurve;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class FName TrackName, class FName PropertyName, float Output)> InterpFunc;                                        // 0x0008(0x0014)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrackName;                                         // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FloatPropertyName;                                 // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x1C];                                      // 0x0034(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTimelineFloatTrack) == 0x000008, "Wrong alignment on FTimelineFloatTrack");
//(sizeof(FTimelineFloatTrack) == 0x000050, "Wrong size on FTimelineFloatTrack");
//(offsetof(FTimelineFloatTrack, FloatCurve) == 0x000000, "Member 'FTimelineFloatTrack::FloatCurve' has a wrong offset!");
//(offsetof(FTimelineFloatTrack, InterpFunc) == 0x000008, "Member 'FTimelineFloatTrack::InterpFunc' has a wrong offset!");
//(offsetof(FTimelineFloatTrack, TrackName) == 0x00001C, "Member 'FTimelineFloatTrack::TrackName' has a wrong offset!");
//(offsetof(FTimelineFloatTrack, FloatPropertyName) == 0x000028, "Member 'FTimelineFloatTrack::FloatPropertyName' has a wrong offset!");

// ScriptStruct Engine.VectorAnimationAttribute
// 0x0018 (0x0018 - 0x0000)
struct FVectorAnimationAttribute
{
public:
	struct FVector                                Value;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FVectorAnimationAttribute) == 0x000008, "Wrong alignment on FVectorAnimationAttribute");
//(sizeof(FVectorAnimationAttribute) == 0x000018, "Wrong size on FVectorAnimationAttribute");
//(offsetof(FVectorAnimationAttribute, Value) == 0x000000, "Member 'FVectorAnimationAttribute::Value' has a wrong offset!");

// ScriptStruct Engine.NonBlendableQuaternionAnimationAttribute
// 0x0000 (0x0020 - 0x0020)
struct FNonBlendableQuaternionAnimationAttribute final : public FQuaternionAnimationAttribute
{
};
//(alignof(FNonBlendableQuaternionAnimationAttribute) == 0x000010, "Wrong alignment on FNonBlendableQuaternionAnimationAttribute");
//(sizeof(FNonBlendableQuaternionAnimationAttribute) == 0x000020, "Wrong size on FNonBlendableQuaternionAnimationAttribute");

// ScriptStruct Engine.ParticleBurst
// 0x000C (0x000C - 0x0000)
struct FParticleBurst final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountLow;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FParticleBurst) == 0x000004, "Wrong alignment on FParticleBurst");
//(sizeof(FParticleBurst) == 0x00000C, "Wrong size on FParticleBurst");
//(offsetof(FParticleBurst, Count) == 0x000000, "Member 'FParticleBurst::Count' has a wrong offset!");
//(offsetof(FParticleBurst, CountLow) == 0x000004, "Member 'FParticleBurst::CountLow' has a wrong offset!");
//(offsetof(FParticleBurst, Time) == 0x000008, "Member 'FParticleBurst::Time' has a wrong offset!");

// ScriptStruct Engine.BoneFilter
// 0x0010 (0x0010 - 0x0000)
struct FBoneFilter final
{
public:
	bool                                          bExcludeSelf;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBoneFilter) == 0x000004, "Wrong alignment on FBoneFilter");
//(sizeof(FBoneFilter) == 0x000010, "Wrong size on FBoneFilter");
//(offsetof(FBoneFilter, bExcludeSelf) == 0x000000, "Member 'FBoneFilter::bExcludeSelf' has a wrong offset!");
//(offsetof(FBoneFilter, BoneName) == 0x000004, "Member 'FBoneFilter::BoneName' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshLODGroupSettings
// 0x0090 (0x0090 - 0x0000)
struct FSkeletalMeshLODGroupSettings final
{
public:
	struct FPerPlatformFloat                      ScreenSize;                                        // 0x0000(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LODHysteresis;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneFilterActionOption                       BoneFilterActionOption;                            // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneFilter>                    BoneList;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           BonesToPrioritize;                                 // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SectionsToPrioritize;                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WeightOfPrioritization;                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          BakePose;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSkeletalMeshOptimizationSettings      ReductionSettings;                                 // 0x0050(0x003C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkeletalMeshLODGroupSettings) == 0x000008, "Wrong alignment on FSkeletalMeshLODGroupSettings");
//(sizeof(FSkeletalMeshLODGroupSettings) == 0x000090, "Wrong size on FSkeletalMeshLODGroupSettings");
//(offsetof(FSkeletalMeshLODGroupSettings, ScreenSize) == 0x000000, "Member 'FSkeletalMeshLODGroupSettings::ScreenSize' has a wrong offset!");
//(offsetof(FSkeletalMeshLODGroupSettings, LODHysteresis) == 0x000004, "Member 'FSkeletalMeshLODGroupSettings::LODHysteresis' has a wrong offset!");
//(offsetof(FSkeletalMeshLODGroupSettings, BoneFilterActionOption) == 0x000008, "Member 'FSkeletalMeshLODGroupSettings::BoneFilterActionOption' has a wrong offset!");
//(offsetof(FSkeletalMeshLODGroupSettings, BoneList) == 0x000010, "Member 'FSkeletalMeshLODGroupSettings::BoneList' has a wrong offset!");
//(offsetof(FSkeletalMeshLODGroupSettings, BonesToPrioritize) == 0x000020, "Member 'FSkeletalMeshLODGroupSettings::BonesToPrioritize' has a wrong offset!");
//(offsetof(FSkeletalMeshLODGroupSettings, SectionsToPrioritize) == 0x000030, "Member 'FSkeletalMeshLODGroupSettings::SectionsToPrioritize' has a wrong offset!");
//(offsetof(FSkeletalMeshLODGroupSettings, WeightOfPrioritization) == 0x000040, "Member 'FSkeletalMeshLODGroupSettings::WeightOfPrioritization' has a wrong offset!");
//(offsetof(FSkeletalMeshLODGroupSettings, BakePose) == 0x000048, "Member 'FSkeletalMeshLODGroupSettings::BakePose' has a wrong offset!");
//(offsetof(FSkeletalMeshLODGroupSettings, ReductionSettings) == 0x000050, "Member 'FSkeletalMeshLODGroupSettings::ReductionSettings' has a wrong offset!");

// ScriptStruct Engine.NonBlendableVectorAnimationAttribute
// 0x0000 (0x0018 - 0x0018)
struct FNonBlendableVectorAnimationAttribute final : public FVectorAnimationAttribute
{
};
//(alignof(FNonBlendableVectorAnimationAttribute) == 0x000008, "Wrong alignment on FNonBlendableVectorAnimationAttribute");
//(sizeof(FNonBlendableVectorAnimationAttribute) == 0x000018, "Wrong size on FNonBlendableVectorAnimationAttribute");

// ScriptStruct Engine.CustomOutput
// 0x0010 (0x0010 - 0x0000)
struct FCustomOutput final
{
public:
	class FName                                   OutputName;                                        // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomMaterialOutputType                     OutputType;                                        // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCustomOutput) == 0x000004, "Wrong alignment on FCustomOutput");
//(sizeof(FCustomOutput) == 0x000010, "Wrong size on FCustomOutput");
//(offsetof(FCustomOutput, OutputName) == 0x000000, "Member 'FCustomOutput::OutputName' has a wrong offset!");
//(offsetof(FCustomOutput, OutputType) == 0x00000C, "Member 'FCustomOutput::OutputType' has a wrong offset!");

// ScriptStruct Engine.NonBlendableTransformAnimationAttribute
// 0x0000 (0x0060 - 0x0060)
struct FNonBlendableTransformAnimationAttribute final : public FTransformAnimationAttribute
{
};
//(alignof(FNonBlendableTransformAnimationAttribute) == 0x000010, "Wrong alignment on FNonBlendableTransformAnimationAttribute");
//(sizeof(FNonBlendableTransformAnimationAttribute) == 0x000060, "Wrong size on FNonBlendableTransformAnimationAttribute");

// ScriptStruct Engine.NonBlendableIntegerAnimationAttribute
// 0x0000 (0x0004 - 0x0004)
struct FNonBlendableIntegerAnimationAttribute final : public FIntegerAnimationAttribute
{
};
//(alignof(FNonBlendableIntegerAnimationAttribute) == 0x000004, "Wrong alignment on FNonBlendableIntegerAnimationAttribute");
//(sizeof(FNonBlendableIntegerAnimationAttribute) == 0x000004, "Wrong size on FNonBlendableIntegerAnimationAttribute");

// ScriptStruct Engine.RepObjectReplicatorDebugInfo
// 0x0020 (0x0020 - 0x0000)
struct FRepObjectReplicatorDebugInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRepPropertyDebugInfo>          PropertyList;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FRepObjectReplicatorDebugInfo) == 0x000008, "Wrong alignment on FRepObjectReplicatorDebugInfo");
//(sizeof(FRepObjectReplicatorDebugInfo) == 0x000020, "Wrong size on FRepObjectReplicatorDebugInfo");
//(offsetof(FRepObjectReplicatorDebugInfo, Name) == 0x000000, "Member 'FRepObjectReplicatorDebugInfo::Name' has a wrong offset!");
//(offsetof(FRepObjectReplicatorDebugInfo, PropertyList) == 0x000010, "Member 'FRepObjectReplicatorDebugInfo::PropertyList' has a wrong offset!");

// ScriptStruct Engine.RepActorDebugInfo
// 0x0028 (0x0028 - 0x0000)
struct FRepActorDebugInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        NetGUID;                                           // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRepObjectReplicatorDebugInfo>  ObjectReplicatorList;                              // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FRepActorDebugInfo) == 0x000008, "Wrong alignment on FRepActorDebugInfo");
//(sizeof(FRepActorDebugInfo) == 0x000028, "Wrong size on FRepActorDebugInfo");
//(offsetof(FRepActorDebugInfo, Name) == 0x000000, "Member 'FRepActorDebugInfo::Name' has a wrong offset!");
//(offsetof(FRepActorDebugInfo, NetGUID) == 0x000010, "Member 'FRepActorDebugInfo::NetGUID' has a wrong offset!");
//(offsetof(FRepActorDebugInfo, ObjectReplicatorList) == 0x000018, "Member 'FRepActorDebugInfo::ObjectReplicatorList' has a wrong offset!");

// ScriptStruct Engine.SolverIterations
// 0x0018 (0x0018 - 0x0000)
struct FSolverIterations final
{
public:
	int32                                         SolverIterations;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JointIterations;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollisionIterations;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SolverPushOutIterations;                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JointPushOutIterations;                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollisionPushOutIterations;                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSolverIterations) == 0x000004, "Wrong alignment on FSolverIterations");
//(sizeof(FSolverIterations) == 0x000018, "Wrong size on FSolverIterations");
//(offsetof(FSolverIterations, SolverIterations) == 0x000000, "Member 'FSolverIterations::SolverIterations' has a wrong offset!");
//(offsetof(FSolverIterations, JointIterations) == 0x000004, "Member 'FSolverIterations::JointIterations' has a wrong offset!");
//(offsetof(FSolverIterations, CollisionIterations) == 0x000008, "Member 'FSolverIterations::CollisionIterations' has a wrong offset!");
//(offsetof(FSolverIterations, SolverPushOutIterations) == 0x00000C, "Member 'FSolverIterations::SolverPushOutIterations' has a wrong offset!");
//(offsetof(FSolverIterations, JointPushOutIterations) == 0x000010, "Member 'FSolverIterations::JointPushOutIterations' has a wrong offset!");
//(offsetof(FSolverIterations, CollisionPushOutIterations) == 0x000014, "Member 'FSolverIterations::CollisionPushOutIterations' has a wrong offset!");

// ScriptStruct Engine.NetViewer
// 0x0048 (0x0048 - 0x0000)
struct FNetViewer final
{
public:
	class UNetConnection*                         Connection;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InViewer;                                          // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ViewTarget;                                        // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewLocation;                                      // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewDir;                                           // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNetViewer) == 0x000008, "Wrong alignment on FNetViewer");
//(sizeof(FNetViewer) == 0x000048, "Wrong size on FNetViewer");
//(offsetof(FNetViewer, Connection) == 0x000000, "Member 'FNetViewer::Connection' has a wrong offset!");
//(offsetof(FNetViewer, InViewer) == 0x000008, "Member 'FNetViewer::InViewer' has a wrong offset!");
//(offsetof(FNetViewer, ViewTarget) == 0x000010, "Member 'FNetViewer::ViewTarget' has a wrong offset!");
//(offsetof(FNetViewer, ViewLocation) == 0x000018, "Member 'FNetViewer::ViewLocation' has a wrong offset!");
//(offsetof(FNetViewer, ViewDir) == 0x000030, "Member 'FNetViewer::ViewDir' has a wrong offset!");

// ScriptStruct Engine.SoundWaveSpectralTimeData
// 0x0018 (0x0018 - 0x0000)
struct FSoundWaveSpectralTimeData final
{
public:
	TArray<struct FSoundWaveSpectralDataEntry>    Data;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TimeSec;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSoundWaveSpectralTimeData) == 0x000008, "Wrong alignment on FSoundWaveSpectralTimeData");
//(sizeof(FSoundWaveSpectralTimeData) == 0x000018, "Wrong size on FSoundWaveSpectralTimeData");
//(offsetof(FSoundWaveSpectralTimeData, Data) == 0x000000, "Member 'FSoundWaveSpectralTimeData::Data' has a wrong offset!");
//(offsetof(FSoundWaveSpectralTimeData, TimeSec) == 0x000010, "Member 'FSoundWaveSpectralTimeData::TimeSec' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshSamplingRegionMaterialFilter
// 0x000C (0x000C - 0x0000)
struct FSkeletalMeshSamplingRegionMaterialFilter final
{
public:
	class FName                                   MaterialName;                                      // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSkeletalMeshSamplingRegionMaterialFilter) == 0x000004, "Wrong alignment on FSkeletalMeshSamplingRegionMaterialFilter");
//(sizeof(FSkeletalMeshSamplingRegionMaterialFilter) == 0x00000C, "Wrong size on FSkeletalMeshSamplingRegionMaterialFilter");
//(offsetof(FSkeletalMeshSamplingRegionMaterialFilter, MaterialName) == 0x000000, "Member 'FSkeletalMeshSamplingRegionMaterialFilter::MaterialName' has a wrong offset!");

// ScriptStruct Engine.TextSizingParameters
// 0x0038 (0x0038 - 0x0000)
struct FTextSizingParameters final
{
public:
	float                                         DrawX;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawY;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawXL;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawYL;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Scaling;                                           // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  DrawFont;                                          // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpacingAdjust;                                     // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTextSizingParameters) == 0x000008, "Wrong alignment on FTextSizingParameters");
//(sizeof(FTextSizingParameters) == 0x000038, "Wrong size on FTextSizingParameters");
//(offsetof(FTextSizingParameters, DrawX) == 0x000000, "Member 'FTextSizingParameters::DrawX' has a wrong offset!");
//(offsetof(FTextSizingParameters, DrawY) == 0x000004, "Member 'FTextSizingParameters::DrawY' has a wrong offset!");
//(offsetof(FTextSizingParameters, DrawXL) == 0x000008, "Member 'FTextSizingParameters::DrawXL' has a wrong offset!");
//(offsetof(FTextSizingParameters, DrawYL) == 0x00000C, "Member 'FTextSizingParameters::DrawYL' has a wrong offset!");
//(offsetof(FTextSizingParameters, Scaling) == 0x000010, "Member 'FTextSizingParameters::Scaling' has a wrong offset!");
//(offsetof(FTextSizingParameters, DrawFont) == 0x000020, "Member 'FTextSizingParameters::DrawFont' has a wrong offset!");
//(offsetof(FTextSizingParameters, SpacingAdjust) == 0x000028, "Member 'FTextSizingParameters::SpacingAdjust' has a wrong offset!");

// ScriptStruct Engine.LightmassMaterialInterfaceSettings
// 0x0010 (0x0010 - 0x0000)
struct FLightmassMaterialInterfaceSettings final
{
public:
	float                                         EmissiveBoost;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiffuseBoost;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExportResolutionScale;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCastShadowAsMasked : 1;                           // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideCastShadowAsMasked : 1;                   // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideEmissiveBoost : 1;                        // 0x000C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideDiffuseBoost : 1;                         // 0x000C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideExportResolutionScale : 1;                // 0x000C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLightmassMaterialInterfaceSettings) == 0x000004, "Wrong alignment on FLightmassMaterialInterfaceSettings");
//(sizeof(FLightmassMaterialInterfaceSettings) == 0x000010, "Wrong size on FLightmassMaterialInterfaceSettings");
//(offsetof(FLightmassMaterialInterfaceSettings, EmissiveBoost) == 0x000000, "Member 'FLightmassMaterialInterfaceSettings::EmissiveBoost' has a wrong offset!");
//(offsetof(FLightmassMaterialInterfaceSettings, DiffuseBoost) == 0x000004, "Member 'FLightmassMaterialInterfaceSettings::DiffuseBoost' has a wrong offset!");
//(offsetof(FLightmassMaterialInterfaceSettings, ExportResolutionScale) == 0x000008, "Member 'FLightmassMaterialInterfaceSettings::ExportResolutionScale' has a wrong offset!");

// ScriptStruct Engine.WrappedStringElement
// 0x0020 (0x0020 - 0x0000)
struct FWrappedStringElement final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LineExtent;                                        // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FWrappedStringElement) == 0x000008, "Wrong alignment on FWrappedStringElement");
//(sizeof(FWrappedStringElement) == 0x000020, "Wrong size on FWrappedStringElement");
//(offsetof(FWrappedStringElement, Value) == 0x000000, "Member 'FWrappedStringElement::Value' has a wrong offset!");
//(offsetof(FWrappedStringElement, LineExtent) == 0x000010, "Member 'FWrappedStringElement::LineExtent' has a wrong offset!");

// ScriptStruct Engine.SkelMeshMergeMeshUVTransforms
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshMergeMeshUVTransforms final
{
public:
	TArray<struct FTransform>                     UVTransforms;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FSkelMeshMergeMeshUVTransforms) == 0x000008, "Wrong alignment on FSkelMeshMergeMeshUVTransforms");
//(sizeof(FSkelMeshMergeMeshUVTransforms) == 0x000010, "Wrong size on FSkelMeshMergeMeshUVTransforms");
//(offsetof(FSkelMeshMergeMeshUVTransforms, UVTransforms) == 0x000000, "Member 'FSkelMeshMergeMeshUVTransforms::UVTransforms' has a wrong offset!");

// ScriptStruct Engine.CharacterNetworkSerializationPackedBits
// 0x2018 (0x2018 - 0x0000)
struct alignas(0x08) FCharacterNetworkSerializationPackedBits
{
public:
	uint8                                         Pad_0[0x2018];                                     // 0x0000(0x2018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCharacterNetworkSerializationPackedBits) == 0x000008, "Wrong alignment on FCharacterNetworkSerializationPackedBits");
//(sizeof(FCharacterNetworkSerializationPackedBits) == 0x002018, "Wrong size on FCharacterNetworkSerializationPackedBits");

// ScriptStruct Engine.CharacterNetworkMoveLogicFrameData
// 0x0010 (0x0010 - 0x0000)
struct FCharacterNetworkMoveLogicFrameData final
{
public:
	class FString                                 SyncSignature;                                     // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCharacterNetworkMoveLogicFrameData) == 0x000008, "Wrong alignment on FCharacterNetworkMoveLogicFrameData");
//(sizeof(FCharacterNetworkMoveLogicFrameData) == 0x000010, "Wrong size on FCharacterNetworkMoveLogicFrameData");
//(offsetof(FCharacterNetworkMoveLogicFrameData, SyncSignature) == 0x000000, "Member 'FCharacterNetworkMoveLogicFrameData::SyncSignature' has a wrong offset!");

// ScriptStruct Engine.CompressedRichCurve
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCompressedRichCurve final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCompressedRichCurve) == 0x000008, "Wrong alignment on FCompressedRichCurve");
//(sizeof(FCompressedRichCurve) == 0x000018, "Wrong size on FCompressedRichCurve");

// ScriptStruct Engine.TextureSourceColorSettings
// 0x0050 (0x0050 - 0x0000)
struct FTextureSourceColorSettings final
{
public:
	ETextureSourceEncoding                        EncodingOverride;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureColorSpace                            ColorSpace;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RedChromaticityCoordinate;                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GreenChromaticityCoordinate;                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BlueChromaticityCoordinate;                        // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WhiteChromaticityCoordinate;                       // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureChromaticAdaptationMethod             ChromaticAdaptationMethod;                         // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTextureSourceColorSettings) == 0x000008, "Wrong alignment on FTextureSourceColorSettings");
//(sizeof(FTextureSourceColorSettings) == 0x000050, "Wrong size on FTextureSourceColorSettings");
//(offsetof(FTextureSourceColorSettings, EncodingOverride) == 0x000000, "Member 'FTextureSourceColorSettings::EncodingOverride' has a wrong offset!");
//(offsetof(FTextureSourceColorSettings, ColorSpace) == 0x000001, "Member 'FTextureSourceColorSettings::ColorSpace' has a wrong offset!");
//(offsetof(FTextureSourceColorSettings, RedChromaticityCoordinate) == 0x000008, "Member 'FTextureSourceColorSettings::RedChromaticityCoordinate' has a wrong offset!");
//(offsetof(FTextureSourceColorSettings, GreenChromaticityCoordinate) == 0x000018, "Member 'FTextureSourceColorSettings::GreenChromaticityCoordinate' has a wrong offset!");
//(offsetof(FTextureSourceColorSettings, BlueChromaticityCoordinate) == 0x000028, "Member 'FTextureSourceColorSettings::BlueChromaticityCoordinate' has a wrong offset!");
//(offsetof(FTextureSourceColorSettings, WhiteChromaticityCoordinate) == 0x000038, "Member 'FTextureSourceColorSettings::WhiteChromaticityCoordinate' has a wrong offset!");
//(offsetof(FTextureSourceColorSettings, ChromaticAdaptationMethod) == 0x000048, "Member 'FTextureSourceColorSettings::ChromaticAdaptationMethod' has a wrong offset!");

// ScriptStruct Engine.CharacterServerMovePackedBits
// 0x0000 (0x2018 - 0x2018)
struct FCharacterServerMovePackedBits final : public FCharacterNetworkSerializationPackedBits
{
};
//(alignof(FCharacterServerMovePackedBits) == 0x000008, "Wrong alignment on FCharacterServerMovePackedBits");
//(sizeof(FCharacterServerMovePackedBits) == 0x002018, "Wrong size on FCharacterServerMovePackedBits");

// ScriptStruct Engine.GaussianSumBloomSettings
// 0x0084 (0x0084 - 0x0000)
struct FGaussianSumBloomSettings final
{
public:
	float                                         Intensity;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threshold;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeScale;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Filter1Size;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Filter2Size;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Filter3Size;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Filter4Size;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Filter5Size;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Filter6Size;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Filter1Tint;                                       // 0x0024(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Filter2Tint;                                       // 0x0034(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Filter3Tint;                                       // 0x0044(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Filter4Tint;                                       // 0x0054(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Filter5Tint;                                       // 0x0064(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Filter6Tint;                                       // 0x0074(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FGaussianSumBloomSettings) == 0x000004, "Wrong alignment on FGaussianSumBloomSettings");
//(sizeof(FGaussianSumBloomSettings) == 0x000084, "Wrong size on FGaussianSumBloomSettings");
//(offsetof(FGaussianSumBloomSettings, Intensity) == 0x000000, "Member 'FGaussianSumBloomSettings::Intensity' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Threshold) == 0x000004, "Member 'FGaussianSumBloomSettings::Threshold' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, SizeScale) == 0x000008, "Member 'FGaussianSumBloomSettings::SizeScale' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter1Size) == 0x00000C, "Member 'FGaussianSumBloomSettings::Filter1Size' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter2Size) == 0x000010, "Member 'FGaussianSumBloomSettings::Filter2Size' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter3Size) == 0x000014, "Member 'FGaussianSumBloomSettings::Filter3Size' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter4Size) == 0x000018, "Member 'FGaussianSumBloomSettings::Filter4Size' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter5Size) == 0x00001C, "Member 'FGaussianSumBloomSettings::Filter5Size' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter6Size) == 0x000020, "Member 'FGaussianSumBloomSettings::Filter6Size' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter1Tint) == 0x000024, "Member 'FGaussianSumBloomSettings::Filter1Tint' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter2Tint) == 0x000034, "Member 'FGaussianSumBloomSettings::Filter2Tint' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter3Tint) == 0x000044, "Member 'FGaussianSumBloomSettings::Filter3Tint' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter4Tint) == 0x000054, "Member 'FGaussianSumBloomSettings::Filter4Tint' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter5Tint) == 0x000064, "Member 'FGaussianSumBloomSettings::Filter5Tint' has a wrong offset!");
//(offsetof(FGaussianSumBloomSettings, Filter6Tint) == 0x000074, "Member 'FGaussianSumBloomSettings::Filter6Tint' has a wrong offset!");

// ScriptStruct Engine.LensBloomSettings
// 0x00C0 (0x00C0 - 0x0000)
struct FLensBloomSettings final
{
public:
	struct FGaussianSumBloomSettings              GaussianSum;                                       // 0x0000(0x0084)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConvolutionBloomSettings              Convolution;                                       // 0x0088(0x0030)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	EBloomMethod                                  Method;                                            // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLensBloomSettings) == 0x000008, "Wrong alignment on FLensBloomSettings");
//(sizeof(FLensBloomSettings) == 0x0000C0, "Wrong size on FLensBloomSettings");
//(offsetof(FLensBloomSettings, GaussianSum) == 0x000000, "Member 'FLensBloomSettings::GaussianSum' has a wrong offset!");
//(offsetof(FLensBloomSettings, Convolution) == 0x000088, "Member 'FLensBloomSettings::Convolution' has a wrong offset!");
//(offsetof(FLensBloomSettings, Method) == 0x0000B8, "Member 'FLensBloomSettings::Method' has a wrong offset!");

// ScriptStruct Engine.CharacterMoveResponsePackedBits
// 0x0000 (0x2018 - 0x2018)
struct FCharacterMoveResponsePackedBits final : public FCharacterNetworkSerializationPackedBits
{
};
//(alignof(FCharacterMoveResponsePackedBits) == 0x000008, "Wrong alignment on FCharacterMoveResponsePackedBits");
//(sizeof(FCharacterMoveResponsePackedBits) == 0x002018, "Wrong size on FCharacterMoveResponsePackedBits");

// ScriptStruct Engine.CanvasIcon
// 0x0018 (0x0018 - 0x0000)
struct FCanvasIcon final
{
public:
	class UTexture*                               Texture;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         U;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         V;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UL;                                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VL;                                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCanvasIcon) == 0x000008, "Wrong alignment on FCanvasIcon");
//(sizeof(FCanvasIcon) == 0x000018, "Wrong size on FCanvasIcon");
//(offsetof(FCanvasIcon, Texture) == 0x000000, "Member 'FCanvasIcon::Texture' has a wrong offset!");
//(offsetof(FCanvasIcon, U) == 0x000008, "Member 'FCanvasIcon::U' has a wrong offset!");
//(offsetof(FCanvasIcon, V) == 0x00000C, "Member 'FCanvasIcon::V' has a wrong offset!");
//(offsetof(FCanvasIcon, UL) == 0x000010, "Member 'FCanvasIcon::UL' has a wrong offset!");
//(offsetof(FCanvasIcon, VL) == 0x000014, "Member 'FCanvasIcon::VL' has a wrong offset!");

// ScriptStruct Engine.CustomAttributeSetting
// 0x0020 (0x0020 - 0x0000)
struct FCustomAttributeSetting final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Meaning;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCustomAttributeSetting) == 0x000008, "Wrong alignment on FCustomAttributeSetting");
//(sizeof(FCustomAttributeSetting) == 0x000020, "Wrong size on FCustomAttributeSetting");
//(offsetof(FCustomAttributeSetting, Name) == 0x000000, "Member 'FCustomAttributeSetting::Name' has a wrong offset!");
//(offsetof(FCustomAttributeSetting, Meaning) == 0x000010, "Member 'FCustomAttributeSetting::Meaning' has a wrong offset!");

// ScriptStruct Engine.TimecodeCustomAttributeNameSettings
// 0x0054 (0x0054 - 0x0000)
struct FTimecodeCustomAttributeNameSettings final
{
public:
	class FName                                   HourAttributeName;                                 // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MinuteAttributeName;                               // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondAttributeName;                               // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FrameAttributeName;                                // 0x0024(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubframeAttributeName;                             // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RateAttributeName;                                 // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TakenameAttributeName;                             // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTimecodeCustomAttributeNameSettings) == 0x000004, "Wrong alignment on FTimecodeCustomAttributeNameSettings");
//(sizeof(FTimecodeCustomAttributeNameSettings) == 0x000054, "Wrong size on FTimecodeCustomAttributeNameSettings");
//(offsetof(FTimecodeCustomAttributeNameSettings, HourAttributeName) == 0x000000, "Member 'FTimecodeCustomAttributeNameSettings::HourAttributeName' has a wrong offset!");
//(offsetof(FTimecodeCustomAttributeNameSettings, MinuteAttributeName) == 0x00000C, "Member 'FTimecodeCustomAttributeNameSettings::MinuteAttributeName' has a wrong offset!");
//(offsetof(FTimecodeCustomAttributeNameSettings, SecondAttributeName) == 0x000018, "Member 'FTimecodeCustomAttributeNameSettings::SecondAttributeName' has a wrong offset!");
//(offsetof(FTimecodeCustomAttributeNameSettings, FrameAttributeName) == 0x000024, "Member 'FTimecodeCustomAttributeNameSettings::FrameAttributeName' has a wrong offset!");
//(offsetof(FTimecodeCustomAttributeNameSettings, SubframeAttributeName) == 0x000030, "Member 'FTimecodeCustomAttributeNameSettings::SubframeAttributeName' has a wrong offset!");
//(offsetof(FTimecodeCustomAttributeNameSettings, RateAttributeName) == 0x00003C, "Member 'FTimecodeCustomAttributeNameSettings::RateAttributeName' has a wrong offset!");
//(offsetof(FTimecodeCustomAttributeNameSettings, TakenameAttributeName) == 0x000048, "Member 'FTimecodeCustomAttributeNameSettings::TakenameAttributeName' has a wrong offset!");

// ScriptStruct Engine.RPCDoSState
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FRPCDoSState
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLogEscalate;                                      // 0x0008(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendEscalateAnalytics;                            // 0x0009(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKickPlayer;                                       // 0x000A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrackRecentRPCs;                                  // 0x000B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         EscalateQuotaRPCsPerFrame;                         // 0x000C(0x0002)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         EscalateTimeQuotaMSPerFrame;                       // 0x000E(0x0002)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         EscalateQuotaRPCsPerPeriod;                        // 0x0010(0x0002)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         EscalateTimeQuotaMSPerPeriod;                      // 0x0012(0x0002)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          EscalateQuotaTimePeriod;                           // 0x0014(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          EscalationCountTolerance;                          // 0x0015(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         EscalationTimeToleranceMS;                         // 0x0016(0x0002)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         RPCRepeatLimitPerPeriod;                           // 0x0018(0x0002)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         RPCRepeatLimitMSPerPeriod;                         // 0x001A(0x0002)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          RPCRepeatLimitTimePeriod;                          // 0x001C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x1];                                       // 0x001D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int16                                         CooloffTime;                                       // 0x001E(0x0002)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         AutoEscalateTime;                                  // 0x0020(0x0002)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x26];                                      // 0x0022(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRPCDoSState) == 0x000008, "Wrong alignment on FRPCDoSState");
//(sizeof(FRPCDoSState) == 0x000048, "Wrong size on FRPCDoSState");
//(offsetof(FRPCDoSState, bLogEscalate) == 0x000008, "Member 'FRPCDoSState::bLogEscalate' has a wrong offset!");
//(offsetof(FRPCDoSState, bSendEscalateAnalytics) == 0x000009, "Member 'FRPCDoSState::bSendEscalateAnalytics' has a wrong offset!");
//(offsetof(FRPCDoSState, bKickPlayer) == 0x00000A, "Member 'FRPCDoSState::bKickPlayer' has a wrong offset!");
//(offsetof(FRPCDoSState, bTrackRecentRPCs) == 0x00000B, "Member 'FRPCDoSState::bTrackRecentRPCs' has a wrong offset!");
//(offsetof(FRPCDoSState, EscalateQuotaRPCsPerFrame) == 0x00000C, "Member 'FRPCDoSState::EscalateQuotaRPCsPerFrame' has a wrong offset!");
//(offsetof(FRPCDoSState, EscalateTimeQuotaMSPerFrame) == 0x00000E, "Member 'FRPCDoSState::EscalateTimeQuotaMSPerFrame' has a wrong offset!");
//(offsetof(FRPCDoSState, EscalateQuotaRPCsPerPeriod) == 0x000010, "Member 'FRPCDoSState::EscalateQuotaRPCsPerPeriod' has a wrong offset!");
//(offsetof(FRPCDoSState, EscalateTimeQuotaMSPerPeriod) == 0x000012, "Member 'FRPCDoSState::EscalateTimeQuotaMSPerPeriod' has a wrong offset!");
//(offsetof(FRPCDoSState, EscalateQuotaTimePeriod) == 0x000014, "Member 'FRPCDoSState::EscalateQuotaTimePeriod' has a wrong offset!");
//(offsetof(FRPCDoSState, EscalationCountTolerance) == 0x000015, "Member 'FRPCDoSState::EscalationCountTolerance' has a wrong offset!");
//(offsetof(FRPCDoSState, EscalationTimeToleranceMS) == 0x000016, "Member 'FRPCDoSState::EscalationTimeToleranceMS' has a wrong offset!");
//(offsetof(FRPCDoSState, RPCRepeatLimitPerPeriod) == 0x000018, "Member 'FRPCDoSState::RPCRepeatLimitPerPeriod' has a wrong offset!");
//(offsetof(FRPCDoSState, RPCRepeatLimitMSPerPeriod) == 0x00001A, "Member 'FRPCDoSState::RPCRepeatLimitMSPerPeriod' has a wrong offset!");
//(offsetof(FRPCDoSState, RPCRepeatLimitTimePeriod) == 0x00001C, "Member 'FRPCDoSState::RPCRepeatLimitTimePeriod' has a wrong offset!");
//(offsetof(FRPCDoSState, CooloffTime) == 0x00001E, "Member 'FRPCDoSState::CooloffTime' has a wrong offset!");
//(offsetof(FRPCDoSState, AutoEscalateTime) == 0x000020, "Member 'FRPCDoSState::AutoEscalateTime' has a wrong offset!");

// ScriptStruct Engine.RPCDoSStateConfig
// 0x0030 (0x0078 - 0x0048)
struct FRPCDoSStateConfig final : public FRPCDoSState
{
public:
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRPCDoSStateConfig) == 0x000008, "Wrong alignment on FRPCDoSStateConfig");
//(sizeof(FRPCDoSStateConfig) == 0x000078, "Wrong size on FRPCDoSStateConfig");

// ScriptStruct Engine.CustomAttribute
// 0x0001 (0x0001 - 0x0000)
struct FCustomAttribute final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCustomAttribute) == 0x000001, "Wrong alignment on FCustomAttribute");
//(sizeof(FCustomAttribute) == 0x000001, "Wrong size on FCustomAttribute");

// ScriptStruct Engine.SkeletalMeshSamplingRegionBoneFilter
// 0x0010 (0x0010 - 0x0000)
struct FSkeletalMeshSamplingRegionBoneFilter final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIncludeOrExclude : 1;                             // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyToChildren : 1;                              // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkeletalMeshSamplingRegionBoneFilter) == 0x000004, "Wrong alignment on FSkeletalMeshSamplingRegionBoneFilter");
//(sizeof(FSkeletalMeshSamplingRegionBoneFilter) == 0x000010, "Wrong size on FSkeletalMeshSamplingRegionBoneFilter");
//(offsetof(FSkeletalMeshSamplingRegionBoneFilter, BoneName) == 0x000000, "Member 'FSkeletalMeshSamplingRegionBoneFilter::BoneName' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshSamplingRegionVertexColorFilter
// 0x0003 (0x0003 - 0x0000)
struct FSkeletalMeshSamplingRegionVertexColorFilter final
{
public:
	ESkinVertexColorChannel                       ColorChannel;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MinValue;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxValue;                                          // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSkeletalMeshSamplingRegionVertexColorFilter) == 0x000001, "Wrong alignment on FSkeletalMeshSamplingRegionVertexColorFilter");
//(sizeof(FSkeletalMeshSamplingRegionVertexColorFilter) == 0x000003, "Wrong size on FSkeletalMeshSamplingRegionVertexColorFilter");
//(offsetof(FSkeletalMeshSamplingRegionVertexColorFilter, ColorChannel) == 0x000000, "Member 'FSkeletalMeshSamplingRegionVertexColorFilter::ColorChannel' has a wrong offset!");
//(offsetof(FSkeletalMeshSamplingRegionVertexColorFilter, MinValue) == 0x000001, "Member 'FSkeletalMeshSamplingRegionVertexColorFilter::MinValue' has a wrong offset!");
//(offsetof(FSkeletalMeshSamplingRegionVertexColorFilter, MaxValue) == 0x000002, "Member 'FSkeletalMeshSamplingRegionVertexColorFilter::MaxValue' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshSamplingRegion
// 0x0048 (0x0048 - 0x0000)
struct FSkeletalMeshSamplingRegion final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSupportUniformlyDistributedSampling : 1;          // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkeletalMeshSamplingRegionMaterialFilter> MaterialFilters;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkeletalMeshSamplingRegionBoneFilter> BoneFilters;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkeletalMeshSamplingRegionVertexColorFilter> VertexColorFilters;                                // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FSkeletalMeshSamplingRegion) == 0x000008, "Wrong alignment on FSkeletalMeshSamplingRegion");
//(sizeof(FSkeletalMeshSamplingRegion) == 0x000048, "Wrong size on FSkeletalMeshSamplingRegion");
//(offsetof(FSkeletalMeshSamplingRegion, Name) == 0x000000, "Member 'FSkeletalMeshSamplingRegion::Name' has a wrong offset!");
//(offsetof(FSkeletalMeshSamplingRegion, LODIndex) == 0x00000C, "Member 'FSkeletalMeshSamplingRegion::LODIndex' has a wrong offset!");
//(offsetof(FSkeletalMeshSamplingRegion, MaterialFilters) == 0x000018, "Member 'FSkeletalMeshSamplingRegion::MaterialFilters' has a wrong offset!");
//(offsetof(FSkeletalMeshSamplingRegion, BoneFilters) == 0x000028, "Member 'FSkeletalMeshSamplingRegion::BoneFilters' has a wrong offset!");
//(offsetof(FSkeletalMeshSamplingRegion, VertexColorFilters) == 0x000038, "Member 'FSkeletalMeshSamplingRegion::VertexColorFilters' has a wrong offset!");

// ScriptStruct Engine.BakedStringCustomAttribute
// 0x0001 (0x0001 - 0x0000)
struct FBakedStringCustomAttribute final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBakedStringCustomAttribute) == 0x000001, "Wrong alignment on FBakedStringCustomAttribute");
//(sizeof(FBakedStringCustomAttribute) == 0x000001, "Wrong size on FBakedStringCustomAttribute");

// ScriptStruct Engine.BakedIntegerCustomAttribute
// 0x0001 (0x0001 - 0x0000)
struct FBakedIntegerCustomAttribute final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBakedIntegerCustomAttribute) == 0x000001, "Wrong alignment on FBakedIntegerCustomAttribute");
//(sizeof(FBakedIntegerCustomAttribute) == 0x000001, "Wrong size on FBakedIntegerCustomAttribute");

// ScriptStruct Engine.SwitchCustomInput
// 0x0040 (0x0040 - 0x0000)
struct FSwitchCustomInput final
{
public:
	class FName                                   InputName;                                         // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Input;                                             // 0x0010(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FSwitchCustomInput) == 0x000008, "Wrong alignment on FSwitchCustomInput");
//(sizeof(FSwitchCustomInput) == 0x000040, "Wrong size on FSwitchCustomInput");
//(offsetof(FSwitchCustomInput, InputName) == 0x000000, "Member 'FSwitchCustomInput::InputName' has a wrong offset!");
//(offsetof(FSwitchCustomInput, Input) == 0x000010, "Member 'FSwitchCustomInput::Input' has a wrong offset!");

// ScriptStruct Engine.BakedCustomAttributePerBoneData
// 0x0001 (0x0001 - 0x0000)
struct FBakedCustomAttributePerBoneData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBakedCustomAttributePerBoneData) == 0x000001, "Wrong alignment on FBakedCustomAttributePerBoneData");
//(sizeof(FBakedCustomAttributePerBoneData) == 0x000001, "Wrong size on FBakedCustomAttributePerBoneData");

// ScriptStruct Engine.SkeletalMeshSamplingLODBuiltData
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FSkeletalMeshSamplingLODBuiltData final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkeletalMeshSamplingLODBuiltData) == 0x000008, "Wrong alignment on FSkeletalMeshSamplingLODBuiltData");
//(sizeof(FSkeletalMeshSamplingLODBuiltData) == 0x000048, "Wrong size on FSkeletalMeshSamplingLODBuiltData");

// ScriptStruct Engine.SkeletalMeshSamplingRegionBuiltData
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FSkeletalMeshSamplingRegionBuiltData final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkeletalMeshSamplingRegionBuiltData) == 0x000008, "Wrong alignment on FSkeletalMeshSamplingRegionBuiltData");
//(sizeof(FSkeletalMeshSamplingRegionBuiltData) == 0x000078, "Wrong size on FSkeletalMeshSamplingRegionBuiltData");

// ScriptStruct Engine.SkeletalMeshSamplingBuiltData
// 0x0020 (0x0020 - 0x0000)
struct FSkeletalMeshSamplingBuiltData final
{
public:
	TArray<struct FSkeletalMeshSamplingLODBuiltData> WholeMeshBuiltData;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkeletalMeshSamplingRegionBuiltData> RegionBuiltData;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FSkeletalMeshSamplingBuiltData) == 0x000008, "Wrong alignment on FSkeletalMeshSamplingBuiltData");
//(sizeof(FSkeletalMeshSamplingBuiltData) == 0x000020, "Wrong size on FSkeletalMeshSamplingBuiltData");
//(offsetof(FSkeletalMeshSamplingBuiltData, WholeMeshBuiltData) == 0x000000, "Member 'FSkeletalMeshSamplingBuiltData::WholeMeshBuiltData' has a wrong offset!");
//(offsetof(FSkeletalMeshSamplingBuiltData, RegionBuiltData) == 0x000010, "Member 'FSkeletalMeshSamplingBuiltData::RegionBuiltData' has a wrong offset!");

// ScriptStruct Engine.DebugMovementDetailData
// 0x0080 (0x0080 - 0x0000)
struct FDebugMovementDetailData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExternInfo;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDebugMovementDetailData) == 0x000010, "Wrong alignment on FDebugMovementDetailData");
//(sizeof(FDebugMovementDetailData) == 0x000080, "Wrong size on FDebugMovementDetailData");
//(offsetof(FDebugMovementDetailData, Name) == 0x000000, "Member 'FDebugMovementDetailData::Name' has a wrong offset!");
//(offsetof(FDebugMovementDetailData, Transform) == 0x000010, "Member 'FDebugMovementDetailData::Transform' has a wrong offset!");
//(offsetof(FDebugMovementDetailData, ExternInfo) == 0x000070, "Member 'FDebugMovementDetailData::ExternInfo' has a wrong offset!");

// ScriptStruct Engine.DebugMovementFrameData
// 0x0080 (0x0080 - 0x0000)
struct FDebugMovementFrameData final
{
public:
	int64                                         Frame;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldTime;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDebugMovementDetailData>       Data;                                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDebugMovementFrameData) == 0x000010, "Wrong alignment on FDebugMovementFrameData");
//(sizeof(FDebugMovementFrameData) == 0x000080, "Wrong size on FDebugMovementFrameData");
//(offsetof(FDebugMovementFrameData, Frame) == 0x000000, "Member 'FDebugMovementFrameData::Frame' has a wrong offset!");
//(offsetof(FDebugMovementFrameData, WorldTime) == 0x000008, "Member 'FDebugMovementFrameData::WorldTime' has a wrong offset!");
//(offsetof(FDebugMovementFrameData, Data) == 0x000010, "Member 'FDebugMovementFrameData::Data' has a wrong offset!");
//(offsetof(FDebugMovementFrameData, Transform) == 0x000020, "Member 'FDebugMovementFrameData::Transform' has a wrong offset!");

// ScriptStruct Engine.PrimitiveComponentInstanceData
// 0x0078 (0x0130 - 0x00B8)
struct FPrimitiveComponentInstanceData : public FSceneComponentInstanceData
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ComponentTransform;                                // 0x00C0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VisibilityId;                                      // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    LODParent;                                         // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FPrimitiveComponentInstanceData) == 0x000010, "Wrong alignment on FPrimitiveComponentInstanceData");
//(sizeof(FPrimitiveComponentInstanceData) == 0x000130, "Wrong size on FPrimitiveComponentInstanceData");
//(offsetof(FPrimitiveComponentInstanceData, ComponentTransform) == 0x0000C0, "Member 'FPrimitiveComponentInstanceData::ComponentTransform' has a wrong offset!");
//(offsetof(FPrimitiveComponentInstanceData, VisibilityId) == 0x000120, "Member 'FPrimitiveComponentInstanceData::VisibilityId' has a wrong offset!");
//(offsetof(FPrimitiveComponentInstanceData, LODParent) == 0x000128, "Member 'FPrimitiveComponentInstanceData::LODParent' has a wrong offset!");

// ScriptStruct Engine.AnimNode_StateResult
// 0x0000 (0x0038 - 0x0038)
struct FAnimNode_StateResult final : public FAnimNode_Root
{
};
//(alignof(FAnimNode_StateResult) == 0x000008, "Wrong alignment on FAnimNode_StateResult");
//(sizeof(FAnimNode_StateResult) == 0x000038, "Wrong size on FAnimNode_StateResult");

// ScriptStruct Engine.DebugMovementData
// 0x0030 (0x0030 - 0x0000)
struct FDebugMovementData final
{
public:
	class FString                                 ActorName;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDebugMovementFrameData>        Frames;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDebugMovementData) == 0x000008, "Wrong alignment on FDebugMovementData");
//(sizeof(FDebugMovementData) == 0x000030, "Wrong size on FDebugMovementData");
//(offsetof(FDebugMovementData, ActorName) == 0x000000, "Member 'FDebugMovementData::ActorName' has a wrong offset!");
//(offsetof(FDebugMovementData, Frames) == 0x000010, "Member 'FDebugMovementData::Frames' has a wrong offset!");

// ScriptStruct Engine.DebugTextInfo
// 0x0080 (0x0080 - 0x0000)
struct FDebugTextInfo final
{
public:
	class AActor*                                 SrcActor;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SrcActorOffset;                                    // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SrcActorDesiredOffset;                             // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DebugText;                                         // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRemaining;                                     // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TextColor;                                         // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAbsoluteLocation : 1;                             // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bKeepAttachedToActor : 1;                          // 0x0054(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawShadow : 1;                                   // 0x0054(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OrigActorLocation;                                 // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x0070(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FontScale;                                         // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDebugTextInfo) == 0x000008, "Wrong alignment on FDebugTextInfo");
//(sizeof(FDebugTextInfo) == 0x000080, "Wrong size on FDebugTextInfo");
//(offsetof(FDebugTextInfo, SrcActor) == 0x000000, "Member 'FDebugTextInfo::SrcActor' has a wrong offset!");
//(offsetof(FDebugTextInfo, SrcActorOffset) == 0x000008, "Member 'FDebugTextInfo::SrcActorOffset' has a wrong offset!");
//(offsetof(FDebugTextInfo, SrcActorDesiredOffset) == 0x000020, "Member 'FDebugTextInfo::SrcActorDesiredOffset' has a wrong offset!");
//(offsetof(FDebugTextInfo, DebugText) == 0x000038, "Member 'FDebugTextInfo::DebugText' has a wrong offset!");
//(offsetof(FDebugTextInfo, TimeRemaining) == 0x000048, "Member 'FDebugTextInfo::TimeRemaining' has a wrong offset!");
//(offsetof(FDebugTextInfo, Duration) == 0x00004C, "Member 'FDebugTextInfo::Duration' has a wrong offset!");
//(offsetof(FDebugTextInfo, TextColor) == 0x000050, "Member 'FDebugTextInfo::TextColor' has a wrong offset!");
//(offsetof(FDebugTextInfo, OrigActorLocation) == 0x000058, "Member 'FDebugTextInfo::OrigActorLocation' has a wrong offset!");
//(offsetof(FDebugTextInfo, Font) == 0x000070, "Member 'FDebugTextInfo::Font' has a wrong offset!");
//(offsetof(FDebugTextInfo, FontScale) == 0x000078, "Member 'FDebugTextInfo::FontScale' has a wrong offset!");

// ScriptStruct Engine.EdGraphPinReference
// 0x0018 (0x0018 - 0x0000)
struct FEdGraphPinReference final
{
public:
	TWeakObjectPtr<class UEdGraphNode>            OwningNode;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  PinId;                                             // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FEdGraphPinReference) == 0x000004, "Wrong alignment on FEdGraphPinReference");
//(sizeof(FEdGraphPinReference) == 0x000018, "Wrong size on FEdGraphPinReference");
//(offsetof(FEdGraphPinReference, OwningNode) == 0x000000, "Member 'FEdGraphPinReference::OwningNode' has a wrong offset!");
//(offsetof(FEdGraphPinReference, PinId) == 0x000008, "Member 'FEdGraphPinReference::PinId' has a wrong offset!");

// ScriptStruct Engine.EdGraphSchemaAction
// 0x0100 (0x0100 - 0x0000)
struct FEdGraphSchemaAction
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MenuDescription;                                   // 0x0008(0x0018)(NativeAccessSpecifierPrivate)
	class FText                                   TooltipDescription;                                // 0x0020(0x0018)(NativeAccessSpecifierPrivate)
	class FText                                   Category;                                          // 0x0038(0x0018)(NativeAccessSpecifierPrivate)
	class FText                                   Keywords;                                          // 0x0050(0x0018)(NativeAccessSpecifierPrivate)
	int32                                         Grouping;                                          // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionID;                                         // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         MenuDescriptionArray;                              // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         FullSearchTitlesArray;                             // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         FullSearchKeywordsArray;                           // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         FullSearchCategoryArray;                           // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         LocalizedMenuDescriptionArray;                     // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         LocalizedFullSearchTitlesArray;                    // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         LocalizedFullSearchKeywordsArray;                  // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         LocalizedFullSearchCategoryArray;                  // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SearchText;                                        // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FEdGraphSchemaAction) == 0x000008, "Wrong alignment on FEdGraphSchemaAction");
//(sizeof(FEdGraphSchemaAction) == 0x000100, "Wrong size on FEdGraphSchemaAction");
//(offsetof(FEdGraphSchemaAction, MenuDescription) == 0x000008, "Member 'FEdGraphSchemaAction::MenuDescription' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, TooltipDescription) == 0x000020, "Member 'FEdGraphSchemaAction::TooltipDescription' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, Category) == 0x000038, "Member 'FEdGraphSchemaAction::Category' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, Keywords) == 0x000050, "Member 'FEdGraphSchemaAction::Keywords' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, Grouping) == 0x000068, "Member 'FEdGraphSchemaAction::Grouping' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, SectionID) == 0x00006C, "Member 'FEdGraphSchemaAction::SectionID' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, MenuDescriptionArray) == 0x000070, "Member 'FEdGraphSchemaAction::MenuDescriptionArray' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, FullSearchTitlesArray) == 0x000080, "Member 'FEdGraphSchemaAction::FullSearchTitlesArray' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, FullSearchKeywordsArray) == 0x000090, "Member 'FEdGraphSchemaAction::FullSearchKeywordsArray' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, FullSearchCategoryArray) == 0x0000A0, "Member 'FEdGraphSchemaAction::FullSearchCategoryArray' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, LocalizedMenuDescriptionArray) == 0x0000B0, "Member 'FEdGraphSchemaAction::LocalizedMenuDescriptionArray' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, LocalizedFullSearchTitlesArray) == 0x0000C0, "Member 'FEdGraphSchemaAction::LocalizedFullSearchTitlesArray' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, LocalizedFullSearchKeywordsArray) == 0x0000D0, "Member 'FEdGraphSchemaAction::LocalizedFullSearchKeywordsArray' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, LocalizedFullSearchCategoryArray) == 0x0000E0, "Member 'FEdGraphSchemaAction::LocalizedFullSearchCategoryArray' has a wrong offset!");
//(offsetof(FEdGraphSchemaAction, SearchText) == 0x0000F0, "Member 'FEdGraphSchemaAction::SearchText' has a wrong offset!");

// ScriptStruct Engine.SkeletalMaterial
// 0x0028 (0x0028 - 0x0000)
struct FSkeletalMaterial final
{
public:
	class UMaterialInterface*                     MaterialInterface;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialSlotName;                                  // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMeshUVChannelInfo                     UVChannelData;                                     // 0x0014(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FSkeletalMaterial) == 0x000008, "Wrong alignment on FSkeletalMaterial");
//(sizeof(FSkeletalMaterial) == 0x000028, "Wrong size on FSkeletalMaterial");
//(offsetof(FSkeletalMaterial, MaterialInterface) == 0x000000, "Member 'FSkeletalMaterial::MaterialInterface' has a wrong offset!");
//(offsetof(FSkeletalMaterial, MaterialSlotName) == 0x000008, "Member 'FSkeletalMaterial::MaterialSlotName' has a wrong offset!");
//(offsetof(FSkeletalMaterial, UVChannelData) == 0x000014, "Member 'FSkeletalMaterial::UVChannelData' has a wrong offset!");

// ScriptStruct Engine.EdGraphSchemaAction_NewNode
// 0x0008 (0x0108 - 0x0100)
struct FEdGraphSchemaAction_NewNode final : public FEdGraphSchemaAction
{
public:
	class UEdGraphNode*                           NodeTemplate;                                      // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FEdGraphSchemaAction_NewNode) == 0x000008, "Wrong alignment on FEdGraphSchemaAction_NewNode");
//(sizeof(FEdGraphSchemaAction_NewNode) == 0x000108, "Wrong size on FEdGraphSchemaAction_NewNode");
//(offsetof(FEdGraphSchemaAction_NewNode, NodeTemplate) == 0x000100, "Member 'FEdGraphSchemaAction_NewNode::NodeTemplate' has a wrong offset!");

// ScriptStruct Engine.RepCheckClassInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FRepCheckClassInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRepCheckClassInfo) == 0x000008, "Wrong alignment on FRepCheckClassInfo");
//(sizeof(FRepCheckClassInfo) == 0x000018, "Wrong size on FRepCheckClassInfo");

// ScriptStruct Engine.AnimNotifyEventReference
// 0x0030 (0x0030 - 0x0000)
struct FAnimNotifyEventReference final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMirrorDataTable*                       MirrorTable;                                       // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                NotifySource;                                      // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNotifyEventReference) == 0x000008, "Wrong alignment on FAnimNotifyEventReference");
//(sizeof(FAnimNotifyEventReference) == 0x000030, "Wrong size on FAnimNotifyEventReference");
//(offsetof(FAnimNotifyEventReference, MirrorTable) == 0x000018, "Member 'FAnimNotifyEventReference::MirrorTable' has a wrong offset!");
//(offsetof(FAnimNotifyEventReference, NotifySource) == 0x000020, "Member 'FAnimNotifyEventReference::NotifySource' has a wrong offset!");

// ScriptStruct Engine.AnimNotifyArray
// 0x0010 (0x0010 - 0x0000)
struct FAnimNotifyArray final
{
public:
	TArray<struct FAnimNotifyEventReference>      Notifies;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
//(alignof(FAnimNotifyArray) == 0x000008, "Wrong alignment on FAnimNotifyArray");
//(sizeof(FAnimNotifyArray) == 0x000010, "Wrong size on FAnimNotifyArray");
//(offsetof(FAnimNotifyArray, Notifies) == 0x000000, "Member 'FAnimNotifyArray::Notifies' has a wrong offset!");

// ScriptStruct Engine.AnimNotifyQueue
// 0x0090 (0x0090 - 0x0000)
struct FAnimNotifyQueue final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimNotifyEventReference>      AnimNotifies;                                      // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<class FName, struct FAnimNotifyArray>    UnfilteredMontageAnimNotifies;                     // 0x0040(0x0050)(Transient, NativeAccessSpecifierPublic)
};
//(alignof(FAnimNotifyQueue) == 0x000008, "Wrong alignment on FAnimNotifyQueue");
//(sizeof(FAnimNotifyQueue) == 0x000090, "Wrong size on FAnimNotifyQueue");
//(offsetof(FAnimNotifyQueue, AnimNotifies) == 0x000030, "Member 'FAnimNotifyQueue::AnimNotifies' has a wrong offset!");
//(offsetof(FAnimNotifyQueue, UnfilteredMontageAnimNotifies) == 0x000040, "Member 'FAnimNotifyQueue::UnfilteredMontageAnimNotifies' has a wrong offset!");

// ScriptStruct Engine.OrbitOptions
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FOrbitOptions final
{
public:
	uint8                                         bProcessDuringSpawn : 1;                           // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bProcessDuringUpdate : 1;                          // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseEmitterTime : 1;                               // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FOrbitOptions) == 0x000004, "Wrong alignment on FOrbitOptions");
//(sizeof(FOrbitOptions) == 0x000004, "Wrong size on FOrbitOptions");

// ScriptStruct Engine.NetDriverDefinition
// 0x0028 (0x0028 - 0x0000)
struct FNetDriverDefinition final
{
public:
	class FName                                   DefName;                                           // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DriverClassName;                                   // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DriverClassNameFallback;                           // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxChannelsOverride;                               // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNetDriverDefinition) == 0x000004, "Wrong alignment on FNetDriverDefinition");
//(sizeof(FNetDriverDefinition) == 0x000028, "Wrong size on FNetDriverDefinition");
//(offsetof(FNetDriverDefinition, DefName) == 0x000000, "Member 'FNetDriverDefinition::DefName' has a wrong offset!");
//(offsetof(FNetDriverDefinition, DriverClassName) == 0x00000C, "Member 'FNetDriverDefinition::DriverClassName' has a wrong offset!");
//(offsetof(FNetDriverDefinition, DriverClassNameFallback) == 0x000018, "Member 'FNetDriverDefinition::DriverClassNameFallback' has a wrong offset!");
//(offsetof(FNetDriverDefinition, MaxChannelsOverride) == 0x000024, "Member 'FNetDriverDefinition::MaxChannelsOverride' has a wrong offset!");

// ScriptStruct Engine.IrisNetDriverConfig
// 0x0030 (0x0030 - 0x0000)
struct FIrisNetDriverConfig final
{
public:
	class FName                                   NetDriverDefinition;                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NetDriverName;                                     // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NetDriverWildcardName;                             // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseIris;                                       // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FIrisNetDriverConfig) == 0x000008, "Wrong alignment on FIrisNetDriverConfig");
//(sizeof(FIrisNetDriverConfig) == 0x000030, "Wrong size on FIrisNetDriverConfig");
//(offsetof(FIrisNetDriverConfig, NetDriverDefinition) == 0x000000, "Member 'FIrisNetDriverConfig::NetDriverDefinition' has a wrong offset!");
//(offsetof(FIrisNetDriverConfig, NetDriverName) == 0x00000C, "Member 'FIrisNetDriverConfig::NetDriverName' has a wrong offset!");
//(offsetof(FIrisNetDriverConfig, NetDriverWildcardName) == 0x000018, "Member 'FIrisNetDriverConfig::NetDriverWildcardName' has a wrong offset!");
//(offsetof(FIrisNetDriverConfig, bCanUseIris) == 0x000028, "Member 'FIrisNetDriverConfig::bCanUseIris' has a wrong offset!");

// ScriptStruct Engine.ParticleRandomSeedInfo
// 0x0020 (0x0020 - 0x0000)
struct FParticleRandomSeedInfo final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGetSeedFromInstance : 1;                          // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInstanceSeedIsIndex : 1;                          // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetSeedOnEmitterLooping : 1;                    // 0x000C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRandomlySelectSeedArray : 1;                      // 0x000C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 RandomSeeds;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FParticleRandomSeedInfo) == 0x000008, "Wrong alignment on FParticleRandomSeedInfo");
//(sizeof(FParticleRandomSeedInfo) == 0x000020, "Wrong size on FParticleRandomSeedInfo");
//(offsetof(FParticleRandomSeedInfo, ParameterName) == 0x000000, "Member 'FParticleRandomSeedInfo::ParameterName' has a wrong offset!");
//(offsetof(FParticleRandomSeedInfo, RandomSeeds) == 0x000010, "Member 'FParticleRandomSeedInfo::RandomSeeds' has a wrong offset!");

// ScriptStruct Engine.StatColorMapping
// 0x0028 (0x0028 - 0x0000)
struct FStatColorMapping final
{
public:
	class FString                                 StatName;                                          // 0x0000(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStatColorMapEntry>             ColorMap;                                          // 0x0010(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	uint8                                         DisableBlend : 1;                                  // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, GlobalConfig, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStatColorMapping) == 0x000008, "Wrong alignment on FStatColorMapping");
//(sizeof(FStatColorMapping) == 0x000028, "Wrong size on FStatColorMapping");
//(offsetof(FStatColorMapping, StatName) == 0x000000, "Member 'FStatColorMapping::StatName' has a wrong offset!");
//(offsetof(FStatColorMapping, ColorMap) == 0x000010, "Member 'FStatColorMapping::ColorMap' has a wrong offset!");

// ScriptStruct Engine.DataDrivenShaderPlatformInfoInput
// 0x0010 (0x0010 - 0x0000)
struct FDataDrivenShaderPlatformInfoInput final
{
public:
	class FName                                   InputName;                                         // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataDrivenShaderPlatformInfoCondition        PropertyCondition;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDataDrivenShaderPlatformInfoInput) == 0x000004, "Wrong alignment on FDataDrivenShaderPlatformInfoInput");
//(sizeof(FDataDrivenShaderPlatformInfoInput) == 0x000010, "Wrong size on FDataDrivenShaderPlatformInfoInput");
//(offsetof(FDataDrivenShaderPlatformInfoInput, InputName) == 0x000000, "Member 'FDataDrivenShaderPlatformInfoInput::InputName' has a wrong offset!");
//(offsetof(FDataDrivenShaderPlatformInfoInput, PropertyCondition) == 0x00000C, "Member 'FDataDrivenShaderPlatformInfoInput::PropertyCondition' has a wrong offset!");

// ScriptStruct Engine.DropNoteInfo
// 0x0040 (0x0040 - 0x0000)
struct FDropNoteInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDropNoteInfo) == 0x000008, "Wrong alignment on FDropNoteInfo");
//(sizeof(FDropNoteInfo) == 0x000040, "Wrong size on FDropNoteInfo");
//(offsetof(FDropNoteInfo, Location) == 0x000000, "Member 'FDropNoteInfo::Location' has a wrong offset!");
//(offsetof(FDropNoteInfo, Rotation) == 0x000018, "Member 'FDropNoteInfo::Rotation' has a wrong offset!");
//(offsetof(FDropNoteInfo, Comment) == 0x000030, "Member 'FDropNoteInfo::Comment' has a wrong offset!");

// ScriptStruct Engine.NamedEmitterMaterial
// 0x0018 (0x0018 - 0x0000)
struct FNamedEmitterMaterial final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNamedEmitterMaterial) == 0x000008, "Wrong alignment on FNamedEmitterMaterial");
//(sizeof(FNamedEmitterMaterial) == 0x000018, "Wrong size on FNamedEmitterMaterial");
//(offsetof(FNamedEmitterMaterial, Name) == 0x000000, "Member 'FNamedEmitterMaterial::Name' has a wrong offset!");
//(offsetof(FNamedEmitterMaterial, Material) == 0x000010, "Member 'FNamedEmitterMaterial::Material' has a wrong offset!");

// ScriptStruct Engine.ScreenMessageString
// 0x0038 (0x0038 - 0x0000)
struct FScreenMessageString final
{
public:
	uint64                                        Key;                                               // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ScreenMessage;                                     // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DisplayColor;                                      // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToDisplay;                                     // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTimeDisplayed;                              // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TextScale;                                         // 0x0028(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FScreenMessageString) == 0x000008, "Wrong alignment on FScreenMessageString");
//(sizeof(FScreenMessageString) == 0x000038, "Wrong size on FScreenMessageString");
//(offsetof(FScreenMessageString, Key) == 0x000000, "Member 'FScreenMessageString::Key' has a wrong offset!");
//(offsetof(FScreenMessageString, ScreenMessage) == 0x000008, "Member 'FScreenMessageString::ScreenMessage' has a wrong offset!");
//(offsetof(FScreenMessageString, DisplayColor) == 0x000018, "Member 'FScreenMessageString::DisplayColor' has a wrong offset!");
//(offsetof(FScreenMessageString, TimeToDisplay) == 0x00001C, "Member 'FScreenMessageString::TimeToDisplay' has a wrong offset!");
//(offsetof(FScreenMessageString, CurrentTimeDisplayed) == 0x000020, "Member 'FScreenMessageString::CurrentTimeDisplayed' has a wrong offset!");
//(offsetof(FScreenMessageString, TextScale) == 0x000028, "Member 'FScreenMessageString::TextScale' has a wrong offset!");

// ScriptStruct Engine.GameNameRedirect
// 0x0018 (0x0018 - 0x0000)
struct FGameNameRedirect final
{
public:
	class FName                                   OldGameName;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewGameName;                                       // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FGameNameRedirect) == 0x000004, "Wrong alignment on FGameNameRedirect");
//(sizeof(FGameNameRedirect) == 0x000018, "Wrong size on FGameNameRedirect");
//(offsetof(FGameNameRedirect, OldGameName) == 0x000000, "Member 'FGameNameRedirect::OldGameName' has a wrong offset!");
//(offsetof(FGameNameRedirect, NewGameName) == 0x00000C, "Member 'FGameNameRedirect::NewGameName' has a wrong offset!");

// ScriptStruct Engine.ClassRedirect
// 0x0058 (0x0058 - 0x0000)
struct FClassRedirect final
{
public:
	class FName                                   ObjectName;                                        // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OldClassName;                                      // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewClassName;                                      // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OldSubobjName;                                     // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewSubobjName;                                     // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewClassClass;                                     // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewClassPackage;                                   // 0x0048(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InstanceOnly;                                      // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FClassRedirect) == 0x000004, "Wrong alignment on FClassRedirect");
//(sizeof(FClassRedirect) == 0x000058, "Wrong size on FClassRedirect");
//(offsetof(FClassRedirect, ObjectName) == 0x000000, "Member 'FClassRedirect::ObjectName' has a wrong offset!");
//(offsetof(FClassRedirect, OldClassName) == 0x00000C, "Member 'FClassRedirect::OldClassName' has a wrong offset!");
//(offsetof(FClassRedirect, NewClassName) == 0x000018, "Member 'FClassRedirect::NewClassName' has a wrong offset!");
//(offsetof(FClassRedirect, OldSubobjName) == 0x000024, "Member 'FClassRedirect::OldSubobjName' has a wrong offset!");
//(offsetof(FClassRedirect, NewSubobjName) == 0x000030, "Member 'FClassRedirect::NewSubobjName' has a wrong offset!");
//(offsetof(FClassRedirect, NewClassClass) == 0x00003C, "Member 'FClassRedirect::NewClassClass' has a wrong offset!");
//(offsetof(FClassRedirect, NewClassPackage) == 0x000048, "Member 'FClassRedirect::NewClassPackage' has a wrong offset!");
//(offsetof(FClassRedirect, InstanceOnly) == 0x000054, "Member 'FClassRedirect::InstanceOnly' has a wrong offset!");

// ScriptStruct Engine.StructRedirect
// 0x0018 (0x0018 - 0x0000)
struct FStructRedirect final
{
public:
	class FName                                   OldStructName;                                     // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewStructName;                                     // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FStructRedirect) == 0x000004, "Wrong alignment on FStructRedirect");
//(sizeof(FStructRedirect) == 0x000018, "Wrong size on FStructRedirect");
//(offsetof(FStructRedirect, OldStructName) == 0x000000, "Member 'FStructRedirect::OldStructName' has a wrong offset!");
//(offsetof(FStructRedirect, NewStructName) == 0x00000C, "Member 'FStructRedirect::NewStructName' has a wrong offset!");

// ScriptStruct Engine.SoundWaveCuePoint
// 0x0028 (0x0028 - 0x0000)
struct FSoundWaveCuePoint final
{
public:
	int32                                         CuePointID;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Label;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FramePosition;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameLength;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoopRegion;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSoundWaveCuePoint) == 0x000008, "Wrong alignment on FSoundWaveCuePoint");
//(sizeof(FSoundWaveCuePoint) == 0x000028, "Wrong size on FSoundWaveCuePoint");
//(offsetof(FSoundWaveCuePoint, CuePointID) == 0x000000, "Member 'FSoundWaveCuePoint::CuePointID' has a wrong offset!");
//(offsetof(FSoundWaveCuePoint, Label) == 0x000008, "Member 'FSoundWaveCuePoint::Label' has a wrong offset!");
//(offsetof(FSoundWaveCuePoint, FramePosition) == 0x000018, "Member 'FSoundWaveCuePoint::FramePosition' has a wrong offset!");
//(offsetof(FSoundWaveCuePoint, FrameLength) == 0x00001C, "Member 'FSoundWaveCuePoint::FrameLength' has a wrong offset!");
//(offsetof(FSoundWaveCuePoint, bIsLoopRegion) == 0x000020, "Member 'FSoundWaveCuePoint::bIsLoopRegion' has a wrong offset!");

// ScriptStruct Engine.PluginRedirect
// 0x0020 (0x0020 - 0x0000)
struct FPluginRedirect final
{
public:
	class FString                                 OldPluginName;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewPluginName;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPluginRedirect) == 0x000008, "Wrong alignment on FPluginRedirect");
//(sizeof(FPluginRedirect) == 0x000020, "Wrong size on FPluginRedirect");
//(offsetof(FPluginRedirect, OldPluginName) == 0x000000, "Member 'FPluginRedirect::OldPluginName' has a wrong offset!");
//(offsetof(FPluginRedirect, NewPluginName) == 0x000010, "Member 'FPluginRedirect::NewPluginName' has a wrong offset!");

// ScriptStruct Engine.TickPrerequisite
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FTickPrerequisite final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTickPrerequisite) == 0x000008, "Wrong alignment on FTickPrerequisite");
//(sizeof(FTickPrerequisite) == 0x000010, "Wrong size on FTickPrerequisite");

// ScriptStruct Engine.ExposureSettings
// 0x0008 (0x0008 - 0x0000)
struct FExposureSettings final
{
public:
	float                                         FixedEV100;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixed;                                            // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FExposureSettings) == 0x000004, "Wrong alignment on FExposureSettings");
//(sizeof(FExposureSettings) == 0x000008, "Wrong size on FExposureSettings");
//(offsetof(FExposureSettings, FixedEV100) == 0x000000, "Member 'FExposureSettings::FixedEV100' has a wrong offset!");
//(offsetof(FExposureSettings, bFixed) == 0x000004, "Member 'FExposureSettings::bFixed' has a wrong offset!");

// ScriptStruct Engine.ChaosPhysicsSettings
// 0x0003 (0x0003 - 0x0000)
struct FChaosPhysicsSettings final
{
public:
	EChaosThreadingMode                           DefaultThreadingModel;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChaosSolverTickMode                          DedicatedThreadTickMode;                           // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChaosBufferMode                              DedicatedThreadBufferMode;                         // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FChaosPhysicsSettings) == 0x000001, "Wrong alignment on FChaosPhysicsSettings");
//(sizeof(FChaosPhysicsSettings) == 0x000003, "Wrong size on FChaosPhysicsSettings");
//(offsetof(FChaosPhysicsSettings, DefaultThreadingModel) == 0x000000, "Member 'FChaosPhysicsSettings::DefaultThreadingModel' has a wrong offset!");
//(offsetof(FChaosPhysicsSettings, DedicatedThreadTickMode) == 0x000001, "Member 'FChaosPhysicsSettings::DedicatedThreadTickMode' has a wrong offset!");
//(offsetof(FChaosPhysicsSettings, DedicatedThreadBufferMode) == 0x000002, "Member 'FChaosPhysicsSettings::DedicatedThreadBufferMode' has a wrong offset!");

// ScriptStruct Engine.LightingChannelsIntensity
// 0x000C (0x000C - 0x0000)
struct FLightingChannelsIntensity final
{
public:
	float                                         Channel0Intensity;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Channel1Intensity;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Channel2Intensity;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FLightingChannelsIntensity) == 0x000004, "Wrong alignment on FLightingChannelsIntensity");
//(sizeof(FLightingChannelsIntensity) == 0x00000C, "Wrong size on FLightingChannelsIntensity");
//(offsetof(FLightingChannelsIntensity, Channel0Intensity) == 0x000000, "Member 'FLightingChannelsIntensity::Channel0Intensity' has a wrong offset!");
//(offsetof(FLightingChannelsIntensity, Channel1Intensity) == 0x000004, "Member 'FLightingChannelsIntensity::Channel1Intensity' has a wrong offset!");
//(offsetof(FLightingChannelsIntensity, Channel2Intensity) == 0x000008, "Member 'FLightingChannelsIntensity::Channel2Intensity' has a wrong offset!");

// ScriptStruct Engine.ViewTargetTransitionParams
// 0x0018 (0x0018 - 0x0000)
struct FViewTargetTransitionParams final
{
public:
	float                                         BlendTime;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLockOutgoing : 1;                                 // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCurveMove : 1;                                    // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ControlPointDistance;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ControlPointSide : 1;                              // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FViewTargetTransitionParams) == 0x000004, "Wrong alignment on FViewTargetTransitionParams");
//(sizeof(FViewTargetTransitionParams) == 0x000018, "Wrong size on FViewTargetTransitionParams");
//(offsetof(FViewTargetTransitionParams, BlendTime) == 0x000000, "Member 'FViewTargetTransitionParams::BlendTime' has a wrong offset!");
//(offsetof(FViewTargetTransitionParams, BlendFunction) == 0x000004, "Member 'FViewTargetTransitionParams::BlendFunction' has a wrong offset!");
//(offsetof(FViewTargetTransitionParams, BlendExp) == 0x000008, "Member 'FViewTargetTransitionParams::BlendExp' has a wrong offset!");
//(offsetof(FViewTargetTransitionParams, ControlPointDistance) == 0x000010, "Member 'FViewTargetTransitionParams::ControlPointDistance' has a wrong offset!");

// ScriptStruct Engine.MaterialShadingModelField
// 0x0002 (0x0002 - 0x0000)
struct FMaterialShadingModelField final
{
public:
	uint16                                        ShadingModelField;                                 // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FMaterialShadingModelField) == 0x000002, "Wrong alignment on FMaterialShadingModelField");
//(sizeof(FMaterialShadingModelField) == 0x000002, "Wrong size on FMaterialShadingModelField");
//(offsetof(FMaterialShadingModelField, ShadingModelField) == 0x000000, "Member 'FMaterialShadingModelField::ShadingModelField' has a wrong offset!");

// ScriptStruct Engine.StrataMaterialInfo
// 0x0030 (0x0030 - 0x0000)
struct FStrataMaterialInfo final
{
public:
	uint16                                        ShadingModelField;                                 // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bHasShadingModelFromExpression;                    // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ConnectedProperties;                               // 0x0004(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint64                                        ConnectedPropertyMask;                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USubsurfaceProfile*>             SubsurfaceProfiles;                                // 0x0010(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class USpecularProfile*>               SpecularProfiles;                                  // 0x0020(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
};
//(alignof(FStrataMaterialInfo) == 0x000008, "Wrong alignment on FStrataMaterialInfo");
//(sizeof(FStrataMaterialInfo) == 0x000030, "Wrong size on FStrataMaterialInfo");
//(offsetof(FStrataMaterialInfo, ShadingModelField) == 0x000000, "Member 'FStrataMaterialInfo::ShadingModelField' has a wrong offset!");
//(offsetof(FStrataMaterialInfo, bHasShadingModelFromExpression) == 0x000002, "Member 'FStrataMaterialInfo::bHasShadingModelFromExpression' has a wrong offset!");
//(offsetof(FStrataMaterialInfo, ConnectedProperties) == 0x000004, "Member 'FStrataMaterialInfo::ConnectedProperties' has a wrong offset!");
//(offsetof(FStrataMaterialInfo, ConnectedPropertyMask) == 0x000008, "Member 'FStrataMaterialInfo::ConnectedPropertyMask' has a wrong offset!");
//(offsetof(FStrataMaterialInfo, SubsurfaceProfiles) == 0x000010, "Member 'FStrataMaterialInfo::SubsurfaceProfiles' has a wrong offset!");
//(offsetof(FStrataMaterialInfo, SpecularProfiles) == 0x000020, "Member 'FStrataMaterialInfo::SpecularProfiles' has a wrong offset!");

// ScriptStruct Engine.RigidBodyErrorCorrection
// 0x0034 (0x0034 - 0x0000)
struct FRigidBodyErrorCorrection final
{
public:
	float                                         PingExtrapolation;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PingLimit;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorPerLinearDifference;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorPerAngularDifference;                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRestoredStateError;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearHardSnapDistance;                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionLerp;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleLerp;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearVelocityCoefficient;                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularVelocityCoefficient;                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorAccumulationSeconds;                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorAccumulationDistanceSq;                       // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorAccumulationSimilarity;                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRigidBodyErrorCorrection) == 0x000004, "Wrong alignment on FRigidBodyErrorCorrection");
//(sizeof(FRigidBodyErrorCorrection) == 0x000034, "Wrong size on FRigidBodyErrorCorrection");
//(offsetof(FRigidBodyErrorCorrection, PingExtrapolation) == 0x000000, "Member 'FRigidBodyErrorCorrection::PingExtrapolation' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, PingLimit) == 0x000004, "Member 'FRigidBodyErrorCorrection::PingLimit' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, ErrorPerLinearDifference) == 0x000008, "Member 'FRigidBodyErrorCorrection::ErrorPerLinearDifference' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, ErrorPerAngularDifference) == 0x00000C, "Member 'FRigidBodyErrorCorrection::ErrorPerAngularDifference' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, MaxRestoredStateError) == 0x000010, "Member 'FRigidBodyErrorCorrection::MaxRestoredStateError' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, MaxLinearHardSnapDistance) == 0x000014, "Member 'FRigidBodyErrorCorrection::MaxLinearHardSnapDistance' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, PositionLerp) == 0x000018, "Member 'FRigidBodyErrorCorrection::PositionLerp' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, AngleLerp) == 0x00001C, "Member 'FRigidBodyErrorCorrection::AngleLerp' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, LinearVelocityCoefficient) == 0x000020, "Member 'FRigidBodyErrorCorrection::LinearVelocityCoefficient' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, AngularVelocityCoefficient) == 0x000024, "Member 'FRigidBodyErrorCorrection::AngularVelocityCoefficient' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, ErrorAccumulationSeconds) == 0x000028, "Member 'FRigidBodyErrorCorrection::ErrorAccumulationSeconds' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, ErrorAccumulationDistanceSq) == 0x00002C, "Member 'FRigidBodyErrorCorrection::ErrorAccumulationDistanceSq' has a wrong offset!");
//(offsetof(FRigidBodyErrorCorrection, ErrorAccumulationSimilarity) == 0x000030, "Member 'FRigidBodyErrorCorrection::ErrorAccumulationSimilarity' has a wrong offset!");

// ScriptStruct Engine.ParticleSystemLOD
// 0x0001 (0x0001 - 0x0000)
struct FParticleSystemLOD final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FParticleSystemLOD) == 0x000001, "Wrong alignment on FParticleSystemLOD");
//(sizeof(FParticleSystemLOD) == 0x000001, "Wrong size on FParticleSystemLOD");

// ScriptStruct Engine.ExternalSpatialAccelerationPayload
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FExternalSpatialAccelerationPayload final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FExternalSpatialAccelerationPayload) == 0x000004, "Wrong alignment on FExternalSpatialAccelerationPayload");
//(sizeof(FExternalSpatialAccelerationPayload) == 0x000010, "Wrong size on FExternalSpatialAccelerationPayload");

// ScriptStruct Engine.ClusterUnionPendingAddData
// 0x0020 (0x0020 - 0x0000)
struct FClusterUnionPendingAddData final
{
public:
	TArray<int32>                                 BoneIds;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FExternalSpatialAccelerationPayload> AccelerationPayloads;                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FClusterUnionPendingAddData) == 0x000008, "Wrong alignment on FClusterUnionPendingAddData");
//(sizeof(FClusterUnionPendingAddData) == 0x000020, "Wrong size on FClusterUnionPendingAddData");
//(offsetof(FClusterUnionPendingAddData, BoneIds) == 0x000000, "Member 'FClusterUnionPendingAddData::BoneIds' has a wrong offset!");
//(offsetof(FClusterUnionPendingAddData, AccelerationPayloads) == 0x000010, "Member 'FClusterUnionPendingAddData::AccelerationPayloads' has a wrong offset!");

// ScriptStruct Engine.RigidBodyContactInfo
// 0x0048 (0x0048 - 0x0000)
struct FRigidBodyContactInfo final
{
public:
	struct FVector                                ContactPosition;                                   // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ContactNormal;                                     // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactPenetration;                                // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContactProbe;                                     // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      PhysMaterial[0x2];                                 // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRigidBodyContactInfo) == 0x000008, "Wrong alignment on FRigidBodyContactInfo");
//(sizeof(FRigidBodyContactInfo) == 0x000048, "Wrong size on FRigidBodyContactInfo");
//(offsetof(FRigidBodyContactInfo, ContactPosition) == 0x000000, "Member 'FRigidBodyContactInfo::ContactPosition' has a wrong offset!");
//(offsetof(FRigidBodyContactInfo, ContactNormal) == 0x000018, "Member 'FRigidBodyContactInfo::ContactNormal' has a wrong offset!");
//(offsetof(FRigidBodyContactInfo, ContactPenetration) == 0x000030, "Member 'FRigidBodyContactInfo::ContactPenetration' has a wrong offset!");
//(offsetof(FRigidBodyContactInfo, bContactProbe) == 0x000034, "Member 'FRigidBodyContactInfo::bContactProbe' has a wrong offset!");
//(offsetof(FRigidBodyContactInfo, PhysMaterial) == 0x000038, "Member 'FRigidBodyContactInfo::PhysMaterial' has a wrong offset!");

// ScriptStruct Engine.A2Pose
// 0x0010 (0x0010 - 0x0000)
struct FA2Pose
{
public:
	TArray<struct FTransform>                     Bones;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FA2Pose) == 0x000008, "Wrong alignment on FA2Pose");
//(sizeof(FA2Pose) == 0x000010, "Wrong size on FA2Pose");
//(offsetof(FA2Pose, Bones) == 0x000000, "Member 'FA2Pose::Bones' has a wrong offset!");

// ScriptStruct Engine.AnimParentNodeAssetOverride
// 0x0018 (0x0018 - 0x0000)
struct FAnimParentNodeAssetOverride final
{
public:
	class UAnimationAsset*                        NewAsset;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ParentNodeGuid;                                    // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimParentNodeAssetOverride) == 0x000008, "Wrong alignment on FAnimParentNodeAssetOverride");
//(sizeof(FAnimParentNodeAssetOverride) == 0x000018, "Wrong size on FAnimParentNodeAssetOverride");
//(offsetof(FAnimParentNodeAssetOverride, NewAsset) == 0x000000, "Member 'FAnimParentNodeAssetOverride::NewAsset' has a wrong offset!");
//(offsetof(FAnimParentNodeAssetOverride, ParentNodeGuid) == 0x000008, "Member 'FAnimParentNodeAssetOverride::ParentNodeGuid' has a wrong offset!");

// ScriptStruct Engine.CollisionImpactData
// 0x0048 (0x0048 - 0x0000)
struct FCollisionImpactData final
{
public:
	TArray<struct FRigidBodyContactInfo>          ContactInfos;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                TotalNormalImpulse;                                // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TotalFrictionImpulse;                              // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVelocityDeltaUnderThreshold;                    // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTouchEnter;                                     // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCollisionImpactData) == 0x000008, "Wrong alignment on FCollisionImpactData");
//(sizeof(FCollisionImpactData) == 0x000048, "Wrong size on FCollisionImpactData");
//(offsetof(FCollisionImpactData, ContactInfos) == 0x000000, "Member 'FCollisionImpactData::ContactInfos' has a wrong offset!");
//(offsetof(FCollisionImpactData, TotalNormalImpulse) == 0x000010, "Member 'FCollisionImpactData::TotalNormalImpulse' has a wrong offset!");
//(offsetof(FCollisionImpactData, TotalFrictionImpulse) == 0x000028, "Member 'FCollisionImpactData::TotalFrictionImpulse' has a wrong offset!");
//(offsetof(FCollisionImpactData, bIsVelocityDeltaUnderThreshold) == 0x000040, "Member 'FCollisionImpactData::bIsVelocityDeltaUnderThreshold' has a wrong offset!");
//(offsetof(FCollisionImpactData, bIsTouchEnter) == 0x000041, "Member 'FCollisionImpactData::bIsTouchEnter' has a wrong offset!");

// ScriptStruct Engine.ImportFactorySettingValues
// 0x0020 (0x0020 - 0x0000)
struct FImportFactorySettingValues final
{
public:
	class FString                                 SettingName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FImportFactorySettingValues) == 0x000008, "Wrong alignment on FImportFactorySettingValues");
//(sizeof(FImportFactorySettingValues) == 0x000020, "Wrong size on FImportFactorySettingValues");
//(offsetof(FImportFactorySettingValues, SettingName) == 0x000000, "Member 'FImportFactorySettingValues::SettingName' has a wrong offset!");
//(offsetof(FImportFactorySettingValues, Value) == 0x000010, "Member 'FImportFactorySettingValues::Value' has a wrong offset!");

// ScriptStruct Engine.EditorImportWorkflowDefinition
// 0x0020 (0x0020 - 0x0000)
struct FEditorImportWorkflowDefinition final
{
public:
	struct FFilePath                              ImportFilePath;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FImportFactorySettingValues>    FactorySettings;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
//(alignof(FEditorImportWorkflowDefinition) == 0x000008, "Wrong alignment on FEditorImportWorkflowDefinition");
//(sizeof(FEditorImportWorkflowDefinition) == 0x000020, "Wrong size on FEditorImportWorkflowDefinition");
//(offsetof(FEditorImportWorkflowDefinition, ImportFilePath) == 0x000000, "Member 'FEditorImportWorkflowDefinition::ImportFilePath' has a wrong offset!");
//(offsetof(FEditorImportWorkflowDefinition, FactorySettings) == 0x000010, "Member 'FEditorImportWorkflowDefinition::FactorySettings' has a wrong offset!");

// ScriptStruct Engine.FractureEffect
// 0x0010 (0x0010 - 0x0000)
struct FFractureEffect final
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FFractureEffect) == 0x000008, "Wrong alignment on FFractureEffect");
//(sizeof(FFractureEffect) == 0x000010, "Wrong size on FFractureEffect");
//(offsetof(FFractureEffect, ParticleSystem) == 0x000000, "Member 'FFractureEffect::ParticleSystem' has a wrong offset!");
//(offsetof(FFractureEffect, Sound) == 0x000008, "Member 'FFractureEffect::Sound' has a wrong offset!");

// ScriptStruct Engine.BasedPosition
// 0x0068 (0x0068 - 0x0000)
struct FBasedPosition final
{
public:
	class AActor*                                 base;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CachedBaseLocation;                                // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CachedBaseRotation;                                // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CachedTransPosition;                               // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBasedPosition) == 0x000008, "Wrong alignment on FBasedPosition");
//(sizeof(FBasedPosition) == 0x000068, "Wrong size on FBasedPosition");
//(offsetof(FBasedPosition, base) == 0x000000, "Member 'FBasedPosition::base' has a wrong offset!");
//(offsetof(FBasedPosition, Position) == 0x000008, "Member 'FBasedPosition::Position' has a wrong offset!");
//(offsetof(FBasedPosition, CachedBaseLocation) == 0x000020, "Member 'FBasedPosition::CachedBaseLocation' has a wrong offset!");
//(offsetof(FBasedPosition, CachedBaseRotation) == 0x000038, "Member 'FBasedPosition::CachedBaseRotation' has a wrong offset!");
//(offsetof(FBasedPosition, CachedTransPosition) == 0x000050, "Member 'FBasedPosition::CachedTransPosition' has a wrong offset!");

// ScriptStruct Engine.VertexOffsetUsage
// 0x0004 (0x0004 - 0x0000)
struct FVertexOffsetUsage final
{
public:
	int32                                         Usage;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FVertexOffsetUsage) == 0x000004, "Wrong alignment on FVertexOffsetUsage");
//(sizeof(FVertexOffsetUsage) == 0x000004, "Wrong size on FVertexOffsetUsage");
//(offsetof(FVertexOffsetUsage, Usage) == 0x000000, "Member 'FVertexOffsetUsage::Usage' has a wrong offset!");

// ScriptStruct Engine.TTEventTrack
// 0x0018 (0x0030 - 0x0018)
struct FTTEventTrack final : public FTTTrackBase
{
public:
	class FName                                   FunctionName;                                      // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CurveKeys;                                         // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTTEventTrack) == 0x000008, "Wrong alignment on FTTEventTrack");
//(sizeof(FTTEventTrack) == 0x000030, "Wrong size on FTTEventTrack");
//(offsetof(FTTEventTrack, FunctionName) == 0x000018, "Member 'FTTEventTrack::FunctionName' has a wrong offset!");
//(offsetof(FTTEventTrack, CurveKeys) == 0x000028, "Member 'FTTEventTrack::CurveKeys' has a wrong offset!");

// ScriptStruct Engine.LightmassLightSettings
// 0x000C (0x000C - 0x0000)
struct FLightmassLightSettings
{
public:
	float                                         IndirectLightingSaturation;                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowExponent;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAreaShadowsForStationaryLight;                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLightmassLightSettings) == 0x000004, "Wrong alignment on FLightmassLightSettings");
//(sizeof(FLightmassLightSettings) == 0x00000C, "Wrong size on FLightmassLightSettings");
//(offsetof(FLightmassLightSettings, IndirectLightingSaturation) == 0x000000, "Member 'FLightmassLightSettings::IndirectLightingSaturation' has a wrong offset!");
//(offsetof(FLightmassLightSettings, ShadowExponent) == 0x000004, "Member 'FLightmassLightSettings::ShadowExponent' has a wrong offset!");
//(offsetof(FLightmassLightSettings, bUseAreaShadowsForStationaryLight) == 0x000008, "Member 'FLightmassLightSettings::bUseAreaShadowsForStationaryLight' has a wrong offset!");

// ScriptStruct Engine.WorldPartitionActorFilter
// 0x0001 (0x0001 - 0x0000)
struct FWorldPartitionActorFilter final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FWorldPartitionActorFilter) == 0x000001, "Wrong alignment on FWorldPartitionActorFilter");
//(sizeof(FWorldPartitionActorFilter) == 0x000001, "Wrong size on FWorldPartitionActorFilter");

// ScriptStruct Engine.LightmassPointLightSettings
// 0x0000 (0x000C - 0x000C)
struct FLightmassPointLightSettings final : public FLightmassLightSettings
{
};
//(alignof(FLightmassPointLightSettings) == 0x000004, "Wrong alignment on FLightmassPointLightSettings");
//(sizeof(FLightmassPointLightSettings) == 0x00000C, "Wrong size on FLightmassPointLightSettings");

// ScriptStruct Engine.TexturePlatformData
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FTexturePlatformData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTexturePlatformData) == 0x000008, "Wrong alignment on FTexturePlatformData");
//(sizeof(FTexturePlatformData) == 0x000030, "Wrong size on FTexturePlatformData");

// ScriptStruct Engine.LightmassDirectionalLightSettings
// 0x0004 (0x0010 - 0x000C)
struct FLightmassDirectionalLightSettings final : public FLightmassLightSettings
{
public:
	float                                         LightSourceAngle;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FLightmassDirectionalLightSettings) == 0x000004, "Wrong alignment on FLightmassDirectionalLightSettings");
//(sizeof(FLightmassDirectionalLightSettings) == 0x000010, "Wrong size on FLightmassDirectionalLightSettings");
//(offsetof(FLightmassDirectionalLightSettings, LightSourceAngle) == 0x00000C, "Member 'FLightmassDirectionalLightSettings::LightSourceAngle' has a wrong offset!");

// ScriptStruct Engine.LightmassPrimitiveSettings
// 0x0018 (0x0018 - 0x0000)
struct FLightmassPrimitiveSettings final
{
public:
	uint8                                         bUseTwoSidedLighting : 1;                          // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShadowIndirectOnly : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseEmissiveForStaticLighting : 1;                 // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseVertexNormalForHemisphereGather : 1;           // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EmissiveLightFalloffExponent;                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveLightExplicitInfluenceRadius;              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveBoost;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiffuseBoost;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullyOccludedSamplesFraction;                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FLightmassPrimitiveSettings) == 0x000004, "Wrong alignment on FLightmassPrimitiveSettings");
//(sizeof(FLightmassPrimitiveSettings) == 0x000018, "Wrong size on FLightmassPrimitiveSettings");
//(offsetof(FLightmassPrimitiveSettings, EmissiveLightFalloffExponent) == 0x000004, "Member 'FLightmassPrimitiveSettings::EmissiveLightFalloffExponent' has a wrong offset!");
//(offsetof(FLightmassPrimitiveSettings, EmissiveLightExplicitInfluenceRadius) == 0x000008, "Member 'FLightmassPrimitiveSettings::EmissiveLightExplicitInfluenceRadius' has a wrong offset!");
//(offsetof(FLightmassPrimitiveSettings, EmissiveBoost) == 0x00000C, "Member 'FLightmassPrimitiveSettings::EmissiveBoost' has a wrong offset!");
//(offsetof(FLightmassPrimitiveSettings, DiffuseBoost) == 0x000010, "Member 'FLightmassPrimitiveSettings::DiffuseBoost' has a wrong offset!");
//(offsetof(FLightmassPrimitiveSettings, FullyOccludedSamplesFraction) == 0x000014, "Member 'FLightmassPrimitiveSettings::FullyOccludedSamplesFraction' has a wrong offset!");

// ScriptStruct Engine.StaticParameterSet
// 0x0000 (0x0038 - 0x0038)
struct FStaticParameterSet final : public FStaticParameterSetRuntimeData
{
};
//(alignof(FStaticParameterSet) == 0x000008, "Wrong alignment on FStaticParameterSet");
//(sizeof(FStaticParameterSet) == 0x000038, "Wrong size on FStaticParameterSet");

// ScriptStruct Engine.AnimGroupInfo
// 0x001C (0x001C - 0x0000)
struct FAnimGroupInfo final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimGroupInfo) == 0x000004, "Wrong alignment on FAnimGroupInfo");
//(sizeof(FAnimGroupInfo) == 0x00001C, "Wrong size on FAnimGroupInfo");
//(offsetof(FAnimGroupInfo, Name) == 0x000000, "Member 'FAnimGroupInfo::Name' has a wrong offset!");
//(offsetof(FAnimGroupInfo, Color) == 0x00000C, "Member 'FAnimGroupInfo::Color' has a wrong offset!");

// ScriptStruct Engine.LightmassDebugOptions
// 0x0010 (0x0010 - 0x0000)
struct FLightmassDebugOptions final
{
public:
	uint8                                         bDebugMode : 1;                                    // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStatsEnabled : 1;                                 // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGatherBSPSurfacesAcrossComponents : 1;            // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoplanarTolerance;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseImmediateImport : 1;                           // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImmediateProcessMappings : 1;                     // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSortMappings : 1;                                 // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDumpBinaryFiles : 1;                              // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugMaterials : 1;                               // 0x0008(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPadMappings : 1;                                  // 0x0008(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugPaddings : 1;                                // 0x0008(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlyCalcDebugTexelMappings : 1;                   // 0x0008(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseRandomColors : 1;                              // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bColorBordersGreen : 1;                            // 0x0009(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bColorByExecutionTime : 1;                         // 0x0009(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExecutionTimeDivisor;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FLightmassDebugOptions) == 0x000004, "Wrong alignment on FLightmassDebugOptions");
//(sizeof(FLightmassDebugOptions) == 0x000010, "Wrong size on FLightmassDebugOptions");
//(offsetof(FLightmassDebugOptions, CoplanarTolerance) == 0x000004, "Member 'FLightmassDebugOptions::CoplanarTolerance' has a wrong offset!");
//(offsetof(FLightmassDebugOptions, ExecutionTimeDivisor) == 0x00000C, "Member 'FLightmassDebugOptions::ExecutionTimeDivisor' has a wrong offset!");

// ScriptStruct Engine.AnimMontageAddCurve
// 0x0014 (0x0014 - 0x0000)
struct FAnimMontageAddCurve final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraCurveOption                            CameraCurveOption;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingLocalCoordinates;                            // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GenerationInterval;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimMontageAddCurve) == 0x000004, "Wrong alignment on FAnimMontageAddCurve");
//(sizeof(FAnimMontageAddCurve) == 0x000014, "Wrong size on FAnimMontageAddCurve");
//(offsetof(FAnimMontageAddCurve, SocketName) == 0x000000, "Member 'FAnimMontageAddCurve::SocketName' has a wrong offset!");
//(offsetof(FAnimMontageAddCurve, CameraCurveOption) == 0x00000C, "Member 'FAnimMontageAddCurve::CameraCurveOption' has a wrong offset!");
//(offsetof(FAnimMontageAddCurve, bUsingLocalCoordinates) == 0x00000D, "Member 'FAnimMontageAddCurve::bUsingLocalCoordinates' has a wrong offset!");
//(offsetof(FAnimMontageAddCurve, GenerationInterval) == 0x000010, "Member 'FAnimMontageAddCurve::GenerationInterval' has a wrong offset!");

// ScriptStruct Engine.DefaultAudioBusSettings
// 0x0028 (0x0028 - 0x0000)
struct FDefaultAudioBusSettings final
{
public:
	struct FSoftObjectPath                        AudioBus;                                          // 0x0000(0x0028)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDefaultAudioBusSettings) == 0x000008, "Wrong alignment on FDefaultAudioBusSettings");
//(sizeof(FDefaultAudioBusSettings) == 0x000028, "Wrong size on FDefaultAudioBusSettings");
//(offsetof(FDefaultAudioBusSettings, AudioBus) == 0x000000, "Member 'FDefaultAudioBusSettings::AudioBus' has a wrong offset!");

// ScriptStruct Engine.SwarmDebugOptions
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FSwarmDebugOptions final
{
public:
	uint8                                         bDistributionEnabled : 1;                          // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceContentExport : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitialized : 1;                                  // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSwarmDebugOptions) == 0x000004, "Wrong alignment on FSwarmDebugOptions");
//(sizeof(FSwarmDebugOptions) == 0x000004, "Wrong size on FSwarmDebugOptions");

// ScriptStruct Engine.KeyBind
// 0x0038 (0x0038 - 0x0000)
struct FKeyBind final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0020)(Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Command;                                           // 0x0020(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Control : 1;                                       // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Shift : 1;                                         // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Alt : 1;                                           // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Cmd : 1;                                           // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreCtrl : 1;                                   // 0x0030(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreShift : 1;                                  // 0x0030(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreAlt : 1;                                    // 0x0030(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreCmd : 1;                                    // 0x0030(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisabled : 1;                                     // 0x0031(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FKeyBind) == 0x000008, "Wrong alignment on FKeyBind");
//(sizeof(FKeyBind) == 0x000038, "Wrong size on FKeyBind");
//(offsetof(FKeyBind, Key) == 0x000000, "Member 'FKeyBind::Key' has a wrong offset!");
//(offsetof(FKeyBind, Command) == 0x000020, "Member 'FKeyBind::Command' has a wrong offset!");

// ScriptStruct Engine.AnimUpdateRateParameters
// 0x0088 (0x0088 - 0x0000)
struct FAnimUpdateRateParameters final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EUpdateRateShiftBucket                        ShiftBucket;                                       // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInterpolateSkippedFrames : 1;                     // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldUseLodMap : 1;                              // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldUseMinLod : 1;                              // 0x0002(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkipUpdate : 1;                                   // 0x0002(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkipEvaluation : 1;                               // 0x0002(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UpdateRate;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvaluationRate;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickedPoseOffestTime;                              // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalTime;                                    // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseNonRenderedUpdateRate;                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEvalRateForInterpolation;                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 BaseVisibleDistanceFactorThesholds;                // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            LODToFrameSkipMap;                                 // 0x0030(0x0050)(NativeAccessSpecifierPublic)
	int32                                         SkippedUpdateFrames;                               // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkippedEvalFrames;                                 // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimUpdateRateParameters) == 0x000008, "Wrong alignment on FAnimUpdateRateParameters");
//(sizeof(FAnimUpdateRateParameters) == 0x000088, "Wrong size on FAnimUpdateRateParameters");
//(offsetof(FAnimUpdateRateParameters, ShiftBucket) == 0x000001, "Member 'FAnimUpdateRateParameters::ShiftBucket' has a wrong offset!");
//(offsetof(FAnimUpdateRateParameters, UpdateRate) == 0x000004, "Member 'FAnimUpdateRateParameters::UpdateRate' has a wrong offset!");
//(offsetof(FAnimUpdateRateParameters, EvaluationRate) == 0x000008, "Member 'FAnimUpdateRateParameters::EvaluationRate' has a wrong offset!");
//(offsetof(FAnimUpdateRateParameters, TickedPoseOffestTime) == 0x00000C, "Member 'FAnimUpdateRateParameters::TickedPoseOffestTime' has a wrong offset!");
//(offsetof(FAnimUpdateRateParameters, AdditionalTime) == 0x000010, "Member 'FAnimUpdateRateParameters::AdditionalTime' has a wrong offset!");
//(offsetof(FAnimUpdateRateParameters, BaseNonRenderedUpdateRate) == 0x000018, "Member 'FAnimUpdateRateParameters::BaseNonRenderedUpdateRate' has a wrong offset!");
//(offsetof(FAnimUpdateRateParameters, MaxEvalRateForInterpolation) == 0x00001C, "Member 'FAnimUpdateRateParameters::MaxEvalRateForInterpolation' has a wrong offset!");
//(offsetof(FAnimUpdateRateParameters, BaseVisibleDistanceFactorThesholds) == 0x000020, "Member 'FAnimUpdateRateParameters::BaseVisibleDistanceFactorThesholds' has a wrong offset!");
//(offsetof(FAnimUpdateRateParameters, LODToFrameSkipMap) == 0x000030, "Member 'FAnimUpdateRateParameters::LODToFrameSkipMap' has a wrong offset!");
//(offsetof(FAnimUpdateRateParameters, SkippedUpdateFrames) == 0x000080, "Member 'FAnimUpdateRateParameters::SkippedUpdateFrames' has a wrong offset!");
//(offsetof(FAnimUpdateRateParameters, SkippedEvalFrames) == 0x000084, "Member 'FAnimUpdateRateParameters::SkippedEvalFrames' has a wrong offset!");

// ScriptStruct Engine.ColorGradingSettings
// 0x0290 (0x0290 - 0x0000)
struct FColorGradingSettings final
{
public:
	struct FColorGradePerRangeSettings            Global;                                            // 0x0000(0x00A0)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FColorGradePerRangeSettings            Shadows;                                           // 0x00A0(0x00A0)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FColorGradePerRangeSettings            Midtones;                                          // 0x0140(0x00A0)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FColorGradePerRangeSettings            Highlights;                                        // 0x01E0(0x00A0)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ShadowsMax;                                        // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighlightsMin;                                     // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighlightsMax;                                     // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FColorGradingSettings) == 0x000010, "Wrong alignment on FColorGradingSettings");
//(sizeof(FColorGradingSettings) == 0x000290, "Wrong size on FColorGradingSettings");
//(offsetof(FColorGradingSettings, Global) == 0x000000, "Member 'FColorGradingSettings::Global' has a wrong offset!");
//(offsetof(FColorGradingSettings, Shadows) == 0x0000A0, "Member 'FColorGradingSettings::Shadows' has a wrong offset!");
//(offsetof(FColorGradingSettings, Midtones) == 0x000140, "Member 'FColorGradingSettings::Midtones' has a wrong offset!");
//(offsetof(FColorGradingSettings, Highlights) == 0x0001E0, "Member 'FColorGradingSettings::Highlights' has a wrong offset!");
//(offsetof(FColorGradingSettings, ShadowsMax) == 0x000280, "Member 'FColorGradingSettings::ShadowsMax' has a wrong offset!");
//(offsetof(FColorGradingSettings, HighlightsMin) == 0x000284, "Member 'FColorGradingSettings::HighlightsMin' has a wrong offset!");
//(offsetof(FColorGradingSettings, HighlightsMax) == 0x000288, "Member 'FColorGradingSettings::HighlightsMax' has a wrong offset!");

// ScriptStruct Engine.POV
// 0x0038 (0x0038 - 0x0000)
struct FPOV final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPOV) == 0x000008, "Wrong alignment on FPOV");
//(sizeof(FPOV) == 0x000038, "Wrong size on FPOV");
//(offsetof(FPOV, Location) == 0x000000, "Member 'FPOV::Location' has a wrong offset!");
//(offsetof(FPOV, Rotation) == 0x000018, "Member 'FPOV::Rotation' has a wrong offset!");
//(offsetof(FPOV, FOV) == 0x000030, "Member 'FPOV::FOV' has a wrong offset!");

// ScriptStruct Engine.TTFloatTrack
// 0x0008 (0x0030 - 0x0028)
struct FTTFloatTrack final : public FTTPropertyTrack
{
public:
	class UCurveFloat*                            CurveFloat;                                        // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTTFloatTrack) == 0x000008, "Wrong alignment on FTTFloatTrack");
//(sizeof(FTTFloatTrack) == 0x000030, "Wrong size on FTTFloatTrack");
//(offsetof(FTTFloatTrack, CurveFloat) == 0x000028, "Member 'FTTFloatTrack::CurveFloat' has a wrong offset!");

// ScriptStruct Engine.MeshBuildSettings
// 0x0048 (0x0048 - 0x0000)
struct FMeshBuildSettings final
{
public:
	uint8                                         bUseMikkTSpace : 1;                                // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRecomputeNormals : 1;                             // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRecomputeTangents : 1;                            // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bComputeWeightedNormals : 1;                       // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRemoveDegenerates : 1;                            // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBuildReversedIndexBuffer : 1;                     // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseHighPrecisionTangentBasis : 1;                 // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFullPrecisionUVs : 1;                          // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseBackwardsCompatibleF16TruncUVs : 1;            // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateLightmapUVs : 1;                          // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateDistanceFieldAsIfTwoSided : 1;            // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportFaceRemap : 1;                             // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinLightmapResolution;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SrcLightmapIndex;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DstLightmapIndex;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildScale;                                        // 0x0010(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BuildScale3D;                                      // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFieldResolutionScale;                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            DistanceFieldReplacementMesh;                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLumenMeshCards;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMeshBuildSettings) == 0x000008, "Wrong alignment on FMeshBuildSettings");
//(sizeof(FMeshBuildSettings) == 0x000048, "Wrong size on FMeshBuildSettings");
//(offsetof(FMeshBuildSettings, MinLightmapResolution) == 0x000004, "Member 'FMeshBuildSettings::MinLightmapResolution' has a wrong offset!");
//(offsetof(FMeshBuildSettings, SrcLightmapIndex) == 0x000008, "Member 'FMeshBuildSettings::SrcLightmapIndex' has a wrong offset!");
//(offsetof(FMeshBuildSettings, DstLightmapIndex) == 0x00000C, "Member 'FMeshBuildSettings::DstLightmapIndex' has a wrong offset!");
//(offsetof(FMeshBuildSettings, BuildScale) == 0x000010, "Member 'FMeshBuildSettings::BuildScale' has a wrong offset!");
//(offsetof(FMeshBuildSettings, BuildScale3D) == 0x000018, "Member 'FMeshBuildSettings::BuildScale3D' has a wrong offset!");
//(offsetof(FMeshBuildSettings, DistanceFieldResolutionScale) == 0x000030, "Member 'FMeshBuildSettings::DistanceFieldResolutionScale' has a wrong offset!");
//(offsetof(FMeshBuildSettings, DistanceFieldReplacementMesh) == 0x000038, "Member 'FMeshBuildSettings::DistanceFieldReplacementMesh' has a wrong offset!");
//(offsetof(FMeshBuildSettings, MaxLumenMeshCards) == 0x000040, "Member 'FMeshBuildSettings::MaxLumenMeshCards' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshBuildSettings
// 0x0018 (0x0018 - 0x0000)
struct FSkeletalMeshBuildSettings final
{
public:
	uint8                                         bRecomputeNormals : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRecomputeTangents : 1;                            // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseMikkTSpace : 1;                                // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bComputeWeightedNormals : 1;                       // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRemoveDegenerates : 1;                            // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseHighPrecisionTangentBasis : 1;                 // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseHighPrecisionSkinWeights : 1;                  // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFullPrecisionUVs : 1;                          // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseBackwardsCompatibleF16TruncUVs : 1;            // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThresholdPosition;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThresholdTangentNormal;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThresholdUV;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MorphThresholdPosition;                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneInfluenceLimit;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSkeletalMeshBuildSettings) == 0x000004, "Wrong alignment on FSkeletalMeshBuildSettings");
//(sizeof(FSkeletalMeshBuildSettings) == 0x000018, "Wrong size on FSkeletalMeshBuildSettings");
//(offsetof(FSkeletalMeshBuildSettings, ThresholdPosition) == 0x000004, "Member 'FSkeletalMeshBuildSettings::ThresholdPosition' has a wrong offset!");
//(offsetof(FSkeletalMeshBuildSettings, ThresholdTangentNormal) == 0x000008, "Member 'FSkeletalMeshBuildSettings::ThresholdTangentNormal' has a wrong offset!");
//(offsetof(FSkeletalMeshBuildSettings, ThresholdUV) == 0x00000C, "Member 'FSkeletalMeshBuildSettings::ThresholdUV' has a wrong offset!");
//(offsetof(FSkeletalMeshBuildSettings, MorphThresholdPosition) == 0x000010, "Member 'FSkeletalMeshBuildSettings::MorphThresholdPosition' has a wrong offset!");
//(offsetof(FSkeletalMeshBuildSettings, BoneInfluenceLimit) == 0x000014, "Member 'FSkeletalMeshBuildSettings::BoneInfluenceLimit' has a wrong offset!");

// ScriptStruct Engine.TimelineEventEntry
// 0x0018 (0x0018 - 0x0000)
struct FTimelineEventEntry final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             EventFunc;                                         // 0x0004(0x0014)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTimelineEventEntry) == 0x000004, "Wrong alignment on FTimelineEventEntry");
//(sizeof(FTimelineEventEntry) == 0x000018, "Wrong size on FTimelineEventEntry");
//(offsetof(FTimelineEventEntry, Time) == 0x000000, "Member 'FTimelineEventEntry::Time' has a wrong offset!");
//(offsetof(FTimelineEventEntry, EventFunc) == 0x000004, "Member 'FTimelineEventEntry::EventFunc' has a wrong offset!");

// ScriptStruct Engine.TimelineVectorTrack
// 0x0050 (0x0050 - 0x0000)
struct FTimelineVectorTrack final
{
public:
	class UCurveVector*                           VectorCurve;                                       // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FVector& Output)> InterpFunc;                                        // 0x0008(0x0014)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrackName;                                         // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Playing;                                           // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   VectorPropertyName;                                // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTimelineVectorTrack) == 0x000008, "Wrong alignment on FTimelineVectorTrack");
//(sizeof(FTimelineVectorTrack) == 0x000050, "Wrong size on FTimelineVectorTrack");
//(offsetof(FTimelineVectorTrack, VectorCurve) == 0x000000, "Member 'FTimelineVectorTrack::VectorCurve' has a wrong offset!");
//(offsetof(FTimelineVectorTrack, InterpFunc) == 0x000008, "Member 'FTimelineVectorTrack::InterpFunc' has a wrong offset!");
//(offsetof(FTimelineVectorTrack, TrackName) == 0x00001C, "Member 'FTimelineVectorTrack::TrackName' has a wrong offset!");
//(offsetof(FTimelineVectorTrack, Playing) == 0x000028, "Member 'FTimelineVectorTrack::Playing' has a wrong offset!");
//(offsetof(FTimelineVectorTrack, VectorPropertyName) == 0x00002C, "Member 'FTimelineVectorTrack::VectorPropertyName' has a wrong offset!");

// ScriptStruct Engine.TimelineLinearColorTrack
// 0x0050 (0x0050 - 0x0000)
struct FTimelineLinearColorTrack final
{
public:
	class UCurveLinearColor*                      LinearColorCurve;                                  // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FLinearColor& Output)> InterpFunc;                                        // 0x0008(0x0014)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrackName;                                         // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LinearColorPropertyName;                           // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x1C];                                      // 0x0034(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTimelineLinearColorTrack) == 0x000008, "Wrong alignment on FTimelineLinearColorTrack");
//(sizeof(FTimelineLinearColorTrack) == 0x000050, "Wrong size on FTimelineLinearColorTrack");
//(offsetof(FTimelineLinearColorTrack, LinearColorCurve) == 0x000000, "Member 'FTimelineLinearColorTrack::LinearColorCurve' has a wrong offset!");
//(offsetof(FTimelineLinearColorTrack, InterpFunc) == 0x000008, "Member 'FTimelineLinearColorTrack::InterpFunc' has a wrong offset!");
//(offsetof(FTimelineLinearColorTrack, TrackName) == 0x00001C, "Member 'FTimelineLinearColorTrack::TrackName' has a wrong offset!");
//(offsetof(FTimelineLinearColorTrack, LinearColorPropertyName) == 0x000028, "Member 'FTimelineLinearColorTrack::LinearColorPropertyName' has a wrong offset!");

// ScriptStruct Engine.Timeline
// 0x00A8 (0x00A8 - 0x0000)
struct FTimeline final
{
public:
	ETimelineLengthMode                           LengthMode;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bLooping : 1;                                      // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bReversePlayback : 1;                              // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bPlaying : 1;                                      // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Length;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayRate;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Position;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTimelineEventEntry>            Events;                                            // 0x0010(0x0010)(ZeroConstructor, RepSkip, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FTimelineVectorTrack>           InterpVectors;                                     // 0x0020(0x0010)(ZeroConstructor, RepSkip, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FTimelineFloatTrack>            InterpFloats;                                      // 0x0030(0x0010)(ZeroConstructor, RepSkip, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FTimelineLinearColorTrack>      InterpLinearColors;                                // 0x0040(0x0010)(ZeroConstructor, RepSkip, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             TimelinePostUpdateFunc;                            // 0x0050(0x0014)(ZeroConstructor, InstancedReference, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             TimelineFinishedFunc;                              // 0x0064(0x0014)(ZeroConstructor, InstancedReference, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UObject>                 PropertySetObject;                                 // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DirectionPropertyName;                             // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x1C];                                      // 0x008C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTimeline) == 0x000008, "Wrong alignment on FTimeline");
//(sizeof(FTimeline) == 0x0000A8, "Wrong size on FTimeline");
//(offsetof(FTimeline, LengthMode) == 0x000000, "Member 'FTimeline::LengthMode' has a wrong offset!");
//(offsetof(FTimeline, Length) == 0x000004, "Member 'FTimeline::Length' has a wrong offset!");
//(offsetof(FTimeline, PlayRate) == 0x000008, "Member 'FTimeline::PlayRate' has a wrong offset!");
//(offsetof(FTimeline, Position) == 0x00000C, "Member 'FTimeline::Position' has a wrong offset!");
//(offsetof(FTimeline, Events) == 0x000010, "Member 'FTimeline::Events' has a wrong offset!");
//(offsetof(FTimeline, InterpVectors) == 0x000020, "Member 'FTimeline::InterpVectors' has a wrong offset!");
//(offsetof(FTimeline, InterpFloats) == 0x000030, "Member 'FTimeline::InterpFloats' has a wrong offset!");
//(offsetof(FTimeline, InterpLinearColors) == 0x000040, "Member 'FTimeline::InterpLinearColors' has a wrong offset!");
//(offsetof(FTimeline, TimelinePostUpdateFunc) == 0x000050, "Member 'FTimeline::TimelinePostUpdateFunc' has a wrong offset!");
//(offsetof(FTimeline, TimelineFinishedFunc) == 0x000064, "Member 'FTimeline::TimelineFinishedFunc' has a wrong offset!");
//(offsetof(FTimeline, PropertySetObject) == 0x000078, "Member 'FTimeline::PropertySetObject' has a wrong offset!");
//(offsetof(FTimeline, DirectionPropertyName) == 0x000080, "Member 'FTimeline::DirectionPropertyName' has a wrong offset!");

// ScriptStruct Engine.BlueprintEditorPromotionSettings
// 0x0030 (0x0030 - 0x0000)
struct FBlueprintEditorPromotionSettings final
{
public:
	struct FFilePath                              FirstMeshPath;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              SecondMeshPath;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              DefaultParticleAsset;                              // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBlueprintEditorPromotionSettings) == 0x000008, "Wrong alignment on FBlueprintEditorPromotionSettings");
//(sizeof(FBlueprintEditorPromotionSettings) == 0x000030, "Wrong size on FBlueprintEditorPromotionSettings");
//(offsetof(FBlueprintEditorPromotionSettings, FirstMeshPath) == 0x000000, "Member 'FBlueprintEditorPromotionSettings::FirstMeshPath' has a wrong offset!");
//(offsetof(FBlueprintEditorPromotionSettings, SecondMeshPath) == 0x000010, "Member 'FBlueprintEditorPromotionSettings::SecondMeshPath' has a wrong offset!");
//(offsetof(FBlueprintEditorPromotionSettings, DefaultParticleAsset) == 0x000020, "Member 'FBlueprintEditorPromotionSettings::DefaultParticleAsset' has a wrong offset!");

// ScriptStruct Engine.SoundDebugEntry
// 0x0038 (0x0038 - 0x0000)
struct FSoundDebugEntry final
{
public:
	class FName                                   DebugName;                                         // 0x0000(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Sound;                                             // 0x0010(0x0028)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoundDebugEntry) == 0x000008, "Wrong alignment on FSoundDebugEntry");
//(sizeof(FSoundDebugEntry) == 0x000038, "Wrong size on FSoundDebugEntry");
//(offsetof(FSoundDebugEntry, DebugName) == 0x000000, "Member 'FSoundDebugEntry::DebugName' has a wrong offset!");
//(offsetof(FSoundDebugEntry, Sound) == 0x000010, "Member 'FSoundDebugEntry::Sound' has a wrong offset!");

// ScriptStruct Engine.ConstrainComponentPropName
// 0x000C (0x000C - 0x0000)
struct FConstrainComponentPropName final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FConstrainComponentPropName) == 0x000004, "Wrong alignment on FConstrainComponentPropName");
//(sizeof(FConstrainComponentPropName) == 0x00000C, "Wrong size on FConstrainComponentPropName");
//(offsetof(FConstrainComponentPropName, ComponentName) == 0x000000, "Member 'FConstrainComponentPropName::ComponentName' has a wrong offset!");

// ScriptStruct Engine.GraphAssetPlayerInformation
// 0x0010 (0x0010 - 0x0000)
struct FGraphAssetPlayerInformation final
{
public:
	TArray<int32>                                 PlayerNodeIndices;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FGraphAssetPlayerInformation) == 0x000008, "Wrong alignment on FGraphAssetPlayerInformation");
//(sizeof(FGraphAssetPlayerInformation) == 0x000010, "Wrong size on FGraphAssetPlayerInformation");
//(offsetof(FGraphAssetPlayerInformation, PlayerNodeIndices) == 0x000000, "Member 'FGraphAssetPlayerInformation::PlayerNodeIndices' has a wrong offset!");

// ScriptStruct Engine.ResolutionSharpness
// 0x0010 (0x0010 - 0x0000)
struct FResolutionSharpness final
{
public:
	float                                         Num_720;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Num_1080;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Num_2k;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Num_4k;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FResolutionSharpness) == 0x000004, "Wrong alignment on FResolutionSharpness");
//(sizeof(FResolutionSharpness) == 0x000010, "Wrong size on FResolutionSharpness");
//(offsetof(FResolutionSharpness, Num_720) == 0x000000, "Member 'FResolutionSharpness::Num_720' has a wrong offset!");
//(offsetof(FResolutionSharpness, Num_1080) == 0x000004, "Member 'FResolutionSharpness::Num_1080' has a wrong offset!");
//(offsetof(FResolutionSharpness, Num_2k) == 0x000008, "Member 'FResolutionSharpness::Num_2k' has a wrong offset!");
//(offsetof(FResolutionSharpness, Num_4k) == 0x00000C, "Member 'FResolutionSharpness::Num_4k' has a wrong offset!");

// ScriptStruct Engine.Redirector
// 0x0018 (0x0018 - 0x0000)
struct FRedirector final
{
public:
	class FName                                   OldName;                                           // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewName;                                           // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRedirector) == 0x000004, "Wrong alignment on FRedirector");
//(sizeof(FRedirector) == 0x000018, "Wrong size on FRedirector");
//(offsetof(FRedirector, OldName) == 0x000000, "Member 'FRedirector::OldName' has a wrong offset!");
//(offsetof(FRedirector, NewName) == 0x00000C, "Member 'FRedirector::NewName' has a wrong offset!");

// ScriptStruct Engine.InputAxisProperties
// 0x0010 (0x0010 - 0x0000)
struct FInputAxisProperties final
{
public:
	float                                         DeadZone;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sensitivity;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Exponent;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInvert : 1;                                       // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FInputAxisProperties) == 0x000004, "Wrong alignment on FInputAxisProperties");
//(sizeof(FInputAxisProperties) == 0x000010, "Wrong size on FInputAxisProperties");
//(offsetof(FInputAxisProperties, DeadZone) == 0x000000, "Member 'FInputAxisProperties::DeadZone' has a wrong offset!");
//(offsetof(FInputAxisProperties, Sensitivity) == 0x000004, "Member 'FInputAxisProperties::Sensitivity' has a wrong offset!");
//(offsetof(FInputAxisProperties, Exponent) == 0x000008, "Member 'FInputAxisProperties::Exponent' has a wrong offset!");

// ScriptStruct Engine.InputAxisConfigEntry
// 0x001C (0x001C - 0x0000)
struct FInputAxisConfigEntry final
{
public:
	class FName                                   AxisKeyName;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputAxisProperties                   AxisProperties;                                    // 0x000C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FInputAxisConfigEntry) == 0x000004, "Wrong alignment on FInputAxisConfigEntry");
//(sizeof(FInputAxisConfigEntry) == 0x00001C, "Wrong size on FInputAxisConfigEntry");
//(offsetof(FInputAxisConfigEntry, AxisKeyName) == 0x000000, "Member 'FInputAxisConfigEntry::AxisKeyName' has a wrong offset!");
//(offsetof(FInputAxisConfigEntry, AxisProperties) == 0x00000C, "Member 'FInputAxisConfigEntry::AxisProperties' has a wrong offset!");

// ScriptStruct Engine.DepthFieldGlowInfo
// 0x0038 (0x0038 - 0x0000)
struct FDepthFieldGlowInfo final
{
public:
	uint8                                         bEnableGlow : 1;                                   // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           GlowColor;                                         // 0x0004(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              GlowOuterRadius;                                   // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GlowInnerRadius;                                   // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDepthFieldGlowInfo) == 0x000008, "Wrong alignment on FDepthFieldGlowInfo");
//(sizeof(FDepthFieldGlowInfo) == 0x000038, "Wrong size on FDepthFieldGlowInfo");
//(offsetof(FDepthFieldGlowInfo, GlowColor) == 0x000004, "Member 'FDepthFieldGlowInfo::GlowColor' has a wrong offset!");
//(offsetof(FDepthFieldGlowInfo, GlowOuterRadius) == 0x000018, "Member 'FDepthFieldGlowInfo::GlowOuterRadius' has a wrong offset!");
//(offsetof(FDepthFieldGlowInfo, GlowInnerRadius) == 0x000028, "Member 'FDepthFieldGlowInfo::GlowInnerRadius' has a wrong offset!");

// ScriptStruct Engine.FontRenderInfo
// 0x0040 (0x0040 - 0x0000)
struct FFontRenderInfo final
{
public:
	uint8                                         bClipText : 1;                                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableShadow : 1;                                 // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDepthFieldGlowInfo                    GlowInfo;                                          // 0x0008(0x0038)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FFontRenderInfo) == 0x000008, "Wrong alignment on FFontRenderInfo");
//(sizeof(FFontRenderInfo) == 0x000040, "Wrong size on FFontRenderInfo");
//(offsetof(FFontRenderInfo, GlowInfo) == 0x000008, "Member 'FFontRenderInfo::GlowInfo' has a wrong offset!");

// ScriptStruct Engine.MeshApproximationSettings
// 0x0128 (0x0128 - 0x0000)
struct FMeshApproximationSettings final
{
public:
	EMeshApproximationType                        OutputType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ApproximationAccuracy;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClampVoxelDimension;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttemptAutoThickening;                            // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetMinThicknessMultiplier;                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTinyParts;                                  // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TinyPartSizeMultiplier;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshApproximationBaseCappingType             BaseCapping;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindingThreshold;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFillGaps;                                         // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GapDistance;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOccludedGeometryFilteringPolicy              OcclusionMethod;                                   // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOccludeFromBottom;                                // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshApproximationSimplificationPolicy        SimplifyMethod;                                    // 0x002E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetTriCount;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrianglesPerM;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GeometricDeviation;                                // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshApproximationGroundPlaneClippingPolicy   GroundClipping;                                    // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundClippingZHeight;                             // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEstimateHardNormals;                              // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HardNormalAngle;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshApproximationUVGenerationPolicy          UVGenerationMethod;                                // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialPatchCount;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurvatureAlignment;                                // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MergingThreshold;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleDeviation;                                 // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateNaniteEnabledMesh;                        // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NaniteProxyTrianglePercent;                        // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportRayTracing;                                // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDistanceField;                               // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MultiSamplingAA;                                   // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenderCaptureResolution;                           // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMaterialProxySettings                 MaterialSettings;                                  // 0x0078(0x00A0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CaptureFieldOfView;                                // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearPlaneDist;                                     // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRenderLODMeshes;                               // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSimplifyPrePass;                            // 0x0121(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableParallelBaking;                             // 0x0122(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrintDebugMessages;                               // 0x0123(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmitFullDebugMesh;                                // 0x0124(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMeshApproximationSettings) == 0x000008, "Wrong alignment on FMeshApproximationSettings");
//(sizeof(FMeshApproximationSettings) == 0x000128, "Wrong size on FMeshApproximationSettings");
//(offsetof(FMeshApproximationSettings, OutputType) == 0x000000, "Member 'FMeshApproximationSettings::OutputType' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, ApproximationAccuracy) == 0x000004, "Member 'FMeshApproximationSettings::ApproximationAccuracy' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, ClampVoxelDimension) == 0x000008, "Member 'FMeshApproximationSettings::ClampVoxelDimension' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bAttemptAutoThickening) == 0x00000C, "Member 'FMeshApproximationSettings::bAttemptAutoThickening' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, TargetMinThicknessMultiplier) == 0x000010, "Member 'FMeshApproximationSettings::TargetMinThicknessMultiplier' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bIgnoreTinyParts) == 0x000014, "Member 'FMeshApproximationSettings::bIgnoreTinyParts' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, TinyPartSizeMultiplier) == 0x000018, "Member 'FMeshApproximationSettings::TinyPartSizeMultiplier' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, BaseCapping) == 0x00001C, "Member 'FMeshApproximationSettings::BaseCapping' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, WindingThreshold) == 0x000020, "Member 'FMeshApproximationSettings::WindingThreshold' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bFillGaps) == 0x000024, "Member 'FMeshApproximationSettings::bFillGaps' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, GapDistance) == 0x000028, "Member 'FMeshApproximationSettings::GapDistance' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, OcclusionMethod) == 0x00002C, "Member 'FMeshApproximationSettings::OcclusionMethod' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bOccludeFromBottom) == 0x00002D, "Member 'FMeshApproximationSettings::bOccludeFromBottom' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, SimplifyMethod) == 0x00002E, "Member 'FMeshApproximationSettings::SimplifyMethod' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, TargetTriCount) == 0x000030, "Member 'FMeshApproximationSettings::TargetTriCount' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, TrianglesPerM) == 0x000034, "Member 'FMeshApproximationSettings::TrianglesPerM' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, GeometricDeviation) == 0x000038, "Member 'FMeshApproximationSettings::GeometricDeviation' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, GroundClipping) == 0x00003C, "Member 'FMeshApproximationSettings::GroundClipping' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, GroundClippingZHeight) == 0x000040, "Member 'FMeshApproximationSettings::GroundClippingZHeight' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bEstimateHardNormals) == 0x000044, "Member 'FMeshApproximationSettings::bEstimateHardNormals' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, HardNormalAngle) == 0x000048, "Member 'FMeshApproximationSettings::HardNormalAngle' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, UVGenerationMethod) == 0x00004C, "Member 'FMeshApproximationSettings::UVGenerationMethod' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, InitialPatchCount) == 0x000050, "Member 'FMeshApproximationSettings::InitialPatchCount' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, CurvatureAlignment) == 0x000054, "Member 'FMeshApproximationSettings::CurvatureAlignment' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, MergingThreshold) == 0x000058, "Member 'FMeshApproximationSettings::MergingThreshold' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, MaxAngleDeviation) == 0x00005C, "Member 'FMeshApproximationSettings::MaxAngleDeviation' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bGenerateNaniteEnabledMesh) == 0x000060, "Member 'FMeshApproximationSettings::bGenerateNaniteEnabledMesh' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, NaniteProxyTrianglePercent) == 0x000064, "Member 'FMeshApproximationSettings::NaniteProxyTrianglePercent' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bSupportRayTracing) == 0x000068, "Member 'FMeshApproximationSettings::bSupportRayTracing' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bAllowDistanceField) == 0x000069, "Member 'FMeshApproximationSettings::bAllowDistanceField' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, MultiSamplingAA) == 0x00006C, "Member 'FMeshApproximationSettings::MultiSamplingAA' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, RenderCaptureResolution) == 0x000070, "Member 'FMeshApproximationSettings::RenderCaptureResolution' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, MaterialSettings) == 0x000078, "Member 'FMeshApproximationSettings::MaterialSettings' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, CaptureFieldOfView) == 0x000118, "Member 'FMeshApproximationSettings::CaptureFieldOfView' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, NearPlaneDist) == 0x00011C, "Member 'FMeshApproximationSettings::NearPlaneDist' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bUseRenderLODMeshes) == 0x000120, "Member 'FMeshApproximationSettings::bUseRenderLODMeshes' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bEnableSimplifyPrePass) == 0x000121, "Member 'FMeshApproximationSettings::bEnableSimplifyPrePass' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bEnableParallelBaking) == 0x000122, "Member 'FMeshApproximationSettings::bEnableParallelBaking' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bPrintDebugMessages) == 0x000123, "Member 'FMeshApproximationSettings::bPrintDebugMessages' has a wrong offset!");
//(offsetof(FMeshApproximationSettings, bEmitFullDebugMesh) == 0x000124, "Member 'FMeshApproximationSettings::bEmitFullDebugMesh' has a wrong offset!");

// ScriptStruct Engine.PointerToUberGraphFrame
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FPointerToUberGraphFrame final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPointerToUberGraphFrame) == 0x000008, "Wrong alignment on FPointerToUberGraphFrame");
//(sizeof(FPointerToUberGraphFrame) == 0x000008, "Wrong size on FPointerToUberGraphFrame");

// ScriptStruct Engine.CanvasUVTri
// 0x0090 (0x0090 - 0x0000)
struct FCanvasUVTri final
{
public:
	struct FVector2D                              V0_Pos;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V0_UV;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           V0_Color;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V1_Pos;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V1_UV;                                             // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           V1_Color;                                          // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V2_Pos;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V2_UV;                                             // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           V2_Color;                                          // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCanvasUVTri) == 0x000008, "Wrong alignment on FCanvasUVTri");
//(sizeof(FCanvasUVTri) == 0x000090, "Wrong size on FCanvasUVTri");
//(offsetof(FCanvasUVTri, V0_Pos) == 0x000000, "Member 'FCanvasUVTri::V0_Pos' has a wrong offset!");
//(offsetof(FCanvasUVTri, V0_UV) == 0x000010, "Member 'FCanvasUVTri::V0_UV' has a wrong offset!");
//(offsetof(FCanvasUVTri, V0_Color) == 0x000020, "Member 'FCanvasUVTri::V0_Color' has a wrong offset!");
//(offsetof(FCanvasUVTri, V1_Pos) == 0x000030, "Member 'FCanvasUVTri::V1_Pos' has a wrong offset!");
//(offsetof(FCanvasUVTri, V1_UV) == 0x000040, "Member 'FCanvasUVTri::V1_UV' has a wrong offset!");
//(offsetof(FCanvasUVTri, V1_Color) == 0x000050, "Member 'FCanvasUVTri::V1_Color' has a wrong offset!");
//(offsetof(FCanvasUVTri, V2_Pos) == 0x000060, "Member 'FCanvasUVTri::V2_Pos' has a wrong offset!");
//(offsetof(FCanvasUVTri, V2_UV) == 0x000070, "Member 'FCanvasUVTri::V2_UV' has a wrong offset!");
//(offsetof(FCanvasUVTri, V2_Color) == 0x000080, "Member 'FCanvasUVTri::V2_Color' has a wrong offset!");

// ScriptStruct Engine.QuartzTimeSignature
// 0x0018 (0x0018 - 0x0000)
struct FQuartzTimeSignature final
{
public:
	int32                                         NumBeats;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuartzTimeSignatureQuantization              BeatType;                                          // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuartzPulseOverrideStep>       OptionalPulseOverride;                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FQuartzTimeSignature) == 0x000008, "Wrong alignment on FQuartzTimeSignature");
//(sizeof(FQuartzTimeSignature) == 0x000018, "Wrong size on FQuartzTimeSignature");
//(offsetof(FQuartzTimeSignature, NumBeats) == 0x000000, "Member 'FQuartzTimeSignature::NumBeats' has a wrong offset!");
//(offsetof(FQuartzTimeSignature, BeatType) == 0x000004, "Member 'FQuartzTimeSignature::BeatType' has a wrong offset!");
//(offsetof(FQuartzTimeSignature, OptionalPulseOverride) == 0x000008, "Member 'FQuartzTimeSignature::OptionalPulseOverride' has a wrong offset!");

// ScriptStruct Engine.PooledCameraShakes
// 0x0010 (0x0010 - 0x0000)
struct FPooledCameraShakes final
{
public:
	TArray<class UCameraShakeBase*>               PooledShakes;                                      // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FPooledCameraShakes) == 0x000008, "Wrong alignment on FPooledCameraShakes");
//(sizeof(FPooledCameraShakes) == 0x000010, "Wrong size on FPooledCameraShakes");
//(offsetof(FPooledCameraShakes, PooledShakes) == 0x000000, "Member 'FPooledCameraShakes::PooledShakes' has a wrong offset!");

// ScriptStruct Engine.ExponentialHeightFogData
// 0x000C (0x000C - 0x0000)
struct FExponentialHeightFogData final
{
public:
	float                                         FogDensity;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFalloff;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightOffset;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FExponentialHeightFogData) == 0x000004, "Wrong alignment on FExponentialHeightFogData");
//(sizeof(FExponentialHeightFogData) == 0x00000C, "Wrong size on FExponentialHeightFogData");
//(offsetof(FExponentialHeightFogData, FogDensity) == 0x000000, "Member 'FExponentialHeightFogData::FogDensity' has a wrong offset!");
//(offsetof(FExponentialHeightFogData, FogHeightFalloff) == 0x000004, "Member 'FExponentialHeightFogData::FogHeightFalloff' has a wrong offset!");
//(offsetof(FExponentialHeightFogData, FogHeightOffset) == 0x000008, "Member 'FExponentialHeightFogData::FogHeightOffset' has a wrong offset!");

// ScriptStruct Engine.FontImportOptionsData
// 0x00B0 (0x00B0 - 0x0000)
struct FFontImportOptionsData final
{
public:
	class FString                                 FontName;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableAntialiasing : 1;                           // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableBold : 1;                                   // 0x0014(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableItalic : 1;                                 // 0x0014(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableUnderline : 1;                              // 0x0014(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlphaOnly : 1;                                    // 0x0014(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFontImportCharacterSet                       CharacterSet;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Chars;                                             // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UnicodeRange;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharsFilePath;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharsFileWildcard;                                 // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCreatePrintableOnly : 1;                          // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIncludeASCIIRange : 1;                            // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ForegroundColor;                                   // 0x0064(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableDropShadow : 1;                             // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TexturePageWidth;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TexturePageMaxHeight;                              // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPadding;                                          // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YPadding;                                          // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtendBoxTop;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtendBoxBottom;                                   // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtendBoxRight;                                    // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtendBoxLeft;                                     // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableLegacyMode : 1;                             // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Kerning;                                           // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseDistanceFieldAlpha : 1;                        // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DistanceFieldScaleFactor;                          // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFieldScanRadiusScale;                      // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FFontImportOptionsData) == 0x000008, "Wrong alignment on FFontImportOptionsData");
//(sizeof(FFontImportOptionsData) == 0x0000B0, "Wrong size on FFontImportOptionsData");
//(offsetof(FFontImportOptionsData, FontName) == 0x000000, "Member 'FFontImportOptionsData::FontName' has a wrong offset!");
//(offsetof(FFontImportOptionsData, Height) == 0x000010, "Member 'FFontImportOptionsData::Height' has a wrong offset!");
//(offsetof(FFontImportOptionsData, CharacterSet) == 0x000018, "Member 'FFontImportOptionsData::CharacterSet' has a wrong offset!");
//(offsetof(FFontImportOptionsData, Chars) == 0x000020, "Member 'FFontImportOptionsData::Chars' has a wrong offset!");
//(offsetof(FFontImportOptionsData, UnicodeRange) == 0x000030, "Member 'FFontImportOptionsData::UnicodeRange' has a wrong offset!");
//(offsetof(FFontImportOptionsData, CharsFilePath) == 0x000040, "Member 'FFontImportOptionsData::CharsFilePath' has a wrong offset!");
//(offsetof(FFontImportOptionsData, CharsFileWildcard) == 0x000050, "Member 'FFontImportOptionsData::CharsFileWildcard' has a wrong offset!");
//(offsetof(FFontImportOptionsData, ForegroundColor) == 0x000064, "Member 'FFontImportOptionsData::ForegroundColor' has a wrong offset!");
//(offsetof(FFontImportOptionsData, TexturePageWidth) == 0x000078, "Member 'FFontImportOptionsData::TexturePageWidth' has a wrong offset!");
//(offsetof(FFontImportOptionsData, TexturePageMaxHeight) == 0x00007C, "Member 'FFontImportOptionsData::TexturePageMaxHeight' has a wrong offset!");
//(offsetof(FFontImportOptionsData, XPadding) == 0x000080, "Member 'FFontImportOptionsData::XPadding' has a wrong offset!");
//(offsetof(FFontImportOptionsData, YPadding) == 0x000084, "Member 'FFontImportOptionsData::YPadding' has a wrong offset!");
//(offsetof(FFontImportOptionsData, ExtendBoxTop) == 0x000088, "Member 'FFontImportOptionsData::ExtendBoxTop' has a wrong offset!");
//(offsetof(FFontImportOptionsData, ExtendBoxBottom) == 0x00008C, "Member 'FFontImportOptionsData::ExtendBoxBottom' has a wrong offset!");
//(offsetof(FFontImportOptionsData, ExtendBoxRight) == 0x000090, "Member 'FFontImportOptionsData::ExtendBoxRight' has a wrong offset!");
//(offsetof(FFontImportOptionsData, ExtendBoxLeft) == 0x000094, "Member 'FFontImportOptionsData::ExtendBoxLeft' has a wrong offset!");
//(offsetof(FFontImportOptionsData, Kerning) == 0x00009C, "Member 'FFontImportOptionsData::Kerning' has a wrong offset!");
//(offsetof(FFontImportOptionsData, DistanceFieldScaleFactor) == 0x0000A4, "Member 'FFontImportOptionsData::DistanceFieldScaleFactor' has a wrong offset!");
//(offsetof(FFontImportOptionsData, DistanceFieldScanRadiusScale) == 0x0000A8, "Member 'FFontImportOptionsData::DistanceFieldScanRadiusScale' has a wrong offset!");

// ScriptStruct Engine.AnimPoseContext
// 0x0000 (0x0010 - 0x0010)
struct FAnimPoseContext final : public FAnimExecutionContext
{
};
//(alignof(FAnimPoseContext) == 0x000008, "Wrong alignment on FAnimPoseContext");
//(sizeof(FAnimPoseContext) == 0x000010, "Wrong size on FAnimPoseContext");

// ScriptStruct Engine.LevelViewportInfo
// 0x0038 (0x0038 - 0x0000)
struct FLevelViewportInfo final
{
public:
	struct FVector                                CamPosition;                                       // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CamRotation;                                       // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CamOrthoZoom;                                      // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CamUpdated;                                        // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLevelViewportInfo) == 0x000008, "Wrong alignment on FLevelViewportInfo");
//(sizeof(FLevelViewportInfo) == 0x000038, "Wrong size on FLevelViewportInfo");
//(offsetof(FLevelViewportInfo, CamPosition) == 0x000000, "Member 'FLevelViewportInfo::CamPosition' has a wrong offset!");
//(offsetof(FLevelViewportInfo, CamRotation) == 0x000018, "Member 'FLevelViewportInfo::CamRotation' has a wrong offset!");
//(offsetof(FLevelViewportInfo, CamOrthoZoom) == 0x000030, "Member 'FLevelViewportInfo::CamOrthoZoom' has a wrong offset!");
//(offsetof(FLevelViewportInfo, CamUpdated) == 0x000034, "Member 'FLevelViewportInfo::CamUpdated' has a wrong offset!");

// ScriptStruct Engine.ForceFeedbackParameters
// 0x0010 (0x0010 - 0x0000)
struct FForceFeedbackParameters final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTimeDilation;                               // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayWhilePaused;                                  // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FForceFeedbackParameters) == 0x000004, "Wrong alignment on FForceFeedbackParameters");
//(sizeof(FForceFeedbackParameters) == 0x000010, "Wrong size on FForceFeedbackParameters");
//(offsetof(FForceFeedbackParameters, Tag) == 0x000000, "Member 'FForceFeedbackParameters::Tag' has a wrong offset!");
//(offsetof(FForceFeedbackParameters, bLooping) == 0x00000C, "Member 'FForceFeedbackParameters::bLooping' has a wrong offset!");
//(offsetof(FForceFeedbackParameters, bIgnoreTimeDilation) == 0x00000D, "Member 'FForceFeedbackParameters::bIgnoreTimeDilation' has a wrong offset!");
//(offsetof(FForceFeedbackParameters, bPlayWhilePaused) == 0x00000E, "Member 'FForceFeedbackParameters::bPlayWhilePaused' has a wrong offset!");

// ScriptStruct Engine.PredictProjectilePathParams
// 0x0080 (0x0080 - 0x0000)
struct FPredictProjectilePathParams final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LaunchVelocity;                                    // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceWithCollision;                               // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectileRadius;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimTime;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceWithChannel;                                 // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         SimFrequency;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideGravityZ;                                  // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDebugTime;                                     // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCurveGravity;                                  // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UCurveFloat>             DistanceCurveGravity;                              // 0x0074(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPredictProjectilePathParams) == 0x000008, "Wrong alignment on FPredictProjectilePathParams");
//(sizeof(FPredictProjectilePathParams) == 0x000080, "Wrong size on FPredictProjectilePathParams");
//(offsetof(FPredictProjectilePathParams, StartLocation) == 0x000000, "Member 'FPredictProjectilePathParams::StartLocation' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, LaunchVelocity) == 0x000018, "Member 'FPredictProjectilePathParams::LaunchVelocity' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, bTraceWithCollision) == 0x000030, "Member 'FPredictProjectilePathParams::bTraceWithCollision' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, ProjectileRadius) == 0x000034, "Member 'FPredictProjectilePathParams::ProjectileRadius' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, MaxSimTime) == 0x000038, "Member 'FPredictProjectilePathParams::MaxSimTime' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, bTraceWithChannel) == 0x00003C, "Member 'FPredictProjectilePathParams::bTraceWithChannel' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, TraceChannel) == 0x00003D, "Member 'FPredictProjectilePathParams::TraceChannel' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, ObjectTypes) == 0x000040, "Member 'FPredictProjectilePathParams::ObjectTypes' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, ActorsToIgnore) == 0x000050, "Member 'FPredictProjectilePathParams::ActorsToIgnore' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, SimFrequency) == 0x000060, "Member 'FPredictProjectilePathParams::SimFrequency' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, OverrideGravityZ) == 0x000064, "Member 'FPredictProjectilePathParams::OverrideGravityZ' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, DrawDebugType) == 0x000068, "Member 'FPredictProjectilePathParams::DrawDebugType' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, DrawDebugTime) == 0x00006C, "Member 'FPredictProjectilePathParams::DrawDebugTime' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, bTraceComplex) == 0x000070, "Member 'FPredictProjectilePathParams::bTraceComplex' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, bUseCurveGravity) == 0x000071, "Member 'FPredictProjectilePathParams::bUseCurveGravity' has a wrong offset!");
//(offsetof(FPredictProjectilePathParams, DistanceCurveGravity) == 0x000074, "Member 'FPredictProjectilePathParams::DistanceCurveGravity' has a wrong offset!");

// ScriptStruct Engine.LensSettings
// 0x00E8 (0x00E8 - 0x0000)
struct FLensSettings final
{
public:
	struct FLensBloomSettings                     Bloom;                                             // 0x0000(0x00C0)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FLensImperfectionSettings              Imperfections;                                     // 0x00C0(0x0020)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ChromaticAberration;                               // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLensSettings) == 0x000008, "Wrong alignment on FLensSettings");
//(sizeof(FLensSettings) == 0x0000E8, "Wrong size on FLensSettings");
//(offsetof(FLensSettings, Bloom) == 0x000000, "Member 'FLensSettings::Bloom' has a wrong offset!");
//(offsetof(FLensSettings, Imperfections) == 0x0000C0, "Member 'FLensSettings::Imperfections' has a wrong offset!");
//(offsetof(FLensSettings, ChromaticAberration) == 0x0000E0, "Member 'FLensSettings::ChromaticAberration' has a wrong offset!");

// ScriptStruct Engine.SceneViewExtensionIsActiveFunctor
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FSceneViewExtensionIsActiveFunctor final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSceneViewExtensionIsActiveFunctor) == 0x000010, "Wrong alignment on FSceneViewExtensionIsActiveFunctor");
//(sizeof(FSceneViewExtensionIsActiveFunctor) == 0x000050, "Wrong size on FSceneViewExtensionIsActiveFunctor");

// ScriptStruct Engine.PredictProjectilePathResult
// 0x01A8 (0x01A8 - 0x0000)
struct FPredictProjectilePathResult final
{
public:
	TArray<struct FPredictProjectilePathPointData> PathData;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FPredictProjectilePathPointData        LastTraceDestination;                              // 0x0010(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0048(0x0160)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
//(alignof(FPredictProjectilePathResult) == 0x000008, "Wrong alignment on FPredictProjectilePathResult");
//(sizeof(FPredictProjectilePathResult) == 0x0001A8, "Wrong size on FPredictProjectilePathResult");
//(offsetof(FPredictProjectilePathResult, PathData) == 0x000000, "Member 'FPredictProjectilePathResult::PathData' has a wrong offset!");
//(offsetof(FPredictProjectilePathResult, LastTraceDestination) == 0x000010, "Member 'FPredictProjectilePathResult::LastTraceDestination' has a wrong offset!");
//(offsetof(FPredictProjectilePathResult, HitResult) == 0x000048, "Member 'FPredictProjectilePathResult::HitResult' has a wrong offset!");

// ScriptStruct Engine.InputConsumeKeyInfo
// 0x0048 (0x0048 - 0x0000)
struct FInputConsumeKeyInfo final
{
public:
	class UObject*                                ConsumeSource;                                     // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConsumeKeyCause                              ConsumeCause;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   InKey;                                             // 0x0010(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputStackIndex;                                   // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActionName;                                        // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FInputConsumeKeyInfo) == 0x000008, "Wrong alignment on FInputConsumeKeyInfo");
//(sizeof(FInputConsumeKeyInfo) == 0x000048, "Wrong size on FInputConsumeKeyInfo");
//(offsetof(FInputConsumeKeyInfo, ConsumeSource) == 0x000000, "Member 'FInputConsumeKeyInfo::ConsumeSource' has a wrong offset!");
//(offsetof(FInputConsumeKeyInfo, ConsumeCause) == 0x000008, "Member 'FInputConsumeKeyInfo::ConsumeCause' has a wrong offset!");
//(offsetof(FInputConsumeKeyInfo, InKey) == 0x000010, "Member 'FInputConsumeKeyInfo::InKey' has a wrong offset!");
//(offsetof(FInputConsumeKeyInfo, InputStackIndex) == 0x000030, "Member 'FInputConsumeKeyInfo::InputStackIndex' has a wrong offset!");
//(offsetof(FInputConsumeKeyInfo, ActionName) == 0x000038, "Member 'FInputConsumeKeyInfo::ActionName' has a wrong offset!");

// ScriptStruct Engine.ActiveHapticFeedbackEffect
// 0x0048 (0x0048 - 0x0000)
struct FActiveHapticFeedbackEffect final
{
public:
	class UHapticFeedbackEffect_Base*             HapticEffect;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x40];                                       // 0x0008(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FActiveHapticFeedbackEffect) == 0x000008, "Wrong alignment on FActiveHapticFeedbackEffect");
//(sizeof(FActiveHapticFeedbackEffect) == 0x000048, "Wrong size on FActiveHapticFeedbackEffect");
//(offsetof(FActiveHapticFeedbackEffect, HapticEffect) == 0x000000, "Member 'FActiveHapticFeedbackEffect::HapticEffect' has a wrong offset!");

// ScriptStruct Engine.HapticFeedbackDetails_Curve
// 0x0110 (0x0110 - 0x0000)
struct FHapticFeedbackDetails_Curve final
{
public:
	struct FRuntimeFloatCurve                     Frequency;                                         // 0x0000(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     Amplitude;                                         // 0x0088(0x0088)(Edit, NativeAccessSpecifierPublic)
};
//(alignof(FHapticFeedbackDetails_Curve) == 0x000008, "Wrong alignment on FHapticFeedbackDetails_Curve");
//(sizeof(FHapticFeedbackDetails_Curve) == 0x000110, "Wrong size on FHapticFeedbackDetails_Curve");
//(offsetof(FHapticFeedbackDetails_Curve, Frequency) == 0x000000, "Member 'FHapticFeedbackDetails_Curve::Frequency' has a wrong offset!");
//(offsetof(FHapticFeedbackDetails_Curve, Amplitude) == 0x000088, "Member 'FHapticFeedbackDetails_Curve::Amplitude' has a wrong offset!");

// ScriptStruct Engine.PerPlatformFrameRate
// 0x0008 (0x0008 - 0x0000)
struct FPerPlatformFrameRate final
{
public:
	struct FFrameRate                             Default;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPerPlatformFrameRate) == 0x000004, "Wrong alignment on FPerPlatformFrameRate");
//(sizeof(FPerPlatformFrameRate) == 0x000008, "Wrong size on FPerPlatformFrameRate");
//(offsetof(FPerPlatformFrameRate, Default) == 0x000000, "Member 'FPerPlatformFrameRate::Default' has a wrong offset!");

// ScriptStruct Engine.ClusterNode_DEPRECATED
// 0x0028 (0x0028 - 0x0000)
struct FClusterNode_DEPRECATED final
{
public:
	struct FVector3f                              BoundMin;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstChild;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              BoundMax;                                          // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastChild;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstInstance;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastInstance;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FClusterNode_DEPRECATED) == 0x000004, "Wrong alignment on FClusterNode_DEPRECATED");
//(sizeof(FClusterNode_DEPRECATED) == 0x000028, "Wrong size on FClusterNode_DEPRECATED");
//(offsetof(FClusterNode_DEPRECATED, BoundMin) == 0x000000, "Member 'FClusterNode_DEPRECATED::BoundMin' has a wrong offset!");
//(offsetof(FClusterNode_DEPRECATED, FirstChild) == 0x00000C, "Member 'FClusterNode_DEPRECATED::FirstChild' has a wrong offset!");
//(offsetof(FClusterNode_DEPRECATED, BoundMax) == 0x000010, "Member 'FClusterNode_DEPRECATED::BoundMax' has a wrong offset!");
//(offsetof(FClusterNode_DEPRECATED, LastChild) == 0x00001C, "Member 'FClusterNode_DEPRECATED::LastChild' has a wrong offset!");
//(offsetof(FClusterNode_DEPRECATED, FirstInstance) == 0x000020, "Member 'FClusterNode_DEPRECATED::FirstInstance' has a wrong offset!");
//(offsetof(FClusterNode_DEPRECATED, LastInstance) == 0x000024, "Member 'FClusterNode_DEPRECATED::LastInstance' has a wrong offset!");

// ScriptStruct Engine.UniqueNetIdRepl
// 0x002F (0x0030 - 0x0001)
struct FUniqueNetIdRepl final : public FUniqueNetIdWrapper
{
public:
	uint8                                         Pad_1[0x1F];                                       // 0x0001(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ReplicationBytes;                                  // 0x0020(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
};
//(alignof(FUniqueNetIdRepl) == 0x000008, "Wrong alignment on FUniqueNetIdRepl");
//(sizeof(FUniqueNetIdRepl) == 0x000030, "Wrong size on FUniqueNetIdRepl");
//(offsetof(FUniqueNetIdRepl, ReplicationBytes) == 0x000020, "Member 'FUniqueNetIdRepl::ReplicationBytes' has a wrong offset!");

// ScriptStruct Engine.HLODSubActor
// 0x0001 (0x0001 - 0x0000)
struct FHLODSubActor final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FHLODSubActor) == 0x000001, "Wrong alignment on FHLODSubActor");
//(sizeof(FHLODSubActor) == 0x000001, "Wrong size on FHLODSubActor");

// ScriptStruct Engine.BoneAnimationTrack
// 0x0040 (0x0040 - 0x0000)
struct FBoneAnimationTrack final
{
public:
	struct FRawAnimSequenceTrack                  InternalTrackData;                                 // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	int32                                         BoneTreeIndex;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBoneAnimationTrack) == 0x000008, "Wrong alignment on FBoneAnimationTrack");
//(sizeof(FBoneAnimationTrack) == 0x000040, "Wrong size on FBoneAnimationTrack");
//(offsetof(FBoneAnimationTrack, InternalTrackData) == 0x000000, "Member 'FBoneAnimationTrack::InternalTrackData' has a wrong offset!");
//(offsetof(FBoneAnimationTrack, BoneTreeIndex) == 0x000030, "Member 'FBoneAnimationTrack::BoneTreeIndex' has a wrong offset!");
//(offsetof(FBoneAnimationTrack, Name) == 0x000034, "Member 'FBoneAnimationTrack::Name' has a wrong offset!");

// ScriptStruct Engine.InputAxisKeyMapping
// 0x0030 (0x0030 - 0x0000)
struct FInputAxisKeyMapping final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0010(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FInputAxisKeyMapping) == 0x000008, "Wrong alignment on FInputAxisKeyMapping");
//(sizeof(FInputAxisKeyMapping) == 0x000030, "Wrong size on FInputAxisKeyMapping");
//(offsetof(FInputAxisKeyMapping, AxisName) == 0x000000, "Member 'FInputAxisKeyMapping::AxisName' has a wrong offset!");
//(offsetof(FInputAxisKeyMapping, Scale) == 0x00000C, "Member 'FInputAxisKeyMapping::Scale' has a wrong offset!");
//(offsetof(FInputAxisKeyMapping, Key) == 0x000010, "Member 'FInputAxisKeyMapping::Key' has a wrong offset!");

// ScriptStruct Engine.AnimationCurveData
// 0x0020 (0x0020 - 0x0000)
struct FAnimationCurveData final
{
public:
	TArray<struct FFloatCurve>                    FloatCurves;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTransformCurve>                TransformCurves;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
//(alignof(FAnimationCurveData) == 0x000008, "Wrong alignment on FAnimationCurveData");
//(sizeof(FAnimationCurveData) == 0x000020, "Wrong size on FAnimationCurveData");
//(offsetof(FAnimationCurveData, FloatCurves) == 0x000000, "Member 'FAnimationCurveData::FloatCurves' has a wrong offset!");
//(offsetof(FAnimationCurveData, TransformCurves) == 0x000010, "Member 'FAnimationCurveData::TransformCurves' has a wrong offset!");

// ScriptStruct Engine.StreamingLevelsToConsider
// 0x0028 (0x0028 - 0x0000)
struct FStreamingLevelsToConsider final
{
public:
	TArray<class ULevelStreaming*>                StreamingLevels;                                   // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStreamingLevelsToConsider) == 0x000008, "Wrong alignment on FStreamingLevelsToConsider");
//(sizeof(FStreamingLevelsToConsider) == 0x000028, "Wrong size on FStreamingLevelsToConsider");
//(offsetof(FStreamingLevelsToConsider, StreamingLevels) == 0x000000, "Member 'FStreamingLevelsToConsider::StreamingLevels' has a wrong offset!");

// ScriptStruct Engine.RuntimePartitionDesc
// 0x0001 (0x0001 - 0x0000)
struct FRuntimePartitionDesc final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRuntimePartitionDesc) == 0x000001, "Wrong alignment on FRuntimePartitionDesc");
//(sizeof(FRuntimePartitionDesc) == 0x000001, "Wrong size on FRuntimePartitionDesc");

// ScriptStruct Engine.SoundWaveEnvelopeDataPerSound
// 0x0010 (0x0010 - 0x0000)
struct FSoundWaveEnvelopeDataPerSound final
{
public:
	float                                         Envelope;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaybackTime;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             SoundWave;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoundWaveEnvelopeDataPerSound) == 0x000008, "Wrong alignment on FSoundWaveEnvelopeDataPerSound");
//(sizeof(FSoundWaveEnvelopeDataPerSound) == 0x000010, "Wrong size on FSoundWaveEnvelopeDataPerSound");
//(offsetof(FSoundWaveEnvelopeDataPerSound, Envelope) == 0x000000, "Member 'FSoundWaveEnvelopeDataPerSound::Envelope' has a wrong offset!");
//(offsetof(FSoundWaveEnvelopeDataPerSound, PlaybackTime) == 0x000004, "Member 'FSoundWaveEnvelopeDataPerSound::PlaybackTime' has a wrong offset!");
//(offsetof(FSoundWaveEnvelopeDataPerSound, SoundWave) == 0x000008, "Member 'FSoundWaveEnvelopeDataPerSound::SoundWave' has a wrong offset!");

// ScriptStruct Engine.InstancedStaticMeshInstanceData
// 0x0080 (0x0080 - 0x0000)
struct FInstancedStaticMeshInstanceData final
{
public:
	struct FMatrix                                Transform;                                         // 0x0000(0x0080)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FInstancedStaticMeshInstanceData) == 0x000010, "Wrong alignment on FInstancedStaticMeshInstanceData");
//(sizeof(FInstancedStaticMeshInstanceData) == 0x000080, "Wrong size on FInstancedStaticMeshInstanceData");
//(offsetof(FInstancedStaticMeshInstanceData, Transform) == 0x000000, "Member 'FInstancedStaticMeshInstanceData::Transform' has a wrong offset!");

// ScriptStruct Engine.SoundTimecodeOffset
// 0x0008 (0x0008 - 0x0000)
struct FSoundTimecodeOffset final
{
public:
	double                                        NumOfSecondsSinceMidnight;                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoundTimecodeOffset) == 0x000008, "Wrong alignment on FSoundTimecodeOffset");
//(sizeof(FSoundTimecodeOffset) == 0x000008, "Wrong size on FSoundTimecodeOffset");
//(offsetof(FSoundTimecodeOffset, NumOfSecondsSinceMidnight) == 0x000000, "Member 'FSoundTimecodeOffset::NumOfSecondsSinceMidnight' has a wrong offset!");

// ScriptStruct Engine.InstancedStaticMeshComponentInstanceData
// 0x00D8 (0x0190 - 0x00B8)
struct FInstancedStaticMeshComponentInstanceData final : public FSceneComponentInstanceData
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInstancedStaticMeshLightMapInstanceData CachedStaticLighting;                              // 0x00C0(0x0070)(NativeAccessSpecifierPublic)
	TArray<struct FInstancedStaticMeshInstanceData> PerInstanceSMData;                                 // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 PerInstanceSMCustomData;                           // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x20];                                     // 0x0150(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InstancingRandomSeed;                              // 0x0170(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInstancedStaticMeshRandomSeed> AdditionalRandomSeeds;                             // 0x0178(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasPerInstanceHitProxies;                         // 0x0188(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FInstancedStaticMeshComponentInstanceData) == 0x000010, "Wrong alignment on FInstancedStaticMeshComponentInstanceData");
//(sizeof(FInstancedStaticMeshComponentInstanceData) == 0x000190, "Wrong size on FInstancedStaticMeshComponentInstanceData");
//(offsetof(FInstancedStaticMeshComponentInstanceData, StaticMesh) == 0x0000B8, "Member 'FInstancedStaticMeshComponentInstanceData::StaticMesh' has a wrong offset!");
//(offsetof(FInstancedStaticMeshComponentInstanceData, CachedStaticLighting) == 0x0000C0, "Member 'FInstancedStaticMeshComponentInstanceData::CachedStaticLighting' has a wrong offset!");
//(offsetof(FInstancedStaticMeshComponentInstanceData, PerInstanceSMData) == 0x000130, "Member 'FInstancedStaticMeshComponentInstanceData::PerInstanceSMData' has a wrong offset!");
//(offsetof(FInstancedStaticMeshComponentInstanceData, PerInstanceSMCustomData) == 0x000140, "Member 'FInstancedStaticMeshComponentInstanceData::PerInstanceSMCustomData' has a wrong offset!");
//(offsetof(FInstancedStaticMeshComponentInstanceData, InstancingRandomSeed) == 0x000170, "Member 'FInstancedStaticMeshComponentInstanceData::InstancingRandomSeed' has a wrong offset!");
//(offsetof(FInstancedStaticMeshComponentInstanceData, AdditionalRandomSeeds) == 0x000178, "Member 'FInstancedStaticMeshComponentInstanceData::AdditionalRandomSeeds' has a wrong offset!");
//(offsetof(FInstancedStaticMeshComponentInstanceData, bHasPerInstanceHitProxies) == 0x000188, "Member 'FInstancedStaticMeshComponentInstanceData::bHasPerInstanceHitProxies' has a wrong offset!");

// ScriptStruct Engine.AudioEffectParameters
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FAudioEffectParameters
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAudioEffectParameters) == 0x000008, "Wrong alignment on FAudioEffectParameters");
//(sizeof(FAudioEffectParameters) == 0x000008, "Wrong size on FAudioEffectParameters");

// ScriptStruct Engine.AudioEQEffect
// 0x0038 (0x0040 - 0x0008)
struct FAudioEQEffect final : public FAudioEffectParameters
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FrequencyCenter0;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gain0;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bandwidth0;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrequencyCenter1;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gain1;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bandwidth1;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrequencyCenter2;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gain2;                                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bandwidth2;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrequencyCenter3;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gain3;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bandwidth3;                                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAudioEQEffect) == 0x000008, "Wrong alignment on FAudioEQEffect");
//(sizeof(FAudioEQEffect) == 0x000040, "Wrong size on FAudioEQEffect");
//(offsetof(FAudioEQEffect, FrequencyCenter0) == 0x000010, "Member 'FAudioEQEffect::FrequencyCenter0' has a wrong offset!");
//(offsetof(FAudioEQEffect, Gain0) == 0x000014, "Member 'FAudioEQEffect::Gain0' has a wrong offset!");
//(offsetof(FAudioEQEffect, Bandwidth0) == 0x000018, "Member 'FAudioEQEffect::Bandwidth0' has a wrong offset!");
//(offsetof(FAudioEQEffect, FrequencyCenter1) == 0x00001C, "Member 'FAudioEQEffect::FrequencyCenter1' has a wrong offset!");
//(offsetof(FAudioEQEffect, Gain1) == 0x000020, "Member 'FAudioEQEffect::Gain1' has a wrong offset!");
//(offsetof(FAudioEQEffect, Bandwidth1) == 0x000024, "Member 'FAudioEQEffect::Bandwidth1' has a wrong offset!");
//(offsetof(FAudioEQEffect, FrequencyCenter2) == 0x000028, "Member 'FAudioEQEffect::FrequencyCenter2' has a wrong offset!");
//(offsetof(FAudioEQEffect, Gain2) == 0x00002C, "Member 'FAudioEQEffect::Gain2' has a wrong offset!");
//(offsetof(FAudioEQEffect, Bandwidth2) == 0x000030, "Member 'FAudioEQEffect::Bandwidth2' has a wrong offset!");
//(offsetof(FAudioEQEffect, FrequencyCenter3) == 0x000034, "Member 'FAudioEQEffect::FrequencyCenter3' has a wrong offset!");
//(offsetof(FAudioEQEffect, Gain3) == 0x000038, "Member 'FAudioEQEffect::Gain3' has a wrong offset!");
//(offsetof(FAudioEQEffect, Bandwidth3) == 0x00003C, "Member 'FAudioEQEffect::Bandwidth3' has a wrong offset!");

// ScriptStruct Engine.UniqueNetIdReplNetSerializerStringStruct
// 0x0010 (0x0010 - 0x0000)
struct FUniqueNetIdReplNetSerializerStringStruct final
{
public:
	class FString                                 String;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FUniqueNetIdReplNetSerializerStringStruct) == 0x000008, "Wrong alignment on FUniqueNetIdReplNetSerializerStringStruct");
//(sizeof(FUniqueNetIdReplNetSerializerStringStruct) == 0x000010, "Wrong size on FUniqueNetIdReplNetSerializerStringStruct");
//(offsetof(FUniqueNetIdReplNetSerializerStringStruct, String) == 0x000000, "Member 'FUniqueNetIdReplNetSerializerStringStruct::String' has a wrong offset!");

// ScriptStruct Engine.UniqueNetIdReplNetSerializerNameStruct
// 0x000C (0x000C - 0x0000)
struct FUniqueNetIdReplNetSerializerNameStruct final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FUniqueNetIdReplNetSerializerNameStruct) == 0x000004, "Wrong alignment on FUniqueNetIdReplNetSerializerNameStruct");
//(sizeof(FUniqueNetIdReplNetSerializerNameStruct) == 0x00000C, "Wrong size on FUniqueNetIdReplNetSerializerNameStruct");
//(offsetof(FUniqueNetIdReplNetSerializerNameStruct, Name) == 0x000000, "Member 'FUniqueNetIdReplNetSerializerNameStruct::Name' has a wrong offset!");

// ScriptStruct Engine.ConstraintInstanceAccessor
// 0x000C (0x000C - 0x0000)
struct FConstraintInstanceAccessor final
{
public:
	TWeakObjectPtr<class UObject>                 Owner;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        Index;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FConstraintInstanceAccessor) == 0x000004, "Wrong alignment on FConstraintInstanceAccessor");
//(sizeof(FConstraintInstanceAccessor) == 0x00000C, "Wrong size on FConstraintInstanceAccessor");
//(offsetof(FConstraintInstanceAccessor, Owner) == 0x000000, "Member 'FConstraintInstanceAccessor::Owner' has a wrong offset!");
//(offsetof(FConstraintInstanceAccessor, Index) == 0x000008, "Member 'FConstraintInstanceAccessor::Index' has a wrong offset!");

// ScriptStruct Engine.ISMClientHandle
// 0x0014 (0x0014 - 0x0000)
struct FISMClientHandle final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  Guid;                                              // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FISMClientHandle) == 0x000004, "Wrong alignment on FISMClientHandle");
//(sizeof(FISMClientHandle) == 0x000014, "Wrong size on FISMClientHandle");
//(offsetof(FISMClientHandle, Index) == 0x000000, "Member 'FISMClientHandle::Index' has a wrong offset!");
//(offsetof(FISMClientHandle, Guid) == 0x000004, "Member 'FISMClientHandle::Guid' has a wrong offset!");

// ScriptStruct Engine.ISMClientInstanceManagerData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FISMClientInstanceManagerData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FISMClientInstanceManagerData) == 0x000008, "Wrong alignment on FISMClientInstanceManagerData");
//(sizeof(FISMClientInstanceManagerData) == 0x000010, "Wrong size on FISMClientInstanceManagerData");

// ScriptStruct Engine.NewLevelInstanceParams
// 0x0048 (0x0048 - 0x0000)
struct FNewLevelInstanceParams final
{
public:
	ELevelInstanceCreationType                    Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELevelInstancePivotType                       PivotType;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PivotActor;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowDialog;                                 // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 TemplateWorld;                                     // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelPackageName;                                  // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPromptForSave;                                    // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     LevelInstanceClass;                                // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStreaming;                                  // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExternalActors;                                   // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForceExternalActors;                              // 0x0042(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHideCreationType;                                 // 0x0043(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FNewLevelInstanceParams) == 0x000008, "Wrong alignment on FNewLevelInstanceParams");
//(sizeof(FNewLevelInstanceParams) == 0x000048, "Wrong size on FNewLevelInstanceParams");
//(offsetof(FNewLevelInstanceParams, Type) == 0x000000, "Member 'FNewLevelInstanceParams::Type' has a wrong offset!");
//(offsetof(FNewLevelInstanceParams, PivotType) == 0x000001, "Member 'FNewLevelInstanceParams::PivotType' has a wrong offset!");
//(offsetof(FNewLevelInstanceParams, PivotActor) == 0x000008, "Member 'FNewLevelInstanceParams::PivotActor' has a wrong offset!");
//(offsetof(FNewLevelInstanceParams, bAlwaysShowDialog) == 0x000010, "Member 'FNewLevelInstanceParams::bAlwaysShowDialog' has a wrong offset!");
//(offsetof(FNewLevelInstanceParams, TemplateWorld) == 0x000018, "Member 'FNewLevelInstanceParams::TemplateWorld' has a wrong offset!");
//(offsetof(FNewLevelInstanceParams, LevelPackageName) == 0x000020, "Member 'FNewLevelInstanceParams::LevelPackageName' has a wrong offset!");
//(offsetof(FNewLevelInstanceParams, bPromptForSave) == 0x000030, "Member 'FNewLevelInstanceParams::bPromptForSave' has a wrong offset!");
//(offsetof(FNewLevelInstanceParams, LevelInstanceClass) == 0x000038, "Member 'FNewLevelInstanceParams::LevelInstanceClass' has a wrong offset!");
//(offsetof(FNewLevelInstanceParams, bEnableStreaming) == 0x000040, "Member 'FNewLevelInstanceParams::bEnableStreaming' has a wrong offset!");
//(offsetof(FNewLevelInstanceParams, bExternalActors) == 0x000041, "Member 'FNewLevelInstanceParams::bExternalActors' has a wrong offset!");
//(offsetof(FNewLevelInstanceParams, bForceExternalActors) == 0x000042, "Member 'FNewLevelInstanceParams::bForceExternalActors' has a wrong offset!");
//(offsetof(FNewLevelInstanceParams, bHideCreationType) == 0x000043, "Member 'FNewLevelInstanceParams::bHideCreationType' has a wrong offset!");

// ScriptStruct Engine.MarvelDistanceFieldVolumeData
// 0x0068 (0x0068 - 0x0000)
struct FMarvelDistanceFieldVolumeData final
{
public:
	TArray<uint8>                                 DistanceFieldVolume;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FIntVector                             Size;                                              // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   LocalBoundingBox;                                  // 0x0020(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              DistanceScaledBias;                                // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMarvelDistanceFieldVolumeData) == 0x000008, "Wrong alignment on FMarvelDistanceFieldVolumeData");
//(sizeof(FMarvelDistanceFieldVolumeData) == 0x000068, "Wrong size on FMarvelDistanceFieldVolumeData");
//(offsetof(FMarvelDistanceFieldVolumeData, DistanceFieldVolume) == 0x000000, "Member 'FMarvelDistanceFieldVolumeData::DistanceFieldVolume' has a wrong offset!");
//(offsetof(FMarvelDistanceFieldVolumeData, Size) == 0x000010, "Member 'FMarvelDistanceFieldVolumeData::Size' has a wrong offset!");
//(offsetof(FMarvelDistanceFieldVolumeData, LocalBoundingBox) == 0x000020, "Member 'FMarvelDistanceFieldVolumeData::LocalBoundingBox' has a wrong offset!");
//(offsetof(FMarvelDistanceFieldVolumeData, DistanceScaledBias) == 0x000058, "Member 'FMarvelDistanceFieldVolumeData::DistanceScaledBias' has a wrong offset!");

// ScriptStruct Engine.ParticleEvent_GenerateInfo
// 0x0030 (0x0030 - 0x0000)
struct FParticleEvent_GenerateInfo final
{
public:
	EParticleEventType                            Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Frequency;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleFrequency;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FirstTimeOnly : 1;                                 // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         LastTimeOnly : 1;                                  // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseReflectedImpactVector : 1;                      // 0x000C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseOrbitOffset : 1;                               // 0x000C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomName;                                        // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleModuleEventSendToGame*> ParticleModuleEventsToSendToGame;                  // 0x0020(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FParticleEvent_GenerateInfo) == 0x000008, "Wrong alignment on FParticleEvent_GenerateInfo");
//(sizeof(FParticleEvent_GenerateInfo) == 0x000030, "Wrong size on FParticleEvent_GenerateInfo");
//(offsetof(FParticleEvent_GenerateInfo, Type) == 0x000000, "Member 'FParticleEvent_GenerateInfo::Type' has a wrong offset!");
//(offsetof(FParticleEvent_GenerateInfo, Frequency) == 0x000004, "Member 'FParticleEvent_GenerateInfo::Frequency' has a wrong offset!");
//(offsetof(FParticleEvent_GenerateInfo, ParticleFrequency) == 0x000008, "Member 'FParticleEvent_GenerateInfo::ParticleFrequency' has a wrong offset!");
//(offsetof(FParticleEvent_GenerateInfo, CustomName) == 0x000010, "Member 'FParticleEvent_GenerateInfo::CustomName' has a wrong offset!");
//(offsetof(FParticleEvent_GenerateInfo, ParticleModuleEventsToSendToGame) == 0x000020, "Member 'FParticleEvent_GenerateInfo::ParticleModuleEventsToSendToGame' has a wrong offset!");

// ScriptStruct Engine.SoundConcurrencySettings
// 0x0020 (0x0020 - 0x0000)
struct FSoundConcurrencySettings final
{
public:
	int32                                         MaxCount;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLimitToOwner : 1;                                 // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVolumeScaleCanRelease : 1;                        // 0x0004(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EMaxConcurrentResolutionRule                  ResolutionRule;                                    // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RetriggerTime;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeScale;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EConcurrencyVolumeScaleMode                   VolumeScaleMode;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeScaleAttackTime;                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeScaleReleaseTime;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoiceStealReleaseTime;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoundConcurrencySettings) == 0x000004, "Wrong alignment on FSoundConcurrencySettings");
//(sizeof(FSoundConcurrencySettings) == 0x000020, "Wrong size on FSoundConcurrencySettings");
//(offsetof(FSoundConcurrencySettings, MaxCount) == 0x000000, "Member 'FSoundConcurrencySettings::MaxCount' has a wrong offset!");
//(offsetof(FSoundConcurrencySettings, ResolutionRule) == 0x000005, "Member 'FSoundConcurrencySettings::ResolutionRule' has a wrong offset!");
//(offsetof(FSoundConcurrencySettings, RetriggerTime) == 0x000008, "Member 'FSoundConcurrencySettings::RetriggerTime' has a wrong offset!");
//(offsetof(FSoundConcurrencySettings, VolumeScale) == 0x00000C, "Member 'FSoundConcurrencySettings::VolumeScale' has a wrong offset!");
//(offsetof(FSoundConcurrencySettings, VolumeScaleMode) == 0x000010, "Member 'FSoundConcurrencySettings::VolumeScaleMode' has a wrong offset!");
//(offsetof(FSoundConcurrencySettings, VolumeScaleAttackTime) == 0x000014, "Member 'FSoundConcurrencySettings::VolumeScaleAttackTime' has a wrong offset!");
//(offsetof(FSoundConcurrencySettings, VolumeScaleReleaseTime) == 0x000018, "Member 'FSoundConcurrencySettings::VolumeScaleReleaseTime' has a wrong offset!");
//(offsetof(FSoundConcurrencySettings, VoiceStealReleaseTime) == 0x00001C, "Member 'FSoundConcurrencySettings::VoiceStealReleaseTime' has a wrong offset!");

// ScriptStruct Engine.ModifierHandle
// 0x0020 (0x0020 - 0x0000)
struct FModifierHandle final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        Handle;                                            // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FModifierHandle) == 0x000008, "Wrong alignment on FModifierHandle");
//(sizeof(FModifierHandle) == 0x000020, "Wrong size on FModifierHandle");
//(offsetof(FModifierHandle, Handle) == 0x000018, "Member 'FModifierHandle::Handle' has a wrong offset!");

// ScriptStruct Engine.RootMotionExtractionStep
// 0x0010 (0x0010 - 0x0000)
struct FRootMotionExtractionStep final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPosition;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndPosition;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRootMotionExtractionStep) == 0x000008, "Wrong alignment on FRootMotionExtractionStep");
//(sizeof(FRootMotionExtractionStep) == 0x000010, "Wrong size on FRootMotionExtractionStep");
//(offsetof(FRootMotionExtractionStep, AnimSequence) == 0x000000, "Member 'FRootMotionExtractionStep::AnimSequence' has a wrong offset!");
//(offsetof(FRootMotionExtractionStep, StartPosition) == 0x000008, "Member 'FRootMotionExtractionStep::StartPosition' has a wrong offset!");
//(offsetof(FRootMotionExtractionStep, EndPosition) == 0x00000C, "Member 'FRootMotionExtractionStep::EndPosition' has a wrong offset!");

// ScriptStruct Engine.ModifierExtraInfo
// 0x0018 (0x0018 - 0x0000)
struct FModifierExtraInfo final
{
public:
	EModifierPriority                             Priority;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DebugStr;                                          // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FModifierExtraInfo) == 0x000008, "Wrong alignment on FModifierExtraInfo");
//(sizeof(FModifierExtraInfo) == 0x000018, "Wrong size on FModifierExtraInfo");
//(offsetof(FModifierExtraInfo, Priority) == 0x000000, "Member 'FModifierExtraInfo::Priority' has a wrong offset!");
//(offsetof(FModifierExtraInfo, Duration) == 0x000004, "Member 'FModifierExtraInfo::Duration' has a wrong offset!");
//(offsetof(FModifierExtraInfo, DebugStr) == 0x000008, "Member 'FModifierExtraInfo::DebugStr' has a wrong offset!");

// ScriptStruct Engine.AssetEditorOrbitCameraPosition
// 0x0050 (0x0050 - 0x0000)
struct FAssetEditorOrbitCameraPosition final
{
public:
	bool                                          bIsSet;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CamOrbitPoint;                                     // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CamOrbitZoom;                                      // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CamOrbitRotation;                                  // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FAssetEditorOrbitCameraPosition) == 0x000008, "Wrong alignment on FAssetEditorOrbitCameraPosition");
//(sizeof(FAssetEditorOrbitCameraPosition) == 0x000050, "Wrong size on FAssetEditorOrbitCameraPosition");
//(offsetof(FAssetEditorOrbitCameraPosition, bIsSet) == 0x000000, "Member 'FAssetEditorOrbitCameraPosition::bIsSet' has a wrong offset!");
//(offsetof(FAssetEditorOrbitCameraPosition, CamOrbitPoint) == 0x000008, "Member 'FAssetEditorOrbitCameraPosition::CamOrbitPoint' has a wrong offset!");
//(offsetof(FAssetEditorOrbitCameraPosition, CamOrbitZoom) == 0x000020, "Member 'FAssetEditorOrbitCameraPosition::CamOrbitZoom' has a wrong offset!");
//(offsetof(FAssetEditorOrbitCameraPosition, CamOrbitRotation) == 0x000038, "Member 'FAssetEditorOrbitCameraPosition::CamOrbitRotation' has a wrong offset!");

// ScriptStruct Engine.PropertyModifier
// 0x0070 (0x0070 - 0x0000)
struct FPropertyModifier final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PropertyName;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModifierExtraInfo                     ExtraInfo;                                         // 0x0030(0x0018)(NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPropertyModifier) == 0x000008, "Wrong alignment on FPropertyModifier");
//(sizeof(FPropertyModifier) == 0x000070, "Wrong size on FPropertyModifier");
//(offsetof(FPropertyModifier, PropertyName) == 0x000010, "Member 'FPropertyModifier::PropertyName' has a wrong offset!");
//(offsetof(FPropertyModifier, ExtraInfo) == 0x000030, "Member 'FPropertyModifier::ExtraInfo' has a wrong offset!");

// ScriptStruct Engine.IntersectedMeshInfo
// 0x0030 (0x0030 - 0x0000)
struct FIntersectedMeshInfo final
{
public:
	TArray<struct FVector>                        VertexPositionBuffer;                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        VertexNormalBuffer;                                // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint32>                                TriangleVertexIndexBuffer;                         // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FIntersectedMeshInfo) == 0x000008, "Wrong alignment on FIntersectedMeshInfo");
//(sizeof(FIntersectedMeshInfo) == 0x000030, "Wrong size on FIntersectedMeshInfo");
//(offsetof(FIntersectedMeshInfo, VertexPositionBuffer) == 0x000000, "Member 'FIntersectedMeshInfo::VertexPositionBuffer' has a wrong offset!");
//(offsetof(FIntersectedMeshInfo, VertexNormalBuffer) == 0x000010, "Member 'FIntersectedMeshInfo::VertexNormalBuffer' has a wrong offset!");
//(offsetof(FIntersectedMeshInfo, TriangleVertexIndexBuffer) == 0x000020, "Member 'FIntersectedMeshInfo::TriangleVertexIndexBuffer' has a wrong offset!");

// ScriptStruct Engine.PaintSceneReconnectRebuildData
// 0x0028 (0x0028 - 0x0000)
struct FPaintSceneReconnectRebuildData final
{
public:
	struct FVector2f                              MinPoint;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointInterval;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              RepresentPointNum;                                 // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 RepresentPointFlags;                               // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FPaintSceneReconnectRebuildData) == 0x000008, "Wrong alignment on FPaintSceneReconnectRebuildData");
//(sizeof(FPaintSceneReconnectRebuildData) == 0x000028, "Wrong size on FPaintSceneReconnectRebuildData");
//(offsetof(FPaintSceneReconnectRebuildData, MinPoint) == 0x000000, "Member 'FPaintSceneReconnectRebuildData::MinPoint' has a wrong offset!");
//(offsetof(FPaintSceneReconnectRebuildData, PointInterval) == 0x000008, "Member 'FPaintSceneReconnectRebuildData::PointInterval' has a wrong offset!");
//(offsetof(FPaintSceneReconnectRebuildData, RepresentPointNum) == 0x00000C, "Member 'FPaintSceneReconnectRebuildData::RepresentPointNum' has a wrong offset!");
//(offsetof(FPaintSceneReconnectRebuildData, RepresentPointFlags) == 0x000018, "Member 'FPaintSceneReconnectRebuildData::RepresentPointFlags' has a wrong offset!");

// ScriptStruct Engine.TextureSourceBlock
// 0x0018 (0x0018 - 0x0000)
struct FTextureSourceBlock final
{
public:
	int32                                         BlockX;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockY;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeX;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSlices;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumMips;                                           // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTextureSourceBlock) == 0x000004, "Wrong alignment on FTextureSourceBlock");
//(sizeof(FTextureSourceBlock) == 0x000018, "Wrong size on FTextureSourceBlock");
//(offsetof(FTextureSourceBlock, BlockX) == 0x000000, "Member 'FTextureSourceBlock::BlockX' has a wrong offset!");
//(offsetof(FTextureSourceBlock, BlockY) == 0x000004, "Member 'FTextureSourceBlock::BlockY' has a wrong offset!");
//(offsetof(FTextureSourceBlock, SizeX) == 0x000008, "Member 'FTextureSourceBlock::SizeX' has a wrong offset!");
//(offsetof(FTextureSourceBlock, SizeY) == 0x00000C, "Member 'FTextureSourceBlock::SizeY' has a wrong offset!");
//(offsetof(FTextureSourceBlock, NumSlices) == 0x000010, "Member 'FTextureSourceBlock::NumSlices' has a wrong offset!");
//(offsetof(FTextureSourceBlock, NumMips) == 0x000014, "Member 'FTextureSourceBlock::NumMips' has a wrong offset!");

// ScriptStruct Engine.SamplePoints
// 0x0020 (0x0020 - 0x0000)
struct FSamplePoints final
{
public:
	TArray<struct FVector>                        PositionBuffer;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        NormalBuffer;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
//(alignof(FSamplePoints) == 0x000008, "Wrong alignment on FSamplePoints");
//(sizeof(FSamplePoints) == 0x000020, "Wrong size on FSamplePoints");
//(offsetof(FSamplePoints, PositionBuffer) == 0x000000, "Member 'FSamplePoints::PositionBuffer' has a wrong offset!");
//(offsetof(FSamplePoints, NormalBuffer) == 0x000010, "Member 'FSamplePoints::NormalBuffer' has a wrong offset!");

// ScriptStruct Engine.StreamingRenderAssetPrimitiveInfo
// 0x0050 (0x0050 - 0x0000)
struct FStreamingRenderAssetPrimitiveInfo final
{
public:
	class UStreamableRenderAsset*                 RenderAsset;                                       // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       Bounds;                                            // 0x0008(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TexelFactor;                                       // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PackedRelativeBox;                                 // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAllowInvalidTexelFactorWhenUnregistered : 1;      // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectedByComponentScale : 1;                     // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStreamingRenderAssetPrimitiveInfo) == 0x000008, "Wrong alignment on FStreamingRenderAssetPrimitiveInfo");
//(sizeof(FStreamingRenderAssetPrimitiveInfo) == 0x000050, "Wrong size on FStreamingRenderAssetPrimitiveInfo");
//(offsetof(FStreamingRenderAssetPrimitiveInfo, RenderAsset) == 0x000000, "Member 'FStreamingRenderAssetPrimitiveInfo::RenderAsset' has a wrong offset!");
//(offsetof(FStreamingRenderAssetPrimitiveInfo, Bounds) == 0x000008, "Member 'FStreamingRenderAssetPrimitiveInfo::Bounds' has a wrong offset!");
//(offsetof(FStreamingRenderAssetPrimitiveInfo, TexelFactor) == 0x000040, "Member 'FStreamingRenderAssetPrimitiveInfo::TexelFactor' has a wrong offset!");
//(offsetof(FStreamingRenderAssetPrimitiveInfo, PackedRelativeBox) == 0x000044, "Member 'FStreamingRenderAssetPrimitiveInfo::PackedRelativeBox' has a wrong offset!");

// ScriptStruct Engine.MarvelSampleBox
// 0x00C0 (0x00C0 - 0x0000)
struct FMarvelSampleBox final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SampleNumber;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntersectedMeshInfo                   MeshInfo;                                          // 0x0068(0x0030)(NativeAccessSpecifierPublic)
	struct FSamplePoints                          SamplePoints;                                      // 0x0098(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMarvelSampleBox) == 0x000010, "Wrong alignment on FMarvelSampleBox");
//(sizeof(FMarvelSampleBox) == 0x0000C0, "Wrong size on FMarvelSampleBox");
//(offsetof(FMarvelSampleBox, Transform) == 0x000000, "Member 'FMarvelSampleBox::Transform' has a wrong offset!");
//(offsetof(FMarvelSampleBox, SampleNumber) == 0x000060, "Member 'FMarvelSampleBox::SampleNumber' has a wrong offset!");
//(offsetof(FMarvelSampleBox, MeshInfo) == 0x000068, "Member 'FMarvelSampleBox::MeshInfo' has a wrong offset!");
//(offsetof(FMarvelSampleBox, SamplePoints) == 0x000098, "Member 'FMarvelSampleBox::SamplePoints' has a wrong offset!");

// ScriptStruct Engine.PhysicalAnimationData
// 0x0030 (0x0030 - 0x0000)
struct FPhysicalAnimationData final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsLocalSimulation : 1;                            // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OrientationStrength;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularVelocityStrength;                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionStrength;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityStrength;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearForce;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngularForce;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearDamping;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPhysicalAnimationData) == 0x000004, "Wrong alignment on FPhysicalAnimationData");
//(sizeof(FPhysicalAnimationData) == 0x000030, "Wrong size on FPhysicalAnimationData");
//(offsetof(FPhysicalAnimationData, BodyName) == 0x000000, "Member 'FPhysicalAnimationData::BodyName' has a wrong offset!");
//(offsetof(FPhysicalAnimationData, OrientationStrength) == 0x000010, "Member 'FPhysicalAnimationData::OrientationStrength' has a wrong offset!");
//(offsetof(FPhysicalAnimationData, AngularVelocityStrength) == 0x000014, "Member 'FPhysicalAnimationData::AngularVelocityStrength' has a wrong offset!");
//(offsetof(FPhysicalAnimationData, PositionStrength) == 0x000018, "Member 'FPhysicalAnimationData::PositionStrength' has a wrong offset!");
//(offsetof(FPhysicalAnimationData, VelocityStrength) == 0x00001C, "Member 'FPhysicalAnimationData::VelocityStrength' has a wrong offset!");
//(offsetof(FPhysicalAnimationData, MaxLinearForce) == 0x000020, "Member 'FPhysicalAnimationData::MaxLinearForce' has a wrong offset!");
//(offsetof(FPhysicalAnimationData, MaxAngularForce) == 0x000024, "Member 'FPhysicalAnimationData::MaxAngularForce' has a wrong offset!");
//(offsetof(FPhysicalAnimationData, LinearDamping) == 0x000028, "Member 'FPhysicalAnimationData::LinearDamping' has a wrong offset!");
//(offsetof(FPhysicalAnimationData, AngularDamping) == 0x00002C, "Member 'FPhysicalAnimationData::AngularDamping' has a wrong offset!");

// ScriptStruct Engine.MarvelSoftObjectPath
// 0x0038 (0x0038 - 0x0000)
struct FMarvelSoftObjectPath final
{
public:
	struct FSoftObjectPath                        SoftObjectPath;                                    // 0x0000(0x0028)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringPath;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMarvelSoftObjectPath) == 0x000008, "Wrong alignment on FMarvelSoftObjectPath");
//(sizeof(FMarvelSoftObjectPath) == 0x000038, "Wrong size on FMarvelSoftObjectPath");
//(offsetof(FMarvelSoftObjectPath, SoftObjectPath) == 0x000000, "Member 'FMarvelSoftObjectPath::SoftObjectPath' has a wrong offset!");
//(offsetof(FMarvelSoftObjectPath, StringPath) == 0x000028, "Member 'FMarvelSoftObjectPath::StringPath' has a wrong offset!");

// ScriptStruct Engine.ExpressionExecOutput
// 0x0008 (0x0008 - 0x0000)
struct FExpressionExecOutput final
{
public:
	class UMaterialExpression*                    Expression;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FExpressionExecOutput) == 0x000008, "Wrong alignment on FExpressionExecOutput");
//(sizeof(FExpressionExecOutput) == 0x000008, "Wrong size on FExpressionExecOutput");
//(offsetof(FExpressionExecOutput, Expression) == 0x000000, "Member 'FExpressionExecOutput::Expression' has a wrong offset!");

// ScriptStruct Engine.StaticMeshComponentLODInfo
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FStaticMeshComponentLODInfo final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStaticMeshComponentLODInfo) == 0x000008, "Wrong alignment on FStaticMeshComponentLODInfo");
//(sizeof(FStaticMeshComponentLODInfo) == 0x000090, "Wrong size on FStaticMeshComponentLODInfo");

// ScriptStruct Engine.MeshSectionInfo
// 0x000C (0x000C - 0x0000)
struct FMeshSectionInfo final
{
public:
	int32                                         MaterialIndex;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCollision;                                  // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCastShadow;                                       // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibleInRayTracing;                              // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectDistanceFieldLighting;                      // 0x0007(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceOpaque;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMeshSectionInfo) == 0x000004, "Wrong alignment on FMeshSectionInfo");
//(sizeof(FMeshSectionInfo) == 0x00000C, "Wrong size on FMeshSectionInfo");
//(offsetof(FMeshSectionInfo, MaterialIndex) == 0x000000, "Member 'FMeshSectionInfo::MaterialIndex' has a wrong offset!");
//(offsetof(FMeshSectionInfo, bEnableCollision) == 0x000004, "Member 'FMeshSectionInfo::bEnableCollision' has a wrong offset!");
//(offsetof(FMeshSectionInfo, bCastShadow) == 0x000005, "Member 'FMeshSectionInfo::bCastShadow' has a wrong offset!");
//(offsetof(FMeshSectionInfo, bVisibleInRayTracing) == 0x000006, "Member 'FMeshSectionInfo::bVisibleInRayTracing' has a wrong offset!");
//(offsetof(FMeshSectionInfo, bAffectDistanceFieldLighting) == 0x000007, "Member 'FMeshSectionInfo::bAffectDistanceFieldLighting' has a wrong offset!");
//(offsetof(FMeshSectionInfo, bForceOpaque) == 0x000008, "Member 'FMeshSectionInfo::bForceOpaque' has a wrong offset!");

// ScriptStruct Engine.MaterialExpressionCollection
// 0x0030 (0x0030 - 0x0000)
struct FMaterialExpressionCollection final
{
public:
	TArray<class UMaterialExpression*>            Expressions;                                       // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMaterialExpressionComment*>     EditorComments;                                    // 0x0010(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterialExpressionExecBegin*           ExpressionExecBegin;                               // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialExpressionExecEnd*             ExpressionExecEnd;                                 // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialExpressionCollection) == 0x000008, "Wrong alignment on FMaterialExpressionCollection");
//(sizeof(FMaterialExpressionCollection) == 0x000030, "Wrong size on FMaterialExpressionCollection");
//(offsetof(FMaterialExpressionCollection, Expressions) == 0x000000, "Member 'FMaterialExpressionCollection::Expressions' has a wrong offset!");
//(offsetof(FMaterialExpressionCollection, EditorComments) == 0x000010, "Member 'FMaterialExpressionCollection::EditorComments' has a wrong offset!");
//(offsetof(FMaterialExpressionCollection, ExpressionExecBegin) == 0x000020, "Member 'FMaterialExpressionCollection::ExpressionExecBegin' has a wrong offset!");
//(offsetof(FMaterialExpressionCollection, ExpressionExecEnd) == 0x000028, "Member 'FMaterialExpressionCollection::ExpressionExecEnd' has a wrong offset!");

// ScriptStruct Engine.CustomInput
// 0x0040 (0x0040 - 0x0000)
struct FCustomInput final
{
public:
	class FName                                   InputName;                                         // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Input;                                             // 0x0010(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FCustomInput) == 0x000008, "Wrong alignment on FCustomInput");
//(sizeof(FCustomInput) == 0x000040, "Wrong size on FCustomInput");
//(offsetof(FCustomInput, InputName) == 0x000000, "Member 'FCustomInput::InputName' has a wrong offset!");
//(offsetof(FCustomInput, Input) == 0x000010, "Member 'FCustomInput::Input' has a wrong offset!");

// ScriptStruct Engine.FunctionExpressionInput
// 0x0048 (0x0048 - 0x0000)
struct FFunctionExpressionInput final
{
public:
	class UMaterialExpressionFunctionInput*       ExpressionInput;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionInputId;                                 // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Input;                                             // 0x0018(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FFunctionExpressionInput) == 0x000008, "Wrong alignment on FFunctionExpressionInput");
//(sizeof(FFunctionExpressionInput) == 0x000048, "Wrong size on FFunctionExpressionInput");
//(offsetof(FFunctionExpressionInput, ExpressionInput) == 0x000000, "Member 'FFunctionExpressionInput::ExpressionInput' has a wrong offset!");
//(offsetof(FFunctionExpressionInput, ExpressionInputId) == 0x000008, "Member 'FFunctionExpressionInput::ExpressionInputId' has a wrong offset!");
//(offsetof(FFunctionExpressionInput, Input) == 0x000018, "Member 'FFunctionExpressionInput::Input' has a wrong offset!");

// ScriptStruct Engine.CompositeReroute
// 0x0018 (0x0018 - 0x0000)
struct FCompositeReroute final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialExpressionReroute*             Expression;                                        // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCompositeReroute) == 0x000008, "Wrong alignment on FCompositeReroute");
//(sizeof(FCompositeReroute) == 0x000018, "Wrong size on FCompositeReroute");
//(offsetof(FCompositeReroute, Name) == 0x000000, "Member 'FCompositeReroute::Name' has a wrong offset!");
//(offsetof(FCompositeReroute, Expression) == 0x000010, "Member 'FCompositeReroute::Expression' has a wrong offset!");

// ScriptStruct Engine.MaterialInstanceBasePropertyOverrides
// 0x0024 (0x0024 - 0x0000)
struct FMaterialInstanceBasePropertyOverrides final
{
public:
	uint8                                         bOverride_OpacityMaskClipValue : 1;                // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BlendMode : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MaterialTranslucencyPass : 1;            // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ShadingModel : 1;                        // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DitheredLODTransition : 1;               // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_CastDynamicShadowAsMasked : 1;           // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_TwoSided : 1;                            // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_bIsThinSurface : 1;                      // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OutputTranslucentVelocity : 1;           // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DisplacementScaling : 1;                 // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MaxWorldPositionOffsetDisplacement : 1;  // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RimlightShell : 1;                       // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRimlightShell : 1;                                // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DisableInsetShadow : 1;                  // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableInsetShadow : 1;                           // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DisableNormalShadow : 1;                 // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableNormalShadow : 1;                          // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_UseTranslucencyVertexFog : 1;            // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseTranslucencyVertexFog : 1;                     // 0x0002(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_EnableResponsiveAA : 1;                  // 0x0002(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableResponsiveAA : 1;                           // 0x0002(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MarvelStyleDiffuse : 1;                  // 0x0002(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMarvelStyleDiffuse : 1;                           // 0x0002(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MaterialDecalResponse : 1;               // 0x0002(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_EnableShellFur : 1;                      // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ShellFurLayers : 1;                      // 0x0003(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_TranslucencyLightingMode : 1;            // 0x0003(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableShellFur : 1;                               // 0x0003(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint32                                        ShellFurLayers;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETranslucencyLightingMode                     TranslucencyLightingMode;                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialDecalResponse                        MaterialDecalResponse;                             // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnableToonOutline : 1;                   // 0x000A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableToonOutline : 1;                            // 0x000A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OutlineDepthOnly : 1;                    // 0x000A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOutlineDepthOnly : 1;                             // 0x000A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RefractionMethod : 1;                    // 0x000A(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RefractionDepthBias : 1;                 // 0x000A(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ERefractionMode                               RefractionMode;                                    // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefractionDepthBias;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TwoSided : 1;                                      // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsThinSurface : 1;                                // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DitheredLODTransition : 1;                         // 0x0010(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastDynamicShadowAsMasked : 1;                    // 0x0010(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOutputTranslucentVelocity : 1;                    // 0x0010(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EBlendMode                                    BlendMode;                                         // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialTranslucencyPass                     MaterialTranslucencyPass;                          // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialShadingModel                         ShadingModel;                                      // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpacityMaskClipValue;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDisplacementScaling                   DisplacementScaling;                               // 0x0018(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxWorldPositionOffsetDisplacement;                // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialInstanceBasePropertyOverrides) == 0x000004, "Wrong alignment on FMaterialInstanceBasePropertyOverrides");
//(sizeof(FMaterialInstanceBasePropertyOverrides) == 0x000024, "Wrong size on FMaterialInstanceBasePropertyOverrides");
//(offsetof(FMaterialInstanceBasePropertyOverrides, ShellFurLayers) == 0x000004, "Member 'FMaterialInstanceBasePropertyOverrides::ShellFurLayers' has a wrong offset!");
//(offsetof(FMaterialInstanceBasePropertyOverrides, TranslucencyLightingMode) == 0x000008, "Member 'FMaterialInstanceBasePropertyOverrides::TranslucencyLightingMode' has a wrong offset!");
//(offsetof(FMaterialInstanceBasePropertyOverrides, MaterialDecalResponse) == 0x000009, "Member 'FMaterialInstanceBasePropertyOverrides::MaterialDecalResponse' has a wrong offset!");
//(offsetof(FMaterialInstanceBasePropertyOverrides, RefractionMode) == 0x00000B, "Member 'FMaterialInstanceBasePropertyOverrides::RefractionMode' has a wrong offset!");
//(offsetof(FMaterialInstanceBasePropertyOverrides, RefractionDepthBias) == 0x00000C, "Member 'FMaterialInstanceBasePropertyOverrides::RefractionDepthBias' has a wrong offset!");
//(offsetof(FMaterialInstanceBasePropertyOverrides, BlendMode) == 0x000011, "Member 'FMaterialInstanceBasePropertyOverrides::BlendMode' has a wrong offset!");
//(offsetof(FMaterialInstanceBasePropertyOverrides, MaterialTranslucencyPass) == 0x000012, "Member 'FMaterialInstanceBasePropertyOverrides::MaterialTranslucencyPass' has a wrong offset!");
//(offsetof(FMaterialInstanceBasePropertyOverrides, ShadingModel) == 0x000013, "Member 'FMaterialInstanceBasePropertyOverrides::ShadingModel' has a wrong offset!");
//(offsetof(FMaterialInstanceBasePropertyOverrides, OpacityMaskClipValue) == 0x000014, "Member 'FMaterialInstanceBasePropertyOverrides::OpacityMaskClipValue' has a wrong offset!");
//(offsetof(FMaterialInstanceBasePropertyOverrides, DisplacementScaling) == 0x000018, "Member 'FMaterialInstanceBasePropertyOverrides::DisplacementScaling' has a wrong offset!");
//(offsetof(FMaterialInstanceBasePropertyOverrides, MaxWorldPositionOffsetDisplacement) == 0x000020, "Member 'FMaterialInstanceBasePropertyOverrides::MaxWorldPositionOffsetDisplacement' has a wrong offset!");

// ScriptStruct Engine.MaterialTextureInfo
// 0x0014 (0x0014 - 0x0000)
struct FMaterialTextureInfo final
{
public:
	float                                         SamplingScale;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UVChannelIndex;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextureName;                                       // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialTextureInfo) == 0x000004, "Wrong alignment on FMaterialTextureInfo");
//(sizeof(FMaterialTextureInfo) == 0x000014, "Wrong size on FMaterialTextureInfo");
//(offsetof(FMaterialTextureInfo, SamplingScale) == 0x000000, "Member 'FMaterialTextureInfo::SamplingScale' has a wrong offset!");
//(offsetof(FMaterialTextureInfo, UVChannelIndex) == 0x000004, "Member 'FMaterialTextureInfo::UVChannelIndex' has a wrong offset!");
//(offsetof(FMaterialTextureInfo, TextureName) == 0x000008, "Member 'FMaterialTextureInfo::TextureName' has a wrong offset!");

// ScriptStruct Engine.PurchaseInfo
// 0x0040 (0x0040 - 0x0000)
struct FPurchaseInfo final
{
public:
	class FString                                 Identifier;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayDescription;                                // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayPrice;                                      // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPurchaseInfo) == 0x000008, "Wrong alignment on FPurchaseInfo");
//(sizeof(FPurchaseInfo) == 0x000040, "Wrong size on FPurchaseInfo");
//(offsetof(FPurchaseInfo, Identifier) == 0x000000, "Member 'FPurchaseInfo::Identifier' has a wrong offset!");
//(offsetof(FPurchaseInfo, DisplayName) == 0x000010, "Member 'FPurchaseInfo::DisplayName' has a wrong offset!");
//(offsetof(FPurchaseInfo, DisplayDescription) == 0x000020, "Member 'FPurchaseInfo::DisplayDescription' has a wrong offset!");
//(offsetof(FPurchaseInfo, DisplayPrice) == 0x000030, "Member 'FPurchaseInfo::DisplayPrice' has a wrong offset!");

// ScriptStruct Engine.NavAvoidanceMask
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FNavAvoidanceMask final
{
public:
	uint8                                         bGroup0 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup1 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup2 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup3 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup4 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup5 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup6 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup7 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup8 : 1;                                       // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup9 : 1;                                       // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup10 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup11 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup12 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup13 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup14 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup15 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup16 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup17 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup18 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup19 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup20 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup21 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup22 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup23 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup24 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup25 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup26 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup27 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup28 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup29 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup30 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGroup31 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
//(alignof(FNavAvoidanceMask) == 0x000004, "Wrong alignment on FNavAvoidanceMask");
//(sizeof(FNavAvoidanceMask) == 0x000004, "Wrong size on FNavAvoidanceMask");

// ScriptStruct Engine.ParticleCurvePair
// 0x0018 (0x0018 - 0x0000)
struct FParticleCurvePair final
{
public:
	class FString                                 CurveName;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CurveObject;                                       // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FParticleCurvePair) == 0x000008, "Wrong alignment on FParticleCurvePair");
//(sizeof(FParticleCurvePair) == 0x000018, "Wrong size on FParticleCurvePair");
//(offsetof(FParticleCurvePair, CurveName) == 0x000000, "Member 'FParticleCurvePair::CurveName' has a wrong offset!");
//(offsetof(FParticleCurvePair, CurveObject) == 0x000010, "Member 'FParticleCurvePair::CurveObject' has a wrong offset!");

// ScriptStruct Engine.BeamModifierOptions
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FBeamModifierOptions final
{
public:
	uint8                                         bModify : 1;                                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScale : 1;                                        // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLock : 1;                                         // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBeamModifierOptions) == 0x000004, "Wrong alignment on FBeamModifierOptions");
//(sizeof(FBeamModifierOptions) == 0x000004, "Wrong size on FBeamModifierOptions");

// ScriptStruct Engine.LocationBoneSocketInfo
// 0x0028 (0x0028 - 0x0000)
struct FLocationBoneSocketInfo final
{
public:
	class FName                                   BoneSocketName;                                    // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0010(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FLocationBoneSocketInfo) == 0x000008, "Wrong alignment on FLocationBoneSocketInfo");
//(sizeof(FLocationBoneSocketInfo) == 0x000028, "Wrong size on FLocationBoneSocketInfo");
//(offsetof(FLocationBoneSocketInfo, BoneSocketName) == 0x000000, "Member 'FLocationBoneSocketInfo::BoneSocketName' has a wrong offset!");
//(offsetof(FLocationBoneSocketInfo, Offset) == 0x000010, "Member 'FLocationBoneSocketInfo::Offset' has a wrong offset!");

// ScriptStruct Engine.EmitterDynamicParameter
// 0x0048 (0x0048 - 0x0000)
struct FEmitterDynamicParameter final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseEmitterTime : 1;                               // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSpawnTimeOnly : 1;                                // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EEmitterDynamicParameterValue                 ValueMethod;                                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bScaleVelocityByParamValue : 1;                    // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  ParamValue;                                        // 0x0018(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
//(alignof(FEmitterDynamicParameter) == 0x000008, "Wrong alignment on FEmitterDynamicParameter");
//(sizeof(FEmitterDynamicParameter) == 0x000048, "Wrong size on FEmitterDynamicParameter");
//(offsetof(FEmitterDynamicParameter, ParamName) == 0x000000, "Member 'FEmitterDynamicParameter::ParamName' has a wrong offset!");
//(offsetof(FEmitterDynamicParameter, ValueMethod) == 0x000010, "Member 'FEmitterDynamicParameter::ValueMethod' has a wrong offset!");
//(offsetof(FEmitterDynamicParameter, ParamValue) == 0x000018, "Member 'FEmitterDynamicParameter::ParamValue' has a wrong offset!");

// ScriptStruct Engine.LODSoloTrack
// 0x0010 (0x0010 - 0x0000)
struct FLODSoloTrack final
{
public:
	TArray<uint8>                                 SoloEnableSetting;                                 // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
//(alignof(FLODSoloTrack) == 0x000008, "Wrong alignment on FLODSoloTrack");
//(sizeof(FLODSoloTrack) == 0x000010, "Wrong size on FLODSoloTrack");
//(offsetof(FLODSoloTrack, SoloEnableSetting) == 0x000000, "Member 'FLODSoloTrack::SoloEnableSetting' has a wrong offset!");

// ScriptStruct Engine.ParticleSysParam
// 0x00E0 (0x00E0 - 0x0000)
struct alignas(0x10) FParticleSysParam final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleSysParamType                         ParamType;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scalar;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scalar_Low;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector_Low;                                        // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x80];                                      // 0x0060(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FParticleSysParam) == 0x000010, "Wrong alignment on FParticleSysParam");
//(sizeof(FParticleSysParam) == 0x0000E0, "Wrong size on FParticleSysParam");
//(offsetof(FParticleSysParam, Name) == 0x000000, "Member 'FParticleSysParam::Name' has a wrong offset!");
//(offsetof(FParticleSysParam, ParamType) == 0x00000C, "Member 'FParticleSysParam::ParamType' has a wrong offset!");
//(offsetof(FParticleSysParam, Scalar) == 0x000010, "Member 'FParticleSysParam::Scalar' has a wrong offset!");
//(offsetof(FParticleSysParam, Scalar_Low) == 0x000014, "Member 'FParticleSysParam::Scalar_Low' has a wrong offset!");
//(offsetof(FParticleSysParam, Vector) == 0x000018, "Member 'FParticleSysParam::Vector' has a wrong offset!");
//(offsetof(FParticleSysParam, Vector_Low) == 0x000030, "Member 'FParticleSysParam::Vector_Low' has a wrong offset!");
//(offsetof(FParticleSysParam, Color) == 0x000048, "Member 'FParticleSysParam::Color' has a wrong offset!");
//(offsetof(FParticleSysParam, Actor) == 0x000050, "Member 'FParticleSysParam::Actor' has a wrong offset!");
//(offsetof(FParticleSysParam, Material) == 0x000058, "Member 'FParticleSysParam::Material' has a wrong offset!");

// ScriptStruct Engine.DelegateArray
// 0x0010 (0x0010 - 0x0000)
struct FDelegateArray final
{
public:
	TArray<TDelegate<void(struct FPlatformInterfaceDelegateResult& Result)>> Delegates;                                         // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
//(alignof(FDelegateArray) == 0x000008, "Wrong alignment on FDelegateArray");
//(sizeof(FDelegateArray) == 0x000010, "Wrong size on FDelegateArray");
//(offsetof(FDelegateArray, Delegates) == 0x000000, "Member 'FDelegateArray::Delegates' has a wrong offset!");

// ScriptStruct Engine.SpriteCategoryInfo
// 0x0040 (0x0040 - 0x0000)
struct FSpriteCategoryInfo final
{
public:
	class FName                                   Category;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(NativeAccessSpecifierPublic)
};
//(alignof(FSpriteCategoryInfo) == 0x000008, "Wrong alignment on FSpriteCategoryInfo");
//(sizeof(FSpriteCategoryInfo) == 0x000040, "Wrong size on FSpriteCategoryInfo");
//(offsetof(FSpriteCategoryInfo, Category) == 0x000000, "Member 'FSpriteCategoryInfo::Category' has a wrong offset!");
//(offsetof(FSpriteCategoryInfo, DisplayName) == 0x000010, "Member 'FSpriteCategoryInfo::DisplayName' has a wrong offset!");
//(offsetof(FSpriteCategoryInfo, Description) == 0x000028, "Member 'FSpriteCategoryInfo::Description' has a wrong offset!");

// ScriptStruct Engine.LevelNameAndTime
// 0x0018 (0x0018 - 0x0000)
struct FLevelNameAndTime final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        LevelChangeTimeInMS;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLevelNameAndTime) == 0x000008, "Wrong alignment on FLevelNameAndTime");
//(sizeof(FLevelNameAndTime) == 0x000018, "Wrong size on FLevelNameAndTime");
//(offsetof(FLevelNameAndTime, LevelName) == 0x000000, "Member 'FLevelNameAndTime::LevelName' has a wrong offset!");
//(offsetof(FLevelNameAndTime, LevelChangeTimeInMS) == 0x000010, "Member 'FLevelNameAndTime::LevelChangeTimeInMS' has a wrong offset!");

// ScriptStruct Engine.RepConnectionDebugInfo
// 0x0020 (0x0020 - 0x0000)
struct FRepConnectionDebugInfo final
{
public:
	uint32                                        FrameNum;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRepActorDebugInfo>             ActorList;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        FrameCounter;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsServer;                                          // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRepConnectionDebugInfo) == 0x000008, "Wrong alignment on FRepConnectionDebugInfo");
//(sizeof(FRepConnectionDebugInfo) == 0x000020, "Wrong size on FRepConnectionDebugInfo");
//(offsetof(FRepConnectionDebugInfo, FrameNum) == 0x000000, "Member 'FRepConnectionDebugInfo::FrameNum' has a wrong offset!");
//(offsetof(FRepConnectionDebugInfo, ActorList) == 0x000008, "Member 'FRepConnectionDebugInfo::ActorList' has a wrong offset!");
//(offsetof(FRepConnectionDebugInfo, FrameCounter) == 0x000018, "Member 'FRepConnectionDebugInfo::FrameCounter' has a wrong offset!");
//(offsetof(FRepConnectionDebugInfo, IsServer) == 0x00001C, "Member 'FRepConnectionDebugInfo::IsServer' has a wrong offset!");

// ScriptStruct Engine.RepCheckMsg
// 0x0010 (0x0010 - 0x0000)
struct FRepCheckMsg final
{
public:
	TArray<struct FRepCheckRowMsg>                Data;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FRepCheckMsg) == 0x000008, "Wrong alignment on FRepCheckMsg");
//(sizeof(FRepCheckMsg) == 0x000010, "Wrong size on FRepCheckMsg");
//(offsetof(FRepCheckMsg, Data) == 0x000000, "Member 'FRepCheckMsg::Data' has a wrong offset!");

// ScriptStruct Engine.RepCheckClassTotalInfo
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FRepCheckClassTotalInfo final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRepCheckClassTotalInfo) == 0x000008, "Wrong alignment on FRepCheckClassTotalInfo");
//(sizeof(FRepCheckClassTotalInfo) == 0x000050, "Wrong size on FRepCheckClassTotalInfo");

// ScriptStruct Engine.FilmStockSettings
// 0x0014 (0x0014 - 0x0000)
struct FFilmStockSettings final
{
public:
	float                                         Slope;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Toe;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Shoulder;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlackClip;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhiteClip;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FFilmStockSettings) == 0x000004, "Wrong alignment on FFilmStockSettings");
//(sizeof(FFilmStockSettings) == 0x000014, "Wrong size on FFilmStockSettings");
//(offsetof(FFilmStockSettings, Slope) == 0x000000, "Member 'FFilmStockSettings::Slope' has a wrong offset!");
//(offsetof(FFilmStockSettings, Toe) == 0x000004, "Member 'FFilmStockSettings::Toe' has a wrong offset!");
//(offsetof(FFilmStockSettings, Shoulder) == 0x000008, "Member 'FFilmStockSettings::Shoulder' has a wrong offset!");
//(offsetof(FFilmStockSettings, BlackClip) == 0x00000C, "Member 'FFilmStockSettings::BlackClip' has a wrong offset!");
//(offsetof(FFilmStockSettings, WhiteClip) == 0x000010, "Member 'FFilmStockSettings::WhiteClip' has a wrong offset!");

// ScriptStruct Engine.PaintSceneCommand
// 0x0050 (0x0050 - 0x0000)
struct FPaintSceneCommand final
{
public:
	struct FTransform3f                           PaintTransform;                                    // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScenePaintTeamType                           TeamType;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PaintMaterialIndex;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              StartScale;                                        // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPaintSceneCommand) == 0x000010, "Wrong alignment on FPaintSceneCommand");
//(sizeof(FPaintSceneCommand) == 0x000050, "Wrong size on FPaintSceneCommand");
//(offsetof(FPaintSceneCommand, PaintTransform) == 0x000000, "Member 'FPaintSceneCommand::PaintTransform' has a wrong offset!");
//(offsetof(FPaintSceneCommand, TeamType) == 0x000030, "Member 'FPaintSceneCommand::TeamType' has a wrong offset!");
//(offsetof(FPaintSceneCommand, PaintMaterialIndex) == 0x000034, "Member 'FPaintSceneCommand::PaintMaterialIndex' has a wrong offset!");
//(offsetof(FPaintSceneCommand, StartScale) == 0x000038, "Member 'FPaintSceneCommand::StartScale' has a wrong offset!");

// ScriptStruct Engine.MIDPool
// 0x0050 (0x0050 - 0x0000)
struct FMIDPool final
{
public:
	TSet<class UMaterialInstanceDynamic*>         PoolMIDs;                                          // 0x0000(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FMIDPool) == 0x000008, "Wrong alignment on FMIDPool");
//(sizeof(FMIDPool) == 0x000050, "Wrong size on FMIDPool");
//(offsetof(FMIDPool, PoolMIDs) == 0x000000, "Member 'FMIDPool::PoolMIDs' has a wrong offset!");

// ScriptStruct Engine.SimpleMIDPool
// 0x0050 (0x0050 - 0x0000)
struct FSimpleMIDPool final
{
public:
	TMap<class UMaterialInterface*, struct FMIDPool> PoolMIDMap;                                        // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
};
//(alignof(FSimpleMIDPool) == 0x000008, "Wrong alignment on FSimpleMIDPool");
//(sizeof(FSimpleMIDPool) == 0x000050, "Wrong size on FSimpleMIDPool");
//(offsetof(FSimpleMIDPool, PoolMIDMap) == 0x000000, "Member 'FSimpleMIDPool::PoolMIDMap' has a wrong offset!");

// ScriptStruct Engine.SkelMeshComponentLODInfo
// 0x0028 (0x0028 - 0x0000)
struct FSkelMeshComponentLODInfo final
{
public:
	TArray<bool>                                  HiddenMaterials;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkelMeshComponentLODInfo) == 0x000008, "Wrong alignment on FSkelMeshComponentLODInfo");
//(sizeof(FSkelMeshComponentLODInfo) == 0x000028, "Wrong size on FSkelMeshComponentLODInfo");
//(offsetof(FSkelMeshComponentLODInfo, HiddenMaterials) == 0x000000, "Member 'FSkelMeshComponentLODInfo::HiddenMaterials' has a wrong offset!");

// ScriptStruct Engine.PrecomputedSkyLightInstanceData
// 0x00B8 (0x0170 - 0x00B8)
struct alignas(0x10) FPrecomputedSkyLightInstanceData final : public FSceneComponentInstanceData
{
public:
	struct FGuid                                  LightGuid;                                         // 0x00B8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageBrightness;                                 // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0xA4];                                      // 0x00CC(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPrecomputedSkyLightInstanceData) == 0x000010, "Wrong alignment on FPrecomputedSkyLightInstanceData");
//(sizeof(FPrecomputedSkyLightInstanceData) == 0x000170, "Wrong size on FPrecomputedSkyLightInstanceData");
//(offsetof(FPrecomputedSkyLightInstanceData, LightGuid) == 0x0000B8, "Member 'FPrecomputedSkyLightInstanceData::LightGuid' has a wrong offset!");
//(offsetof(FPrecomputedSkyLightInstanceData, AverageBrightness) == 0x0000C8, "Member 'FPrecomputedSkyLightInstanceData::AverageBrightness' has a wrong offset!");

// ScriptStruct Engine.SoundAttenuationPluginSettings
// 0x0040 (0x0040 - 0x0000)
struct FSoundAttenuationPluginSettings final
{
public:
	TArray<class USpatializationPluginSourceSettingsBase*> SpatializationPluginSettingsArray;                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UOcclusionPluginSourceSettingsBase*> OcclusionPluginSettingsArray;                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UReverbPluginSourceSettingsBase*> ReverbPluginSettingsArray;                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class USourceDataOverridePluginSourceSettingsBase*> SourceDataOverridePluginSettingsArray;             // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FSoundAttenuationPluginSettings) == 0x000008, "Wrong alignment on FSoundAttenuationPluginSettings");
//(sizeof(FSoundAttenuationPluginSettings) == 0x000040, "Wrong size on FSoundAttenuationPluginSettings");
//(offsetof(FSoundAttenuationPluginSettings, SpatializationPluginSettingsArray) == 0x000000, "Member 'FSoundAttenuationPluginSettings::SpatializationPluginSettingsArray' has a wrong offset!");
//(offsetof(FSoundAttenuationPluginSettings, OcclusionPluginSettingsArray) == 0x000010, "Member 'FSoundAttenuationPluginSettings::OcclusionPluginSettingsArray' has a wrong offset!");
//(offsetof(FSoundAttenuationPluginSettings, ReverbPluginSettingsArray) == 0x000020, "Member 'FSoundAttenuationPluginSettings::ReverbPluginSettingsArray' has a wrong offset!");
//(offsetof(FSoundAttenuationPluginSettings, SourceDataOverridePluginSettingsArray) == 0x000030, "Member 'FSoundAttenuationPluginSettings::SourceDataOverridePluginSettingsArray' has a wrong offset!");

// ScriptStruct Engine.AttenuationSubmixSendSettings
// 0x00A8 (0x00A8 - 0x0000)
struct FAttenuationSubmixSendSettings final
{
public:
	class USoundSubmixBase*                       Submix;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubmixSendMethod                             SubmixSendMethod;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SubmixSendLevelMin;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubmixSendLevelMax;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubmixSendDistanceMin;                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubmixSendDistanceMax;                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManualSubmixSendLevel;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     CustomSubmixSendCurve;                             // 0x0020(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
//(alignof(FAttenuationSubmixSendSettings) == 0x000008, "Wrong alignment on FAttenuationSubmixSendSettings");
//(sizeof(FAttenuationSubmixSendSettings) == 0x0000A8, "Wrong size on FAttenuationSubmixSendSettings");
//(offsetof(FAttenuationSubmixSendSettings, Submix) == 0x000000, "Member 'FAttenuationSubmixSendSettings::Submix' has a wrong offset!");
//(offsetof(FAttenuationSubmixSendSettings, SubmixSendMethod) == 0x000008, "Member 'FAttenuationSubmixSendSettings::SubmixSendMethod' has a wrong offset!");
//(offsetof(FAttenuationSubmixSendSettings, SubmixSendLevelMin) == 0x00000C, "Member 'FAttenuationSubmixSendSettings::SubmixSendLevelMin' has a wrong offset!");
//(offsetof(FAttenuationSubmixSendSettings, SubmixSendLevelMax) == 0x000010, "Member 'FAttenuationSubmixSendSettings::SubmixSendLevelMax' has a wrong offset!");
//(offsetof(FAttenuationSubmixSendSettings, SubmixSendDistanceMin) == 0x000014, "Member 'FAttenuationSubmixSendSettings::SubmixSendDistanceMin' has a wrong offset!");
//(offsetof(FAttenuationSubmixSendSettings, SubmixSendDistanceMax) == 0x000018, "Member 'FAttenuationSubmixSendSettings::SubmixSendDistanceMax' has a wrong offset!");
//(offsetof(FAttenuationSubmixSendSettings, ManualSubmixSendLevel) == 0x00001C, "Member 'FAttenuationSubmixSendSettings::ManualSubmixSendLevel' has a wrong offset!");
//(offsetof(FAttenuationSubmixSendSettings, CustomSubmixSendCurve) == 0x000020, "Member 'FAttenuationSubmixSendSettings::CustomSubmixSendCurve' has a wrong offset!");

// ScriptStruct Engine.SoundAttenuationSettings
// 0x0310 (0x03D0 - 0x00C0)
struct FSoundAttenuationSettings final : public FBaseAttenuationSettings
{
public:
	uint8                                         bAttenuate : 1;                                    // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSpatialize : 1;                                   // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAttenuateWithLPF : 1;                             // 0x00C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableListenerFocus : 1;                          // 0x00C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableFocusInterpolation : 1;                     // 0x00C0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableOcclusion : 1;                              // 0x00C0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseComplexCollisionForOcclusion : 1;              // 0x00C0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableReverbSend : 1;                             // 0x00C0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnablePriorityAttenuation : 1;                    // 0x00C1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyNormalizationToStereoSounds : 1;             // 0x00C1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableLogFrequencyScaling : 1;                    // 0x00C1(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableSubmixSends : 1;                            // 0x00C1(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableSourceDataOverride : 1;                     // 0x00C1(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableSendToAudioLink : 1;                        // 0x00C1(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ESoundSpatializationAlgorithm                 SpatializationAlgorithm;                           // 0x00C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3[0x5];                                       // 0x00C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioLinkSettingsAbstract*             AudioLinkSettingsOverride;                         // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BinauralRadius;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     CustomLowpassAirAbsorptionCurve;                   // 0x00D8(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     CustomHighpassAirAbsorptionCurve;                  // 0x0160(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EAirAbsorptionMethod                          AbsorptionMethod;                                  // 0x01E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             OcclusionTraceChannel;                             // 0x01E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReverbSendMethod                             ReverbSendMethod;                                  // 0x01EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPriorityAttenuationMethod                    PriorityAttenuationMethod;                         // 0x01EB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonSpatializedRadiusStart;                         // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonSpatializedRadiusEnd;                           // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENonSpatializedRadiusSpeakerMapMode           NonSpatializedRadiusMode;                          // 0x01F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F5[0x3];                                      // 0x01F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StereoSpread;                                      // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPFRadiusMin;                                      // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPFRadiusMax;                                      // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPFFrequencyAtMin;                                 // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPFFrequencyAtMax;                                 // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPFFrequencyAtMin;                                 // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPFFrequencyAtMax;                                 // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusAzimuth;                                      // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusAzimuth;                                   // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusDistanceScale;                                // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusDistanceScale;                             // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusPriorityScale;                                // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusPriorityScale;                             // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusVolumeAttenuation;                            // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusVolumeAttenuation;                         // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusAttackInterpSpeed;                            // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusReleaseInterpSpeed;                           // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionLowPassFilterFrequency;                   // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionVolumeAttenuation;                        // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionInterpolationTime;                        // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReverbWetLevelMin;                                 // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReverbWetLevelMax;                                 // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReverbDistanceMin;                                 // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReverbDistanceMax;                                 // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManualReverbSendLevel;                             // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PriorityAttenuationMin;                            // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PriorityAttenuationMax;                            // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PriorityAttenuationDistanceMin;                    // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PriorityAttenuationDistanceMax;                    // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManualPriorityAttenuation;                         // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     CustomReverbSendCurve;                             // 0x0270(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FAttenuationSubmixSendSettings> SubmixSendSettings;                                // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     CustomPriorityAttenuationCurve;                    // 0x0308(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoundAttenuationPluginSettings        PluginSettings;                                    // 0x0390(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
//(alignof(FSoundAttenuationSettings) == 0x000008, "Wrong alignment on FSoundAttenuationSettings");
//(sizeof(FSoundAttenuationSettings) == 0x0003D0, "Wrong size on FSoundAttenuationSettings");
//(offsetof(FSoundAttenuationSettings, SpatializationAlgorithm) == 0x0000C2, "Member 'FSoundAttenuationSettings::SpatializationAlgorithm' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, AudioLinkSettingsOverride) == 0x0000C8, "Member 'FSoundAttenuationSettings::AudioLinkSettingsOverride' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, BinauralRadius) == 0x0000D0, "Member 'FSoundAttenuationSettings::BinauralRadius' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, CustomLowpassAirAbsorptionCurve) == 0x0000D8, "Member 'FSoundAttenuationSettings::CustomLowpassAirAbsorptionCurve' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, CustomHighpassAirAbsorptionCurve) == 0x000160, "Member 'FSoundAttenuationSettings::CustomHighpassAirAbsorptionCurve' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, AbsorptionMethod) == 0x0001E8, "Member 'FSoundAttenuationSettings::AbsorptionMethod' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, OcclusionTraceChannel) == 0x0001E9, "Member 'FSoundAttenuationSettings::OcclusionTraceChannel' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, ReverbSendMethod) == 0x0001EA, "Member 'FSoundAttenuationSettings::ReverbSendMethod' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, PriorityAttenuationMethod) == 0x0001EB, "Member 'FSoundAttenuationSettings::PriorityAttenuationMethod' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, NonSpatializedRadiusStart) == 0x0001EC, "Member 'FSoundAttenuationSettings::NonSpatializedRadiusStart' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, NonSpatializedRadiusEnd) == 0x0001F0, "Member 'FSoundAttenuationSettings::NonSpatializedRadiusEnd' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, NonSpatializedRadiusMode) == 0x0001F4, "Member 'FSoundAttenuationSettings::NonSpatializedRadiusMode' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, StereoSpread) == 0x0001F8, "Member 'FSoundAttenuationSettings::StereoSpread' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, LPFRadiusMin) == 0x0001FC, "Member 'FSoundAttenuationSettings::LPFRadiusMin' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, LPFRadiusMax) == 0x000200, "Member 'FSoundAttenuationSettings::LPFRadiusMax' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, LPFFrequencyAtMin) == 0x000204, "Member 'FSoundAttenuationSettings::LPFFrequencyAtMin' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, LPFFrequencyAtMax) == 0x000208, "Member 'FSoundAttenuationSettings::LPFFrequencyAtMax' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, HPFFrequencyAtMin) == 0x00020C, "Member 'FSoundAttenuationSettings::HPFFrequencyAtMin' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, HPFFrequencyAtMax) == 0x000210, "Member 'FSoundAttenuationSettings::HPFFrequencyAtMax' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, FocusAzimuth) == 0x000214, "Member 'FSoundAttenuationSettings::FocusAzimuth' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, NonFocusAzimuth) == 0x000218, "Member 'FSoundAttenuationSettings::NonFocusAzimuth' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, FocusDistanceScale) == 0x00021C, "Member 'FSoundAttenuationSettings::FocusDistanceScale' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, NonFocusDistanceScale) == 0x000220, "Member 'FSoundAttenuationSettings::NonFocusDistanceScale' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, FocusPriorityScale) == 0x000224, "Member 'FSoundAttenuationSettings::FocusPriorityScale' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, NonFocusPriorityScale) == 0x000228, "Member 'FSoundAttenuationSettings::NonFocusPriorityScale' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, FocusVolumeAttenuation) == 0x00022C, "Member 'FSoundAttenuationSettings::FocusVolumeAttenuation' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, NonFocusVolumeAttenuation) == 0x000230, "Member 'FSoundAttenuationSettings::NonFocusVolumeAttenuation' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, FocusAttackInterpSpeed) == 0x000234, "Member 'FSoundAttenuationSettings::FocusAttackInterpSpeed' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, FocusReleaseInterpSpeed) == 0x000238, "Member 'FSoundAttenuationSettings::FocusReleaseInterpSpeed' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, OcclusionLowPassFilterFrequency) == 0x00023C, "Member 'FSoundAttenuationSettings::OcclusionLowPassFilterFrequency' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, OcclusionVolumeAttenuation) == 0x000240, "Member 'FSoundAttenuationSettings::OcclusionVolumeAttenuation' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, OcclusionInterpolationTime) == 0x000244, "Member 'FSoundAttenuationSettings::OcclusionInterpolationTime' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, ReverbWetLevelMin) == 0x000248, "Member 'FSoundAttenuationSettings::ReverbWetLevelMin' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, ReverbWetLevelMax) == 0x00024C, "Member 'FSoundAttenuationSettings::ReverbWetLevelMax' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, ReverbDistanceMin) == 0x000250, "Member 'FSoundAttenuationSettings::ReverbDistanceMin' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, ReverbDistanceMax) == 0x000254, "Member 'FSoundAttenuationSettings::ReverbDistanceMax' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, ManualReverbSendLevel) == 0x000258, "Member 'FSoundAttenuationSettings::ManualReverbSendLevel' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, PriorityAttenuationMin) == 0x00025C, "Member 'FSoundAttenuationSettings::PriorityAttenuationMin' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, PriorityAttenuationMax) == 0x000260, "Member 'FSoundAttenuationSettings::PriorityAttenuationMax' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, PriorityAttenuationDistanceMin) == 0x000264, "Member 'FSoundAttenuationSettings::PriorityAttenuationDistanceMin' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, PriorityAttenuationDistanceMax) == 0x000268, "Member 'FSoundAttenuationSettings::PriorityAttenuationDistanceMax' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, ManualPriorityAttenuation) == 0x00026C, "Member 'FSoundAttenuationSettings::ManualPriorityAttenuation' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, CustomReverbSendCurve) == 0x000270, "Member 'FSoundAttenuationSettings::CustomReverbSendCurve' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, SubmixSendSettings) == 0x0002F8, "Member 'FSoundAttenuationSettings::SubmixSendSettings' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, CustomPriorityAttenuationCurve) == 0x000308, "Member 'FSoundAttenuationSettings::CustomPriorityAttenuationCurve' has a wrong offset!");
//(offsetof(FSoundAttenuationSettings, PluginSettings) == 0x000390, "Member 'FSoundAttenuationSettings::PluginSettings' has a wrong offset!");

// ScriptStruct Engine.SoundSourceBusSendInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FSoundSourceBusSendInfo final
{
public:
	ESourceBusSendLevelControlMethod              SourceBusSendLevelControlMethod;                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSourceBus*                        SoundSourceBus;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioBus*                              AudioBus;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendLevel;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSendLevel;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSendLevel;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSendDistance;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSendDistance;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     CustomSendLevelCurve;                              // 0x0030(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
//(alignof(FSoundSourceBusSendInfo) == 0x000008, "Wrong alignment on FSoundSourceBusSendInfo");
//(sizeof(FSoundSourceBusSendInfo) == 0x0000B8, "Wrong size on FSoundSourceBusSendInfo");
//(offsetof(FSoundSourceBusSendInfo, SourceBusSendLevelControlMethod) == 0x000000, "Member 'FSoundSourceBusSendInfo::SourceBusSendLevelControlMethod' has a wrong offset!");
//(offsetof(FSoundSourceBusSendInfo, SoundSourceBus) == 0x000008, "Member 'FSoundSourceBusSendInfo::SoundSourceBus' has a wrong offset!");
//(offsetof(FSoundSourceBusSendInfo, AudioBus) == 0x000010, "Member 'FSoundSourceBusSendInfo::AudioBus' has a wrong offset!");
//(offsetof(FSoundSourceBusSendInfo, SendLevel) == 0x000018, "Member 'FSoundSourceBusSendInfo::SendLevel' has a wrong offset!");
//(offsetof(FSoundSourceBusSendInfo, MinSendLevel) == 0x00001C, "Member 'FSoundSourceBusSendInfo::MinSendLevel' has a wrong offset!");
//(offsetof(FSoundSourceBusSendInfo, MaxSendLevel) == 0x000020, "Member 'FSoundSourceBusSendInfo::MaxSendLevel' has a wrong offset!");
//(offsetof(FSoundSourceBusSendInfo, MinSendDistance) == 0x000024, "Member 'FSoundSourceBusSendInfo::MinSendDistance' has a wrong offset!");
//(offsetof(FSoundSourceBusSendInfo, MaxSendDistance) == 0x000028, "Member 'FSoundSourceBusSendInfo::MaxSendDistance' has a wrong offset!");
//(offsetof(FSoundSourceBusSendInfo, CustomSendLevelCurve) == 0x000030, "Member 'FSoundSourceBusSendInfo::CustomSendLevelCurve' has a wrong offset!");

// ScriptStruct Engine.StreamedAudioPlatformData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FStreamedAudioPlatformData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStreamedAudioPlatformData) == 0x000008, "Wrong alignment on FStreamedAudioPlatformData");
//(sizeof(FStreamedAudioPlatformData) == 0x000020, "Wrong size on FStreamedAudioPlatformData");

// ScriptStruct Engine.SoundWaveEnvelopeTimeData
// 0x0008 (0x0008 - 0x0000)
struct FSoundWaveEnvelopeTimeData final
{
public:
	float                                         Amplitude;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSec;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoundWaveEnvelopeTimeData) == 0x000004, "Wrong alignment on FSoundWaveEnvelopeTimeData");
//(sizeof(FSoundWaveEnvelopeTimeData) == 0x000008, "Wrong size on FSoundWaveEnvelopeTimeData");
//(offsetof(FSoundWaveEnvelopeTimeData, Amplitude) == 0x000000, "Member 'FSoundWaveEnvelopeTimeData::Amplitude' has a wrong offset!");
//(offsetof(FSoundWaveEnvelopeTimeData, TimeSec) == 0x000004, "Member 'FSoundWaveEnvelopeTimeData::TimeSec' has a wrong offset!");

// ScriptStruct Engine.SoundWaveTimecodeInfo
// 0x0070 (0x0070 - 0x0000)
struct FSoundWaveTimecodeInfo final
{
public:
	uint64                                        NumSamplesSinceMidnight;                           // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NumSamplesPerSecond;                               // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OriginatorTime;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OriginatorDate;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OriginatorDescription;                             // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OriginatorReference;                               // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameRate                             TimecodeRate;                                      // 0x0060(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimecodeIsDropFrame;                              // 0x0068(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSoundWaveTimecodeInfo) == 0x000008, "Wrong alignment on FSoundWaveTimecodeInfo");
//(sizeof(FSoundWaveTimecodeInfo) == 0x000070, "Wrong size on FSoundWaveTimecodeInfo");
//(offsetof(FSoundWaveTimecodeInfo, NumSamplesSinceMidnight) == 0x000000, "Member 'FSoundWaveTimecodeInfo::NumSamplesSinceMidnight' has a wrong offset!");
//(offsetof(FSoundWaveTimecodeInfo, NumSamplesPerSecond) == 0x000008, "Member 'FSoundWaveTimecodeInfo::NumSamplesPerSecond' has a wrong offset!");
//(offsetof(FSoundWaveTimecodeInfo, Description) == 0x000010, "Member 'FSoundWaveTimecodeInfo::Description' has a wrong offset!");
//(offsetof(FSoundWaveTimecodeInfo, OriginatorTime) == 0x000020, "Member 'FSoundWaveTimecodeInfo::OriginatorTime' has a wrong offset!");
//(offsetof(FSoundWaveTimecodeInfo, OriginatorDate) == 0x000030, "Member 'FSoundWaveTimecodeInfo::OriginatorDate' has a wrong offset!");
//(offsetof(FSoundWaveTimecodeInfo, OriginatorDescription) == 0x000040, "Member 'FSoundWaveTimecodeInfo::OriginatorDescription' has a wrong offset!");
//(offsetof(FSoundWaveTimecodeInfo, OriginatorReference) == 0x000050, "Member 'FSoundWaveTimecodeInfo::OriginatorReference' has a wrong offset!");
//(offsetof(FSoundWaveTimecodeInfo, TimecodeRate) == 0x000060, "Member 'FSoundWaveTimecodeInfo::TimecodeRate' has a wrong offset!");
//(offsetof(FSoundWaveTimecodeInfo, bTimecodeIsDropFrame) == 0x000068, "Member 'FSoundWaveTimecodeInfo::bTimecodeIsDropFrame' has a wrong offset!");

// ScriptStruct Engine.EquirectProps
// 0x0098 (0x0098 - 0x0000)
struct FEquirectProps final
{
public:
	struct FBox2D                                 LeftUVRect;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox2D                                 RightUVRect;                                       // 0x0028(0x0028)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              LeftScale;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RightScale;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeftBias;                                          // 0x0070(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RightBias;                                         // 0x0080(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0090(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FEquirectProps) == 0x000008, "Wrong alignment on FEquirectProps");
//(sizeof(FEquirectProps) == 0x000098, "Wrong size on FEquirectProps");
//(offsetof(FEquirectProps, LeftUVRect) == 0x000000, "Member 'FEquirectProps::LeftUVRect' has a wrong offset!");
//(offsetof(FEquirectProps, RightUVRect) == 0x000028, "Member 'FEquirectProps::RightUVRect' has a wrong offset!");
//(offsetof(FEquirectProps, LeftScale) == 0x000050, "Member 'FEquirectProps::LeftScale' has a wrong offset!");
//(offsetof(FEquirectProps, RightScale) == 0x000060, "Member 'FEquirectProps::RightScale' has a wrong offset!");
//(offsetof(FEquirectProps, LeftBias) == 0x000070, "Member 'FEquirectProps::LeftBias' has a wrong offset!");
//(offsetof(FEquirectProps, RightBias) == 0x000080, "Member 'FEquirectProps::RightBias' has a wrong offset!");
//(offsetof(FEquirectProps, Radius) == 0x000090, "Member 'FEquirectProps::Radius' has a wrong offset!");

// ScriptStruct Engine.StreamingTextureBuildInfo
// 0x000C (0x000C - 0x0000)
struct FStreamingTextureBuildInfo final
{
public:
	uint32                                        PackedRelativeBox;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureLevelIndex;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TexelFactor;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FStreamingTextureBuildInfo) == 0x000004, "Wrong alignment on FStreamingTextureBuildInfo");
//(sizeof(FStreamingTextureBuildInfo) == 0x00000C, "Wrong size on FStreamingTextureBuildInfo");
//(offsetof(FStreamingTextureBuildInfo, PackedRelativeBox) == 0x000000, "Member 'FStreamingTextureBuildInfo::PackedRelativeBox' has a wrong offset!");
//(offsetof(FStreamingTextureBuildInfo, TextureLevelIndex) == 0x000004, "Member 'FStreamingTextureBuildInfo::TextureLevelIndex' has a wrong offset!");
//(offsetof(FStreamingTextureBuildInfo, TexelFactor) == 0x000008, "Member 'FStreamingTextureBuildInfo::TexelFactor' has a wrong offset!");

// ScriptStruct Engine.TimelineNotifyContext
// 0x0018 (0x0018 - 0x0000)
struct FTimelineNotifyContext final
{
public:
	class UAnimTimeline*                          Timeline;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Owner;                                             // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTimelineNotifyContext) == 0x000008, "Wrong alignment on FTimelineNotifyContext");
//(sizeof(FTimelineNotifyContext) == 0x000018, "Wrong size on FTimelineNotifyContext");
//(offsetof(FTimelineNotifyContext, Timeline) == 0x000000, "Member 'FTimelineNotifyContext::Timeline' has a wrong offset!");
//(offsetof(FTimelineNotifyContext, Owner) == 0x000008, "Member 'FTimelineNotifyContext::Owner' has a wrong offset!");

// ScriptStruct Engine.LightmassWorldInfoSettings
// 0x004C (0x004C - 0x0000)
struct FLightmassWorldInfoSettings final
{
public:
	float                                         StaticLightingLevelScale;                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumIndirectLightingBounces;                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSkyLightingBounces;                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndirectLightingQuality;                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndirectLightingSmoothness;                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 EnvironmentColor;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnvironmentIntensity;                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveBoost;                                     // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiffuseBoost;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVolumeLightingMethod                         VolumeLightingMethod;                              // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseAmbientOcclusion : 1;                          // 0x0025(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateAmbientOcclusionMaterialMask : 1;         // 0x0025(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVisualizeMaterialDiffuse : 1;                     // 0x0025(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVisualizeAmbientOcclusion : 1;                    // 0x0025(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCompressLightmaps : 1;                            // 0x0025(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumetricLightmapDetailCellSize;                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricLightmapMaximumBrickMemoryMb;            // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricLightmapSphericalHarmonicSmoothing;      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeLightSamplePlacementScale;                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectIlluminationOcclusionFraction;               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndirectIlluminationOcclusionFraction;             // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionExponent;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullyOccludedSamplesFraction;                      // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOcclusionDistance;                              // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FLightmassWorldInfoSettings) == 0x000004, "Wrong alignment on FLightmassWorldInfoSettings");
//(sizeof(FLightmassWorldInfoSettings) == 0x00004C, "Wrong size on FLightmassWorldInfoSettings");
//(offsetof(FLightmassWorldInfoSettings, StaticLightingLevelScale) == 0x000000, "Member 'FLightmassWorldInfoSettings::StaticLightingLevelScale' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, NumIndirectLightingBounces) == 0x000004, "Member 'FLightmassWorldInfoSettings::NumIndirectLightingBounces' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, NumSkyLightingBounces) == 0x000008, "Member 'FLightmassWorldInfoSettings::NumSkyLightingBounces' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, IndirectLightingQuality) == 0x00000C, "Member 'FLightmassWorldInfoSettings::IndirectLightingQuality' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, IndirectLightingSmoothness) == 0x000010, "Member 'FLightmassWorldInfoSettings::IndirectLightingSmoothness' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, EnvironmentColor) == 0x000014, "Member 'FLightmassWorldInfoSettings::EnvironmentColor' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, EnvironmentIntensity) == 0x000018, "Member 'FLightmassWorldInfoSettings::EnvironmentIntensity' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, EmissiveBoost) == 0x00001C, "Member 'FLightmassWorldInfoSettings::EmissiveBoost' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, DiffuseBoost) == 0x000020, "Member 'FLightmassWorldInfoSettings::DiffuseBoost' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, VolumeLightingMethod) == 0x000024, "Member 'FLightmassWorldInfoSettings::VolumeLightingMethod' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, VolumetricLightmapDetailCellSize) == 0x000028, "Member 'FLightmassWorldInfoSettings::VolumetricLightmapDetailCellSize' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, VolumetricLightmapMaximumBrickMemoryMb) == 0x00002C, "Member 'FLightmassWorldInfoSettings::VolumetricLightmapMaximumBrickMemoryMb' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, VolumetricLightmapSphericalHarmonicSmoothing) == 0x000030, "Member 'FLightmassWorldInfoSettings::VolumetricLightmapSphericalHarmonicSmoothing' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, VolumeLightSamplePlacementScale) == 0x000034, "Member 'FLightmassWorldInfoSettings::VolumeLightSamplePlacementScale' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, DirectIlluminationOcclusionFraction) == 0x000038, "Member 'FLightmassWorldInfoSettings::DirectIlluminationOcclusionFraction' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, IndirectIlluminationOcclusionFraction) == 0x00003C, "Member 'FLightmassWorldInfoSettings::IndirectIlluminationOcclusionFraction' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, OcclusionExponent) == 0x000040, "Member 'FLightmassWorldInfoSettings::OcclusionExponent' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, FullyOccludedSamplesFraction) == 0x000044, "Member 'FLightmassWorldInfoSettings::FullyOccludedSamplesFraction' has a wrong offset!");
//(offsetof(FLightmassWorldInfoSettings, MaxOcclusionDistance) == 0x000048, "Member 'FLightmassWorldInfoSettings::MaxOcclusionDistance' has a wrong offset!");

// ScriptStruct Engine.HierarchicalSimplification
// 0x0350 (0x0350 - 0x0000)
struct FHierarchicalSimplification final
{
public:
	float                                         TransitionScreenSize;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideDrawDistance;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseOverrideDrawDistance : 1;                      // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowSpecificExclusion : 1;                       // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlyGenerateClustersForVolumes : 1;               // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReusePreviousLevelClusters : 1;                   // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EHierarchicalSimplificationMethod             SimplificationMethod;                              // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeshProxySettings                     ProxySetting;                                      // 0x0010(0x0100)(Edit, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FMeshMergingSettings                   MergeSetting;                                      // 0x0110(0x0108)(Edit, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FMeshApproximationSettings             ApproximateSettings;                               // 0x0218(0x0128)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         DesiredBoundRadius;                                // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredFillingPercentage;                          // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinNumberOfActorsToBuild;                          // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FHierarchicalSimplification) == 0x000008, "Wrong alignment on FHierarchicalSimplification");
//(sizeof(FHierarchicalSimplification) == 0x000350, "Wrong size on FHierarchicalSimplification");
//(offsetof(FHierarchicalSimplification, TransitionScreenSize) == 0x000000, "Member 'FHierarchicalSimplification::TransitionScreenSize' has a wrong offset!");
//(offsetof(FHierarchicalSimplification, OverrideDrawDistance) == 0x000004, "Member 'FHierarchicalSimplification::OverrideDrawDistance' has a wrong offset!");
//(offsetof(FHierarchicalSimplification, SimplificationMethod) == 0x000009, "Member 'FHierarchicalSimplification::SimplificationMethod' has a wrong offset!");
//(offsetof(FHierarchicalSimplification, ProxySetting) == 0x000010, "Member 'FHierarchicalSimplification::ProxySetting' has a wrong offset!");
//(offsetof(FHierarchicalSimplification, MergeSetting) == 0x000110, "Member 'FHierarchicalSimplification::MergeSetting' has a wrong offset!");
//(offsetof(FHierarchicalSimplification, ApproximateSettings) == 0x000218, "Member 'FHierarchicalSimplification::ApproximateSettings' has a wrong offset!");
//(offsetof(FHierarchicalSimplification, DesiredBoundRadius) == 0x000340, "Member 'FHierarchicalSimplification::DesiredBoundRadius' has a wrong offset!");
//(offsetof(FHierarchicalSimplification, DesiredFillingPercentage) == 0x000344, "Member 'FHierarchicalSimplification::DesiredFillingPercentage' has a wrong offset!");
//(offsetof(FHierarchicalSimplification, MinNumberOfActorsToBuild) == 0x000348, "Member 'FHierarchicalSimplification::MinNumberOfActorsToBuild' has a wrong offset!");

// ScriptStruct Engine.NaniteSettings
// 0x0001 (0x0001 - 0x0000)
struct FNaniteSettings final
{
public:
	bool                                          bAllowMaskedMaterials;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNaniteSettings) == 0x000001, "Wrong alignment on FNaniteSettings");
//(sizeof(FNaniteSettings) == 0x000001, "Wrong size on FNaniteSettings");
//(offsetof(FNaniteSettings, bAllowMaskedMaterials) == 0x000000, "Member 'FNaniteSettings::bAllowMaskedMaterials' has a wrong offset!");

// ScriptStruct Engine.BroadphaseSettings
// 0x0080 (0x0080 - 0x0000)
struct FBroadphaseSettings final
{
public:
	bool                                          bUseMBPOnClient;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMBPOnServer;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMBPOuterBounds;                                // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   MBPBounds;                                         // 0x0008(0x0038)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   MBPOuterBounds;                                    // 0x0040(0x0038)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint32                                        MBPNumSubdivs;                                     // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOutOfBoundsWarning;                         // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBroadphaseSettings) == 0x000008, "Wrong alignment on FBroadphaseSettings");
//(sizeof(FBroadphaseSettings) == 0x000080, "Wrong size on FBroadphaseSettings");
//(offsetof(FBroadphaseSettings, bUseMBPOnClient) == 0x000000, "Member 'FBroadphaseSettings::bUseMBPOnClient' has a wrong offset!");
//(offsetof(FBroadphaseSettings, bUseMBPOnServer) == 0x000001, "Member 'FBroadphaseSettings::bUseMBPOnServer' has a wrong offset!");
//(offsetof(FBroadphaseSettings, bUseMBPOuterBounds) == 0x000002, "Member 'FBroadphaseSettings::bUseMBPOuterBounds' has a wrong offset!");
//(offsetof(FBroadphaseSettings, MBPBounds) == 0x000008, "Member 'FBroadphaseSettings::MBPBounds' has a wrong offset!");
//(offsetof(FBroadphaseSettings, MBPOuterBounds) == 0x000040, "Member 'FBroadphaseSettings::MBPOuterBounds' has a wrong offset!");
//(offsetof(FBroadphaseSettings, MBPNumSubdivs) == 0x000078, "Member 'FBroadphaseSettings::MBPNumSubdivs' has a wrong offset!");
//(offsetof(FBroadphaseSettings, bIgnoreOutOfBoundsWarning) == 0x00007C, "Member 'FBroadphaseSettings::bIgnoreOutOfBoundsWarning' has a wrong offset!");

// ScriptStruct Engine.QuartzClockSettings
// 0x0020 (0x0020 - 0x0000)
struct FQuartzClockSettings final
{
public:
	struct FQuartzTimeSignature                   TimeSignature;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIgnoreLevelChange;                                // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FQuartzClockSettings) == 0x000008, "Wrong alignment on FQuartzClockSettings");
//(sizeof(FQuartzClockSettings) == 0x000020, "Wrong size on FQuartzClockSettings");
//(offsetof(FQuartzClockSettings, TimeSignature) == 0x000000, "Member 'FQuartzClockSettings::TimeSignature' has a wrong offset!");
//(offsetof(FQuartzClockSettings, bIgnoreLevelChange) == 0x000018, "Member 'FQuartzClockSettings::bIgnoreLevelChange' has a wrong offset!");

// ScriptStruct Engine.NavAvoidanceData
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FNavAvoidanceData final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FNavAvoidanceData) == 0x000008, "Wrong alignment on FNavAvoidanceData");
//(sizeof(FNavAvoidanceData) == 0x000058, "Wrong size on FNavAvoidanceData");

// ScriptStruct Engine.NavLinkAuxiliaryId
// 0x0008 (0x0008 - 0x0000)
struct FNavLinkAuxiliaryId final
{
public:
	uint64                                        ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FNavLinkAuxiliaryId) == 0x000008, "Wrong alignment on FNavLinkAuxiliaryId");
//(sizeof(FNavLinkAuxiliaryId) == 0x000008, "Wrong size on FNavLinkAuxiliaryId");
//(offsetof(FNavLinkAuxiliaryId, ID) == 0x000000, "Member 'FNavLinkAuxiliaryId::ID' has a wrong offset!");

// ScriptStruct Engine.TileCustomGeneralConfig
// 0x0006 (0x0006 - 0x0000)
struct FTileCustomGeneralConfig final
{
public:
	uint16                                        AgentRadius;                                       // 0x0000(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        AgentHeight;                                       // 0x0002(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSkipFilterLowHangingWalkableObstacle : 1;         // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkipFilterLedgeSpans : 1;                         // 0x0004(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMarkLowHeightAreas : 1;                           // 0x0004(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x1];                                        // 0x0005(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTileCustomGeneralConfig) == 0x000002, "Wrong alignment on FTileCustomGeneralConfig");
//(sizeof(FTileCustomGeneralConfig) == 0x000006, "Wrong size on FTileCustomGeneralConfig");
//(offsetof(FTileCustomGeneralConfig, AgentRadius) == 0x000000, "Member 'FTileCustomGeneralConfig::AgentRadius' has a wrong offset!");
//(offsetof(FTileCustomGeneralConfig, AgentHeight) == 0x000002, "Member 'FTileCustomGeneralConfig::AgentHeight' has a wrong offset!");

// ScriptStruct Engine.BlendFilter
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBlendFilter final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBlendFilter) == 0x000008, "Wrong alignment on FBlendFilter");
//(sizeof(FBlendFilter) == 0x000010, "Wrong size on FBlendFilter");

// ScriptStruct Engine.MarkerSyncAnimPosition
// 0x001C (0x001C - 0x0000)
struct FMarkerSyncAnimPosition final
{
public:
	class FName                                   PreviousMarkerName;                                // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextMarkerName;                                    // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionBetweenMarkers;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMarkerSyncAnimPosition) == 0x000004, "Wrong alignment on FMarkerSyncAnimPosition");
//(sizeof(FMarkerSyncAnimPosition) == 0x00001C, "Wrong size on FMarkerSyncAnimPosition");
//(offsetof(FMarkerSyncAnimPosition, PreviousMarkerName) == 0x000000, "Member 'FMarkerSyncAnimPosition::PreviousMarkerName' has a wrong offset!");
//(offsetof(FMarkerSyncAnimPosition, NextMarkerName) == 0x00000C, "Member 'FMarkerSyncAnimPosition::NextMarkerName' has a wrong offset!");
//(offsetof(FMarkerSyncAnimPosition, PositionBetweenMarkers) == 0x000018, "Member 'FMarkerSyncAnimPosition::PositionBetweenMarkers' has a wrong offset!");

// ScriptStruct Engine.AnimTickRecord
// 0x0070 (0x0070 - 0x0000)
struct FAnimTickRecord final
{
public:
	class UAnimationAsset*                        SourceAsset;                                       // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x68];                                       // 0x0008(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimTickRecord) == 0x000008, "Wrong alignment on FAnimTickRecord");
//(sizeof(FAnimTickRecord) == 0x000070, "Wrong size on FAnimTickRecord");
//(offsetof(FAnimTickRecord, SourceAsset) == 0x000000, "Member 'FAnimTickRecord::SourceAsset' has a wrong offset!");

// ScriptStruct Engine.AnimationGroupReference
// 0x0014 (0x0014 - 0x0000)
struct FAnimationGroupReference final
{
public:
	EAnimSyncMethod                               Method;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GroupName;                                         // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimGroupRole                                GroupRole;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimationGroupReference) == 0x000004, "Wrong alignment on FAnimationGroupReference");
//(sizeof(FAnimationGroupReference) == 0x000014, "Wrong size on FAnimationGroupReference");
//(offsetof(FAnimationGroupReference, Method) == 0x000000, "Member 'FAnimationGroupReference::Method' has a wrong offset!");
//(offsetof(FAnimationGroupReference, GroupName) == 0x000004, "Member 'FAnimationGroupReference::GroupName' has a wrong offset!");
//(offsetof(FAnimationGroupReference, GroupRole) == 0x000010, "Member 'FAnimationGroupReference::GroupRole' has a wrong offset!");

// ScriptStruct Engine.AnimationRecordingSettings
// 0x0040 (0x0040 - 0x0000)
struct FAnimationRecordingSettings final
{
public:
	bool                                          bRecordInWorldSpace;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveRootAnimation;                              // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSaveAsset;                                    // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFrameRate                             SampleFrameRate;                                   // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimInterpolationType                        Interpolation;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveInterpMode                          InterpMode;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveTangentMode                         TangentMode;                                       // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRecordTransforms;                                 // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordMorphTargets;                               // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordAttributeCurves;                            // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordMaterialCurves;                             // 0x0017(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransactRecording;                                // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         IncludeAnimationNames;                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExcludeAnimationNames;                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FAnimationRecordingSettings) == 0x000008, "Wrong alignment on FAnimationRecordingSettings");
//(sizeof(FAnimationRecordingSettings) == 0x000040, "Wrong size on FAnimationRecordingSettings");
//(offsetof(FAnimationRecordingSettings, bRecordInWorldSpace) == 0x000000, "Member 'FAnimationRecordingSettings::bRecordInWorldSpace' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, bRemoveRootAnimation) == 0x000001, "Member 'FAnimationRecordingSettings::bRemoveRootAnimation' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, bAutoSaveAsset) == 0x000002, "Member 'FAnimationRecordingSettings::bAutoSaveAsset' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, SampleFrameRate) == 0x000004, "Member 'FAnimationRecordingSettings::SampleFrameRate' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, Length) == 0x00000C, "Member 'FAnimationRecordingSettings::Length' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, Interpolation) == 0x000010, "Member 'FAnimationRecordingSettings::Interpolation' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, InterpMode) == 0x000011, "Member 'FAnimationRecordingSettings::InterpMode' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, TangentMode) == 0x000012, "Member 'FAnimationRecordingSettings::TangentMode' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, bRecordTransforms) == 0x000014, "Member 'FAnimationRecordingSettings::bRecordTransforms' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, bRecordMorphTargets) == 0x000015, "Member 'FAnimationRecordingSettings::bRecordMorphTargets' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, bRecordAttributeCurves) == 0x000016, "Member 'FAnimationRecordingSettings::bRecordAttributeCurves' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, bRecordMaterialCurves) == 0x000017, "Member 'FAnimationRecordingSettings::bRecordMaterialCurves' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, bTransactRecording) == 0x000018, "Member 'FAnimationRecordingSettings::bTransactRecording' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, IncludeAnimationNames) == 0x000020, "Member 'FAnimationRecordingSettings::IncludeAnimationNames' has a wrong offset!");
//(offsetof(FAnimationRecordingSettings, ExcludeAnimationNames) == 0x000030, "Member 'FAnimationRecordingSettings::ExcludeAnimationNames' has a wrong offset!");

// ScriptStruct Engine.StateMachineDebugData
// 0x0150 (0x0150 - 0x0000)
struct alignas(0x08) FStateMachineDebugData final
{
public:
	uint8                                         Pad_0[0x150];                                      // 0x0000(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStateMachineDebugData) == 0x000008, "Wrong alignment on FStateMachineDebugData");
//(sizeof(FStateMachineDebugData) == 0x000150, "Wrong size on FStateMachineDebugData");

// ScriptStruct Engine.AnimBlueprintDebugData
// 0x0001 (0x0001 - 0x0000)
struct FAnimBlueprintDebugData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimBlueprintDebugData) == 0x000001, "Wrong alignment on FAnimBlueprintDebugData");
//(sizeof(FAnimBlueprintDebugData) == 0x000001, "Wrong size on FAnimBlueprintDebugData");

// ScriptStruct Engine.AnimBlueprintMutableData
// 0x0001 (0x0001 - 0x0000)
struct FAnimBlueprintMutableData
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimBlueprintMutableData) == 0x000001, "Wrong alignment on FAnimBlueprintMutableData");
//(sizeof(FAnimBlueprintMutableData) == 0x000001, "Wrong size on FAnimBlueprintMutableData");

// ScriptStruct Engine.AnimBlueprintConstantData
// 0x0001 (0x0001 - 0x0000)
struct FAnimBlueprintConstantData
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimBlueprintConstantData) == 0x000001, "Wrong alignment on FAnimBlueprintConstantData");
//(sizeof(FAnimBlueprintConstantData) == 0x000001, "Wrong size on FAnimBlueprintConstantData");

// ScriptStruct Engine.AnimBlueprintFunctionData
// 0x0040 (0x0040 - 0x0000)
struct FAnimBlueprintFunctionData final
{
public:
	TFieldPath<struct FStructProperty>            OutputPoseNodeProperty;                            // 0x0000(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TFieldPath<struct FStructProperty>>    InputPoseNodeProperties;                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TFieldPath<struct FProperty>>          InputProperties;                                   // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FAnimBlueprintFunctionData) == 0x000008, "Wrong alignment on FAnimBlueprintFunctionData");
//(sizeof(FAnimBlueprintFunctionData) == 0x000040, "Wrong size on FAnimBlueprintFunctionData");
//(offsetof(FAnimBlueprintFunctionData, OutputPoseNodeProperty) == 0x000000, "Member 'FAnimBlueprintFunctionData::OutputPoseNodeProperty' has a wrong offset!");
//(offsetof(FAnimBlueprintFunctionData, InputPoseNodeProperties) == 0x000020, "Member 'FAnimBlueprintFunctionData::InputPoseNodeProperties' has a wrong offset!");
//(offsetof(FAnimBlueprintFunctionData, InputProperties) == 0x000030, "Member 'FAnimBlueprintFunctionData::InputProperties' has a wrong offset!");

// ScriptStruct Engine.AnimGraphBlendOptions
// 0x0020 (0x0020 - 0x0000)
struct FAnimGraphBlendOptions final
{
public:
	float                                         BlendInTime;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendProfile*                          BlendInProfile;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendProfile*                          BlendOutProfile;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimGraphBlendOptions) == 0x000008, "Wrong alignment on FAnimGraphBlendOptions");
//(sizeof(FAnimGraphBlendOptions) == 0x000020, "Wrong size on FAnimGraphBlendOptions");
//(offsetof(FAnimGraphBlendOptions, BlendInTime) == 0x000000, "Member 'FAnimGraphBlendOptions::BlendInTime' has a wrong offset!");
//(offsetof(FAnimGraphBlendOptions, BlendInProfile) == 0x000008, "Member 'FAnimGraphBlendOptions::BlendInProfile' has a wrong offset!");
//(offsetof(FAnimGraphBlendOptions, BlendOutTime) == 0x000010, "Member 'FAnimGraphBlendOptions::BlendOutTime' has a wrong offset!");
//(offsetof(FAnimGraphBlendOptions, BlendOutProfile) == 0x000018, "Member 'FAnimGraphBlendOptions::BlendOutProfile' has a wrong offset!");

// ScriptStruct Engine.AnimSegment
// 0x0020 (0x0020 - 0x0000)
struct FAnimSegment final
{
public:
	class UAnimSequenceBase*                      AnimReference;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPos;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimStartTime;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimEndTime;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimPlayRate;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopingCount;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimSegment) == 0x000008, "Wrong alignment on FAnimSegment");
//(sizeof(FAnimSegment) == 0x000020, "Wrong size on FAnimSegment");
//(offsetof(FAnimSegment, AnimReference) == 0x000000, "Member 'FAnimSegment::AnimReference' has a wrong offset!");
//(offsetof(FAnimSegment, StartPos) == 0x000008, "Member 'FAnimSegment::StartPos' has a wrong offset!");
//(offsetof(FAnimSegment, AnimStartTime) == 0x00000C, "Member 'FAnimSegment::AnimStartTime' has a wrong offset!");
//(offsetof(FAnimSegment, AnimEndTime) == 0x000010, "Member 'FAnimSegment::AnimEndTime' has a wrong offset!");
//(offsetof(FAnimSegment, AnimPlayRate) == 0x000014, "Member 'FAnimSegment::AnimPlayRate' has a wrong offset!");
//(offsetof(FAnimSegment, LoopingCount) == 0x000018, "Member 'FAnimSegment::LoopingCount' has a wrong offset!");

// ScriptStruct Engine.AnimTrack
// 0x0010 (0x0010 - 0x0000)
struct FAnimTrack final
{
public:
	TArray<struct FAnimSegment>                   AnimSegments;                                      // 0x0000(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FAnimTrack) == 0x000008, "Wrong alignment on FAnimTrack");
//(sizeof(FAnimTrack) == 0x000010, "Wrong size on FAnimTrack");
//(offsetof(FAnimTrack, AnimSegments) == 0x000000, "Member 'FAnimTrack::AnimSegments' has a wrong offset!");

// ScriptStruct Engine.AnimInitializationContext
// 0x0000 (0x0010 - 0x0010)
struct FAnimInitializationContext final : public FAnimExecutionContext
{
};
//(alignof(FAnimInitializationContext) == 0x000008, "Wrong alignment on FAnimInitializationContext");
//(sizeof(FAnimInitializationContext) == 0x000010, "Wrong size on FAnimInitializationContext");

// ScriptStruct Engine.AnimComponentSpacePoseContext
// 0x0000 (0x0010 - 0x0010)
struct FAnimComponentSpacePoseContext final : public FAnimExecutionContext
{
};
//(alignof(FAnimComponentSpacePoseContext) == 0x000008, "Wrong alignment on FAnimComponentSpacePoseContext");
//(sizeof(FAnimComponentSpacePoseContext) == 0x000010, "Wrong size on FAnimComponentSpacePoseContext");

// ScriptStruct Engine.A2CSPose
// 0x0018 (0x0028 - 0x0010)
struct FA2CSPose final : public FA2Pose
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ComponentSpaceFlags;                               // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
//(alignof(FA2CSPose) == 0x000008, "Wrong alignment on FA2CSPose");
//(sizeof(FA2CSPose) == 0x000028, "Wrong size on FA2CSPose");
//(offsetof(FA2CSPose, ComponentSpaceFlags) == 0x000018, "Member 'FA2CSPose::ComponentSpaceFlags' has a wrong offset!");

// ScriptStruct Engine.AnimProxyCache
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAnimProxyCache final : public FAniNodeCacheBase
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimProxyCache) == 0x000008, "Wrong alignment on FAnimProxyCache");
//(sizeof(FAnimProxyCache) == 0x000018, "Wrong size on FAnimProxyCache");

// ScriptStruct Engine.SlotAnimationTrack
// 0x0020 (0x0020 - 0x0000)
struct FSlotAnimationTrack final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimTrack                             AnimTrack;                                         // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
};
//(alignof(FSlotAnimationTrack) == 0x000008, "Wrong alignment on FSlotAnimationTrack");
//(sizeof(FSlotAnimationTrack) == 0x000020, "Wrong size on FSlotAnimationTrack");
//(offsetof(FSlotAnimationTrack, SlotName) == 0x000000, "Member 'FSlotAnimationTrack::SlotName' has a wrong offset!");
//(offsetof(FSlotAnimationTrack, AnimTrack) == 0x000010, "Member 'FSlotAnimationTrack::AnimTrack' has a wrong offset!");

// ScriptStruct Engine.BranchingPoint
// 0x0010 (0x0040 - 0x0030)
struct FBranchingPoint final : public FAnimLinkableElement
{
public:
	class FName                                   EventName;                                         // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTimeOffset;                                 // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBranchingPoint) == 0x000008, "Wrong alignment on FBranchingPoint");
//(sizeof(FBranchingPoint) == 0x000040, "Wrong size on FBranchingPoint");
//(offsetof(FBranchingPoint, EventName) == 0x000030, "Member 'FBranchingPoint::EventName' has a wrong offset!");
//(offsetof(FBranchingPoint, TriggerTimeOffset) == 0x00003C, "Member 'FBranchingPoint::TriggerTimeOffset' has a wrong offset!");

// ScriptStruct Engine.BranchingPointMarker
// 0x000C (0x000C - 0x0000)
struct FBranchingPointMarker final
{
public:
	int32                                         NotifyIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTime;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimNotifyEventType                          NotifyEventType;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBranchingPointMarker) == 0x000004, "Wrong alignment on FBranchingPointMarker");
//(sizeof(FBranchingPointMarker) == 0x00000C, "Wrong size on FBranchingPointMarker");
//(offsetof(FBranchingPointMarker, NotifyIndex) == 0x000000, "Member 'FBranchingPointMarker::NotifyIndex' has a wrong offset!");
//(offsetof(FBranchingPointMarker, TriggerTime) == 0x000004, "Member 'FBranchingPointMarker::TriggerTime' has a wrong offset!");
//(offsetof(FBranchingPointMarker, NotifyEventType) == 0x000008, "Member 'FBranchingPointMarker::NotifyEventType' has a wrong offset!");

// ScriptStruct Engine.MontageBlendSettings
// 0x0020 (0x0020 - 0x0000)
struct FMontageBlendSettings final
{
public:
	class UBlendProfile*                          BlendProfile;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAlphaBlendArgs                        Blend;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EMontageBlendMode                             BlendMode;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMontageBlendSettings) == 0x000008, "Wrong alignment on FMontageBlendSettings");
//(sizeof(FMontageBlendSettings) == 0x000020, "Wrong size on FMontageBlendSettings");
//(offsetof(FMontageBlendSettings, BlendProfile) == 0x000000, "Member 'FMontageBlendSettings::BlendProfile' has a wrong offset!");
//(offsetof(FMontageBlendSettings, Blend) == 0x000008, "Member 'FMontageBlendSettings::Blend' has a wrong offset!");
//(offsetof(FMontageBlendSettings, BlendMode) == 0x000018, "Member 'FMontageBlendSettings::BlendMode' has a wrong offset!");

// ScriptStruct Engine.AnimMontageInstance
// 0x0220 (0x0220 - 0x0000)
struct FAnimMontageInstance final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x38];                                       // 0x0008(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlaying;                                          // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultBlendTimeMultiplier;                        // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x100];                                     // 0x0048(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NextSections;                                      // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 PrevSections;                                      // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimNotifyEvent>               ActiveStateBranchingPoints;                        // 0x0178(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         Position;                                          // 0x0188(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayRate;                                          // 0x018C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAlphaBlend                            Blend;                                             // 0x0190(0x0030)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x3C];                                     // 0x01C0(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DisableRootMotionCount;                            // 0x01FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x20];                                     // 0x0200(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimMontageInstance) == 0x000008, "Wrong alignment on FAnimMontageInstance");
//(sizeof(FAnimMontageInstance) == 0x000220, "Wrong size on FAnimMontageInstance");
//(offsetof(FAnimMontageInstance, Montage) == 0x000000, "Member 'FAnimMontageInstance::Montage' has a wrong offset!");
//(offsetof(FAnimMontageInstance, bPlaying) == 0x000040, "Member 'FAnimMontageInstance::bPlaying' has a wrong offset!");
//(offsetof(FAnimMontageInstance, DefaultBlendTimeMultiplier) == 0x000044, "Member 'FAnimMontageInstance::DefaultBlendTimeMultiplier' has a wrong offset!");
//(offsetof(FAnimMontageInstance, NextSections) == 0x000148, "Member 'FAnimMontageInstance::NextSections' has a wrong offset!");
//(offsetof(FAnimMontageInstance, PrevSections) == 0x000158, "Member 'FAnimMontageInstance::PrevSections' has a wrong offset!");
//(offsetof(FAnimMontageInstance, ActiveStateBranchingPoints) == 0x000178, "Member 'FAnimMontageInstance::ActiveStateBranchingPoints' has a wrong offset!");
//(offsetof(FAnimMontageInstance, Position) == 0x000188, "Member 'FAnimMontageInstance::Position' has a wrong offset!");
//(offsetof(FAnimMontageInstance, PlayRate) == 0x00018C, "Member 'FAnimMontageInstance::PlayRate' has a wrong offset!");
//(offsetof(FAnimMontageInstance, Blend) == 0x000190, "Member 'FAnimMontageInstance::Blend' has a wrong offset!");
//(offsetof(FAnimMontageInstance, DisableRootMotionCount) == 0x0001FC, "Member 'FAnimMontageInstance::DisableRootMotionCount' has a wrong offset!");

// ScriptStruct Engine.AnimNodeData
// 0x0028 (0x0028 - 0x0000)
struct FAnimNodeData final
{
public:
	TScriptInterface<class IAnimClassInterface>   AnimClassInterface;                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<uint32>                                Entries;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         NodeIndex;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        Flags;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FAnimNodeData) == 0x000008, "Wrong alignment on FAnimNodeData");
//(sizeof(FAnimNodeData) == 0x000028, "Wrong size on FAnimNodeData");
//(offsetof(FAnimNodeData, AnimClassInterface) == 0x000000, "Member 'FAnimNodeData::AnimClassInterface' has a wrong offset!");
//(offsetof(FAnimNodeData, Entries) == 0x000010, "Member 'FAnimNodeData::Entries' has a wrong offset!");
//(offsetof(FAnimNodeData, NodeIndex) == 0x000020, "Member 'FAnimNodeData::NodeIndex' has a wrong offset!");
//(offsetof(FAnimNodeData, Flags) == 0x000024, "Member 'FAnimNodeData::Flags' has a wrong offset!");

// ScriptStruct Engine.AnimNode_ConvertComponentToLocalSpace
// 0x0010 (0x0038 - 0x0028)
struct FAnimNode_ConvertComponentToLocalSpace final : public FAnimNode_Base
{
public:
	struct FComponentSpacePoseLink                ComponentPose;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FAnimNode_ConvertComponentToLocalSpace) == 0x000008, "Wrong alignment on FAnimNode_ConvertComponentToLocalSpace");
//(sizeof(FAnimNode_ConvertComponentToLocalSpace) == 0x000038, "Wrong size on FAnimNode_ConvertComponentToLocalSpace");
//(offsetof(FAnimNode_ConvertComponentToLocalSpace, ComponentPose) == 0x000028, "Member 'FAnimNode_ConvertComponentToLocalSpace::ComponentPose' has a wrong offset!");

// ScriptStruct Engine.AnimNode_ConvertLocalToComponentSpace
// 0x0010 (0x0038 - 0x0028)
struct FAnimNode_ConvertLocalToComponentSpace final : public FAnimNode_Base
{
public:
	struct FPoseLink                              LocalPose;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FAnimNode_ConvertLocalToComponentSpace) == 0x000008, "Wrong alignment on FAnimNode_ConvertLocalToComponentSpace");
//(sizeof(FAnimNode_ConvertLocalToComponentSpace) == 0x000038, "Wrong size on FAnimNode_ConvertLocalToComponentSpace");
//(offsetof(FAnimNode_ConvertLocalToComponentSpace, LocalPose) == 0x000028, "Member 'FAnimNode_ConvertLocalToComponentSpace::LocalPose' has a wrong offset!");

// ScriptStruct Engine.InertializationRequest
// 0x0048 (0x0048 - 0x0000)
struct FInertializationRequest final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendProfile*                          BlendProfile;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBlendMode;                                     // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendMode;                                         // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CustomBlendCurve;                                  // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Transient, NativeAccessSpecifierPublic)
	int32                                         NodeId;                                            // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                AnimInstance;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FInertializationRequest) == 0x000008, "Wrong alignment on FInertializationRequest");
//(sizeof(FInertializationRequest) == 0x000048, "Wrong size on FInertializationRequest");
//(offsetof(FInertializationRequest, Duration) == 0x000000, "Member 'FInertializationRequest::Duration' has a wrong offset!");
//(offsetof(FInertializationRequest, BlendProfile) == 0x000008, "Member 'FInertializationRequest::BlendProfile' has a wrong offset!");
//(offsetof(FInertializationRequest, bUseBlendMode) == 0x000010, "Member 'FInertializationRequest::bUseBlendMode' has a wrong offset!");
//(offsetof(FInertializationRequest, BlendMode) == 0x000011, "Member 'FInertializationRequest::BlendMode' has a wrong offset!");
//(offsetof(FInertializationRequest, CustomBlendCurve) == 0x000018, "Member 'FInertializationRequest::CustomBlendCurve' has a wrong offset!");
//(offsetof(FInertializationRequest, Description) == 0x000020, "Member 'FInertializationRequest::Description' has a wrong offset!");
//(offsetof(FInertializationRequest, NodeId) == 0x000038, "Member 'FInertializationRequest::NodeId' has a wrong offset!");
//(offsetof(FInertializationRequest, AnimInstance) == 0x000040, "Member 'FInertializationRequest::AnimInstance' has a wrong offset!");

// ScriptStruct Engine.AnimNode_DeadBlending
// 0x04F8 (0x0520 - 0x0028)
struct alignas(0x10) FAnimNode_DeadBlending final : public FAnimNode_Base
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseLink                              Source;                                            // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAlwaysUseDefaultBlendSettings;                    // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultBlendDuration;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendProfile*                          DefaultBlendProfile;                               // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAlphaBlendOption                             DefaultBlendMode;                                  // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DefaultCustomBlendCurve;                           // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendTimeMultiplier;                               // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLinearlyInterpolateScales;                        // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           FilteredCurves;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FBoneReference>                 FilteredBones;                                     // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         ExtrapolationHalfLife;                             // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExtrapolationHalfLifeMin;                          // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExtrapolationHalfLifeMax;                          // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaximumTranslationVelocity;                        // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaximumRotationVelocity;                           // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaximumScaleVelocity;                              // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaximumCurveVelocity;                              // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPreallocateMemory;                                // 0x00A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A5[0x21B];                                     // 0x00A5(0x021B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInertializationRequest>        RequestQueue;                                      // 0x02C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x228];                                    // 0x02D0(0x0228)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                InertializationRequestAnimInstance;                // 0x04F8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x18];                                     // 0x0500(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            InertializationCustomBlendCurve;                   // 0x0518(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FAnimNode_DeadBlending) == 0x000010, "Wrong alignment on FAnimNode_DeadBlending");
//(sizeof(FAnimNode_DeadBlending) == 0x000520, "Wrong size on FAnimNode_DeadBlending");
//(offsetof(FAnimNode_DeadBlending, Source) == 0x000030, "Member 'FAnimNode_DeadBlending::Source' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, bAlwaysUseDefaultBlendSettings) == 0x000040, "Member 'FAnimNode_DeadBlending::bAlwaysUseDefaultBlendSettings' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, DefaultBlendDuration) == 0x000044, "Member 'FAnimNode_DeadBlending::DefaultBlendDuration' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, DefaultBlendProfile) == 0x000048, "Member 'FAnimNode_DeadBlending::DefaultBlendProfile' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, DefaultBlendMode) == 0x000050, "Member 'FAnimNode_DeadBlending::DefaultBlendMode' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, DefaultCustomBlendCurve) == 0x000058, "Member 'FAnimNode_DeadBlending::DefaultCustomBlendCurve' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, BlendTimeMultiplier) == 0x000060, "Member 'FAnimNode_DeadBlending::BlendTimeMultiplier' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, bLinearlyInterpolateScales) == 0x000064, "Member 'FAnimNode_DeadBlending::bLinearlyInterpolateScales' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, FilteredCurves) == 0x000068, "Member 'FAnimNode_DeadBlending::FilteredCurves' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, FilteredBones) == 0x000078, "Member 'FAnimNode_DeadBlending::FilteredBones' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, ExtrapolationHalfLife) == 0x000088, "Member 'FAnimNode_DeadBlending::ExtrapolationHalfLife' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, ExtrapolationHalfLifeMin) == 0x00008C, "Member 'FAnimNode_DeadBlending::ExtrapolationHalfLifeMin' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, ExtrapolationHalfLifeMax) == 0x000090, "Member 'FAnimNode_DeadBlending::ExtrapolationHalfLifeMax' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, MaximumTranslationVelocity) == 0x000094, "Member 'FAnimNode_DeadBlending::MaximumTranslationVelocity' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, MaximumRotationVelocity) == 0x000098, "Member 'FAnimNode_DeadBlending::MaximumRotationVelocity' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, MaximumScaleVelocity) == 0x00009C, "Member 'FAnimNode_DeadBlending::MaximumScaleVelocity' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, MaximumCurveVelocity) == 0x0000A0, "Member 'FAnimNode_DeadBlending::MaximumCurveVelocity' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, bPreallocateMemory) == 0x0000A4, "Member 'FAnimNode_DeadBlending::bPreallocateMemory' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, RequestQueue) == 0x0002C0, "Member 'FAnimNode_DeadBlending::RequestQueue' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, InertializationRequestAnimInstance) == 0x0004F8, "Member 'FAnimNode_DeadBlending::InertializationRequestAnimInstance' has a wrong offset!");
//(offsetof(FAnimNode_DeadBlending, InertializationCustomBlendCurve) == 0x000518, "Member 'FAnimNode_DeadBlending::InertializationCustomBlendCurve' has a wrong offset!");

// ScriptStruct Engine.InertializationPose
// 0x00D0 (0x00D0 - 0x0000)
struct alignas(0x10) FInertializationPose final
{
public:
	uint8                                         Pad_0[0xD0];                                       // 0x0000(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FInertializationPose) == 0x000010, "Wrong alignment on FInertializationPose");
//(sizeof(FInertializationPose) == 0x0000D0, "Wrong size on FInertializationPose");

// ScriptStruct Engine.AnimNode_Inertialization
// 0x0108 (0x0130 - 0x0028)
struct FAnimNode_Inertialization final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Source;                                            // 0x0028(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UBlendProfile*                          DefaultBlendProfile;                               // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           FilteredCurves;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bPreallocateMemory;                                // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x1F];                                      // 0x0051(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInertializationRequest>        RequestQueue;                                      // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x30];                                      // 0x0080(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                InertializationRequestAnimInstance;                // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x78];                                      // 0x00B8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_Inertialization) == 0x000008, "Wrong alignment on FAnimNode_Inertialization");
//(sizeof(FAnimNode_Inertialization) == 0x000130, "Wrong size on FAnimNode_Inertialization");
//(offsetof(FAnimNode_Inertialization, Source) == 0x000028, "Member 'FAnimNode_Inertialization::Source' has a wrong offset!");
//(offsetof(FAnimNode_Inertialization, DefaultBlendProfile) == 0x000038, "Member 'FAnimNode_Inertialization::DefaultBlendProfile' has a wrong offset!");
//(offsetof(FAnimNode_Inertialization, FilteredCurves) == 0x000040, "Member 'FAnimNode_Inertialization::FilteredCurves' has a wrong offset!");
//(offsetof(FAnimNode_Inertialization, bPreallocateMemory) == 0x000050, "Member 'FAnimNode_Inertialization::bPreallocateMemory' has a wrong offset!");
//(offsetof(FAnimNode_Inertialization, RequestQueue) == 0x000070, "Member 'FAnimNode_Inertialization::RequestQueue' has a wrong offset!");
//(offsetof(FAnimNode_Inertialization, InertializationRequestAnimInstance) == 0x0000B0, "Member 'FAnimNode_Inertialization::InertializationRequestAnimInstance' has a wrong offset!");

// ScriptStruct Engine.AnimNode_LinkedInputPose
// 0x00B8 (0x00E0 - 0x0028)
struct FAnimNode_LinkedInputPose final : public FAnimNode_Base
{
public:
	class FName                                   Name;                                              // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Graph;                                             // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPoseLink                              InputPose;                                         // 0x0040(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x90];                                      // 0x0050(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_LinkedInputPose) == 0x000008, "Wrong alignment on FAnimNode_LinkedInputPose");
//(sizeof(FAnimNode_LinkedInputPose) == 0x0000E0, "Wrong size on FAnimNode_LinkedInputPose");
//(offsetof(FAnimNode_LinkedInputPose, Name) == 0x000028, "Member 'FAnimNode_LinkedInputPose::Name' has a wrong offset!");
//(offsetof(FAnimNode_LinkedInputPose, Graph) == 0x000034, "Member 'FAnimNode_LinkedInputPose::Graph' has a wrong offset!");
//(offsetof(FAnimNode_LinkedInputPose, InputPose) == 0x000040, "Member 'FAnimNode_LinkedInputPose::InputPose' has a wrong offset!");

// ScriptStruct Engine.AnimNode_SaveCachedPose
// 0x0078 (0x00A0 - 0x0028)
struct FAnimNode_SaveCachedPose final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Pose;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   CachePoseName;                                     // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSkipSaveCached;                                   // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateCounter;                                    // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysInitialize;                                 // 0x004A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x55];                                      // 0x004B(0x0055)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_SaveCachedPose) == 0x000008, "Wrong alignment on FAnimNode_SaveCachedPose");
//(sizeof(FAnimNode_SaveCachedPose) == 0x0000A0, "Wrong size on FAnimNode_SaveCachedPose");
//(offsetof(FAnimNode_SaveCachedPose, Pose) == 0x000028, "Member 'FAnimNode_SaveCachedPose::Pose' has a wrong offset!");
//(offsetof(FAnimNode_SaveCachedPose, CachePoseName) == 0x000038, "Member 'FAnimNode_SaveCachedPose::CachePoseName' has a wrong offset!");
//(offsetof(FAnimNode_SaveCachedPose, bSkipSaveCached) == 0x000048, "Member 'FAnimNode_SaveCachedPose::bSkipSaveCached' has a wrong offset!");
//(offsetof(FAnimNode_SaveCachedPose, bUpdateCounter) == 0x000049, "Member 'FAnimNode_SaveCachedPose::bUpdateCounter' has a wrong offset!");
//(offsetof(FAnimNode_SaveCachedPose, bAlwaysInitialize) == 0x00004A, "Member 'FAnimNode_SaveCachedPose::bAlwaysInitialize' has a wrong offset!");

// ScriptStruct Engine.AnimNode_SequencePlayerBase
// 0x0008 (0x0058 - 0x0050)
struct FAnimNode_SequencePlayerBase : public FAnimNode_AssetPlayerBase
{
public:
	struct FInputScaleBiasClampState              PlayRateScaleBiasClampState;                       // 0x0050(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
};
//(alignof(FAnimNode_SequencePlayerBase) == 0x000008, "Wrong alignment on FAnimNode_SequencePlayerBase");
//(sizeof(FAnimNode_SequencePlayerBase) == 0x000058, "Wrong size on FAnimNode_SequencePlayerBase");
//(offsetof(FAnimNode_SequencePlayerBase, PlayRateScaleBiasClampState) == 0x000050, "Member 'FAnimNode_SequencePlayerBase::PlayRateScaleBiasClampState' has a wrong offset!");

// ScriptStruct Engine.AnimNode_SequencePlayer
// 0x0008 (0x0060 - 0x0058)
struct FAnimNode_SequencePlayer : public FAnimNode_SequencePlayerBase
{
public:
	class UAnimSequenceBase*                      Sequence;                                          // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
//(alignof(FAnimNode_SequencePlayer) == 0x000008, "Wrong alignment on FAnimNode_SequencePlayer");
//(sizeof(FAnimNode_SequencePlayer) == 0x000060, "Wrong size on FAnimNode_SequencePlayer");
//(offsetof(FAnimNode_SequencePlayer, Sequence) == 0x000058, "Member 'FAnimNode_SequencePlayer::Sequence' has a wrong offset!");

// ScriptStruct Engine.InputScaleBiasClampConstants
// 0x002C (0x002C - 0x0000)
struct FInputScaleBiasClampConstants final
{
public:
	bool                                          bMapRange;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampResult;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpResult;                                     // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputRange                            InRange;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FInputRange                            OutRange;                                          // 0x000C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bias;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMin;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeedIncreasing;                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeedDecreasing;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FInputScaleBiasClampConstants) == 0x000004, "Wrong alignment on FInputScaleBiasClampConstants");
//(sizeof(FInputScaleBiasClampConstants) == 0x00002C, "Wrong size on FInputScaleBiasClampConstants");
//(offsetof(FInputScaleBiasClampConstants, bMapRange) == 0x000000, "Member 'FInputScaleBiasClampConstants::bMapRange' has a wrong offset!");
//(offsetof(FInputScaleBiasClampConstants, bClampResult) == 0x000001, "Member 'FInputScaleBiasClampConstants::bClampResult' has a wrong offset!");
//(offsetof(FInputScaleBiasClampConstants, bInterpResult) == 0x000002, "Member 'FInputScaleBiasClampConstants::bInterpResult' has a wrong offset!");
//(offsetof(FInputScaleBiasClampConstants, InRange) == 0x000004, "Member 'FInputScaleBiasClampConstants::InRange' has a wrong offset!");
//(offsetof(FInputScaleBiasClampConstants, OutRange) == 0x00000C, "Member 'FInputScaleBiasClampConstants::OutRange' has a wrong offset!");
//(offsetof(FInputScaleBiasClampConstants, Scale) == 0x000014, "Member 'FInputScaleBiasClampConstants::Scale' has a wrong offset!");
//(offsetof(FInputScaleBiasClampConstants, Bias) == 0x000018, "Member 'FInputScaleBiasClampConstants::Bias' has a wrong offset!");
//(offsetof(FInputScaleBiasClampConstants, ClampMin) == 0x00001C, "Member 'FInputScaleBiasClampConstants::ClampMin' has a wrong offset!");
//(offsetof(FInputScaleBiasClampConstants, ClampMax) == 0x000020, "Member 'FInputScaleBiasClampConstants::ClampMax' has a wrong offset!");
//(offsetof(FInputScaleBiasClampConstants, InterpSpeedIncreasing) == 0x000024, "Member 'FInputScaleBiasClampConstants::InterpSpeedIncreasing' has a wrong offset!");
//(offsetof(FInputScaleBiasClampConstants, InterpSpeedDecreasing) == 0x000028, "Member 'FInputScaleBiasClampConstants::InterpSpeedDecreasing' has a wrong offset!");

// ScriptStruct Engine.AnimNode_SequencePlayer_Standalone
// 0x0058 (0x00B0 - 0x0058)
struct FAnimNode_SequencePlayer_Standalone final : public FAnimNode_SequencePlayerBase
{
public:
	class FName                                   GroupName;                                         // 0x0058(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimGroupRole                                GroupRole;                                         // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimSyncMethod                               Method;                                            // 0x0065(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreForRelevancyTest;                           // 0x0066(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Sequence;                                          // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayRateBasis;                                     // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayRate;                                          // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInputScaleBiasClampConstants          PlayRateScaleBiasClampConstants;                   // 0x0078(0x002C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         StartPosition;                                     // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopAnimation;                                    // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartFromMatchingPose;                            // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_SequencePlayer_Standalone) == 0x000008, "Wrong alignment on FAnimNode_SequencePlayer_Standalone");
//(sizeof(FAnimNode_SequencePlayer_Standalone) == 0x0000B0, "Wrong size on FAnimNode_SequencePlayer_Standalone");
//(offsetof(FAnimNode_SequencePlayer_Standalone, GroupName) == 0x000058, "Member 'FAnimNode_SequencePlayer_Standalone::GroupName' has a wrong offset!");
//(offsetof(FAnimNode_SequencePlayer_Standalone, GroupRole) == 0x000064, "Member 'FAnimNode_SequencePlayer_Standalone::GroupRole' has a wrong offset!");
//(offsetof(FAnimNode_SequencePlayer_Standalone, Method) == 0x000065, "Member 'FAnimNode_SequencePlayer_Standalone::Method' has a wrong offset!");
//(offsetof(FAnimNode_SequencePlayer_Standalone, bIgnoreForRelevancyTest) == 0x000066, "Member 'FAnimNode_SequencePlayer_Standalone::bIgnoreForRelevancyTest' has a wrong offset!");
//(offsetof(FAnimNode_SequencePlayer_Standalone, Sequence) == 0x000068, "Member 'FAnimNode_SequencePlayer_Standalone::Sequence' has a wrong offset!");
//(offsetof(FAnimNode_SequencePlayer_Standalone, PlayRateBasis) == 0x000070, "Member 'FAnimNode_SequencePlayer_Standalone::PlayRateBasis' has a wrong offset!");
//(offsetof(FAnimNode_SequencePlayer_Standalone, PlayRate) == 0x000074, "Member 'FAnimNode_SequencePlayer_Standalone::PlayRate' has a wrong offset!");
//(offsetof(FAnimNode_SequencePlayer_Standalone, PlayRateScaleBiasClampConstants) == 0x000078, "Member 'FAnimNode_SequencePlayer_Standalone::PlayRateScaleBiasClampConstants' has a wrong offset!");
//(offsetof(FAnimNode_SequencePlayer_Standalone, StartPosition) == 0x0000A4, "Member 'FAnimNode_SequencePlayer_Standalone::StartPosition' has a wrong offset!");
//(offsetof(FAnimNode_SequencePlayer_Standalone, bLoopAnimation) == 0x0000A8, "Member 'FAnimNode_SequencePlayer_Standalone::bLoopAnimation' has a wrong offset!");
//(offsetof(FAnimNode_SequencePlayer_Standalone, bStartFromMatchingPose) == 0x0000A9, "Member 'FAnimNode_SequencePlayer_Standalone::bStartFromMatchingPose' has a wrong offset!");

// ScriptStruct Engine.AnimNode_StateMachineCache
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FAnimNode_StateMachineCache final : public FAniNodeCacheBase
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_StateMachineCache) == 0x000008, "Wrong alignment on FAnimNode_StateMachineCache");
//(sizeof(FAnimNode_StateMachineCache) == 0x000028, "Wrong size on FAnimNode_StateMachineCache");

// ScriptStruct Engine.AnimNode_StateMachine
// 0x0278 (0x02A0 - 0x0028)
struct FAnimNode_StateMachine final : public FAnimNode_Base
{
public:
	int32                                         StateMachineIndexInClass;                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTransitionsPerFrame;                            // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTransitionsRequests;                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipFirstUpdateTransition;                        // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReinitializeOnBecomingRelevant;                   // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateNotifyMetaData;                             // 0x0036(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowConduitEntryStates;                          // 0x0037(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x268];                                     // 0x0038(0x0268)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_StateMachine) == 0x000008, "Wrong alignment on FAnimNode_StateMachine");
//(sizeof(FAnimNode_StateMachine) == 0x0002A0, "Wrong size on FAnimNode_StateMachine");
//(offsetof(FAnimNode_StateMachine, StateMachineIndexInClass) == 0x000028, "Member 'FAnimNode_StateMachine::StateMachineIndexInClass' has a wrong offset!");
//(offsetof(FAnimNode_StateMachine, MaxTransitionsPerFrame) == 0x00002C, "Member 'FAnimNode_StateMachine::MaxTransitionsPerFrame' has a wrong offset!");
//(offsetof(FAnimNode_StateMachine, MaxTransitionsRequests) == 0x000030, "Member 'FAnimNode_StateMachine::MaxTransitionsRequests' has a wrong offset!");
//(offsetof(FAnimNode_StateMachine, bSkipFirstUpdateTransition) == 0x000034, "Member 'FAnimNode_StateMachine::bSkipFirstUpdateTransition' has a wrong offset!");
//(offsetof(FAnimNode_StateMachine, bReinitializeOnBecomingRelevant) == 0x000035, "Member 'FAnimNode_StateMachine::bReinitializeOnBecomingRelevant' has a wrong offset!");
//(offsetof(FAnimNode_StateMachine, bCreateNotifyMetaData) == 0x000036, "Member 'FAnimNode_StateMachine::bCreateNotifyMetaData' has a wrong offset!");
//(offsetof(FAnimNode_StateMachine, bAllowConduitEntryStates) == 0x000037, "Member 'FAnimNode_StateMachine::bAllowConduitEntryStates' has a wrong offset!");

// ScriptStruct Engine.AnimNode_TransitionPoseCache
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FAnimNode_TransitionPoseCache final : public FAniNodeCacheBase
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_TransitionPoseCache) == 0x000004, "Wrong alignment on FAnimNode_TransitionPoseCache");
//(sizeof(FAnimNode_TransitionPoseCache) == 0x000004, "Wrong size on FAnimNode_TransitionPoseCache");

// ScriptStruct Engine.AnimNode_TransitionResult
// 0x0018 (0x0040 - 0x0028)
struct FAnimNode_TransitionResult final : public FAnimNode_Base
{
public:
	bool                                          bCanEnterTransition;                               // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x17];                                      // 0x0029(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNode_TransitionResult) == 0x000008, "Wrong alignment on FAnimNode_TransitionResult");
//(sizeof(FAnimNode_TransitionResult) == 0x000040, "Wrong size on FAnimNode_TransitionResult");
//(offsetof(FAnimNode_TransitionResult, bCanEnterTransition) == 0x000028, "Member 'FAnimNode_TransitionResult::bCanEnterTransition' has a wrong offset!");

// ScriptStruct Engine.AnimNotifyContext
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAnimNotifyContext final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimNotifyContext) == 0x000008, "Wrong alignment on FAnimNotifyContext");
//(sizeof(FAnimNotifyContext) == 0x000018, "Wrong size on FAnimNotifyContext");

// ScriptStruct Engine.AnimSequenceTrackContainer
// 0x0020 (0x0020 - 0x0000)
struct FAnimSequenceTrackContainer final
{
public:
	TArray<struct FRawAnimSequenceTrack>          AnimationTracks;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           TrackNames;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FAnimSequenceTrackContainer) == 0x000008, "Wrong alignment on FAnimSequenceTrackContainer");
//(sizeof(FAnimSequenceTrackContainer) == 0x000020, "Wrong size on FAnimSequenceTrackContainer");
//(offsetof(FAnimSequenceTrackContainer, AnimationTracks) == 0x000000, "Member 'FAnimSequenceTrackContainer::AnimationTracks' has a wrong offset!");
//(offsetof(FAnimSequenceTrackContainer, TrackNames) == 0x000010, "Member 'FAnimSequenceTrackContainer::TrackNames' has a wrong offset!");

// ScriptStruct Engine.TranslationTrack
// 0x0020 (0x0020 - 0x0000)
struct FTranslationTrack final
{
public:
	TArray<struct FVector3f>                      PosKeys;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Times;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FTranslationTrack) == 0x000008, "Wrong alignment on FTranslationTrack");
//(sizeof(FTranslationTrack) == 0x000020, "Wrong size on FTranslationTrack");
//(offsetof(FTranslationTrack, PosKeys) == 0x000000, "Member 'FTranslationTrack::PosKeys' has a wrong offset!");
//(offsetof(FTranslationTrack, Times) == 0x000010, "Member 'FTranslationTrack::Times' has a wrong offset!");

// ScriptStruct Engine.RotationTrack
// 0x0020 (0x0020 - 0x0000)
struct FRotationTrack final
{
public:
	TArray<struct FQuat4f>                        RotKeys;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Times;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FRotationTrack) == 0x000008, "Wrong alignment on FRotationTrack");
//(sizeof(FRotationTrack) == 0x000020, "Wrong size on FRotationTrack");
//(offsetof(FRotationTrack, RotKeys) == 0x000000, "Member 'FRotationTrack::RotKeys' has a wrong offset!");
//(offsetof(FRotationTrack, Times) == 0x000010, "Member 'FRotationTrack::Times' has a wrong offset!");

// ScriptStruct Engine.CurveTrack
// 0x0020 (0x0020 - 0x0000)
struct FCurveTrack final
{
public:
	class FName                                   CurveName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 CurveWeights;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FCurveTrack) == 0x000008, "Wrong alignment on FCurveTrack");
//(sizeof(FCurveTrack) == 0x000020, "Wrong size on FCurveTrack");
//(offsetof(FCurveTrack, CurveName) == 0x000000, "Member 'FCurveTrack::CurveName' has a wrong offset!");
//(offsetof(FCurveTrack, CurveWeights) == 0x000010, "Member 'FCurveTrack::CurveWeights' has a wrong offset!");

// ScriptStruct Engine.CompressedTrack
// 0x0038 (0x0038 - 0x0000)
struct FCompressedTrack final
{
public:
	TArray<uint8>                                 ByteStream;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Times;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Mins[0x3];                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ranges[0x3];                                       // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCompressedTrack) == 0x000008, "Wrong alignment on FCompressedTrack");
//(sizeof(FCompressedTrack) == 0x000038, "Wrong size on FCompressedTrack");
//(offsetof(FCompressedTrack, ByteStream) == 0x000000, "Member 'FCompressedTrack::ByteStream' has a wrong offset!");
//(offsetof(FCompressedTrack, Times) == 0x000010, "Member 'FCompressedTrack::Times' has a wrong offset!");
//(offsetof(FCompressedTrack, Mins) == 0x000020, "Member 'FCompressedTrack::Mins' has a wrong offset!");
//(offsetof(FCompressedTrack, Ranges) == 0x00002C, "Member 'FCompressedTrack::Ranges' has a wrong offset!");

// ScriptStruct Engine.AnimSetMeshLinkup
// 0x0010 (0x0010 - 0x0000)
struct FAnimSetMeshLinkup final
{
public:
	TArray<int32>                                 BoneToTrackTable;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FAnimSetMeshLinkup) == 0x000008, "Wrong alignment on FAnimSetMeshLinkup");
//(sizeof(FAnimSetMeshLinkup) == 0x000010, "Wrong size on FAnimSetMeshLinkup");
//(offsetof(FAnimSetMeshLinkup, BoneToTrackTable) == 0x000000, "Member 'FAnimSetMeshLinkup::BoneToTrackTable' has a wrong offset!");

// ScriptStruct Engine.AnimSingleNodeInstanceProxy
// 0x0120 (0x08F0 - 0x07D0)
struct FAnimSingleNodeInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_7C8[0x128];                                    // 0x07C8(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimSingleNodeInstanceProxy) == 0x000010, "Wrong alignment on FAnimSingleNodeInstanceProxy");
//(sizeof(FAnimSingleNodeInstanceProxy) == 0x0008F0, "Wrong size on FAnimSingleNodeInstanceProxy");

// ScriptStruct Engine.AnimationTransitionRule
// 0x0014 (0x0014 - 0x0000)
struct FAnimationTransitionRule final
{
public:
	class FName                                   RuleToExecute;                                     // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TransitionReturnVal;                               // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TransitionIndex;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimationTransitionRule) == 0x000004, "Wrong alignment on FAnimationTransitionRule");
//(sizeof(FAnimationTransitionRule) == 0x000014, "Wrong size on FAnimationTransitionRule");
//(offsetof(FAnimationTransitionRule, RuleToExecute) == 0x000000, "Member 'FAnimationTransitionRule::RuleToExecute' has a wrong offset!");
//(offsetof(FAnimationTransitionRule, TransitionReturnVal) == 0x00000C, "Member 'FAnimationTransitionRule::TransitionReturnVal' has a wrong offset!");
//(offsetof(FAnimationTransitionRule, TransitionIndex) == 0x000010, "Member 'FAnimationTransitionRule::TransitionIndex' has a wrong offset!");

// ScriptStruct Engine.AnimationState
// 0x0024 (0x0030 - 0x000C)
struct FAnimationState final : public FAnimationStateBase
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimationTransitionRule>       Transitions;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StateRootNodeIndex;                                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartNotify;                                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndNotify;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FullyBlendedNotify;                                // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAnimationState) == 0x000008, "Wrong alignment on FAnimationState");
//(sizeof(FAnimationState) == 0x000030, "Wrong size on FAnimationState");
//(offsetof(FAnimationState, Transitions) == 0x000010, "Member 'FAnimationState::Transitions' has a wrong offset!");
//(offsetof(FAnimationState, StateRootNodeIndex) == 0x000020, "Member 'FAnimationState::StateRootNodeIndex' has a wrong offset!");
//(offsetof(FAnimationState, StartNotify) == 0x000024, "Member 'FAnimationState::StartNotify' has a wrong offset!");
//(offsetof(FAnimationState, EndNotify) == 0x000028, "Member 'FAnimationState::EndNotify' has a wrong offset!");
//(offsetof(FAnimationState, FullyBlendedNotify) == 0x00002C, "Member 'FAnimationState::FullyBlendedNotify' has a wrong offset!");

// ScriptStruct Engine.ExposedValueCopyRecord
// 0x0014 (0x0014 - 0x0000)
struct FExposedValueCopyRecord final
{
public:
	int32                                         CopyIndex;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPostCopyOperation                            PostCopyOperation;                                 // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SourcePropertyPath;                                // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FExposedValueCopyRecord) == 0x000004, "Wrong alignment on FExposedValueCopyRecord");
//(sizeof(FExposedValueCopyRecord) == 0x000014, "Wrong size on FExposedValueCopyRecord");
//(offsetof(FExposedValueCopyRecord, CopyIndex) == 0x000000, "Member 'FExposedValueCopyRecord::CopyIndex' has a wrong offset!");
//(offsetof(FExposedValueCopyRecord, PostCopyOperation) == 0x000004, "Member 'FExposedValueCopyRecord::PostCopyOperation' has a wrong offset!");
//(offsetof(FExposedValueCopyRecord, SourcePropertyPath) == 0x000008, "Member 'FExposedValueCopyRecord::SourcePropertyPath' has a wrong offset!");

// ScriptStruct Engine.ExposedValueHandler
// 0x0030 (0x0030 - 0x0000)
struct FExposedValueHandler final
{
public:
	TArray<struct FExposedValueCopyRecord>        CopyRecords;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UFunction*                              Function;                                          // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoundFunction;                                     // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FExposedValueHandler) == 0x000008, "Wrong alignment on FExposedValueHandler");
//(sizeof(FExposedValueHandler) == 0x000030, "Wrong size on FExposedValueHandler");
//(offsetof(FExposedValueHandler, CopyRecords) == 0x000000, "Member 'FExposedValueHandler::CopyRecords' has a wrong offset!");
//(offsetof(FExposedValueHandler, Function) == 0x000010, "Member 'FExposedValueHandler::Function' has a wrong offset!");
//(offsetof(FExposedValueHandler, BoundFunction) == 0x000020, "Member 'FExposedValueHandler::BoundFunction' has a wrong offset!");

// ScriptStruct Engine.AnimSubsystem_Base
// 0x0010 (0x0018 - 0x0008)
struct FAnimSubsystem_Base final : public FAnimSubsystem
{
public:
	TArray<struct FExposedValueHandler>           ExposedValueHandlers;                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
//(alignof(FAnimSubsystem_Base) == 0x000008, "Wrong alignment on FAnimSubsystem_Base");
//(sizeof(FAnimSubsystem_Base) == 0x000018, "Wrong size on FAnimSubsystem_Base");
//(offsetof(FAnimSubsystem_Base, ExposedValueHandlers) == 0x000008, "Member 'FAnimSubsystem_Base::ExposedValueHandlers' has a wrong offset!");

// ScriptStruct Engine.AnimSubsystemInstance_NodeRelevancy
// 0x00A0 (0x00A8 - 0x0008)
struct FAnimSubsystemInstance_NodeRelevancy final : public FAnimSubsystemInstance
{
public:
	uint8                                         Pad_8[0xA0];                                       // 0x0008(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimSubsystemInstance_NodeRelevancy) == 0x000008, "Wrong alignment on FAnimSubsystemInstance_NodeRelevancy");
//(sizeof(FAnimSubsystemInstance_NodeRelevancy) == 0x0000A8, "Wrong size on FAnimSubsystemInstance_NodeRelevancy");

// ScriptStruct Engine.PropertyAccessSegment
// 0x0048 (0x0048 - 0x0000)
struct FPropertyAccessSegment final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStruct*                                Struct;                                            // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TFieldPath<struct FProperty>                  Property;                                          // 0x0018(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFunction*                              Function;                                          // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ArrayIndex;                                        // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        Flags;                                             // 0x0044(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPropertyAccessSegment) == 0x000008, "Wrong alignment on FPropertyAccessSegment");
//(sizeof(FPropertyAccessSegment) == 0x000048, "Wrong size on FPropertyAccessSegment");
//(offsetof(FPropertyAccessSegment, Name) == 0x000000, "Member 'FPropertyAccessSegment::Name' has a wrong offset!");
//(offsetof(FPropertyAccessSegment, Struct) == 0x000010, "Member 'FPropertyAccessSegment::Struct' has a wrong offset!");
//(offsetof(FPropertyAccessSegment, Property) == 0x000018, "Member 'FPropertyAccessSegment::Property' has a wrong offset!");
//(offsetof(FPropertyAccessSegment, Function) == 0x000038, "Member 'FPropertyAccessSegment::Function' has a wrong offset!");
//(offsetof(FPropertyAccessSegment, ArrayIndex) == 0x000040, "Member 'FPropertyAccessSegment::ArrayIndex' has a wrong offset!");
//(offsetof(FPropertyAccessSegment, Flags) == 0x000044, "Member 'FPropertyAccessSegment::Flags' has a wrong offset!");

// ScriptStruct Engine.PropertyAccessPath
// 0x0008 (0x0008 - 0x0000)
struct FPropertyAccessPath final
{
public:
	int32                                         PathSegmentStartIndex;                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PathSegmentCount;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FPropertyAccessPath) == 0x000004, "Wrong alignment on FPropertyAccessPath");
//(sizeof(FPropertyAccessPath) == 0x000008, "Wrong size on FPropertyAccessPath");
//(offsetof(FPropertyAccessPath, PathSegmentStartIndex) == 0x000000, "Member 'FPropertyAccessPath::PathSegmentStartIndex' has a wrong offset!");
//(offsetof(FPropertyAccessPath, PathSegmentCount) == 0x000004, "Member 'FPropertyAccessPath::PathSegmentCount' has a wrong offset!");

// ScriptStruct Engine.PropertyAccessCopyBatch
// 0x0010 (0x0010 - 0x0000)
struct FPropertyAccessCopyBatch final
{
public:
	TArray<struct FPropertyAccessCopy>            Copies;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
//(alignof(FPropertyAccessCopyBatch) == 0x000008, "Wrong alignment on FPropertyAccessCopyBatch");
//(sizeof(FPropertyAccessCopyBatch) == 0x000010, "Wrong size on FPropertyAccessCopyBatch");
//(offsetof(FPropertyAccessCopyBatch, Copies) == 0x000000, "Member 'FPropertyAccessCopyBatch::Copies' has a wrong offset!");

// ScriptStruct Engine.PropertyAccessLibrary
// 0x0078 (0x0078 - 0x0000)
struct FPropertyAccessLibrary final
{
public:
	TArray<struct FPropertyAccessSegment>         PathSegments;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPropertyAccessPath>            SrcPaths;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPropertyAccessPath>            DestPaths;                                         // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPropertyAccessCopyBatch>       CopyBatchArray;                                    // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x38];                                      // 0x0040(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPropertyAccessLibrary) == 0x000008, "Wrong alignment on FPropertyAccessLibrary");
//(sizeof(FPropertyAccessLibrary) == 0x000078, "Wrong size on FPropertyAccessLibrary");
//(offsetof(FPropertyAccessLibrary, PathSegments) == 0x000000, "Member 'FPropertyAccessLibrary::PathSegments' has a wrong offset!");
//(offsetof(FPropertyAccessLibrary, SrcPaths) == 0x000010, "Member 'FPropertyAccessLibrary::SrcPaths' has a wrong offset!");
//(offsetof(FPropertyAccessLibrary, DestPaths) == 0x000020, "Member 'FPropertyAccessLibrary::DestPaths' has a wrong offset!");
//(offsetof(FPropertyAccessLibrary, CopyBatchArray) == 0x000030, "Member 'FPropertyAccessLibrary::CopyBatchArray' has a wrong offset!");

// ScriptStruct Engine.AnimSubsystem_PropertyAccess
// 0x0078 (0x0080 - 0x0008)
struct FAnimSubsystem_PropertyAccess final : public FAnimSubsystem
{
public:
	struct FPropertyAccessLibrary                 Library;                                           // 0x0008(0x0078)(NativeAccessSpecifierPrivate)
};
//(alignof(FAnimSubsystem_PropertyAccess) == 0x000008, "Wrong alignment on FAnimSubsystem_PropertyAccess");
//(sizeof(FAnimSubsystem_PropertyAccess) == 0x000080, "Wrong size on FAnimSubsystem_PropertyAccess");
//(offsetof(FAnimSubsystem_PropertyAccess, Library) == 0x000008, "Member 'FAnimSubsystem_PropertyAccess::Library' has a wrong offset!");

// ScriptStruct Engine.AnimSubsystem_Tag
// 0x0058 (0x0060 - 0x0008)
struct FAnimSubsystem_Tag final : public FAnimSubsystem
{
public:
	TMap<class FName, int32>                      NodeIndices;                                       // 0x0008(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAnimSubsystem_Tag) == 0x000008, "Wrong alignment on FAnimSubsystem_Tag");
//(sizeof(FAnimSubsystem_Tag) == 0x000060, "Wrong size on FAnimSubsystem_Tag");
//(offsetof(FAnimSubsystem_Tag, NodeIndices) == 0x000008, "Member 'FAnimSubsystem_Tag::NodeIndices' has a wrong offset!");

// ScriptStruct Engine.AssetMapping
// 0x0010 (0x0010 - 0x0000)
struct FAssetMapping final
{
public:
	class UAnimationAsset*                        SourceAsset;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        TargetAsset;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAssetMapping) == 0x000008, "Wrong alignment on FAssetMapping");
//(sizeof(FAssetMapping) == 0x000010, "Wrong size on FAssetMapping");
//(offsetof(FAssetMapping, SourceAsset) == 0x000000, "Member 'FAssetMapping::SourceAsset' has a wrong offset!");
//(offsetof(FAssetMapping, TargetAsset) == 0x000008, "Member 'FAssetMapping::TargetAsset' has a wrong offset!");

// ScriptStruct Engine.CachedAnimStateArray
// 0x0018 (0x0018 - 0x0000)
struct FCachedAnimStateArray final
{
public:
	TArray<struct FCachedAnimStateData>           States;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCachedAnimStateArray) == 0x000008, "Wrong alignment on FCachedAnimStateArray");
//(sizeof(FCachedAnimStateArray) == 0x000018, "Wrong size on FCachedAnimStateArray");
//(offsetof(FCachedAnimStateArray, States) == 0x000000, "Member 'FCachedAnimStateArray::States' has a wrong offset!");

// ScriptStruct Engine.CachedAnimAssetPlayerData
// 0x0020 (0x0020 - 0x0000)
struct FCachedAnimAssetPlayerData final
{
public:
	class FName                                   StateMachineName;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateName;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCachedAnimAssetPlayerData) == 0x000004, "Wrong alignment on FCachedAnimAssetPlayerData");
//(sizeof(FCachedAnimAssetPlayerData) == 0x000020, "Wrong size on FCachedAnimAssetPlayerData");
//(offsetof(FCachedAnimAssetPlayerData, StateMachineName) == 0x000000, "Member 'FCachedAnimAssetPlayerData::StateMachineName' has a wrong offset!");
//(offsetof(FCachedAnimAssetPlayerData, StateName) == 0x00000C, "Member 'FCachedAnimAssetPlayerData::StateName' has a wrong offset!");

// ScriptStruct Engine.CachedAnimTransitionData
// 0x0030 (0x0030 - 0x0000)
struct FCachedAnimTransitionData final
{
public:
	class FName                                   StateMachineName;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FromStateName;                                     // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToStateName;                                       // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCachedAnimTransitionData) == 0x000004, "Wrong alignment on FCachedAnimTransitionData");
//(sizeof(FCachedAnimTransitionData) == 0x000030, "Wrong size on FCachedAnimTransitionData");
//(offsetof(FCachedAnimTransitionData, StateMachineName) == 0x000000, "Member 'FCachedAnimTransitionData::StateMachineName' has a wrong offset!");
//(offsetof(FCachedAnimTransitionData, FromStateName) == 0x00000C, "Member 'FCachedAnimTransitionData::FromStateName' has a wrong offset!");
//(offsetof(FCachedAnimTransitionData, ToStateName) == 0x000018, "Member 'FCachedAnimTransitionData::ToStateName' has a wrong offset!");

// ScriptStruct Engine.NamedCurveValue
// 0x0010 (0x0010 - 0x0000)
struct FNamedCurveValue final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNamedCurveValue) == 0x000004, "Wrong alignment on FNamedCurveValue");
//(sizeof(FNamedCurveValue) == 0x000010, "Wrong size on FNamedCurveValue");
//(offsetof(FNamedCurveValue, Name) == 0x000000, "Member 'FNamedCurveValue::Name' has a wrong offset!");
//(offsetof(FNamedCurveValue, Value) == 0x00000C, "Member 'FNamedCurveValue::Value' has a wrong offset!");

// ScriptStruct Engine.InputClampConstants
// 0x0014 (0x0014 - 0x0000)
struct FInputClampConstants final
{
public:
	bool                                          bClampResult;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpResult;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampMin;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeedIncreasing;                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeedDecreasing;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FInputClampConstants) == 0x000004, "Wrong alignment on FInputClampConstants");
//(sizeof(FInputClampConstants) == 0x000014, "Wrong size on FInputClampConstants");
//(offsetof(FInputClampConstants, bClampResult) == 0x000000, "Member 'FInputClampConstants::bClampResult' has a wrong offset!");
//(offsetof(FInputClampConstants, bInterpResult) == 0x000001, "Member 'FInputClampConstants::bInterpResult' has a wrong offset!");
//(offsetof(FInputClampConstants, ClampMin) == 0x000004, "Member 'FInputClampConstants::ClampMin' has a wrong offset!");
//(offsetof(FInputClampConstants, ClampMax) == 0x000008, "Member 'FInputClampConstants::ClampMax' has a wrong offset!");
//(offsetof(FInputClampConstants, InterpSpeedIncreasing) == 0x00000C, "Member 'FInputClampConstants::InterpSpeedIncreasing' has a wrong offset!");
//(offsetof(FInputClampConstants, InterpSpeedDecreasing) == 0x000010, "Member 'FInputClampConstants::InterpSpeedDecreasing' has a wrong offset!");

// ScriptStruct Engine.InputClampState
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FInputClampState final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FInputClampState) == 0x000004, "Wrong alignment on FInputClampState");
//(sizeof(FInputClampState) == 0x000008, "Wrong size on FInputClampState");

// ScriptStruct Engine.MirrorFindReplaceExpression
// 0x001C (0x001C - 0x0000)
struct FMirrorFindReplaceExpression final
{
public:
	class FName                                   FindExpression;                                    // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReplaceExpression;                                 // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMirrorFindReplaceMethod                      FindReplaceMethod;                                 // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMirrorFindReplaceExpression) == 0x000004, "Wrong alignment on FMirrorFindReplaceExpression");
//(sizeof(FMirrorFindReplaceExpression) == 0x00001C, "Wrong size on FMirrorFindReplaceExpression");
//(offsetof(FMirrorFindReplaceExpression, FindExpression) == 0x000000, "Member 'FMirrorFindReplaceExpression::FindExpression' has a wrong offset!");
//(offsetof(FMirrorFindReplaceExpression, ReplaceExpression) == 0x00000C, "Member 'FMirrorFindReplaceExpression::ReplaceExpression' has a wrong offset!");
//(offsetof(FMirrorFindReplaceExpression, FindReplaceMethod) == 0x000018, "Member 'FMirrorFindReplaceExpression::FindReplaceMethod' has a wrong offset!");

// ScriptStruct Engine.TrajectorySample
// 0x0090 (0x0090 - 0x0000)
struct FTrajectorySample final
{
public:
	float                                         AccumulatedSeconds;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LinearVelocity;                                    // 0x0070(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTrajectorySample) == 0x000010, "Wrong alignment on FTrajectorySample");
//(sizeof(FTrajectorySample) == 0x000090, "Wrong size on FTrajectorySample");
//(offsetof(FTrajectorySample, AccumulatedSeconds) == 0x000000, "Member 'FTrajectorySample::AccumulatedSeconds' has a wrong offset!");
//(offsetof(FTrajectorySample, Transform) == 0x000010, "Member 'FTrajectorySample::Transform' has a wrong offset!");
//(offsetof(FTrajectorySample, LinearVelocity) == 0x000070, "Member 'FTrajectorySample::LinearVelocity' has a wrong offset!");

// ScriptStruct Engine.TrajectorySampleRange
// 0x0010 (0x0010 - 0x0000)
struct FTrajectorySampleRange final
{
public:
	TArray<struct FTrajectorySample>              Samples;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FTrajectorySampleRange) == 0x000008, "Wrong alignment on FTrajectorySampleRange");
//(sizeof(FTrajectorySampleRange) == 0x000010, "Wrong size on FTrajectorySampleRange");
//(offsetof(FTrajectorySampleRange, Samples) == 0x000000, "Member 'FTrajectorySampleRange::Samples' has a wrong offset!");

// ScriptStruct Engine.NodeItem
// 0x0070 (0x0070 - 0x0000)
struct FNodeItem final
{
public:
	class FName                                   ParentName;                                        // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNodeItem) == 0x000010, "Wrong alignment on FNodeItem");
//(sizeof(FNodeItem) == 0x000070, "Wrong size on FNodeItem");
//(offsetof(FNodeItem, ParentName) == 0x000000, "Member 'FNodeItem::ParentName' has a wrong offset!");
//(offsetof(FNodeItem, Transform) == 0x000010, "Member 'FNodeItem::Transform' has a wrong offset!");

// ScriptStruct Engine.PoseData
// 0x0020 (0x0020 - 0x0000)
struct FPoseData final
{
public:
	TArray<struct FTransform>                     LocalSpacePose;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 CurveData;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FPoseData) == 0x000008, "Wrong alignment on FPoseData");
//(sizeof(FPoseData) == 0x000020, "Wrong size on FPoseData");
//(offsetof(FPoseData, LocalSpacePose) == 0x000000, "Member 'FPoseData::LocalSpacePose' has a wrong offset!");
//(offsetof(FPoseData, CurveData) == 0x000010, "Member 'FPoseData::CurveData' has a wrong offset!");

// ScriptStruct Engine.PoseAssetInfluence
// 0x0008 (0x0008 - 0x0000)
struct FPoseAssetInfluence final
{
public:
	int32                                         PoseIndex;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneTransformIndex;                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPoseAssetInfluence) == 0x000004, "Wrong alignment on FPoseAssetInfluence");
//(sizeof(FPoseAssetInfluence) == 0x000008, "Wrong size on FPoseAssetInfluence");
//(offsetof(FPoseAssetInfluence, PoseIndex) == 0x000000, "Member 'FPoseAssetInfluence::PoseIndex' has a wrong offset!");
//(offsetof(FPoseAssetInfluence, BoneTransformIndex) == 0x000004, "Member 'FPoseAssetInfluence::BoneTransformIndex' has a wrong offset!");

// ScriptStruct Engine.PoseAssetInfluences
// 0x0010 (0x0010 - 0x0000)
struct FPoseAssetInfluences final
{
public:
	TArray<struct FPoseAssetInfluence>            Influences;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FPoseAssetInfluences) == 0x000008, "Wrong alignment on FPoseAssetInfluences");
//(sizeof(FPoseAssetInfluences) == 0x000010, "Wrong size on FPoseAssetInfluences");
//(offsetof(FPoseAssetInfluences, Influences) == 0x000000, "Member 'FPoseAssetInfluences::Influences' has a wrong offset!");

// ScriptStruct Engine.PoseDataContainer
// 0x0070 (0x0070 - 0x0000)
struct FPoseDataContainer final
{
public:
	TArray<class FName>                           PoseFNames;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tracks;                                            // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 TrackBoneIndices;                                  // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPoseAssetInfluences>           TrackPoseInfluenceIndices;                         // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPoseData>                      Poses;                                             // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAnimCurveBase>                 Curves;                                            // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
//(alignof(FPoseDataContainer) == 0x000008, "Wrong alignment on FPoseDataContainer");
//(sizeof(FPoseDataContainer) == 0x000070, "Wrong size on FPoseDataContainer");
//(offsetof(FPoseDataContainer, PoseFNames) == 0x000000, "Member 'FPoseDataContainer::PoseFNames' has a wrong offset!");
//(offsetof(FPoseDataContainer, Tracks) == 0x000020, "Member 'FPoseDataContainer::Tracks' has a wrong offset!");
//(offsetof(FPoseDataContainer, TrackBoneIndices) == 0x000030, "Member 'FPoseDataContainer::TrackBoneIndices' has a wrong offset!");
//(offsetof(FPoseDataContainer, TrackPoseInfluenceIndices) == 0x000040, "Member 'FPoseDataContainer::TrackPoseInfluenceIndices' has a wrong offset!");
//(offsetof(FPoseDataContainer, Poses) == 0x000050, "Member 'FPoseDataContainer::Poses' has a wrong offset!");
//(offsetof(FPoseDataContainer, Curves) == 0x000060, "Member 'FPoseDataContainer::Curves' has a wrong offset!");

// ScriptStruct Engine.PreviewAttachedObjectPair
// 0x0040 (0x0040 - 0x0000)
struct FPreviewAttachedObjectPair final
{
public:
	TSoftObjectPtr<class UObject>                 AttachedObject;                                    // 0x0000(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AttachedTo;                                        // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPreviewAttachedObjectPair) == 0x000008, "Wrong alignment on FPreviewAttachedObjectPair");
//(sizeof(FPreviewAttachedObjectPair) == 0x000040, "Wrong size on FPreviewAttachedObjectPair");
//(offsetof(FPreviewAttachedObjectPair, AttachedObject) == 0x000000, "Member 'FPreviewAttachedObjectPair::AttachedObject' has a wrong offset!");
//(offsetof(FPreviewAttachedObjectPair, AttachedTo) == 0x000030, "Member 'FPreviewAttachedObjectPair::AttachedTo' has a wrong offset!");

// ScriptStruct Engine.PreviewAssetAttachContainer
// 0x0010 (0x0010 - 0x0000)
struct FPreviewAssetAttachContainer final
{
public:
	TArray<struct FPreviewAttachedObjectPair>     AttachedObjects;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
//(alignof(FPreviewAssetAttachContainer) == 0x000008, "Wrong alignment on FPreviewAssetAttachContainer");
//(sizeof(FPreviewAssetAttachContainer) == 0x000010, "Wrong size on FPreviewAssetAttachContainer");
//(offsetof(FPreviewAssetAttachContainer, AttachedObjects) == 0x000000, "Member 'FPreviewAssetAttachContainer::AttachedObjects' has a wrong offset!");

// ScriptStruct Engine.PreviewMeshCollectionEntry
// 0x0060 (0x0060 - 0x0000)
struct FPreviewMeshCollectionEntry final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimBlueprint>          AnimBlueprint;                                     // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPreviewMeshCollectionEntry) == 0x000008, "Wrong alignment on FPreviewMeshCollectionEntry");
//(sizeof(FPreviewMeshCollectionEntry) == 0x000060, "Wrong size on FPreviewMeshCollectionEntry");
//(offsetof(FPreviewMeshCollectionEntry, SkeletalMesh) == 0x000000, "Member 'FPreviewMeshCollectionEntry::SkeletalMesh' has a wrong offset!");
//(offsetof(FPreviewMeshCollectionEntry, AnimBlueprint) == 0x000030, "Member 'FPreviewMeshCollectionEntry::AnimBlueprint' has a wrong offset!");

// ScriptStruct Engine.Node
// 0x00A0 (0x00A0 - 0x0000)
struct FNode final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentName;                                        // 0x000C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdvanced;                                         // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0xF];                                       // 0x0091(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FNode) == 0x000010, "Wrong alignment on FNode");
//(sizeof(FNode) == 0x0000A0, "Wrong size on FNode");
//(offsetof(FNode, Name) == 0x000000, "Member 'FNode::Name' has a wrong offset!");
//(offsetof(FNode, ParentName) == 0x00000C, "Member 'FNode::ParentName' has a wrong offset!");
//(offsetof(FNode, Transform) == 0x000020, "Member 'FNode::Transform' has a wrong offset!");
//(offsetof(FNode, DisplayName) == 0x000080, "Member 'FNode::DisplayName' has a wrong offset!");
//(offsetof(FNode, bAdvanced) == 0x000090, "Member 'FNode::bAdvanced' has a wrong offset!");

// ScriptStruct Engine.RigTransformConstraint
// 0x0014 (0x0014 - 0x0000)
struct FRigTransformConstraint final
{
public:
	EConstraintTransform                          TranformType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParentSpace;                                       // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRigTransformConstraint) == 0x000004, "Wrong alignment on FRigTransformConstraint");
//(sizeof(FRigTransformConstraint) == 0x000014, "Wrong size on FRigTransformConstraint");
//(offsetof(FRigTransformConstraint, TranformType) == 0x000000, "Member 'FRigTransformConstraint::TranformType' has a wrong offset!");
//(offsetof(FRigTransformConstraint, ParentSpace) == 0x000004, "Member 'FRigTransformConstraint::ParentSpace' has a wrong offset!");
//(offsetof(FRigTransformConstraint, Weight) == 0x000010, "Member 'FRigTransformConstraint::Weight' has a wrong offset!");

// ScriptStruct Engine.ActorPlacementDataLayers
// 0x0018 (0x0018 - 0x0000)
struct FActorPlacementDataLayers final
{
public:
	TArray<class FName>                           DataLayerInstanceNames;                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ContextID;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FActorPlacementDataLayers) == 0x000008, "Wrong alignment on FActorPlacementDataLayers");
//(sizeof(FActorPlacementDataLayers) == 0x000018, "Wrong size on FActorPlacementDataLayers");
//(offsetof(FActorPlacementDataLayers, DataLayerInstanceNames) == 0x000000, "Member 'FActorPlacementDataLayers::DataLayerInstanceNames' has a wrong offset!");
//(offsetof(FActorPlacementDataLayers, ContextID) == 0x000010, "Member 'FActorPlacementDataLayers::ContextID' has a wrong offset!");

// ScriptStruct Engine.TransformBaseConstraint
// 0x0010 (0x0010 - 0x0000)
struct FTransformBaseConstraint final
{
public:
	TArray<struct FRigTransformConstraint>        TransformConstraints;                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FTransformBaseConstraint) == 0x000008, "Wrong alignment on FTransformBaseConstraint");
//(sizeof(FTransformBaseConstraint) == 0x000010, "Wrong size on FTransformBaseConstraint");
//(offsetof(FTransformBaseConstraint, TransformConstraints) == 0x000000, "Member 'FTransformBaseConstraint::TransformConstraints' has a wrong offset!");

// ScriptStruct Engine.TransformBase
// 0x0030 (0x0030 - 0x0000)
struct FTransformBase final
{
public:
	class FName                                   Node;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransformBaseConstraint               Constraints[0x2];                                  // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
};
//(alignof(FTransformBase) == 0x000008, "Wrong alignment on FTransformBase");
//(sizeof(FTransformBase) == 0x000030, "Wrong size on FTransformBase");
//(offsetof(FTransformBase, Node) == 0x000000, "Member 'FTransformBase::Node' has a wrong offset!");
//(offsetof(FTransformBase, Constraints) == 0x000010, "Member 'FTransformBase::Constraints' has a wrong offset!");

// ScriptStruct Engine.PerPlatformBool
// 0x0001 (0x0001 - 0x0000)
struct FPerPlatformBool final
{
public:
	bool                                          Default;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPerPlatformBool) == 0x000001, "Wrong alignment on FPerPlatformBool");
//(sizeof(FPerPlatformBool) == 0x000001, "Wrong size on FPerPlatformBool");
//(offsetof(FPerPlatformBool, Default) == 0x000000, "Member 'FPerPlatformBool::Default' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshVertexAttributeInfo
// 0x0014 (0x0014 - 0x0000)
struct FSkeletalMeshVertexAttributeInfo final
{
public:
	struct FPerPlatformBool                       EnabledForRender;                                  // 0x0000(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkeletalMeshVertexAttributeDataType          DataType;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSkeletalMeshVertexAttributeInfo) == 0x000004, "Wrong alignment on FSkeletalMeshVertexAttributeInfo");
//(sizeof(FSkeletalMeshVertexAttributeInfo) == 0x000014, "Wrong size on FSkeletalMeshVertexAttributeInfo");
//(offsetof(FSkeletalMeshVertexAttributeInfo, EnabledForRender) == 0x000000, "Member 'FSkeletalMeshVertexAttributeInfo::EnabledForRender' has a wrong offset!");
//(offsetof(FSkeletalMeshVertexAttributeInfo, Name) == 0x000004, "Member 'FSkeletalMeshVertexAttributeInfo::Name' has a wrong offset!");
//(offsetof(FSkeletalMeshVertexAttributeInfo, DataType) == 0x000010, "Member 'FSkeletalMeshVertexAttributeInfo::DataType' has a wrong offset!");

// ScriptStruct Engine.WorldPartitionPerWorldSettings
// 0x0001 (0x0001 - 0x0000)
struct FWorldPartitionPerWorldSettings final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FWorldPartitionPerWorldSettings) == 0x000001, "Wrong alignment on FWorldPartitionPerWorldSettings");
//(sizeof(FWorldPartitionPerWorldSettings) == 0x000001, "Wrong size on FWorldPartitionPerWorldSettings");

// ScriptStruct Engine.SkeletonToMeshLinkup
// 0x0020 (0x0020 - 0x0000)
struct FSkeletonToMeshLinkup final
{
public:
	TArray<int32>                                 SkeletonToMeshTable;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MeshToSkeletonTable;                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FSkeletonToMeshLinkup) == 0x000008, "Wrong alignment on FSkeletonToMeshLinkup");
//(sizeof(FSkeletonToMeshLinkup) == 0x000020, "Wrong size on FSkeletonToMeshLinkup");
//(offsetof(FSkeletonToMeshLinkup, SkeletonToMeshTable) == 0x000000, "Member 'FSkeletonToMeshLinkup::SkeletonToMeshTable' has a wrong offset!");
//(offsetof(FSkeletonToMeshLinkup, MeshToSkeletonTable) == 0x000010, "Member 'FSkeletonToMeshLinkup::MeshToSkeletonTable' has a wrong offset!");

// ScriptStruct Engine.BoneNode
// 0x0001 (0x0001 - 0x0000)
struct FBoneNode final
{
public:
	EBoneTranslationRetargetingMode               TranslationRetargetingMode;                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBoneNode) == 0x000001, "Wrong alignment on FBoneNode");
//(sizeof(FBoneNode) == 0x000001, "Wrong size on FBoneNode");
//(offsetof(FBoneNode, TranslationRetargetingMode) == 0x000000, "Member 'FBoneNode::TranslationRetargetingMode' has a wrong offset!");

// ScriptStruct Engine.ReferencePose
// 0x0020 (0x0020 - 0x0000)
struct FReferencePose final
{
public:
	class FName                                   PoseName;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     ReferencePose;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FReferencePose) == 0x000008, "Wrong alignment on FReferencePose");
//(sizeof(FReferencePose) == 0x000020, "Wrong size on FReferencePose");
//(offsetof(FReferencePose, PoseName) == 0x000000, "Member 'FReferencePose::PoseName' has a wrong offset!");
//(offsetof(FReferencePose, ReferencePose) == 0x000010, "Member 'FReferencePose::ReferencePose' has a wrong offset!");

// ScriptStruct Engine.BoneReductionSetting
// 0x0010 (0x0010 - 0x0000)
struct FBoneReductionSetting final
{
public:
	TArray<class FName>                           BonesToRemove;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FBoneReductionSetting) == 0x000008, "Wrong alignment on FBoneReductionSetting");
//(sizeof(FBoneReductionSetting) == 0x000010, "Wrong size on FBoneReductionSetting");
//(offsetof(FBoneReductionSetting, BonesToRemove) == 0x000000, "Member 'FBoneReductionSetting::BonesToRemove' has a wrong offset!");

// ScriptStruct Engine.NameMapping
// 0x0018 (0x0018 - 0x0000)
struct FNameMapping final
{
public:
	class FName                                   NodeName;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNameMapping) == 0x000004, "Wrong alignment on FNameMapping");
//(sizeof(FNameMapping) == 0x000018, "Wrong size on FNameMapping");
//(offsetof(FNameMapping, NodeName) == 0x000000, "Member 'FNameMapping::NodeName' has a wrong offset!");
//(offsetof(FNameMapping, BoneName) == 0x00000C, "Member 'FNameMapping::BoneName' has a wrong offset!");

// ScriptStruct Engine.RigConfiguration
// 0x0018 (0x0018 - 0x0000)
struct FRigConfiguration final
{
public:
	class URig*                                   Rig;                                               // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNameMapping>                   BoneMappingTable;                                  // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FRigConfiguration) == 0x000008, "Wrong alignment on FRigConfiguration");
//(sizeof(FRigConfiguration) == 0x000018, "Wrong size on FRigConfiguration");
//(offsetof(FRigConfiguration, Rig) == 0x000000, "Member 'FRigConfiguration::Rig' has a wrong offset!");
//(offsetof(FRigConfiguration, BoneMappingTable) == 0x000008, "Member 'FRigConfiguration::BoneMappingTable' has a wrong offset!");

// ScriptStruct Engine.AnimSlotGroup
// 0x0020 (0x0020 - 0x0000)
struct FAnimSlotGroup final
{
public:
	class FName                                   GroupName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SlotNames;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FAnimSlotGroup) == 0x000008, "Wrong alignment on FAnimSlotGroup");
//(sizeof(FAnimSlotGroup) == 0x000020, "Wrong size on FAnimSlotGroup");
//(offsetof(FAnimSlotGroup, GroupName) == 0x000000, "Member 'FAnimSlotGroup::GroupName' has a wrong offset!");
//(offsetof(FAnimSlotGroup, SlotNames) == 0x000010, "Member 'FAnimSlotGroup::SlotNames' has a wrong offset!");

// ScriptStruct Engine.VirtualBone
// 0x0024 (0x0024 - 0x0000)
struct FVirtualBone final
{
public:
	class FName                                   SourceBoneName;                                    // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetBoneName;                                    // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VirtualBoneName;                                   // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FVirtualBone) == 0x000004, "Wrong alignment on FVirtualBone");
//(sizeof(FVirtualBone) == 0x000024, "Wrong size on FVirtualBone");
//(offsetof(FVirtualBone, SourceBoneName) == 0x000000, "Member 'FVirtualBone::SourceBoneName' has a wrong offset!");
//(offsetof(FVirtualBone, TargetBoneName) == 0x00000C, "Member 'FVirtualBone::TargetBoneName' has a wrong offset!");
//(offsetof(FVirtualBone, VirtualBoneName) == 0x000018, "Member 'FVirtualBone::VirtualBoneName' has a wrong offset!");

// ScriptStruct Engine.StreamingSourceShape
// 0x0048 (0x0048 - 0x0000)
struct FStreamingSourceShape final
{
public:
	bool                                          bUseGridLoadingRange;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoadingRangeScale;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSector;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SectorAngle;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FStreamingSourceShape) == 0x000008, "Wrong alignment on FStreamingSourceShape");
//(sizeof(FStreamingSourceShape) == 0x000048, "Wrong size on FStreamingSourceShape");
//(offsetof(FStreamingSourceShape, bUseGridLoadingRange) == 0x000000, "Member 'FStreamingSourceShape::bUseGridLoadingRange' has a wrong offset!");
//(offsetof(FStreamingSourceShape, LoadingRangeScale) == 0x000004, "Member 'FStreamingSourceShape::LoadingRangeScale' has a wrong offset!");
//(offsetof(FStreamingSourceShape, Radius) == 0x000008, "Member 'FStreamingSourceShape::Radius' has a wrong offset!");
//(offsetof(FStreamingSourceShape, bIsSector) == 0x00000C, "Member 'FStreamingSourceShape::bIsSector' has a wrong offset!");
//(offsetof(FStreamingSourceShape, SectorAngle) == 0x000010, "Member 'FStreamingSourceShape::SectorAngle' has a wrong offset!");
//(offsetof(FStreamingSourceShape, Location) == 0x000018, "Member 'FStreamingSourceShape::Location' has a wrong offset!");
//(offsetof(FStreamingSourceShape, Rotation) == 0x000030, "Member 'FStreamingSourceShape::Rotation' has a wrong offset!");

// ScriptStruct Engine.SkinWeightProfileInfo
// 0x0014 (0x0014 - 0x0000)
struct FSkinWeightProfileInfo final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerPlatformBool                       DefaultProfile;                                    // 0x000C(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerPlatformInt                        DefaultProfileFromLODIndex;                        // 0x0010(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FSkinWeightProfileInfo) == 0x000004, "Wrong alignment on FSkinWeightProfileInfo");
//(sizeof(FSkinWeightProfileInfo) == 0x000014, "Wrong size on FSkinWeightProfileInfo");
//(offsetof(FSkinWeightProfileInfo, Name) == 0x000000, "Member 'FSkinWeightProfileInfo::Name' has a wrong offset!");
//(offsetof(FSkinWeightProfileInfo, DefaultProfile) == 0x00000C, "Member 'FSkinWeightProfileInfo::DefaultProfile' has a wrong offset!");
//(offsetof(FSkinWeightProfileInfo, DefaultProfileFromLODIndex) == 0x000010, "Member 'FSkinWeightProfileInfo::DefaultProfileFromLODIndex' has a wrong offset!");

// ScriptStruct Engine.SkinWeightProfileManagerTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FSkinWeightProfileManagerTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkinWeightProfileManagerTickFunction) == 0x000008, "Wrong alignment on FSkinWeightProfileManagerTickFunction");
//(sizeof(FSkinWeightProfileManagerTickFunction) == 0x000038, "Wrong size on FSkinWeightProfileManagerTickFunction");

// ScriptStruct Engine.SmartNameMapping
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FSmartNameMapping final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSmartNameMapping) == 0x000008, "Wrong alignment on FSmartNameMapping");
//(sizeof(FSmartNameMapping) == 0x000070, "Wrong size on FSmartNameMapping");

// ScriptStruct Engine.SmartNameContainer
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FSmartNameContainer final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSmartNameContainer) == 0x000008, "Wrong alignment on FSmartNameContainer");
//(sizeof(FSmartNameContainer) == 0x000050, "Wrong size on FSmartNameContainer");

// ScriptStruct Engine.MaterialRemapIndex
// 0x0018 (0x0018 - 0x0000)
struct FMaterialRemapIndex final
{
public:
	uint32                                        ImportVersionKey;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 MaterialRemap;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialRemapIndex) == 0x000008, "Wrong alignment on FMaterialRemapIndex");
//(sizeof(FMaterialRemapIndex) == 0x000018, "Wrong size on FMaterialRemapIndex");
//(offsetof(FMaterialRemapIndex, ImportVersionKey) == 0x000000, "Member 'FMaterialRemapIndex::ImportVersionKey' has a wrong offset!");
//(offsetof(FMaterialRemapIndex, MaterialRemap) == 0x000008, "Member 'FMaterialRemapIndex::MaterialRemap' has a wrong offset!");

// ScriptStruct Engine.SmartName
// 0x0010 (0x0010 - 0x0000)
struct FSmartName final
{
public:
	class FName                                   DisplayName;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSmartName) == 0x000004, "Wrong alignment on FSmartName");
//(sizeof(FSmartName) == 0x000010, "Wrong size on FSmartName");
//(offsetof(FSmartName, DisplayName) == 0x000000, "Member 'FSmartName::DisplayName' has a wrong offset!");

// ScriptStruct Engine.TimeStretchCurveMarker
// 0x0010 (0x0010 - 0x0000)
struct FTimeStretchCurveMarker final
{
public:
	float                                         Time[0x3];                                         // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTimeStretchCurveMarker) == 0x000004, "Wrong alignment on FTimeStretchCurveMarker");
//(sizeof(FTimeStretchCurveMarker) == 0x000010, "Wrong size on FTimeStretchCurveMarker");
//(offsetof(FTimeStretchCurveMarker, Time) == 0x000000, "Member 'FTimeStretchCurveMarker::Time' has a wrong offset!");
//(offsetof(FTimeStretchCurveMarker, Alpha) == 0x00000C, "Member 'FTimeStretchCurveMarker::Alpha' has a wrong offset!");

// ScriptStruct Engine.TimeStretchCurve
// 0x0028 (0x0028 - 0x0000)
struct FTimeStretchCurve final
{
public:
	float                                         SamplingRate;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurveValueMinPrecision;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTimeStretchCurveMarker>        Markers;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	float                                         Sum_dT_i_by_C_i[0x3];                              // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTimeStretchCurve) == 0x000008, "Wrong alignment on FTimeStretchCurve");
//(sizeof(FTimeStretchCurve) == 0x000028, "Wrong size on FTimeStretchCurve");
//(offsetof(FTimeStretchCurve, SamplingRate) == 0x000000, "Member 'FTimeStretchCurve::SamplingRate' has a wrong offset!");
//(offsetof(FTimeStretchCurve, CurveValueMinPrecision) == 0x000004, "Member 'FTimeStretchCurve::CurveValueMinPrecision' has a wrong offset!");
//(offsetof(FTimeStretchCurve, Markers) == 0x000008, "Member 'FTimeStretchCurve::Markers' has a wrong offset!");
//(offsetof(FTimeStretchCurve, Sum_dT_i_by_C_i) == 0x000018, "Member 'FTimeStretchCurve::Sum_dT_i_by_C_i' has a wrong offset!");

// ScriptStruct Engine.TimeStretchCurveInstance
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FTimeStretchCurveInstance final
{
public:
	bool                                          bHasValidData;                                     // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x2F];                                       // 0x0001(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTimeStretchCurveInstance) == 0x000008, "Wrong alignment on FTimeStretchCurveInstance");
//(sizeof(FTimeStretchCurveInstance) == 0x000030, "Wrong size on FTimeStretchCurveInstance");
//(offsetof(FTimeStretchCurveInstance, bHasValidData) == 0x000000, "Member 'FTimeStretchCurveInstance::bHasValidData' has a wrong offset!");

// ScriptStruct Engine.AssetCompileData
// 0x0008 (0x0008 - 0x0000)
struct FAssetCompileData final
{
public:
	TWeakObjectPtr<class UObject>                 Asset;                                             // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAssetCompileData) == 0x000004, "Wrong alignment on FAssetCompileData");
//(sizeof(FAssetCompileData) == 0x000008, "Wrong size on FAssetCompileData");
//(offsetof(FAssetCompileData, Asset) == 0x000000, "Member 'FAssetCompileData::Asset' has a wrong offset!");

// ScriptStruct Engine.PrimaryAssetTypeInfo
// 0x0098 (0x0098 - 0x0000)
struct FPrimaryAssetTypeInfo final
{
public:
	class FName                                   PrimaryAssetType;                                  // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AssetBaseClass;                                    // 0x0010(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UObject>                    AssetBaseClassLoaded;                              // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBlueprintClasses;                              // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEditorOnly;                                     // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDirectoryPath>                 Directories;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSoftObjectPath>                SpecificAssets;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FPrimaryAssetRules                     Rules;                                             // 0x0070(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         AssetScanPaths;                                    // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bIsDynamicAsset;                                   // 0x0090(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfAssets;                                    // 0x0094(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPrimaryAssetTypeInfo) == 0x000008, "Wrong alignment on FPrimaryAssetTypeInfo");
//(sizeof(FPrimaryAssetTypeInfo) == 0x000098, "Wrong size on FPrimaryAssetTypeInfo");
//(offsetof(FPrimaryAssetTypeInfo, PrimaryAssetType) == 0x000000, "Member 'FPrimaryAssetTypeInfo::PrimaryAssetType' has a wrong offset!");
//(offsetof(FPrimaryAssetTypeInfo, AssetBaseClass) == 0x000010, "Member 'FPrimaryAssetTypeInfo::AssetBaseClass' has a wrong offset!");
//(offsetof(FPrimaryAssetTypeInfo, AssetBaseClassLoaded) == 0x000040, "Member 'FPrimaryAssetTypeInfo::AssetBaseClassLoaded' has a wrong offset!");
//(offsetof(FPrimaryAssetTypeInfo, bHasBlueprintClasses) == 0x000048, "Member 'FPrimaryAssetTypeInfo::bHasBlueprintClasses' has a wrong offset!");
//(offsetof(FPrimaryAssetTypeInfo, bIsEditorOnly) == 0x000049, "Member 'FPrimaryAssetTypeInfo::bIsEditorOnly' has a wrong offset!");
//(offsetof(FPrimaryAssetTypeInfo, Directories) == 0x000050, "Member 'FPrimaryAssetTypeInfo::Directories' has a wrong offset!");
//(offsetof(FPrimaryAssetTypeInfo, SpecificAssets) == 0x000060, "Member 'FPrimaryAssetTypeInfo::SpecificAssets' has a wrong offset!");
//(offsetof(FPrimaryAssetTypeInfo, Rules) == 0x000070, "Member 'FPrimaryAssetTypeInfo::Rules' has a wrong offset!");
//(offsetof(FPrimaryAssetTypeInfo, AssetScanPaths) == 0x000080, "Member 'FPrimaryAssetTypeInfo::AssetScanPaths' has a wrong offset!");
//(offsetof(FPrimaryAssetTypeInfo, bIsDynamicAsset) == 0x000090, "Member 'FPrimaryAssetTypeInfo::bIsDynamicAsset' has a wrong offset!");
//(offsetof(FPrimaryAssetTypeInfo, NumberOfAssets) == 0x000094, "Member 'FPrimaryAssetTypeInfo::NumberOfAssets' has a wrong offset!");

// ScriptStruct Engine.BuildPromotionOpenAssetSettings
// 0x0060 (0x0060 - 0x0000)
struct FBuildPromotionOpenAssetSettings final
{
public:
	struct FFilePath                              BlueprintAsset;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              MaterialAsset;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              ParticleSystemAsset;                               // 0x0020(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              SkeletalMeshAsset;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              StaticMeshAsset;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              TextureAsset;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBuildPromotionOpenAssetSettings) == 0x000008, "Wrong alignment on FBuildPromotionOpenAssetSettings");
//(sizeof(FBuildPromotionOpenAssetSettings) == 0x000060, "Wrong size on FBuildPromotionOpenAssetSettings");
//(offsetof(FBuildPromotionOpenAssetSettings, BlueprintAsset) == 0x000000, "Member 'FBuildPromotionOpenAssetSettings::BlueprintAsset' has a wrong offset!");
//(offsetof(FBuildPromotionOpenAssetSettings, MaterialAsset) == 0x000010, "Member 'FBuildPromotionOpenAssetSettings::MaterialAsset' has a wrong offset!");
//(offsetof(FBuildPromotionOpenAssetSettings, ParticleSystemAsset) == 0x000020, "Member 'FBuildPromotionOpenAssetSettings::ParticleSystemAsset' has a wrong offset!");
//(offsetof(FBuildPromotionOpenAssetSettings, SkeletalMeshAsset) == 0x000030, "Member 'FBuildPromotionOpenAssetSettings::SkeletalMeshAsset' has a wrong offset!");
//(offsetof(FBuildPromotionOpenAssetSettings, StaticMeshAsset) == 0x000040, "Member 'FBuildPromotionOpenAssetSettings::StaticMeshAsset' has a wrong offset!");
//(offsetof(FBuildPromotionOpenAssetSettings, TextureAsset) == 0x000050, "Member 'FBuildPromotionOpenAssetSettings::TextureAsset' has a wrong offset!");

// ScriptStruct Engine.AssetManagerSearchRules
// 0x0050 (0x0050 - 0x0000)
struct FAssetManagerSearchRules final
{
public:
	TArray<class FString>                         AssetScanPaths;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         IncludePatterns;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExcludePatterns;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    AssetBaseClass;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBlueprintClasses;                              // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSynchronousScan;                             // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipVirtualPathExpansion;                         // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipManagerIncludeCheck;                          // 0x003B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x14];                                      // 0x003C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAssetManagerSearchRules) == 0x000008, "Wrong alignment on FAssetManagerSearchRules");
//(sizeof(FAssetManagerSearchRules) == 0x000050, "Wrong size on FAssetManagerSearchRules");
//(offsetof(FAssetManagerSearchRules, AssetScanPaths) == 0x000000, "Member 'FAssetManagerSearchRules::AssetScanPaths' has a wrong offset!");
//(offsetof(FAssetManagerSearchRules, IncludePatterns) == 0x000010, "Member 'FAssetManagerSearchRules::IncludePatterns' has a wrong offset!");
//(offsetof(FAssetManagerSearchRules, ExcludePatterns) == 0x000020, "Member 'FAssetManagerSearchRules::ExcludePatterns' has a wrong offset!");
//(offsetof(FAssetManagerSearchRules, AssetBaseClass) == 0x000030, "Member 'FAssetManagerSearchRules::AssetBaseClass' has a wrong offset!");
//(offsetof(FAssetManagerSearchRules, bHasBlueprintClasses) == 0x000038, "Member 'FAssetManagerSearchRules::bHasBlueprintClasses' has a wrong offset!");
//(offsetof(FAssetManagerSearchRules, bForceSynchronousScan) == 0x000039, "Member 'FAssetManagerSearchRules::bForceSynchronousScan' has a wrong offset!");
//(offsetof(FAssetManagerSearchRules, bSkipVirtualPathExpansion) == 0x00003A, "Member 'FAssetManagerSearchRules::bSkipVirtualPathExpansion' has a wrong offset!");
//(offsetof(FAssetManagerSearchRules, bSkipManagerIncludeCheck) == 0x00003B, "Member 'FAssetManagerSearchRules::bSkipManagerIncludeCheck' has a wrong offset!");

// ScriptStruct Engine.AudioReverbEffect
// 0x0040 (0x0048 - 0x0008)
struct FAudioReverbEffect final : public FAudioEffectParameters
{
public:
	uint8                                         Pad_8[0x40];                                       // 0x0008(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAudioReverbEffect) == 0x000008, "Wrong alignment on FAudioReverbEffect");
//(sizeof(FAudioReverbEffect) == 0x000048, "Wrong size on FAudioReverbEffect");

// ScriptStruct Engine.AudioQualitySettings
// 0x0020 (0x0020 - 0x0000)
struct FAudioQualitySettings final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         MaxChannels;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAudioQualitySettings) == 0x000008, "Wrong alignment on FAudioQualitySettings");
//(sizeof(FAudioQualitySettings) == 0x000020, "Wrong size on FAudioQualitySettings");
//(offsetof(FAudioQualitySettings, DisplayName) == 0x000000, "Member 'FAudioQualitySettings::DisplayName' has a wrong offset!");
//(offsetof(FAudioQualitySettings, MaxChannels) == 0x000018, "Member 'FAudioQualitySettings::MaxChannels' has a wrong offset!");

// ScriptStruct Engine.SoundSubmixSendInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FSoundSubmixSendInfo final
{
public:
	ESendLevelControlMethod                       SendLevelControlMethod;                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubmixSendStage                              SendStage;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSubmixBase*                       SoundSubmix;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendLevel;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableManualSendClamp;                            // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSendLevel;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSendLevel;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSendDistance;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSendDistance;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     CustomSendLevelCurve;                              // 0x0028(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
//(alignof(FSoundSubmixSendInfo) == 0x000008, "Wrong alignment on FSoundSubmixSendInfo");
//(sizeof(FSoundSubmixSendInfo) == 0x0000B0, "Wrong size on FSoundSubmixSendInfo");
//(offsetof(FSoundSubmixSendInfo, SendLevelControlMethod) == 0x000000, "Member 'FSoundSubmixSendInfo::SendLevelControlMethod' has a wrong offset!");
//(offsetof(FSoundSubmixSendInfo, SendStage) == 0x000001, "Member 'FSoundSubmixSendInfo::SendStage' has a wrong offset!");
//(offsetof(FSoundSubmixSendInfo, SoundSubmix) == 0x000008, "Member 'FSoundSubmixSendInfo::SoundSubmix' has a wrong offset!");
//(offsetof(FSoundSubmixSendInfo, SendLevel) == 0x000010, "Member 'FSoundSubmixSendInfo::SendLevel' has a wrong offset!");
//(offsetof(FSoundSubmixSendInfo, DisableManualSendClamp) == 0x000014, "Member 'FSoundSubmixSendInfo::DisableManualSendClamp' has a wrong offset!");
//(offsetof(FSoundSubmixSendInfo, MinSendLevel) == 0x000018, "Member 'FSoundSubmixSendInfo::MinSendLevel' has a wrong offset!");
//(offsetof(FSoundSubmixSendInfo, MaxSendLevel) == 0x00001C, "Member 'FSoundSubmixSendInfo::MaxSendLevel' has a wrong offset!");
//(offsetof(FSoundSubmixSendInfo, MinSendDistance) == 0x000020, "Member 'FSoundSubmixSendInfo::MinSendDistance' has a wrong offset!");
//(offsetof(FSoundSubmixSendInfo, MaxSendDistance) == 0x000024, "Member 'FSoundSubmixSendInfo::MaxSendDistance' has a wrong offset!");
//(offsetof(FSoundSubmixSendInfo, CustomSendLevelCurve) == 0x000028, "Member 'FSoundSubmixSendInfo::CustomSendLevelCurve' has a wrong offset!");

// ScriptStruct Engine.AudioVolumeSubmixSendSettings
// 0x0018 (0x0018 - 0x0000)
struct FAudioVolumeSubmixSendSettings final
{
public:
	EAudioVolumeLocationState                     ListenerLocationState;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAudioVolumeLocationState                     SourceLocationState;                               // 0x0001(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoundSubmixSendInfo>           SubmixSends;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FAudioVolumeSubmixSendSettings) == 0x000008, "Wrong alignment on FAudioVolumeSubmixSendSettings");
//(sizeof(FAudioVolumeSubmixSendSettings) == 0x000018, "Wrong size on FAudioVolumeSubmixSendSettings");
//(offsetof(FAudioVolumeSubmixSendSettings, ListenerLocationState) == 0x000000, "Member 'FAudioVolumeSubmixSendSettings::ListenerLocationState' has a wrong offset!");
//(offsetof(FAudioVolumeSubmixSendSettings, SourceLocationState) == 0x000001, "Member 'FAudioVolumeSubmixSendSettings::SourceLocationState' has a wrong offset!");
//(offsetof(FAudioVolumeSubmixSendSettings, SubmixSends) == 0x000008, "Member 'FAudioVolumeSubmixSendSettings::SubmixSends' has a wrong offset!");

// ScriptStruct Engine.AudioVolumeSubmixOverrideSettings
// 0x0020 (0x0020 - 0x0000)
struct FAudioVolumeSubmixOverrideSettings final
{
public:
	class USoundSubmix*                           Submix;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundEffectSubmixPreset*>       SubmixEffectChain;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CrossfadeTime;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAudioVolumeSubmixOverrideSettings) == 0x000008, "Wrong alignment on FAudioVolumeSubmixOverrideSettings");
//(sizeof(FAudioVolumeSubmixOverrideSettings) == 0x000020, "Wrong size on FAudioVolumeSubmixOverrideSettings");
//(offsetof(FAudioVolumeSubmixOverrideSettings, Submix) == 0x000000, "Member 'FAudioVolumeSubmixOverrideSettings::Submix' has a wrong offset!");
//(offsetof(FAudioVolumeSubmixOverrideSettings, SubmixEffectChain) == 0x000008, "Member 'FAudioVolumeSubmixOverrideSettings::SubmixEffectChain' has a wrong offset!");
//(offsetof(FAudioVolumeSubmixOverrideSettings, CrossfadeTime) == 0x000018, "Member 'FAudioVolumeSubmixOverrideSettings::CrossfadeTime' has a wrong offset!");

// ScriptStruct Engine.InteriorSettings
// 0x0024 (0x0024 - 0x0000)
struct FInteriorSettings final
{
public:
	bool                                          bIsWorldSettings;                                  // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExteriorVolume;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExteriorTime;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExteriorLPF;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExteriorLPFTime;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorVolume;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorTime;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorLPF;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorLPFTime;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FInteriorSettings) == 0x000004, "Wrong alignment on FInteriorSettings");
//(sizeof(FInteriorSettings) == 0x000024, "Wrong size on FInteriorSettings");
//(offsetof(FInteriorSettings, bIsWorldSettings) == 0x000000, "Member 'FInteriorSettings::bIsWorldSettings' has a wrong offset!");
//(offsetof(FInteriorSettings, ExteriorVolume) == 0x000004, "Member 'FInteriorSettings::ExteriorVolume' has a wrong offset!");
//(offsetof(FInteriorSettings, ExteriorTime) == 0x000008, "Member 'FInteriorSettings::ExteriorTime' has a wrong offset!");
//(offsetof(FInteriorSettings, ExteriorLPF) == 0x00000C, "Member 'FInteriorSettings::ExteriorLPF' has a wrong offset!");
//(offsetof(FInteriorSettings, ExteriorLPFTime) == 0x000010, "Member 'FInteriorSettings::ExteriorLPFTime' has a wrong offset!");
//(offsetof(FInteriorSettings, InteriorVolume) == 0x000014, "Member 'FInteriorSettings::InteriorVolume' has a wrong offset!");
//(offsetof(FInteriorSettings, InteriorTime) == 0x000018, "Member 'FInteriorSettings::InteriorTime' has a wrong offset!");
//(offsetof(FInteriorSettings, InteriorLPF) == 0x00001C, "Member 'FInteriorSettings::InteriorLPF' has a wrong offset!");
//(offsetof(FInteriorSettings, InteriorLPFTime) == 0x000020, "Member 'FInteriorSettings::InteriorLPFTime' has a wrong offset!");

// ScriptStruct Engine.NodeToCodeAssociation
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FNodeToCodeAssociation final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FNodeToCodeAssociation) == 0x000004, "Wrong alignment on FNodeToCodeAssociation");
//(sizeof(FNodeToCodeAssociation) == 0x000014, "Wrong size on FNodeToCodeAssociation");

// ScriptStruct Engine.DebuggingInfoForSingleFunction
// 0x0190 (0x0190 - 0x0000)
struct alignas(0x08) FDebuggingInfoForSingleFunction final
{
public:
	uint8                                         Pad_0[0x190];                                      // 0x0000(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDebuggingInfoForSingleFunction) == 0x000008, "Wrong alignment on FDebuggingInfoForSingleFunction");
//(sizeof(FDebuggingInfoForSingleFunction) == 0x000190, "Wrong size on FDebuggingInfoForSingleFunction");

// ScriptStruct Engine.EventGraphFastCallPair
// 0x0010 (0x0010 - 0x0000)
struct FEventGraphFastCallPair final
{
public:
	class UFunction*                              FunctionToPatch;                                   // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EventGraphCallOffset;                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FEventGraphFastCallPair) == 0x000008, "Wrong alignment on FEventGraphFastCallPair");
//(sizeof(FEventGraphFastCallPair) == 0x000010, "Wrong size on FEventGraphFastCallPair");
//(offsetof(FEventGraphFastCallPair, FunctionToPatch) == 0x000000, "Member 'FEventGraphFastCallPair::FunctionToPatch' has a wrong offset!");
//(offsetof(FEventGraphFastCallPair, EventGraphCallOffset) == 0x000008, "Member 'FEventGraphFastCallPair::EventGraphCallOffset' has a wrong offset!");

// ScriptStruct Engine.BPComponentClassOverride
// 0x0018 (0x0018 - 0x0000)
struct FBPComponentClassOverride final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    ComponentClass;                                    // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBPComponentClassOverride) == 0x000008, "Wrong alignment on FBPComponentClassOverride");
//(sizeof(FBPComponentClassOverride) == 0x000018, "Wrong size on FBPComponentClassOverride");
//(offsetof(FBPComponentClassOverride, ComponentName) == 0x000000, "Member 'FBPComponentClassOverride::ComponentName' has a wrong offset!");
//(offsetof(FBPComponentClassOverride, ComponentClass) == 0x000010, "Member 'FBPComponentClassOverride::ComponentClass' has a wrong offset!");

// ScriptStruct Engine.BookmarkJumpToSettings
// 0x0000 (0x0001 - 0x0001)
struct FBookmarkJumpToSettings final : public FBookmarkBaseJumpToSettings
{
};
//(alignof(FBookmarkJumpToSettings) == 0x000001, "Wrong alignment on FBookmarkJumpToSettings");
//(sizeof(FBookmarkJumpToSettings) == 0x000001, "Wrong size on FBookmarkJumpToSettings");

// ScriptStruct Engine.BuilderPoly
// 0x0028 (0x0028 - 0x0000)
struct FBuilderPoly final
{
public:
	TArray<int32>                                 VertexIndices;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Direction;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemName;                                          // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PolyFlags;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBuilderPoly) == 0x000008, "Wrong alignment on FBuilderPoly");
//(sizeof(FBuilderPoly) == 0x000028, "Wrong size on FBuilderPoly");
//(offsetof(FBuilderPoly, VertexIndices) == 0x000000, "Member 'FBuilderPoly::VertexIndices' has a wrong offset!");
//(offsetof(FBuilderPoly, Direction) == 0x000010, "Member 'FBuilderPoly::Direction' has a wrong offset!");
//(offsetof(FBuilderPoly, ItemName) == 0x000014, "Member 'FBuilderPoly::ItemName' has a wrong offset!");
//(offsetof(FBuilderPoly, PolyFlags) == 0x000020, "Member 'FBuilderPoly::PolyFlags' has a wrong offset!");

// ScriptStruct Engine.ActiveCameraShakeInfo
// 0x0018 (0x0018 - 0x0000)
struct FActiveCameraShakeInfo final
{
public:
	class UCameraShakeBase*                       ShakeInstance;                                     // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UCameraShakeSourceComponent> ShakeSource;                                       // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCustomInitialized;                              // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FActiveCameraShakeInfo) == 0x000008, "Wrong alignment on FActiveCameraShakeInfo");
//(sizeof(FActiveCameraShakeInfo) == 0x000018, "Wrong size on FActiveCameraShakeInfo");
//(offsetof(FActiveCameraShakeInfo, ShakeInstance) == 0x000000, "Member 'FActiveCameraShakeInfo::ShakeInstance' has a wrong offset!");
//(offsetof(FActiveCameraShakeInfo, ShakeSource) == 0x000008, "Member 'FActiveCameraShakeInfo::ShakeSource' has a wrong offset!");
//(offsetof(FActiveCameraShakeInfo, bIsCustomInitialized) == 0x000010, "Member 'FActiveCameraShakeInfo::bIsCustomInitialized' has a wrong offset!");

// ScriptStruct Engine.CameraShakeStartParams
// 0x0001 (0x0001 - 0x0000)
struct FCameraShakeStartParams final
{
public:
	bool                                          bIsRestarting;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCameraShakeStartParams) == 0x000001, "Wrong alignment on FCameraShakeStartParams");
//(sizeof(FCameraShakeStartParams) == 0x000001, "Wrong size on FCameraShakeStartParams");
//(offsetof(FCameraShakeStartParams, bIsRestarting) == 0x000000, "Member 'FCameraShakeStartParams::bIsRestarting' has a wrong offset!");

// ScriptStruct Engine.CameraShakeUpdateParams
// 0x0A60 (0x0A60 - 0x0000)
struct FCameraShakeUpdateParams final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeScale;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicScale;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       POV;                                               // 0x0010(0x0A50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
//(alignof(FCameraShakeUpdateParams) == 0x000010, "Wrong alignment on FCameraShakeUpdateParams");
//(sizeof(FCameraShakeUpdateParams) == 0x000A60, "Wrong size on FCameraShakeUpdateParams");
//(offsetof(FCameraShakeUpdateParams, DeltaTime) == 0x000000, "Member 'FCameraShakeUpdateParams::DeltaTime' has a wrong offset!");
//(offsetof(FCameraShakeUpdateParams, ShakeScale) == 0x000004, "Member 'FCameraShakeUpdateParams::ShakeScale' has a wrong offset!");
//(offsetof(FCameraShakeUpdateParams, DynamicScale) == 0x000008, "Member 'FCameraShakeUpdateParams::DynamicScale' has a wrong offset!");
//(offsetof(FCameraShakeUpdateParams, POV) == 0x000010, "Member 'FCameraShakeUpdateParams::POV' has a wrong offset!");

// ScriptStruct Engine.CameraShakeScrubParams
// 0x0A60 (0x0A60 - 0x0000)
struct FCameraShakeScrubParams final
{
public:
	float                                         AbsoluteTime;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeScale;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicScale;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       POV;                                               // 0x0010(0x0A50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
//(alignof(FCameraShakeScrubParams) == 0x000010, "Wrong alignment on FCameraShakeScrubParams");
//(sizeof(FCameraShakeScrubParams) == 0x000A60, "Wrong size on FCameraShakeScrubParams");
//(offsetof(FCameraShakeScrubParams, AbsoluteTime) == 0x000000, "Member 'FCameraShakeScrubParams::AbsoluteTime' has a wrong offset!");
//(offsetof(FCameraShakeScrubParams, ShakeScale) == 0x000004, "Member 'FCameraShakeScrubParams::ShakeScale' has a wrong offset!");
//(offsetof(FCameraShakeScrubParams, DynamicScale) == 0x000008, "Member 'FCameraShakeScrubParams::DynamicScale' has a wrong offset!");
//(offsetof(FCameraShakeScrubParams, POV) == 0x000010, "Member 'FCameraShakeScrubParams::POV' has a wrong offset!");

// ScriptStruct Engine.CameraShakeUpdateResult
// 0x09C0 (0x09C0 - 0x0000)
struct alignas(0x10) FCameraShakeUpdateResult final
{
public:
	uint8                                         Pad_0[0x9C0];                                      // 0x0000(0x09C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCameraShakeUpdateResult) == 0x000010, "Wrong alignment on FCameraShakeUpdateResult");
//(sizeof(FCameraShakeUpdateResult) == 0x0009C0, "Wrong size on FCameraShakeUpdateResult");

// ScriptStruct Engine.CameraShakeStopParams
// 0x0001 (0x0001 - 0x0000)
struct FCameraShakeStopParams final
{
public:
	bool                                          bImmediately;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCameraShakeStopParams) == 0x000001, "Wrong alignment on FCameraShakeStopParams");
//(sizeof(FCameraShakeStopParams) == 0x000001, "Wrong size on FCameraShakeStopParams");
//(offsetof(FCameraShakeStopParams, bImmediately) == 0x000000, "Member 'FCameraShakeStopParams::bImmediately' has a wrong offset!");

// ScriptStruct Engine.CameraShakeDuration
// 0x0008 (0x0008 - 0x0000)
struct FCameraShakeDuration final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECameraShakeDurationType                      Type;                                              // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCameraShakeDuration) == 0x000004, "Wrong alignment on FCameraShakeDuration");
//(sizeof(FCameraShakeDuration) == 0x000008, "Wrong size on FCameraShakeDuration");
//(offsetof(FCameraShakeDuration, Duration) == 0x000000, "Member 'FCameraShakeDuration::Duration' has a wrong offset!");
//(offsetof(FCameraShakeDuration, Type) == 0x000004, "Member 'FCameraShakeDuration::Type' has a wrong offset!");

// ScriptStruct Engine.CameraShakeInfo
// 0x0010 (0x0010 - 0x0000)
struct FCameraShakeInfo final
{
public:
	struct FCameraShakeDuration                   Duration;                                          // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         BlendIn;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOut;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCameraShakeInfo) == 0x000004, "Wrong alignment on FCameraShakeInfo");
//(sizeof(FCameraShakeInfo) == 0x000010, "Wrong size on FCameraShakeInfo");
//(offsetof(FCameraShakeInfo, Duration) == 0x000000, "Member 'FCameraShakeInfo::Duration' has a wrong offset!");
//(offsetof(FCameraShakeInfo, BlendIn) == 0x000008, "Member 'FCameraShakeInfo::BlendIn' has a wrong offset!");
//(offsetof(FCameraShakeInfo, BlendOut) == 0x00000C, "Member 'FCameraShakeInfo::BlendOut' has a wrong offset!");

// ScriptStruct Engine.DummySpacerCameraTypes
// 0x0001 (0x0001 - 0x0000)
struct FDummySpacerCameraTypes final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDummySpacerCameraTypes) == 0x000001, "Wrong alignment on FDummySpacerCameraTypes");
//(sizeof(FDummySpacerCameraTypes) == 0x000001, "Wrong size on FDummySpacerCameraTypes");

// ScriptStruct Engine.RootMotionSourceSettings
// 0x0001 (0x0001 - 0x0000)
struct FRootMotionSourceSettings final
{
public:
	uint8                                         Flags;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRootMotionSourceSettings) == 0x000001, "Wrong alignment on FRootMotionSourceSettings");
//(sizeof(FRootMotionSourceSettings) == 0x000001, "Wrong size on FRootMotionSourceSettings");
//(offsetof(FRootMotionSourceSettings, Flags) == 0x000000, "Member 'FRootMotionSourceSettings::Flags' has a wrong offset!");

// ScriptStruct Engine.RootMotionSourceGroup
// 0x0098 (0x0098 - 0x0000)
struct FRootMotionSourceGroup final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bHasAdditiveSources : 1;                           // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasOverrideSources : 1;                           // 0x0078(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasOverrideSourcesWithIgnoreZAccumulate : 1;      // 0x0078(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsAdditiveVelocityApplied : 1;                    // 0x0078(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FRootMotionSourceSettings              LastAccumulatedSettings;                           // 0x0079(0x0001)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  LastPreAdditiveVelocity;                           // 0x0080(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRootMotionSourceGroup) == 0x000008, "Wrong alignment on FRootMotionSourceGroup");
//(sizeof(FRootMotionSourceGroup) == 0x000098, "Wrong size on FRootMotionSourceGroup");
//(offsetof(FRootMotionSourceGroup, LastAccumulatedSettings) == 0x000079, "Member 'FRootMotionSourceGroup::LastAccumulatedSettings' has a wrong offset!");
//(offsetof(FRootMotionSourceGroup, LastPreAdditiveVelocity) == 0x000080, "Member 'FRootMotionSourceGroup::LastPreAdditiveVelocity' has a wrong offset!");

// ScriptStruct Engine.RepRootMotionMontage
// 0x0128 (0x0128 - 0x0000)
struct FRepRootMotionMontage final
{
public:
	bool                                          bIsActive;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AnimMontage;                                       // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 Location;                                          // 0x0018(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    MovementBase;                                      // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MovementBaseBoneName;                              // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelativePosition;                                 // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelativeRotation;                                 // 0x005D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionSourceGroup                 AuthoritativeRootMotion;                           // 0x0060(0x0098)(NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  Acceleration;                                      // 0x00F8(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  LinearVelocity;                                    // 0x0110(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRepRootMotionMontage) == 0x000008, "Wrong alignment on FRepRootMotionMontage");
//(sizeof(FRepRootMotionMontage) == 0x000128, "Wrong size on FRepRootMotionMontage");
//(offsetof(FRepRootMotionMontage, bIsActive) == 0x000000, "Member 'FRepRootMotionMontage::bIsActive' has a wrong offset!");
//(offsetof(FRepRootMotionMontage, AnimMontage) == 0x000008, "Member 'FRepRootMotionMontage::AnimMontage' has a wrong offset!");
//(offsetof(FRepRootMotionMontage, Position) == 0x000010, "Member 'FRepRootMotionMontage::Position' has a wrong offset!");
//(offsetof(FRepRootMotionMontage, Location) == 0x000018, "Member 'FRepRootMotionMontage::Location' has a wrong offset!");
//(offsetof(FRepRootMotionMontage, Rotation) == 0x000030, "Member 'FRepRootMotionMontage::Rotation' has a wrong offset!");
//(offsetof(FRepRootMotionMontage, MovementBase) == 0x000048, "Member 'FRepRootMotionMontage::MovementBase' has a wrong offset!");
//(offsetof(FRepRootMotionMontage, MovementBaseBoneName) == 0x000050, "Member 'FRepRootMotionMontage::MovementBaseBoneName' has a wrong offset!");
//(offsetof(FRepRootMotionMontage, bRelativePosition) == 0x00005C, "Member 'FRepRootMotionMontage::bRelativePosition' has a wrong offset!");
//(offsetof(FRepRootMotionMontage, bRelativeRotation) == 0x00005D, "Member 'FRepRootMotionMontage::bRelativeRotation' has a wrong offset!");
//(offsetof(FRepRootMotionMontage, AuthoritativeRootMotion) == 0x000060, "Member 'FRepRootMotionMontage::AuthoritativeRootMotion' has a wrong offset!");
//(offsetof(FRepRootMotionMontage, Acceleration) == 0x0000F8, "Member 'FRepRootMotionMontage::Acceleration' has a wrong offset!");
//(offsetof(FRepRootMotionMontage, LinearVelocity) == 0x000110, "Member 'FRepRootMotionMontage::LinearVelocity' has a wrong offset!");

// ScriptStruct Engine.SimulatedRootMotionReplicatedMove
// 0x0130 (0x0130 - 0x0000)
struct FSimulatedRootMotionReplicatedMove final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRepRootMotionMontage                  RootMotion;                                        // 0x0008(0x0128)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
//(alignof(FSimulatedRootMotionReplicatedMove) == 0x000008, "Wrong alignment on FSimulatedRootMotionReplicatedMove");
//(sizeof(FSimulatedRootMotionReplicatedMove) == 0x000130, "Wrong size on FSimulatedRootMotionReplicatedMove");
//(offsetof(FSimulatedRootMotionReplicatedMove, Time) == 0x000000, "Member 'FSimulatedRootMotionReplicatedMove::Time' has a wrong offset!");
//(offsetof(FSimulatedRootMotionReplicatedMove, RootMotion) == 0x000008, "Member 'FSimulatedRootMotionReplicatedMove::RootMotion' has a wrong offset!");

// ScriptStruct Engine.BasedMovementInfo
// 0x0058 (0x0058 - 0x0000)
struct FBasedMovementInfo final
{
public:
	uint16                                        BaseID;                                            // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    MovementBase;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 Location;                                          // 0x0020(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bServerHasBaseComponent;                           // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelativeRotation;                                 // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerHasVelocity;                                // 0x0052(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBasedMovementInfo) == 0x000008, "Wrong alignment on FBasedMovementInfo");
//(sizeof(FBasedMovementInfo) == 0x000058, "Wrong size on FBasedMovementInfo");
//(offsetof(FBasedMovementInfo, BaseID) == 0x000000, "Member 'FBasedMovementInfo::BaseID' has a wrong offset!");
//(offsetof(FBasedMovementInfo, MovementBase) == 0x000008, "Member 'FBasedMovementInfo::MovementBase' has a wrong offset!");
//(offsetof(FBasedMovementInfo, BoneName) == 0x000010, "Member 'FBasedMovementInfo::BoneName' has a wrong offset!");
//(offsetof(FBasedMovementInfo, Location) == 0x000020, "Member 'FBasedMovementInfo::Location' has a wrong offset!");
//(offsetof(FBasedMovementInfo, Rotation) == 0x000038, "Member 'FBasedMovementInfo::Rotation' has a wrong offset!");
//(offsetof(FBasedMovementInfo, bServerHasBaseComponent) == 0x000050, "Member 'FBasedMovementInfo::bServerHasBaseComponent' has a wrong offset!");
//(offsetof(FBasedMovementInfo, bRelativeRotation) == 0x000051, "Member 'FBasedMovementInfo::bRelativeRotation' has a wrong offset!");
//(offsetof(FBasedMovementInfo, bServerHasVelocity) == 0x000052, "Member 'FBasedMovementInfo::bServerHasVelocity' has a wrong offset!");

// ScriptStruct Engine.FindFloorResult
// 0x02D0 (0x02D0 - 0x0000)
struct FFindFloorResult final
{
public:
	uint8                                         bBlockingHit : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWalkableFloor : 1;                                // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLineTrace : 1;                                    // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloorDist;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDist;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0010(0x0160)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResultWithPenetration;                          // 0x0170(0x0160)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
//(alignof(FFindFloorResult) == 0x000008, "Wrong alignment on FFindFloorResult");
//(sizeof(FFindFloorResult) == 0x0002D0, "Wrong size on FFindFloorResult");
//(offsetof(FFindFloorResult, FloorDist) == 0x000004, "Member 'FFindFloorResult::FloorDist' has a wrong offset!");
//(offsetof(FFindFloorResult, LineDist) == 0x000008, "Member 'FFindFloorResult::LineDist' has a wrong offset!");
//(offsetof(FFindFloorResult, HitResult) == 0x000010, "Member 'FFindFloorResult::HitResult' has a wrong offset!");
//(offsetof(FFindFloorResult, HitResultWithPenetration) == 0x000170, "Member 'FFindFloorResult::HitResultWithPenetration' has a wrong offset!");

// ScriptStruct Engine.CollisionResponseTemplate
// 0x0050 (0x0050 - 0x0000)
struct FCollisionResponseTemplate final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             CollisionEnabled;                                  // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x1];                                        // 0x000D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanModify;                                        // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x21];                                       // 0x000F(0x0021)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ObjectTypeName;                                    // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FResponseChannel>               CustomResponses;                                   // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FCollisionResponseTemplate) == 0x000008, "Wrong alignment on FCollisionResponseTemplate");
//(sizeof(FCollisionResponseTemplate) == 0x000050, "Wrong size on FCollisionResponseTemplate");
//(offsetof(FCollisionResponseTemplate, Name) == 0x000000, "Member 'FCollisionResponseTemplate::Name' has a wrong offset!");
//(offsetof(FCollisionResponseTemplate, CollisionEnabled) == 0x00000C, "Member 'FCollisionResponseTemplate::CollisionEnabled' has a wrong offset!");
//(offsetof(FCollisionResponseTemplate, bCanModify) == 0x00000E, "Member 'FCollisionResponseTemplate::bCanModify' has a wrong offset!");
//(offsetof(FCollisionResponseTemplate, ObjectTypeName) == 0x000030, "Member 'FCollisionResponseTemplate::ObjectTypeName' has a wrong offset!");
//(offsetof(FCollisionResponseTemplate, CustomResponses) == 0x000040, "Member 'FCollisionResponseTemplate::CustomResponses' has a wrong offset!");

// ScriptStruct Engine.CustomChannelSetup
// 0x0010 (0x0010 - 0x0000)
struct FCustomChannelSetup final
{
public:
	ECollisionChannel                             Channel;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            DefaultResponse;                                   // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceType;                                        // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStaticObject;                                     // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCustomChannelSetup) == 0x000004, "Wrong alignment on FCustomChannelSetup");
//(sizeof(FCustomChannelSetup) == 0x000010, "Wrong size on FCustomChannelSetup");
//(offsetof(FCustomChannelSetup, Channel) == 0x000000, "Member 'FCustomChannelSetup::Channel' has a wrong offset!");
//(offsetof(FCustomChannelSetup, DefaultResponse) == 0x000001, "Member 'FCustomChannelSetup::DefaultResponse' has a wrong offset!");
//(offsetof(FCustomChannelSetup, bTraceType) == 0x000002, "Member 'FCustomChannelSetup::bTraceType' has a wrong offset!");
//(offsetof(FCustomChannelSetup, bStaticObject) == 0x000003, "Member 'FCustomChannelSetup::bStaticObject' has a wrong offset!");
//(offsetof(FCustomChannelSetup, Name) == 0x000004, "Member 'FCustomChannelSetup::Name' has a wrong offset!");

// ScriptStruct Engine.BlueprintComponentDelegateBinding
// 0x0024 (0x0024 - 0x0000)
struct FBlueprintComponentDelegateBinding final
{
public:
	class FName                                   ComponentPropertyName;                             // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DelegatePropertyName;                              // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionNameToBind;                                // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBlueprintComponentDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintComponentDelegateBinding");
//(sizeof(FBlueprintComponentDelegateBinding) == 0x000024, "Wrong size on FBlueprintComponentDelegateBinding");
//(offsetof(FBlueprintComponentDelegateBinding, ComponentPropertyName) == 0x000000, "Member 'FBlueprintComponentDelegateBinding::ComponentPropertyName' has a wrong offset!");
//(offsetof(FBlueprintComponentDelegateBinding, DelegatePropertyName) == 0x00000C, "Member 'FBlueprintComponentDelegateBinding::DelegatePropertyName' has a wrong offset!");
//(offsetof(FBlueprintComponentDelegateBinding, FunctionNameToBind) == 0x000018, "Member 'FBlueprintComponentDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.ActorComponentInstanceSourceInfo
// 0x0010 (0x0010 - 0x0000)
struct FActorComponentInstanceSourceInfo final
{
public:
	class UObject*                                SourceComponentTemplate;                           // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EComponentCreationMethod                      SourceComponentCreationMethod;                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SourceComponentTypeSerializedIndex;                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FActorComponentInstanceSourceInfo) == 0x000008, "Wrong alignment on FActorComponentInstanceSourceInfo");
//(sizeof(FActorComponentInstanceSourceInfo) == 0x000010, "Wrong size on FActorComponentInstanceSourceInfo");
//(offsetof(FActorComponentInstanceSourceInfo, SourceComponentTemplate) == 0x000000, "Member 'FActorComponentInstanceSourceInfo::SourceComponentTemplate' has a wrong offset!");
//(offsetof(FActorComponentInstanceSourceInfo, SourceComponentCreationMethod) == 0x000008, "Member 'FActorComponentInstanceSourceInfo::SourceComponentCreationMethod' has a wrong offset!");
//(offsetof(FActorComponentInstanceSourceInfo, SourceComponentTypeSerializedIndex) == 0x00000C, "Member 'FActorComponentInstanceSourceInfo::SourceComponentTypeSerializedIndex' has a wrong offset!");

// ScriptStruct Engine.ActorInstanceData
// 0x0008 (0x0060 - 0x0058)
struct FActorInstanceData final : public FInstanceCacheDataBase
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0058(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
//(alignof(FActorInstanceData) == 0x000008, "Wrong alignment on FActorInstanceData");
//(sizeof(FActorInstanceData) == 0x000060, "Wrong size on FActorInstanceData");
//(offsetof(FActorInstanceData, ActorClass) == 0x000058, "Member 'FActorInstanceData::ActorClass' has a wrong offset!");

// ScriptStruct Engine.PropertyAccessIndirection
// 0x0040 (0x0040 - 0x0000)
struct FPropertyAccessIndirection final
{
public:
	TFieldPath<struct FProperty>                  Property;                                          // 0x0000(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFunction*                              Function;                                          // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ReturnBufferSize;                                  // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ReturnBufferAlignment;                             // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ArrayIndex;                                        // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        Offset;                                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPropertyAccessObjectType                     ObjectType;                                        // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPropertyAccessIndirectionType                Type;                                              // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPropertyAccessIndirection) == 0x000008, "Wrong alignment on FPropertyAccessIndirection");
//(sizeof(FPropertyAccessIndirection) == 0x000040, "Wrong size on FPropertyAccessIndirection");
//(offsetof(FPropertyAccessIndirection, Property) == 0x000000, "Member 'FPropertyAccessIndirection::Property' has a wrong offset!");
//(offsetof(FPropertyAccessIndirection, Function) == 0x000020, "Member 'FPropertyAccessIndirection::Function' has a wrong offset!");
//(offsetof(FPropertyAccessIndirection, ReturnBufferSize) == 0x000028, "Member 'FPropertyAccessIndirection::ReturnBufferSize' has a wrong offset!");
//(offsetof(FPropertyAccessIndirection, ReturnBufferAlignment) == 0x00002C, "Member 'FPropertyAccessIndirection::ReturnBufferAlignment' has a wrong offset!");
//(offsetof(FPropertyAccessIndirection, ArrayIndex) == 0x000030, "Member 'FPropertyAccessIndirection::ArrayIndex' has a wrong offset!");
//(offsetof(FPropertyAccessIndirection, Offset) == 0x000034, "Member 'FPropertyAccessIndirection::Offset' has a wrong offset!");
//(offsetof(FPropertyAccessIndirection, ObjectType) == 0x000038, "Member 'FPropertyAccessIndirection::ObjectType' has a wrong offset!");
//(offsetof(FPropertyAccessIndirection, Type) == 0x000039, "Member 'FPropertyAccessIndirection::Type' has a wrong offset!");

// ScriptStruct Engine.AudioComponentParam
// 0x0008 (0x00A8 - 0x00A0)
struct FAudioComponentParam final : public FAudioParameter
{
public:
	class USoundWave*                             SoundWaveParam;                                    // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAudioComponentParam) == 0x000008, "Wrong alignment on FAudioComponentParam");
//(sizeof(FAudioComponentParam) == 0x0000A8, "Wrong size on FAudioComponentParam");
//(offsetof(FAudioComponentParam, SoundWaveParam) == 0x0000A0, "Member 'FAudioComponentParam::SoundWaveParam' has a wrong offset!");

// ScriptStruct Engine.CharacterMovementComponentPostPhysicsTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FCharacterMovementComponentPostPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCharacterMovementComponentPostPhysicsTickFunction) == 0x000008, "Wrong alignment on FCharacterMovementComponentPostPhysicsTickFunction");
//(sizeof(FCharacterMovementComponentPostPhysicsTickFunction) == 0x000038, "Wrong size on FCharacterMovementComponentPostPhysicsTickFunction");

// ScriptStruct Engine.CharacterMovementComponentPrePhysicsTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FCharacterMovementComponentPrePhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCharacterMovementComponentPrePhysicsTickFunction) == 0x000008, "Wrong alignment on FCharacterMovementComponentPrePhysicsTickFunction");
//(sizeof(FCharacterMovementComponentPrePhysicsTickFunction) == 0x000038, "Wrong size on FCharacterMovementComponentPrePhysicsTickFunction");

// ScriptStruct Engine.MarvelPriorityMovementMode
// 0x000C (0x000C - 0x0000)
struct FMarvelPriorityMovementMode final
{
public:
	EMovementMode                                 NewMovementMode;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UniqueID;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESetMovementModePriority                      SetMovementModePriority;                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMarvelPriorityMovementMode) == 0x000004, "Wrong alignment on FMarvelPriorityMovementMode");
//(sizeof(FMarvelPriorityMovementMode) == 0x00000C, "Wrong size on FMarvelPriorityMovementMode");
//(offsetof(FMarvelPriorityMovementMode, NewMovementMode) == 0x000000, "Member 'FMarvelPriorityMovementMode::NewMovementMode' has a wrong offset!");
//(offsetof(FMarvelPriorityMovementMode, UniqueID) == 0x000004, "Member 'FMarvelPriorityMovementMode::UniqueID' has a wrong offset!");
//(offsetof(FMarvelPriorityMovementMode, SetMovementModePriority) == 0x000008, "Member 'FMarvelPriorityMovementMode::SetMovementModePriority' has a wrong offset!");

// ScriptStruct Engine.RepMovementNetSerializerConfig
// 0x0001 (0x0001 - 0x0000)
struct FRepMovementNetSerializerConfig final : public FNetSerializerConfig
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRepMovementNetSerializerConfig) == 0x000001, "Wrong alignment on FRepMovementNetSerializerConfig");
//(sizeof(FRepMovementNetSerializerConfig) == 0x000001, "Wrong size on FRepMovementNetSerializerConfig");

// ScriptStruct Engine.DebugTrackPoint
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FDebugTrackPoint final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDebugTrackPoint) == 0x000008, "Wrong alignment on FDebugTrackPoint");
//(sizeof(FDebugTrackPoint) == 0x000040, "Wrong size on FDebugTrackPoint");

// ScriptStruct Engine.PriorityMovementModeFrameParam
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FPriorityMovementModeFrameParam final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPriorityMovementModeFrameParam) == 0x000004, "Wrong alignment on FPriorityMovementModeFrameParam");
//(sizeof(FPriorityMovementModeFrameParam) == 0x00000C, "Wrong size on FPriorityMovementModeFrameParam");

// ScriptStruct Engine.ScopedDebugMovement
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FScopedDebugMovement final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FScopedDebugMovement) == 0x000008, "Wrong alignment on FScopedDebugMovement");
//(sizeof(FScopedDebugMovement) == 0x000018, "Wrong size on FScopedDebugMovement");

// ScriptStruct Engine.ChildActorAttachedActorInfo
// 0x0080 (0x0080 - 0x0000)
struct FChildActorAttachedActorInfo final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0020(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FChildActorAttachedActorInfo) == 0x000010, "Wrong alignment on FChildActorAttachedActorInfo");
//(sizeof(FChildActorAttachedActorInfo) == 0x000080, "Wrong size on FChildActorAttachedActorInfo");
//(offsetof(FChildActorAttachedActorInfo, Actor) == 0x000000, "Member 'FChildActorAttachedActorInfo::Actor' has a wrong offset!");
//(offsetof(FChildActorAttachedActorInfo, SocketName) == 0x000008, "Member 'FChildActorAttachedActorInfo::SocketName' has a wrong offset!");
//(offsetof(FChildActorAttachedActorInfo, RelativeTransform) == 0x000020, "Member 'FChildActorAttachedActorInfo::RelativeTransform' has a wrong offset!");

// ScriptStruct Engine.ChildActorComponentInstanceData
// 0x0048 (0x0100 - 0x00B8)
struct FChildActorComponentInstanceData final : public FSceneComponentInstanceData
{
public:
	TSubclassOf<class AActor>                     ChildActorClass;                                   // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChildActorName;                                    // 0x00C0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChildActorAttachedActorInfo>   AttachedActors;                                    // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x20];                                      // 0x00E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FChildActorComponentInstanceData) == 0x000008, "Wrong alignment on FChildActorComponentInstanceData");
//(sizeof(FChildActorComponentInstanceData) == 0x000100, "Wrong size on FChildActorComponentInstanceData");
//(offsetof(FChildActorComponentInstanceData, ChildActorClass) == 0x0000B8, "Member 'FChildActorComponentInstanceData::ChildActorClass' has a wrong offset!");
//(offsetof(FChildActorComponentInstanceData, ChildActorName) == 0x0000C0, "Member 'FChildActorComponentInstanceData::ChildActorName' has a wrong offset!");
//(offsetof(FChildActorComponentInstanceData, AttachedActors) == 0x0000D0, "Member 'FChildActorComponentInstanceData::AttachedActors' has a wrong offset!");

// ScriptStruct Engine.CachedKeyToActionInfo
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FCachedKeyToActionInfo final
{
public:
	TWeakObjectPtr<class UPlayerInput>            PlayerInput;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x68];                                       // 0x0008(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FCachedKeyToActionInfo) == 0x000008, "Wrong alignment on FCachedKeyToActionInfo");
//(sizeof(FCachedKeyToActionInfo) == 0x000070, "Wrong size on FCachedKeyToActionInfo");
//(offsetof(FCachedKeyToActionInfo, PlayerInput) == 0x000000, "Member 'FCachedKeyToActionInfo::PlayerInput' has a wrong offset!");

// ScriptStruct Engine.PrecomputedLightInstanceData
// 0x0088 (0x0140 - 0x00B8)
struct FPrecomputedLightInstanceData final : public FSceneComponentInstanceData
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x00C0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  LightGuid;                                         // 0x0120(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviewShadowMapChannel;                           // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0xC];                                      // 0x0134(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPrecomputedLightInstanceData) == 0x000010, "Wrong alignment on FPrecomputedLightInstanceData");
//(sizeof(FPrecomputedLightInstanceData) == 0x000140, "Wrong size on FPrecomputedLightInstanceData");
//(offsetof(FPrecomputedLightInstanceData, Transform) == 0x0000C0, "Member 'FPrecomputedLightInstanceData::Transform' has a wrong offset!");
//(offsetof(FPrecomputedLightInstanceData, LightGuid) == 0x000120, "Member 'FPrecomputedLightInstanceData::LightGuid' has a wrong offset!");
//(offsetof(FPrecomputedLightInstanceData, PreviewShadowMapChannel) == 0x000130, "Member 'FPrecomputedLightInstanceData::PreviewShadowMapChannel' has a wrong offset!");

// ScriptStruct Engine.BatchedLine
// 0x0050 (0x0050 - 0x0000)
struct FBatchedLine final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingLifeTime;                                 // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        BatchID;                                           // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBatchedLine) == 0x000008, "Wrong alignment on FBatchedLine");
//(sizeof(FBatchedLine) == 0x000050, "Wrong size on FBatchedLine");
//(offsetof(FBatchedLine, Start) == 0x000000, "Member 'FBatchedLine::Start' has a wrong offset!");
//(offsetof(FBatchedLine, End) == 0x000018, "Member 'FBatchedLine::End' has a wrong offset!");
//(offsetof(FBatchedLine, Color) == 0x000030, "Member 'FBatchedLine::Color' has a wrong offset!");
//(offsetof(FBatchedLine, Thickness) == 0x000040, "Member 'FBatchedLine::Thickness' has a wrong offset!");
//(offsetof(FBatchedLine, RemainingLifeTime) == 0x000044, "Member 'FBatchedLine::RemainingLifeTime' has a wrong offset!");
//(offsetof(FBatchedLine, DepthPriority) == 0x000048, "Member 'FBatchedLine::DepthPriority' has a wrong offset!");
//(offsetof(FBatchedLine, BatchID) == 0x00004C, "Member 'FBatchedLine::BatchID' has a wrong offset!");

// ScriptStruct Engine.BatchedPoint
// 0x0038 (0x0038 - 0x0000)
struct FBatchedPoint final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointSize;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingLifeTime;                                 // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        BatchID;                                           // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBatchedPoint) == 0x000008, "Wrong alignment on FBatchedPoint");
//(sizeof(FBatchedPoint) == 0x000038, "Wrong size on FBatchedPoint");
//(offsetof(FBatchedPoint, Position) == 0x000000, "Member 'FBatchedPoint::Position' has a wrong offset!");
//(offsetof(FBatchedPoint, Color) == 0x000018, "Member 'FBatchedPoint::Color' has a wrong offset!");
//(offsetof(FBatchedPoint, PointSize) == 0x000028, "Member 'FBatchedPoint::PointSize' has a wrong offset!");
//(offsetof(FBatchedPoint, RemainingLifeTime) == 0x00002C, "Member 'FBatchedPoint::RemainingLifeTime' has a wrong offset!");
//(offsetof(FBatchedPoint, DepthPriority) == 0x000030, "Member 'FBatchedPoint::DepthPriority' has a wrong offset!");
//(offsetof(FBatchedPoint, BatchID) == 0x000034, "Member 'FBatchedPoint::BatchID' has a wrong offset!");

// ScriptStruct Engine.LODMappingData
// 0x0020 (0x0020 - 0x0000)
struct FLODMappingData final
{
public:
	TArray<int32>                                 Mapping;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 InverseMapping;                                    // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
//(alignof(FLODMappingData) == 0x000008, "Wrong alignment on FLODMappingData");
//(sizeof(FLODMappingData) == 0x000020, "Wrong size on FLODMappingData");
//(offsetof(FLODMappingData, Mapping) == 0x000000, "Member 'FLODMappingData::Mapping' has a wrong offset!");
//(offsetof(FLODMappingData, InverseMapping) == 0x000010, "Member 'FLODMappingData::InverseMapping' has a wrong offset!");

// ScriptStruct Engine.ComponentSync
// 0x0010 (0x0010 - 0x0000)
struct FComponentSync final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESyncOption                                   SyncOption;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FComponentSync) == 0x000004, "Wrong alignment on FComponentSync");
//(sizeof(FComponentSync) == 0x000010, "Wrong size on FComponentSync");
//(offsetof(FComponentSync, Name) == 0x000000, "Member 'FComponentSync::Name' has a wrong offset!");
//(offsetof(FComponentSync, SyncOption) == 0x00000C, "Member 'FComponentSync::SyncOption' has a wrong offset!");

// ScriptStruct Engine.MaterialSpriteElement
// 0x0028 (0x0028 - 0x0000)
struct FMaterialSpriteElement final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DistanceToOpacityCurve;                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSizeIsInScreenSpace : 1;                          // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseSizeX;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSizeY;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DistanceToSizeCurve;                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialSpriteElement) == 0x000008, "Wrong alignment on FMaterialSpriteElement");
//(sizeof(FMaterialSpriteElement) == 0x000028, "Wrong size on FMaterialSpriteElement");
//(offsetof(FMaterialSpriteElement, Material) == 0x000000, "Member 'FMaterialSpriteElement::Material' has a wrong offset!");
//(offsetof(FMaterialSpriteElement, DistanceToOpacityCurve) == 0x000008, "Member 'FMaterialSpriteElement::DistanceToOpacityCurve' has a wrong offset!");
//(offsetof(FMaterialSpriteElement, BaseSizeX) == 0x000014, "Member 'FMaterialSpriteElement::BaseSizeX' has a wrong offset!");
//(offsetof(FMaterialSpriteElement, BaseSizeY) == 0x000018, "Member 'FMaterialSpriteElement::BaseSizeY' has a wrong offset!");
//(offsetof(FMaterialSpriteElement, DistanceToSizeCurve) == 0x000020, "Member 'FMaterialSpriteElement::DistanceToSizeCurve' has a wrong offset!");

// ScriptStruct Engine.SavedMove_Projectile
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FSavedMove_Projectile final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSavedMove_Projectile) == 0x000008, "Wrong alignment on FSavedMove_Projectile");
//(sizeof(FSavedMove_Projectile) == 0x000058, "Wrong size on FSavedMove_Projectile");

// ScriptStruct Engine.EngineShowFlagsSetting
// 0x0018 (0x0018 - 0x0000)
struct FEngineShowFlagsSetting final
{
public:
	class FString                                 ShowFlagName;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FEngineShowFlagsSetting) == 0x000008, "Wrong alignment on FEngineShowFlagsSetting");
//(sizeof(FEngineShowFlagsSetting) == 0x000018, "Wrong size on FEngineShowFlagsSetting");
//(offsetof(FEngineShowFlagsSetting, ShowFlagName) == 0x000000, "Member 'FEngineShowFlagsSetting::ShowFlagName' has a wrong offset!");
//(offsetof(FEngineShowFlagsSetting, Enabled) == 0x000010, "Member 'FEngineShowFlagsSetting::Enabled' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshComponentEndPhysicsTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FSkeletalMeshComponentEndPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkeletalMeshComponentEndPhysicsTickFunction) == 0x000008, "Wrong alignment on FSkeletalMeshComponentEndPhysicsTickFunction");
//(sizeof(FSkeletalMeshComponentEndPhysicsTickFunction) == 0x000038, "Wrong size on FSkeletalMeshComponentEndPhysicsTickFunction");

// ScriptStruct Engine.SkeletalMeshComponentClothTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FSkeletalMeshComponentClothTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkeletalMeshComponentClothTickFunction) == 0x000008, "Wrong alignment on FSkeletalMeshComponentClothTickFunction");
//(sizeof(FSkeletalMeshComponentClothTickFunction) == 0x000038, "Wrong size on FSkeletalMeshComponentClothTickFunction");

// ScriptStruct Engine.SkeletalMeshComponentFramingBodiesFunction
// 0x0010 (0x0040 - 0x0030)
struct FSkeletalMeshComponentFramingBodiesFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkeletalMeshComponentFramingBodiesFunction) == 0x000008, "Wrong alignment on FSkeletalMeshComponentFramingBodiesFunction");
//(sizeof(FSkeletalMeshComponentFramingBodiesFunction) == 0x000040, "Wrong size on FSkeletalMeshComponentFramingBodiesFunction");

// ScriptStruct Engine.SkeletalMeshComponentFilterDataFunction
// 0x0010 (0x0040 - 0x0030)
struct FSkeletalMeshComponentFilterDataFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkeletalMeshComponentFilterDataFunction) == 0x000008, "Wrong alignment on FSkeletalMeshComponentFilterDataFunction");
//(sizeof(FSkeletalMeshComponentFilterDataFunction) == 0x000040, "Wrong size on FSkeletalMeshComponentFilterDataFunction");

// ScriptStruct Engine.SkeletalMeshComponentCache
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FSkeletalMeshComponentCache final : public FAniNodeCacheBase
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkeletalMeshComponentCache) == 0x000010, "Wrong alignment on FSkeletalMeshComponentCache");
//(sizeof(FSkeletalMeshComponentCache) == 0x000080, "Wrong size on FSkeletalMeshComponentCache");

// ScriptStruct Engine.SkeletalCacheNode
// 0x0008 (0x0010 - 0x0008)
struct FSkeletalCacheNode final : public FEvaluation_Cache_Base
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkeletalCacheNode) == 0x000008, "Wrong alignment on FSkeletalCacheNode");
//(sizeof(FSkeletalCacheNode) == 0x000010, "Wrong size on FSkeletalCacheNode");

// ScriptStruct Engine.ExternalPhysInfluencePerBoneChain
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FExternalPhysInfluencePerBoneChain final
{
public:
	class FName                                   BoneChainRoot;                                     // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneChainTail;                                     // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExternalPhysicsInfluence;                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExternalPhysicsInfluenceLinearLimit;               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExternalPhysicsInfluenceAngleLimit;                // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x14];                                      // 0x0024(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FExternalPhysInfluencePerBoneChain) == 0x000008, "Wrong alignment on FExternalPhysInfluencePerBoneChain");
//(sizeof(FExternalPhysInfluencePerBoneChain) == 0x000038, "Wrong size on FExternalPhysInfluencePerBoneChain");
//(offsetof(FExternalPhysInfluencePerBoneChain, BoneChainRoot) == 0x000000, "Member 'FExternalPhysInfluencePerBoneChain::BoneChainRoot' has a wrong offset!");
//(offsetof(FExternalPhysInfluencePerBoneChain, BoneChainTail) == 0x00000C, "Member 'FExternalPhysInfluencePerBoneChain::BoneChainTail' has a wrong offset!");
//(offsetof(FExternalPhysInfluencePerBoneChain, ExternalPhysicsInfluence) == 0x000018, "Member 'FExternalPhysInfluencePerBoneChain::ExternalPhysicsInfluence' has a wrong offset!");
//(offsetof(FExternalPhysInfluencePerBoneChain, ExternalPhysicsInfluenceLinearLimit) == 0x00001C, "Member 'FExternalPhysInfluencePerBoneChain::ExternalPhysicsInfluenceLinearLimit' has a wrong offset!");
//(offsetof(FExternalPhysInfluencePerBoneChain, ExternalPhysicsInfluenceAngleLimit) == 0x000020, "Member 'FExternalPhysInfluencePerBoneChain::ExternalPhysicsInfluenceAngleLimit' has a wrong offset!");

// ScriptStruct Engine.TentDistribution
// 0x000C (0x000C - 0x0000)
struct FTentDistribution final
{
public:
	float                                         TipAltitude;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TipValue;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTentDistribution) == 0x000004, "Wrong alignment on FTentDistribution");
//(sizeof(FTentDistribution) == 0x00000C, "Wrong size on FTentDistribution");
//(offsetof(FTentDistribution, TipAltitude) == 0x000000, "Member 'FTentDistribution::TipAltitude' has a wrong offset!");
//(offsetof(FTentDistribution, TipValue) == 0x000004, "Member 'FTentDistribution::TipValue' has a wrong offset!");
//(offsetof(FTentDistribution, Width) == 0x000008, "Member 'FTentDistribution::Width' has a wrong offset!");

// ScriptStruct Engine.SplineCurves
// 0x0070 (0x0070 - 0x0000)
struct FSplineCurves final
{
public:
	struct FInterpCurveVector                     Position;                                          // 0x0000(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveQuat                       Rotation;                                          // 0x0018(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveVector                     Scale;                                             // 0x0030(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      ReparamTable;                                      // 0x0048(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineMetadata*                        MetaData;                                          // 0x0060(0x0008)(ZeroConstructor, Deprecated, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Version;                                           // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSplineCurves) == 0x000008, "Wrong alignment on FSplineCurves");
//(sizeof(FSplineCurves) == 0x000070, "Wrong size on FSplineCurves");
//(offsetof(FSplineCurves, Position) == 0x000000, "Member 'FSplineCurves::Position' has a wrong offset!");
//(offsetof(FSplineCurves, Rotation) == 0x000018, "Member 'FSplineCurves::Rotation' has a wrong offset!");
//(offsetof(FSplineCurves, Scale) == 0x000030, "Member 'FSplineCurves::Scale' has a wrong offset!");
//(offsetof(FSplineCurves, ReparamTable) == 0x000048, "Member 'FSplineCurves::ReparamTable' has a wrong offset!");
//(offsetof(FSplineCurves, MetaData) == 0x000060, "Member 'FSplineCurves::MetaData' has a wrong offset!");
//(offsetof(FSplineCurves, Version) == 0x000068, "Member 'FSplineCurves::Version' has a wrong offset!");

// ScriptStruct Engine.SplinePoint
// 0x0088 (0x0088 - 0x0000)
struct FSplinePoint final
{
public:
	float                                         InputKey;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArriveTangent;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeaveTangent;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplinePointType                              Type;                                              // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSplinePoint) == 0x000008, "Wrong alignment on FSplinePoint");
//(sizeof(FSplinePoint) == 0x000088, "Wrong size on FSplinePoint");
//(offsetof(FSplinePoint, InputKey) == 0x000000, "Member 'FSplinePoint::InputKey' has a wrong offset!");
//(offsetof(FSplinePoint, Position) == 0x000008, "Member 'FSplinePoint::Position' has a wrong offset!");
//(offsetof(FSplinePoint, ArriveTangent) == 0x000020, "Member 'FSplinePoint::ArriveTangent' has a wrong offset!");
//(offsetof(FSplinePoint, LeaveTangent) == 0x000038, "Member 'FSplinePoint::LeaveTangent' has a wrong offset!");
//(offsetof(FSplinePoint, Rotation) == 0x000050, "Member 'FSplinePoint::Rotation' has a wrong offset!");
//(offsetof(FSplinePoint, Scale) == 0x000068, "Member 'FSplinePoint::Scale' has a wrong offset!");
//(offsetof(FSplinePoint, Type) == 0x000080, "Member 'FSplinePoint::Type' has a wrong offset!");

// ScriptStruct Engine.SplineInstanceData
// 0x00E8 (0x01A0 - 0x00B8)
struct FSplineInstanceData final : public FSceneComponentInstanceData
{
public:
	bool                                          bSplineHasBeenEdited;                              // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSplineCurves                          SplineCurves;                                      // 0x00C0(0x0070)(NativeAccessSpecifierPublic)
	struct FSplineCurves                          SplineCurvesPreUCS;                                // 0x0130(0x0070)(NativeAccessSpecifierPublic)
};
//(alignof(FSplineInstanceData) == 0x000008, "Wrong alignment on FSplineInstanceData");
//(sizeof(FSplineInstanceData) == 0x0001A0, "Wrong size on FSplineInstanceData");
//(offsetof(FSplineInstanceData, bSplineHasBeenEdited) == 0x0000B8, "Member 'FSplineInstanceData::bSplineHasBeenEdited' has a wrong offset!");
//(offsetof(FSplineInstanceData, SplineCurves) == 0x0000C0, "Member 'FSplineInstanceData::SplineCurves' has a wrong offset!");
//(offsetof(FSplineInstanceData, SplineCurvesPreUCS) == 0x000130, "Member 'FSplineInstanceData::SplineCurvesPreUCS' has a wrong offset!");

// ScriptStruct Engine.SplineMeshParams
// 0x00B0 (0x00B0 - 0x0000)
struct FSplineMeshParams final
{
public:
	struct FVector                                StartPos;                                          // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTangent;                                      // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartScale;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartRoll;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              StartOffset;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x0058(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EndScale;                                          // 0x0070(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTangent;                                        // 0x0080(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndRoll;                                           // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              EndOffset;                                         // 0x00A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSplineMeshParams) == 0x000008, "Wrong alignment on FSplineMeshParams");
//(sizeof(FSplineMeshParams) == 0x0000B0, "Wrong size on FSplineMeshParams");
//(offsetof(FSplineMeshParams, StartPos) == 0x000000, "Member 'FSplineMeshParams::StartPos' has a wrong offset!");
//(offsetof(FSplineMeshParams, StartTangent) == 0x000018, "Member 'FSplineMeshParams::StartTangent' has a wrong offset!");
//(offsetof(FSplineMeshParams, StartScale) == 0x000030, "Member 'FSplineMeshParams::StartScale' has a wrong offset!");
//(offsetof(FSplineMeshParams, StartRoll) == 0x000040, "Member 'FSplineMeshParams::StartRoll' has a wrong offset!");
//(offsetof(FSplineMeshParams, StartOffset) == 0x000048, "Member 'FSplineMeshParams::StartOffset' has a wrong offset!");
//(offsetof(FSplineMeshParams, EndPos) == 0x000058, "Member 'FSplineMeshParams::EndPos' has a wrong offset!");
//(offsetof(FSplineMeshParams, EndScale) == 0x000070, "Member 'FSplineMeshParams::EndScale' has a wrong offset!");
//(offsetof(FSplineMeshParams, EndTangent) == 0x000080, "Member 'FSplineMeshParams::EndTangent' has a wrong offset!");
//(offsetof(FSplineMeshParams, EndRoll) == 0x000098, "Member 'FSplineMeshParams::EndRoll' has a wrong offset!");
//(offsetof(FSplineMeshParams, EndOffset) == 0x0000A0, "Member 'FSplineMeshParams::EndOffset' has a wrong offset!");

// ScriptStruct Engine.PaintedVertex
// 0x0040 (0x0040 - 0x0000)
struct FPaintedVertex final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               Normal;                                            // 0x0020(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPaintedVertex) == 0x000010, "Wrong alignment on FPaintedVertex");
//(sizeof(FPaintedVertex) == 0x000040, "Wrong size on FPaintedVertex");
//(offsetof(FPaintedVertex, Position) == 0x000000, "Member 'FPaintedVertex::Position' has a wrong offset!");
//(offsetof(FPaintedVertex, Color) == 0x000018, "Member 'FPaintedVertex::Color' has a wrong offset!");
//(offsetof(FPaintedVertex, Normal) == 0x000020, "Member 'FPaintedVertex::Normal' has a wrong offset!");

// ScriptStruct Engine.StaticMeshVertexColorLODData
// 0x0028 (0x0028 - 0x0000)
struct FStaticMeshVertexColorLODData final
{
public:
	TArray<struct FPaintedVertex>                 PaintedVertices;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         VertexBufferColors;                                // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        LODIndex;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStaticMeshVertexColorLODData) == 0x000008, "Wrong alignment on FStaticMeshVertexColorLODData");
//(sizeof(FStaticMeshVertexColorLODData) == 0x000028, "Wrong size on FStaticMeshVertexColorLODData");
//(offsetof(FStaticMeshVertexColorLODData, PaintedVertices) == 0x000000, "Member 'FStaticMeshVertexColorLODData::PaintedVertices' has a wrong offset!");
//(offsetof(FStaticMeshVertexColorLODData, VertexBufferColors) == 0x000010, "Member 'FStaticMeshVertexColorLODData::VertexBufferColors' has a wrong offset!");
//(offsetof(FStaticMeshVertexColorLODData, LODIndex) == 0x000020, "Member 'FStaticMeshVertexColorLODData::LODIndex' has a wrong offset!");

// ScriptStruct Engine.StaticMeshComponentInstanceData
// 0x0040 (0x0170 - 0x0130)
#pragma pack(push, 0x1)
struct alignas(0x10) FStaticMeshComponentInstanceData : public FPrimitiveComponentInstanceData
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0130(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStaticMeshVertexColorLODData>  VertexColorLODs;                                   // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          CachedStaticLighting;                              // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStreamingTextureBuildInfo>     StreamingTextureData;                              // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
#pragma pack(pop)
//(alignof(FStaticMeshComponentInstanceData) == 0x000010, "Wrong alignment on FStaticMeshComponentInstanceData");
//(sizeof(FStaticMeshComponentInstanceData) == 0x000170, "Wrong size on FStaticMeshComponentInstanceData");
//(offsetof(FStaticMeshComponentInstanceData, StaticMesh) == 0x000130, "Member 'FStaticMeshComponentInstanceData::StaticMesh' has a wrong offset!");
//(offsetof(FStaticMeshComponentInstanceData, VertexColorLODs) == 0x000138, "Member 'FStaticMeshComponentInstanceData::VertexColorLODs' has a wrong offset!");
//(offsetof(FStaticMeshComponentInstanceData, CachedStaticLighting) == 0x000148, "Member 'FStaticMeshComponentInstanceData::CachedStaticLighting' has a wrong offset!");
//(offsetof(FStaticMeshComponentInstanceData, StreamingTextureData) == 0x000158, "Member 'FStaticMeshComponentInstanceData::StreamingTextureData' has a wrong offset!");

// ScriptStruct Engine.SplineMeshInstanceData
// 0x0060 (0x01D0 - 0x0170)
struct FSplineMeshInstanceData final : public FStaticMeshComponentInstanceData
{
public:
	struct FVector                                StartPos;                                          // 0x0168(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x0180(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTangent;                                      // 0x0198(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTangent;                                        // 0x01B0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSplineMeshInstanceData) == 0x000010, "Wrong alignment on FSplineMeshInstanceData");
//(sizeof(FSplineMeshInstanceData) == 0x0001D0, "Wrong size on FSplineMeshInstanceData");
//(offsetof(FSplineMeshInstanceData, StartPos) == 0x000168, "Member 'FSplineMeshInstanceData::StartPos' has a wrong offset!");
//(offsetof(FSplineMeshInstanceData, EndPos) == 0x000180, "Member 'FSplineMeshInstanceData::EndPos' has a wrong offset!");
//(offsetof(FSplineMeshInstanceData, StartTangent) == 0x000198, "Member 'FSplineMeshInstanceData::StartTangent' has a wrong offset!");
//(offsetof(FSplineMeshInstanceData, EndTangent) == 0x0001B0, "Member 'FSplineMeshInstanceData::EndTangent' has a wrong offset!");

// ScriptStruct Engine.ObjectCookedMetaDataStore
// 0x0050 (0x0050 - 0x0000)
struct FObjectCookedMetaDataStore final
{
public:
	TMap<class FName, class FString>              ObjectMetaData;                                    // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
};
//(alignof(FObjectCookedMetaDataStore) == 0x000008, "Wrong alignment on FObjectCookedMetaDataStore");
//(sizeof(FObjectCookedMetaDataStore) == 0x000050, "Wrong size on FObjectCookedMetaDataStore");
//(offsetof(FObjectCookedMetaDataStore, ObjectMetaData) == 0x000000, "Member 'FObjectCookedMetaDataStore::ObjectMetaData' has a wrong offset!");

// ScriptStruct Engine.FieldCookedMetaDataStore
// 0x0050 (0x0050 - 0x0000)
struct FFieldCookedMetaDataStore final
{
public:
	TMap<class FName, class FString>              FieldMetaData;                                     // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
};
//(alignof(FFieldCookedMetaDataStore) == 0x000008, "Wrong alignment on FFieldCookedMetaDataStore");
//(sizeof(FFieldCookedMetaDataStore) == 0x000050, "Wrong size on FFieldCookedMetaDataStore");
//(offsetof(FFieldCookedMetaDataStore, FieldMetaData) == 0x000000, "Member 'FFieldCookedMetaDataStore::FieldMetaData' has a wrong offset!");

// ScriptStruct Engine.StructCookedMetaDataStore
// 0x00A0 (0x00A0 - 0x0000)
struct FStructCookedMetaDataStore final
{
public:
	struct FObjectCookedMetaDataStore             ObjectMetaData;                                    // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FFieldCookedMetaDataStore> PropertiesMetaData;                                // 0x0050(0x0050)(NativeAccessSpecifierPrivate)
};
//(alignof(FStructCookedMetaDataStore) == 0x000008, "Wrong alignment on FStructCookedMetaDataStore");
//(sizeof(FStructCookedMetaDataStore) == 0x0000A0, "Wrong size on FStructCookedMetaDataStore");
//(offsetof(FStructCookedMetaDataStore, ObjectMetaData) == 0x000000, "Member 'FStructCookedMetaDataStore::ObjectMetaData' has a wrong offset!");
//(offsetof(FStructCookedMetaDataStore, PropertiesMetaData) == 0x000050, "Member 'FStructCookedMetaDataStore::PropertiesMetaData' has a wrong offset!");

// ScriptStruct Engine.CullDistanceSizePair
// 0x0008 (0x0008 - 0x0000)
struct FCullDistanceSizePair final
{
public:
	float                                         Size;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistance;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCullDistanceSizePair) == 0x000004, "Wrong alignment on FCullDistanceSizePair");
//(sizeof(FCullDistanceSizePair) == 0x000008, "Wrong size on FCullDistanceSizePair");
//(offsetof(FCullDistanceSizePair, Size) == 0x000000, "Member 'FCullDistanceSizePair::Size' has a wrong offset!");
//(offsetof(FCullDistanceSizePair, CullDistance) == 0x000004, "Member 'FCullDistanceSizePair::CullDistance' has a wrong offset!");

// ScriptStruct Engine.RuntimeCurveLinearColor
// 0x0208 (0x0208 - 0x0000)
struct FRuntimeCurveLinearColor final
{
public:
	struct FRichCurve                             ColorCurves[0x4];                                  // 0x0000(0x0080)(NativeAccessSpecifierPublic)
	class UCurveLinearColor*                      ExternalCurve;                                     // 0x0200(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRuntimeCurveLinearColor) == 0x000008, "Wrong alignment on FRuntimeCurveLinearColor");
//(sizeof(FRuntimeCurveLinearColor) == 0x000208, "Wrong size on FRuntimeCurveLinearColor");
//(offsetof(FRuntimeCurveLinearColor, ColorCurves) == 0x000000, "Member 'FRuntimeCurveLinearColor::ColorCurves' has a wrong offset!");
//(offsetof(FRuntimeCurveLinearColor, ExternalCurve) == 0x000200, "Member 'FRuntimeCurveLinearColor::ExternalCurve' has a wrong offset!");

// ScriptStruct Engine.CurveAtlasColorAdjustments
// 0x0024 (0x0024 - 0x0000)
struct FCurveAtlasColorAdjustments final
{
public:
	uint8                                         bChromaKeyTexture : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustBrightness;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustBrightnessCurve;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustVibrance;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustSaturation;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustRGBCurve;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustHue;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustMinAlpha;                                    // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustMaxAlpha;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCurveAtlasColorAdjustments) == 0x000004, "Wrong alignment on FCurveAtlasColorAdjustments");
//(sizeof(FCurveAtlasColorAdjustments) == 0x000024, "Wrong size on FCurveAtlasColorAdjustments");
//(offsetof(FCurveAtlasColorAdjustments, AdjustBrightness) == 0x000004, "Member 'FCurveAtlasColorAdjustments::AdjustBrightness' has a wrong offset!");
//(offsetof(FCurveAtlasColorAdjustments, AdjustBrightnessCurve) == 0x000008, "Member 'FCurveAtlasColorAdjustments::AdjustBrightnessCurve' has a wrong offset!");
//(offsetof(FCurveAtlasColorAdjustments, AdjustVibrance) == 0x00000C, "Member 'FCurveAtlasColorAdjustments::AdjustVibrance' has a wrong offset!");
//(offsetof(FCurveAtlasColorAdjustments, AdjustSaturation) == 0x000010, "Member 'FCurveAtlasColorAdjustments::AdjustSaturation' has a wrong offset!");
//(offsetof(FCurveAtlasColorAdjustments, AdjustRGBCurve) == 0x000014, "Member 'FCurveAtlasColorAdjustments::AdjustRGBCurve' has a wrong offset!");
//(offsetof(FCurveAtlasColorAdjustments, AdjustHue) == 0x000018, "Member 'FCurveAtlasColorAdjustments::AdjustHue' has a wrong offset!");
//(offsetof(FCurveAtlasColorAdjustments, AdjustMinAlpha) == 0x00001C, "Member 'FCurveAtlasColorAdjustments::AdjustMinAlpha' has a wrong offset!");
//(offsetof(FCurveAtlasColorAdjustments, AdjustMaxAlpha) == 0x000020, "Member 'FCurveAtlasColorAdjustments::AdjustMaxAlpha' has a wrong offset!");

// ScriptStruct Engine.RuntimeVectorCurve
// 0x0188 (0x0188 - 0x0000)
struct FRuntimeVectorCurve final
{
public:
	struct FRichCurve                             VectorCurves[0x3];                                 // 0x0000(0x0080)(NativeAccessSpecifierPublic)
	class UCurveVector*                           ExternalCurve;                                     // 0x0180(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRuntimeVectorCurve) == 0x000008, "Wrong alignment on FRuntimeVectorCurve");
//(sizeof(FRuntimeVectorCurve) == 0x000188, "Wrong size on FRuntimeVectorCurve");
//(offsetof(FRuntimeVectorCurve, VectorCurves) == 0x000000, "Member 'FRuntimeVectorCurve::VectorCurves' has a wrong offset!");
//(offsetof(FRuntimeVectorCurve, ExternalCurve) == 0x000180, "Member 'FRuntimeVectorCurve::ExternalCurve' has a wrong offset!");

// ScriptStruct Engine.IntegralKey
// 0x0008 (0x0008 - 0x0000)
struct FIntegralKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FIntegralKey) == 0x000004, "Wrong alignment on FIntegralKey");
//(sizeof(FIntegralKey) == 0x000008, "Wrong size on FIntegralKey");
//(offsetof(FIntegralKey, Time) == 0x000000, "Member 'FIntegralKey::Time' has a wrong offset!");
//(offsetof(FIntegralKey, Value) == 0x000004, "Member 'FIntegralKey::Value' has a wrong offset!");

// ScriptStruct Engine.IntegralCurve
// 0x0018 (0x0080 - 0x0068)
struct FIntegralCurve final : public FIndexedCurve
{
public:
	TArray<struct FIntegralKey>                   Keys;                                              // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         DefaultValue;                                      // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseDefaultValueBeforeFirstKey;                    // 0x007C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FIntegralCurve) == 0x000008, "Wrong alignment on FIntegralCurve");
//(sizeof(FIntegralCurve) == 0x000080, "Wrong size on FIntegralCurve");
//(offsetof(FIntegralCurve, Keys) == 0x000068, "Member 'FIntegralCurve::Keys' has a wrong offset!");
//(offsetof(FIntegralCurve, DefaultValue) == 0x000078, "Member 'FIntegralCurve::DefaultValue' has a wrong offset!");
//(offsetof(FIntegralCurve, bUseDefaultValueBeforeFirstKey) == 0x00007C, "Member 'FIntegralCurve::bUseDefaultValueBeforeFirstKey' has a wrong offset!");

// ScriptStruct Engine.NameCurveKey
// 0x0010 (0x0010 - 0x0000)
struct FNameCurveKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value;                                             // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNameCurveKey) == 0x000004, "Wrong alignment on FNameCurveKey");
//(sizeof(FNameCurveKey) == 0x000010, "Wrong size on FNameCurveKey");
//(offsetof(FNameCurveKey, Time) == 0x000000, "Member 'FNameCurveKey::Time' has a wrong offset!");
//(offsetof(FNameCurveKey, Value) == 0x000004, "Member 'FNameCurveKey::Value' has a wrong offset!");

// ScriptStruct Engine.NameCurve
// 0x0010 (0x0078 - 0x0068)
struct FNameCurve final : public FIndexedCurve
{
public:
	TArray<struct FNameCurveKey>                  Keys;                                              // 0x0068(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FNameCurve) == 0x000008, "Wrong alignment on FNameCurve");
//(sizeof(FNameCurve) == 0x000078, "Wrong size on FNameCurve");
//(offsetof(FNameCurve, Keys) == 0x000068, "Member 'FNameCurve::Keys' has a wrong offset!");

// ScriptStruct Engine.SimpleCurveKey
// 0x0008 (0x0008 - 0x0000)
struct FSimpleCurveKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSimpleCurveKey) == 0x000004, "Wrong alignment on FSimpleCurveKey");
//(sizeof(FSimpleCurveKey) == 0x000008, "Wrong size on FSimpleCurveKey");
//(offsetof(FSimpleCurveKey, Time) == 0x000000, "Member 'FSimpleCurveKey::Time' has a wrong offset!");
//(offsetof(FSimpleCurveKey, Value) == 0x000004, "Member 'FSimpleCurveKey::Value' has a wrong offset!");

// ScriptStruct Engine.SimpleCurve
// 0x0018 (0x0088 - 0x0070)
struct FSimpleCurve final : public FRealCurve
{
public:
	ERichCurveInterpMode                          InterpMode;                                        // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSimpleCurveKey>                Keys;                                              // 0x0078(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FSimpleCurve) == 0x000008, "Wrong alignment on FSimpleCurve");
//(sizeof(FSimpleCurve) == 0x000088, "Wrong size on FSimpleCurve");
//(offsetof(FSimpleCurve, InterpMode) == 0x000070, "Member 'FSimpleCurve::InterpMode' has a wrong offset!");
//(offsetof(FSimpleCurve, Keys) == 0x000078, "Member 'FSimpleCurve::Keys' has a wrong offset!");

// ScriptStruct Engine.StringCurveKey
// 0x0018 (0x0018 - 0x0000)
struct FStringCurveKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Value;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FStringCurveKey) == 0x000008, "Wrong alignment on FStringCurveKey");
//(sizeof(FStringCurveKey) == 0x000018, "Wrong size on FStringCurveKey");
//(offsetof(FStringCurveKey, Time) == 0x000000, "Member 'FStringCurveKey::Time' has a wrong offset!");
//(offsetof(FStringCurveKey, Value) == 0x000008, "Member 'FStringCurveKey::Value' has a wrong offset!");

// ScriptStruct Engine.StringCurve
// 0x0020 (0x0088 - 0x0068)
struct FStringCurve final : public FIndexedCurve
{
public:
	class FString                                 DefaultValue;                                      // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStringCurveKey>                Keys;                                              // 0x0078(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FStringCurve) == 0x000008, "Wrong alignment on FStringCurve");
//(sizeof(FStringCurve) == 0x000088, "Wrong size on FStringCurve");
//(offsetof(FStringCurve, DefaultValue) == 0x000068, "Member 'FStringCurve::DefaultValue' has a wrong offset!");
//(offsetof(FStringCurve, Keys) == 0x000078, "Member 'FStringCurve::Keys' has a wrong offset!");

// ScriptStruct Engine.DataTableCategoryHandle
// 0x0020 (0x0020 - 0x0000)
struct FDataTableCategoryHandle final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColumnName;                                        // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowContents;                                       // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDataTableCategoryHandle) == 0x000008, "Wrong alignment on FDataTableCategoryHandle");
//(sizeof(FDataTableCategoryHandle) == 0x000020, "Wrong size on FDataTableCategoryHandle");
//(offsetof(FDataTableCategoryHandle, DataTable) == 0x000000, "Member 'FDataTableCategoryHandle::DataTable' has a wrong offset!");
//(offsetof(FDataTableCategoryHandle, ColumnName) == 0x000008, "Member 'FDataTableCategoryHandle::ColumnName' has a wrong offset!");
//(offsetof(FDataTableCategoryHandle, RowContents) == 0x000014, "Member 'FDataTableCategoryHandle::RowContents' has a wrong offset!");

// ScriptStruct Engine.NetworkPhysicsDatas
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FNetworkPhysicsDatas
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ServerFrame;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocalFrame;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputFrame;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FNetworkPhysicsDatas) == 0x000008, "Wrong alignment on FNetworkPhysicsDatas");
//(sizeof(FNetworkPhysicsDatas) == 0x000018, "Wrong size on FNetworkPhysicsDatas");
//(offsetof(FNetworkPhysicsDatas, ServerFrame) == 0x000008, "Member 'FNetworkPhysicsDatas::ServerFrame' has a wrong offset!");
//(offsetof(FNetworkPhysicsDatas, LocalFrame) == 0x00000C, "Member 'FNetworkPhysicsDatas::LocalFrame' has a wrong offset!");
//(offsetof(FNetworkPhysicsDatas, InputFrame) == 0x000010, "Member 'FNetworkPhysicsDatas::InputFrame' has a wrong offset!");

// ScriptStruct Engine.DataTableRowCategoryHandle
// 0x0030 (0x0030 - 0x0000)
struct FDataTableRowCategoryHandle final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColumnName;                                        // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDataTableRowCategoryHandle) == 0x000008, "Wrong alignment on FDataTableRowCategoryHandle");
//(sizeof(FDataTableRowCategoryHandle) == 0x000030, "Wrong size on FDataTableRowCategoryHandle");
//(offsetof(FDataTableRowCategoryHandle, DataTable) == 0x000000, "Member 'FDataTableRowCategoryHandle::DataTable' has a wrong offset!");
//(offsetof(FDataTableRowCategoryHandle, ColumnName) == 0x000008, "Member 'FDataTableRowCategoryHandle::ColumnName' has a wrong offset!");
//(offsetof(FDataTableRowCategoryHandle, RowName) == 0x000014, "Member 'FDataTableRowCategoryHandle::RowName' has a wrong offset!");

// ScriptStruct Engine.DebugCameraControllerSettingsViewModeIndex
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDebugCameraControllerSettingsViewModeIndex final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EViewModeIndex                                ViewModeIndex;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FDebugCameraControllerSettingsViewModeIndex) == 0x000008, "Wrong alignment on FDebugCameraControllerSettingsViewModeIndex");
//(sizeof(FDebugCameraControllerSettingsViewModeIndex) == 0x000010, "Wrong size on FDebugCameraControllerSettingsViewModeIndex");
//(offsetof(FDebugCameraControllerSettingsViewModeIndex, ViewModeIndex) == 0x000008, "Member 'FDebugCameraControllerSettingsViewModeIndex::ViewModeIndex' has a wrong offset!");

// ScriptStruct Engine.RollbackNetStartupActorInfo
// 0x00E0 (0x00E0 - 0x0000)
struct FRollbackNetStartupActorInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Archetype;                                         // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0xB8];                                      // 0x0018(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ObjReferences;                                     // 0x00D0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FRollbackNetStartupActorInfo) == 0x000008, "Wrong alignment on FRollbackNetStartupActorInfo");
//(sizeof(FRollbackNetStartupActorInfo) == 0x0000E0, "Wrong size on FRollbackNetStartupActorInfo");
//(offsetof(FRollbackNetStartupActorInfo, Archetype) == 0x000010, "Member 'FRollbackNetStartupActorInfo::Archetype' has a wrong offset!");
//(offsetof(FRollbackNetStartupActorInfo, ObjReferences) == 0x0000D0, "Member 'FRollbackNetStartupActorInfo::ObjReferences' has a wrong offset!");

// ScriptStruct Engine.MulticastRecordOptions
// 0x0018 (0x0018 - 0x0000)
struct FMulticastRecordOptions final
{
public:
	class FString                                 FuncPathName;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerSkip;                                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientSkip;                                       // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMulticastRecordOptions) == 0x000008, "Wrong alignment on FMulticastRecordOptions");
//(sizeof(FMulticastRecordOptions) == 0x000018, "Wrong size on FMulticastRecordOptions");
//(offsetof(FMulticastRecordOptions, FuncPathName) == 0x000000, "Member 'FMulticastRecordOptions::FuncPathName' has a wrong offset!");
//(offsetof(FMulticastRecordOptions, bServerSkip) == 0x000010, "Member 'FMulticastRecordOptions::bServerSkip' has a wrong offset!");
//(offsetof(FMulticastRecordOptions, bClientSkip) == 0x000011, "Member 'FMulticastRecordOptions::bClientSkip' has a wrong offset!");

// ScriptStruct Engine.PhysicalAnimationProfile
// 0x003C (0x003C - 0x0000)
struct FPhysicalAnimationProfile final
{
public:
	class FName                                   ProfileName;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPhysicalAnimationData                 PhysicalAnimationData;                             // 0x000C(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FPhysicalAnimationProfile) == 0x000004, "Wrong alignment on FPhysicalAnimationProfile");
//(sizeof(FPhysicalAnimationProfile) == 0x00003C, "Wrong size on FPhysicalAnimationProfile");
//(offsetof(FPhysicalAnimationProfile, ProfileName) == 0x000000, "Member 'FPhysicalAnimationProfile::ProfileName' has a wrong offset!");
//(offsetof(FPhysicalAnimationProfile, PhysicalAnimationData) == 0x00000C, "Member 'FPhysicalAnimationProfile::PhysicalAnimationData' has a wrong offset!");

// ScriptStruct Engine.SelectedFragmentProperties
// 0x0028 (0x0028 - 0x0000)
struct FSelectedFragmentProperties final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Fragment;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSelectedFragmentProperties) == 0x000008, "Wrong alignment on FSelectedFragmentProperties");
//(sizeof(FSelectedFragmentProperties) == 0x000028, "Wrong size on FSelectedFragmentProperties");
//(offsetof(FSelectedFragmentProperties, Tag) == 0x000000, "Member 'FSelectedFragmentProperties::Tag' has a wrong offset!");
//(offsetof(FSelectedFragmentProperties, Fragment) == 0x000010, "Member 'FSelectedFragmentProperties::Fragment' has a wrong offset!");
//(offsetof(FSelectedFragmentProperties, bEnabled) == 0x000020, "Member 'FSelectedFragmentProperties::bEnabled' has a wrong offset!");

// ScriptStruct Engine.DPMatchingIfCondition
// 0x0030 (0x0030 - 0x0000)
struct FDPMatchingIfCondition final
{
public:
	class FName                                   Operator;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Arg1;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Arg2;                                              // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDPMatchingIfCondition) == 0x000008, "Wrong alignment on FDPMatchingIfCondition");
//(sizeof(FDPMatchingIfCondition) == 0x000030, "Wrong size on FDPMatchingIfCondition");
//(offsetof(FDPMatchingIfCondition, Operator) == 0x000000, "Member 'FDPMatchingIfCondition::Operator' has a wrong offset!");
//(offsetof(FDPMatchingIfCondition, Arg1) == 0x000010, "Member 'FDPMatchingIfCondition::Arg1' has a wrong offset!");
//(offsetof(FDPMatchingIfCondition, Arg2) == 0x000020, "Member 'FDPMatchingIfCondition::Arg2' has a wrong offset!");

// ScriptStruct Engine.DPMatchingRulestructBase
// 0x0048 (0x0048 - 0x0000)
struct FDPMatchingRulestructBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RuleName;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDPMatchingIfCondition>         IfConditions;                                      // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 AppendFragments;                                   // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SetUserVar;                                        // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDPMatchingRulestructBase) == 0x000008, "Wrong alignment on FDPMatchingRulestructBase");
//(sizeof(FDPMatchingRulestructBase) == 0x000048, "Wrong size on FDPMatchingRulestructBase");
//(offsetof(FDPMatchingRulestructBase, RuleName) == 0x000008, "Member 'FDPMatchingRulestructBase::RuleName' has a wrong offset!");
//(offsetof(FDPMatchingRulestructBase, IfConditions) == 0x000018, "Member 'FDPMatchingRulestructBase::IfConditions' has a wrong offset!");
//(offsetof(FDPMatchingRulestructBase, AppendFragments) == 0x000028, "Member 'FDPMatchingRulestructBase::AppendFragments' has a wrong offset!");
//(offsetof(FDPMatchingRulestructBase, SetUserVar) == 0x000038, "Member 'FDPMatchingRulestructBase::SetUserVar' has a wrong offset!");

// ScriptStruct Engine.DPMatchingRulestructA
// 0x0020 (0x0068 - 0x0048)
struct FDPMatchingRulestructA final : public FDPMatchingRulestructBase
{
public:
	TArray<struct FDPMatchingRulestructBase>      OnTrue;                                            // 0x0048(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FDPMatchingRulestructBase>      OnFalse;                                           // 0x0058(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
//(alignof(FDPMatchingRulestructA) == 0x000008, "Wrong alignment on FDPMatchingRulestructA");
//(sizeof(FDPMatchingRulestructA) == 0x000068, "Wrong size on FDPMatchingRulestructA");
//(offsetof(FDPMatchingRulestructA, OnTrue) == 0x000048, "Member 'FDPMatchingRulestructA::OnTrue' has a wrong offset!");
//(offsetof(FDPMatchingRulestructA, OnFalse) == 0x000058, "Member 'FDPMatchingRulestructA::OnFalse' has a wrong offset!");

// ScriptStruct Engine.TextureSource
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FTextureSource final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTextureSource) == 0x000008, "Wrong alignment on FTextureSource");
//(sizeof(FTextureSource) == 0x000070, "Wrong size on FTextureSource");

// ScriptStruct Engine.DPMatchingRulestructB
// 0x0020 (0x0068 - 0x0048)
struct FDPMatchingRulestructB final : public FDPMatchingRulestructBase
{
public:
	TArray<struct FDPMatchingRulestructA>         OnTrue;                                            // 0x0048(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FDPMatchingRulestructA>         OnFalse;                                           // 0x0058(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
//(alignof(FDPMatchingRulestructB) == 0x000008, "Wrong alignment on FDPMatchingRulestructB");
//(sizeof(FDPMatchingRulestructB) == 0x000068, "Wrong size on FDPMatchingRulestructB");
//(offsetof(FDPMatchingRulestructB, OnTrue) == 0x000048, "Member 'FDPMatchingRulestructB::OnTrue' has a wrong offset!");
//(offsetof(FDPMatchingRulestructB, OnFalse) == 0x000058, "Member 'FDPMatchingRulestructB::OnFalse' has a wrong offset!");

// ScriptStruct Engine.DPMatchingRulestructC
// 0x0020 (0x0068 - 0x0048)
struct FDPMatchingRulestructC final : public FDPMatchingRulestructBase
{
public:
	TArray<struct FDPMatchingRulestructB>         OnTrue;                                            // 0x0048(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FDPMatchingRulestructB>         OnFalse;                                           // 0x0058(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
//(alignof(FDPMatchingRulestructC) == 0x000008, "Wrong alignment on FDPMatchingRulestructC");
//(sizeof(FDPMatchingRulestructC) == 0x000068, "Wrong size on FDPMatchingRulestructC");
//(offsetof(FDPMatchingRulestructC, OnTrue) == 0x000048, "Member 'FDPMatchingRulestructC::OnTrue' has a wrong offset!");
//(offsetof(FDPMatchingRulestructC, OnFalse) == 0x000058, "Member 'FDPMatchingRulestructC::OnFalse' has a wrong offset!");

// ScriptStruct Engine.DPMatchingRulestructD
// 0x0020 (0x0068 - 0x0048)
struct FDPMatchingRulestructD final : public FDPMatchingRulestructBase
{
public:
	TArray<struct FDPMatchingRulestructC>         OnTrue;                                            // 0x0048(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FDPMatchingRulestructC>         OnFalse;                                           // 0x0058(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
//(alignof(FDPMatchingRulestructD) == 0x000008, "Wrong alignment on FDPMatchingRulestructD");
//(sizeof(FDPMatchingRulestructD) == 0x000068, "Wrong size on FDPMatchingRulestructD");
//(offsetof(FDPMatchingRulestructD, OnTrue) == 0x000048, "Member 'FDPMatchingRulestructD::OnTrue' has a wrong offset!");
//(offsetof(FDPMatchingRulestructD, OnFalse) == 0x000058, "Member 'FDPMatchingRulestructD::OnFalse' has a wrong offset!");

// ScriptStruct Engine.DPMatchingRulestructE
// 0x0020 (0x0068 - 0x0048)
struct FDPMatchingRulestructE final : public FDPMatchingRulestructBase
{
public:
	TArray<struct FDPMatchingRulestructD>         OnTrue;                                            // 0x0048(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FDPMatchingRulestructD>         OnFalse;                                           // 0x0058(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
//(alignof(FDPMatchingRulestructE) == 0x000008, "Wrong alignment on FDPMatchingRulestructE");
//(sizeof(FDPMatchingRulestructE) == 0x000068, "Wrong size on FDPMatchingRulestructE");
//(offsetof(FDPMatchingRulestructE, OnTrue) == 0x000048, "Member 'FDPMatchingRulestructE::OnTrue' has a wrong offset!");
//(offsetof(FDPMatchingRulestructE, OnFalse) == 0x000058, "Member 'FDPMatchingRulestructE::OnFalse' has a wrong offset!");

// ScriptStruct Engine.TextureLODGroup
// 0x0070 (0x0070 - 0x0000)
struct FTextureLODGroup final
{
public:
	ETextureGroup                                 Group;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODBias;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODBias_Smaller;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODBias_Smallest;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumStreamedMips;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureMipGenSettings                        MipGenSettings;                                    // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinLODSize;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLODSize;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLODSize_Smaller;                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLODSize_Smallest;                               // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLODSize_VT;                                     // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionalLODBias;                                   // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionalMaxLODSize;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MinMagFilter;                                      // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MipFilter;                                         // 0x0048(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureMipLoadOptions                        MipLoadOptions;                                    // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HighPriorityLoad;                                  // 0x0055(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DuplicateNonOptionalMips;                          // 0x0056(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Downscale;                                         // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureDownscaleOptions                      DownscaleOptions;                                  // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VirtualTextureTileCountBias;                       // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VirtualTextureTileSizeBias;                        // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureLossyCompressionAmount                LossyCompressionAmount;                            // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CookPlatformTilingDisabled;                        // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureCompressionSettings                   CompressionSettings;                               // 0x006A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x1];                                       // 0x006B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAniso;                                          // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTextureLODGroup) == 0x000004, "Wrong alignment on FTextureLODGroup");
//(sizeof(FTextureLODGroup) == 0x000070, "Wrong size on FTextureLODGroup");
//(offsetof(FTextureLODGroup, Group) == 0x000000, "Member 'FTextureLODGroup::Group' has a wrong offset!");
//(offsetof(FTextureLODGroup, LODBias) == 0x000008, "Member 'FTextureLODGroup::LODBias' has a wrong offset!");
//(offsetof(FTextureLODGroup, LODBias_Smaller) == 0x00000C, "Member 'FTextureLODGroup::LODBias_Smaller' has a wrong offset!");
//(offsetof(FTextureLODGroup, LODBias_Smallest) == 0x000010, "Member 'FTextureLODGroup::LODBias_Smallest' has a wrong offset!");
//(offsetof(FTextureLODGroup, NumStreamedMips) == 0x000018, "Member 'FTextureLODGroup::NumStreamedMips' has a wrong offset!");
//(offsetof(FTextureLODGroup, MipGenSettings) == 0x00001C, "Member 'FTextureLODGroup::MipGenSettings' has a wrong offset!");
//(offsetof(FTextureLODGroup, MinLODSize) == 0x000020, "Member 'FTextureLODGroup::MinLODSize' has a wrong offset!");
//(offsetof(FTextureLODGroup, MaxLODSize) == 0x000024, "Member 'FTextureLODGroup::MaxLODSize' has a wrong offset!");
//(offsetof(FTextureLODGroup, MaxLODSize_Smaller) == 0x000028, "Member 'FTextureLODGroup::MaxLODSize_Smaller' has a wrong offset!");
//(offsetof(FTextureLODGroup, MaxLODSize_Smallest) == 0x00002C, "Member 'FTextureLODGroup::MaxLODSize_Smallest' has a wrong offset!");
//(offsetof(FTextureLODGroup, MaxLODSize_VT) == 0x000030, "Member 'FTextureLODGroup::MaxLODSize_VT' has a wrong offset!");
//(offsetof(FTextureLODGroup, OptionalLODBias) == 0x000034, "Member 'FTextureLODGroup::OptionalLODBias' has a wrong offset!");
//(offsetof(FTextureLODGroup, OptionalMaxLODSize) == 0x000038, "Member 'FTextureLODGroup::OptionalMaxLODSize' has a wrong offset!");
//(offsetof(FTextureLODGroup, MinMagFilter) == 0x00003C, "Member 'FTextureLODGroup::MinMagFilter' has a wrong offset!");
//(offsetof(FTextureLODGroup, MipFilter) == 0x000048, "Member 'FTextureLODGroup::MipFilter' has a wrong offset!");
//(offsetof(FTextureLODGroup, MipLoadOptions) == 0x000054, "Member 'FTextureLODGroup::MipLoadOptions' has a wrong offset!");
//(offsetof(FTextureLODGroup, HighPriorityLoad) == 0x000055, "Member 'FTextureLODGroup::HighPriorityLoad' has a wrong offset!");
//(offsetof(FTextureLODGroup, DuplicateNonOptionalMips) == 0x000056, "Member 'FTextureLODGroup::DuplicateNonOptionalMips' has a wrong offset!");
//(offsetof(FTextureLODGroup, Downscale) == 0x000058, "Member 'FTextureLODGroup::Downscale' has a wrong offset!");
//(offsetof(FTextureLODGroup, DownscaleOptions) == 0x00005C, "Member 'FTextureLODGroup::DownscaleOptions' has a wrong offset!");
//(offsetof(FTextureLODGroup, VirtualTextureTileCountBias) == 0x000060, "Member 'FTextureLODGroup::VirtualTextureTileCountBias' has a wrong offset!");
//(offsetof(FTextureLODGroup, VirtualTextureTileSizeBias) == 0x000064, "Member 'FTextureLODGroup::VirtualTextureTileSizeBias' has a wrong offset!");
//(offsetof(FTextureLODGroup, LossyCompressionAmount) == 0x000068, "Member 'FTextureLODGroup::LossyCompressionAmount' has a wrong offset!");
//(offsetof(FTextureLODGroup, CookPlatformTilingDisabled) == 0x000069, "Member 'FTextureLODGroup::CookPlatformTilingDisabled' has a wrong offset!");
//(offsetof(FTextureLODGroup, CompressionSettings) == 0x00006A, "Member 'FTextureLODGroup::CompressionSettings' has a wrong offset!");
//(offsetof(FTextureLODGroup, MaxAniso) == 0x00006C, "Member 'FTextureLODGroup::MaxAniso' has a wrong offset!");

// ScriptStruct Engine.DPMatchingRulestruct
// 0x0020 (0x0068 - 0x0048)
struct FDPMatchingRulestruct final : public FDPMatchingRulestructBase
{
public:
	TArray<struct FDPMatchingRulestructE>         OnTrue;                                            // 0x0048(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FDPMatchingRulestructE>         OnFalse;                                           // 0x0058(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
//(alignof(FDPMatchingRulestruct) == 0x000008, "Wrong alignment on FDPMatchingRulestruct");
//(sizeof(FDPMatchingRulestruct) == 0x000068, "Wrong size on FDPMatchingRulestruct");
//(offsetof(FDPMatchingRulestruct, OnTrue) == 0x000048, "Member 'FDPMatchingRulestruct::OnTrue' has a wrong offset!");
//(offsetof(FDPMatchingRulestruct, OnFalse) == 0x000058, "Member 'FDPMatchingRulestruct::OnFalse' has a wrong offset!");

// ScriptStruct Engine.DialogueContext
// 0x0018 (0x0018 - 0x0000)
struct FDialogueContext final
{
public:
	class UDialogueVoice*                         Speaker;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDialogueVoice*>                 Targets;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
//(alignof(FDialogueContext) == 0x000008, "Wrong alignment on FDialogueContext");
//(sizeof(FDialogueContext) == 0x000018, "Wrong size on FDialogueContext");
//(offsetof(FDialogueContext, Speaker) == 0x000000, "Member 'FDialogueContext::Speaker' has a wrong offset!");
//(offsetof(FDialogueContext, Targets) == 0x000008, "Member 'FDialogueContext::Targets' has a wrong offset!");

// ScriptStruct Engine.DialogueWaveParameter
// 0x0020 (0x0020 - 0x0000)
struct FDialogueWaveParameter final
{
public:
	class UDialogueWave*                          DialogueWave;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogueContext                       Context;                                           // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
//(alignof(FDialogueWaveParameter) == 0x000008, "Wrong alignment on FDialogueWaveParameter");
//(sizeof(FDialogueWaveParameter) == 0x000020, "Wrong size on FDialogueWaveParameter");
//(offsetof(FDialogueWaveParameter, DialogueWave) == 0x000000, "Member 'FDialogueWaveParameter::DialogueWave' has a wrong offset!");
//(offsetof(FDialogueWaveParameter, Context) == 0x000008, "Member 'FDialogueWaveParameter::Context' has a wrong offset!");

// ScriptStruct Engine.DialogueContextMapping
// 0x0038 (0x0038 - 0x0000)
struct FDialogueContextMapping final
{
public:
	struct FDialogueContext                       Context;                                           // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class USoundWave*                             SoundWave;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LocalizationKeyFormat;                             // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueSoundWaveProxy*                Proxy;                                             // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDialogueContextMapping) == 0x000008, "Wrong alignment on FDialogueContextMapping");
//(sizeof(FDialogueContextMapping) == 0x000038, "Wrong size on FDialogueContextMapping");
//(offsetof(FDialogueContextMapping, Context) == 0x000000, "Member 'FDialogueContextMapping::Context' has a wrong offset!");
//(offsetof(FDialogueContextMapping, SoundWave) == 0x000018, "Member 'FDialogueContextMapping::SoundWave' has a wrong offset!");
//(offsetof(FDialogueContextMapping, LocalizationKeyFormat) == 0x000020, "Member 'FDialogueContextMapping::LocalizationKeyFormat' has a wrong offset!");
//(offsetof(FDialogueContextMapping, Proxy) == 0x000030, "Member 'FDialogueContextMapping::Proxy' has a wrong offset!");

// ScriptStruct Engine.GraphReference
// 0x0020 (0x0020 - 0x0000)
struct FGraphReference final
{
public:
	class UEdGraph*                               MacroGraph;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlueprint*                             GraphBlueprint;                                    // 0x0008(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  GraphGuid;                                         // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
//(alignof(FGraphReference) == 0x000008, "Wrong alignment on FGraphReference");
//(sizeof(FGraphReference) == 0x000020, "Wrong size on FGraphReference");
//(offsetof(FGraphReference, MacroGraph) == 0x000000, "Member 'FGraphReference::MacroGraph' has a wrong offset!");
//(offsetof(FGraphReference, GraphBlueprint) == 0x000008, "Member 'FGraphReference::GraphBlueprint' has a wrong offset!");
//(offsetof(FGraphReference, GraphGuid) == 0x000010, "Member 'FGraphReference::GraphGuid' has a wrong offset!");

// ScriptStruct Engine.AssetImportInfo
// 0x0001 (0x0001 - 0x0000)
struct FAssetImportInfo final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAssetImportInfo) == 0x000001, "Wrong alignment on FAssetImportInfo");
//(sizeof(FAssetImportInfo) == 0x000001, "Wrong size on FAssetImportInfo");

// ScriptStruct Engine.TypedElementPasteOptions
// 0x0078 (0x0078 - 0x0000)
struct FTypedElementPasteOptions final
{
public:
	class UTypedElementSelectionSet*              SelectionSetToModify;                              // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPasteAtLocation;                                  // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PasteLocation;                                     // 0x0010(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FTypedElementPasteOptions) == 0x000008, "Wrong alignment on FTypedElementPasteOptions");
//(sizeof(FTypedElementPasteOptions) == 0x000078, "Wrong size on FTypedElementPasteOptions");
//(offsetof(FTypedElementPasteOptions, SelectionSetToModify) == 0x000000, "Member 'FTypedElementPasteOptions::SelectionSetToModify' has a wrong offset!");
//(offsetof(FTypedElementPasteOptions, bPasteAtLocation) == 0x000008, "Member 'FTypedElementPasteOptions::bPasteAtLocation' has a wrong offset!");
//(offsetof(FTypedElementPasteOptions, PasteLocation) == 0x000010, "Member 'FTypedElementPasteOptions::PasteLocation' has a wrong offset!");

// ScriptStruct Engine.TypedElementDeletionOptions
// 0x0003 (0x0003 - 0x0000)
struct FTypedElementDeletionOptions final
{
public:
	bool                                          bVerifyDeletionCanHappen;                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWarnAboutReferences;                              // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWarnAboutSoftReferences;                          // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FTypedElementDeletionOptions) == 0x000001, "Wrong alignment on FTypedElementDeletionOptions");
//(sizeof(FTypedElementDeletionOptions) == 0x000003, "Wrong size on FTypedElementDeletionOptions");
//(offsetof(FTypedElementDeletionOptions, bVerifyDeletionCanHappen) == 0x000000, "Member 'FTypedElementDeletionOptions::bVerifyDeletionCanHappen' has a wrong offset!");
//(offsetof(FTypedElementDeletionOptions, bWarnAboutReferences) == 0x000001, "Member 'FTypedElementDeletionOptions::bWarnAboutReferences' has a wrong offset!");
//(offsetof(FTypedElementDeletionOptions, bWarnAboutSoftReferences) == 0x000002, "Member 'FTypedElementDeletionOptions::bWarnAboutSoftReferences' has a wrong offset!");

// ScriptStruct Engine.HardwareCursorReference
// 0x0020 (0x0020 - 0x0000)
struct FHardwareCursorReference final
{
public:
	class FName                                   CursorPath;                                        // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              HotSpot;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FHardwareCursorReference) == 0x000008, "Wrong alignment on FHardwareCursorReference");
//(sizeof(FHardwareCursorReference) == 0x000020, "Wrong size on FHardwareCursorReference");
//(offsetof(FHardwareCursorReference, CursorPath) == 0x000000, "Member 'FHardwareCursorReference::CursorPath' has a wrong offset!");
//(offsetof(FHardwareCursorReference, HotSpot) == 0x000010, "Member 'FHardwareCursorReference::HotSpot' has a wrong offset!");

// ScriptStruct Engine.PointDamageEvent
// 0x0180 (0x0190 - 0x0010)
struct FPointDamageEvent final : public FDamageEvent
{
public:
	float                                         Damage;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantizeNormal              ShotDirection;                                     // 0x0018(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitInfo;                                           // 0x0030(0x0160)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
//(alignof(FPointDamageEvent) == 0x000008, "Wrong alignment on FPointDamageEvent");
//(sizeof(FPointDamageEvent) == 0x000190, "Wrong size on FPointDamageEvent");
//(offsetof(FPointDamageEvent, Damage) == 0x000010, "Member 'FPointDamageEvent::Damage' has a wrong offset!");
//(offsetof(FPointDamageEvent, ShotDirection) == 0x000018, "Member 'FPointDamageEvent::ShotDirection' has a wrong offset!");
//(offsetof(FPointDamageEvent, HitInfo) == 0x000030, "Member 'FPointDamageEvent::HitInfo' has a wrong offset!");

// ScriptStruct Engine.HitResultNetSerializerConfig
// 0x0001 (0x0001 - 0x0000)
struct FHitResultNetSerializerConfig final : public FNetSerializerConfig
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FHitResultNetSerializerConfig) == 0x000001, "Wrong alignment on FHitResultNetSerializerConfig");
//(sizeof(FHitResultNetSerializerConfig) == 0x000001, "Wrong size on FHitResultNetSerializerConfig");

// ScriptStruct Engine.SkelMeshMergeSectionMapping
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshMergeSectionMapping final
{
public:
	TArray<int32>                                 SectionIDs;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FSkelMeshMergeSectionMapping) == 0x000008, "Wrong alignment on FSkelMeshMergeSectionMapping");
//(sizeof(FSkelMeshMergeSectionMapping) == 0x000010, "Wrong size on FSkelMeshMergeSectionMapping");
//(offsetof(FSkelMeshMergeSectionMapping, SectionIDs) == 0x000000, "Member 'FSkelMeshMergeSectionMapping::SectionIDs' has a wrong offset!");

// ScriptStruct Engine.RigidBodyState
// 0x0080 (0x0080 - 0x0000)
struct FRigidBodyState final
{
public:
	struct FVector_NetQuantize100                 Position;                                          // 0x0000(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Quaternion;                                        // 0x0020(0x0020)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 LinVel;                                            // 0x0040(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 AngVel;                                            // 0x0058(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Flags;                                             // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRigidBodyState) == 0x000010, "Wrong alignment on FRigidBodyState");
//(sizeof(FRigidBodyState) == 0x000080, "Wrong size on FRigidBodyState");
//(offsetof(FRigidBodyState, Position) == 0x000000, "Member 'FRigidBodyState::Position' has a wrong offset!");
//(offsetof(FRigidBodyState, Quaternion) == 0x000020, "Member 'FRigidBodyState::Quaternion' has a wrong offset!");
//(offsetof(FRigidBodyState, LinVel) == 0x000040, "Member 'FRigidBodyState::LinVel' has a wrong offset!");
//(offsetof(FRigidBodyState, AngVel) == 0x000058, "Member 'FRigidBodyState::AngVel' has a wrong offset!");
//(offsetof(FRigidBodyState, Flags) == 0x000070, "Member 'FRigidBodyState::Flags' has a wrong offset!");

// ScriptStruct Engine.FontCharacter
// 0x0018 (0x0018 - 0x0000)
struct FFontCharacter final
{
public:
	int32                                         StartU;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartV;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         USize;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VSize;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TextureIndex;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VerticalOffset;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FFontCharacter) == 0x000004, "Wrong alignment on FFontCharacter");
//(sizeof(FFontCharacter) == 0x000018, "Wrong size on FFontCharacter");
//(offsetof(FFontCharacter, StartU) == 0x000000, "Member 'FFontCharacter::StartU' has a wrong offset!");
//(offsetof(FFontCharacter, StartV) == 0x000004, "Member 'FFontCharacter::StartV' has a wrong offset!");
//(offsetof(FFontCharacter, USize) == 0x000008, "Member 'FFontCharacter::USize' has a wrong offset!");
//(offsetof(FFontCharacter, VSize) == 0x00000C, "Member 'FFontCharacter::VSize' has a wrong offset!");
//(offsetof(FFontCharacter, TextureIndex) == 0x000010, "Member 'FFontCharacter::TextureIndex' has a wrong offset!");
//(offsetof(FFontCharacter, VerticalOffset) == 0x000014, "Member 'FFontCharacter::VerticalOffset' has a wrong offset!");

// ScriptStruct Engine.CharacterNetworkSerializationPackedBitsNetSerializerConfig
// 0x0008 (0x0008 - 0x0000)
struct FCharacterNetworkSerializationPackedBitsNetSerializerConfig final : public FNetSerializerConfig
{
public:
	uint32                                        MaxAllowedDataBits;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxAllowedObjectReferences;                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCharacterNetworkSerializationPackedBitsNetSerializerConfig) == 0x000004, "Wrong alignment on FCharacterNetworkSerializationPackedBitsNetSerializerConfig");
//(sizeof(FCharacterNetworkSerializationPackedBitsNetSerializerConfig) == 0x000008, "Wrong size on FCharacterNetworkSerializationPackedBitsNetSerializerConfig");
//(offsetof(FCharacterNetworkSerializationPackedBitsNetSerializerConfig, MaxAllowedDataBits) == 0x000000, "Member 'FCharacterNetworkSerializationPackedBitsNetSerializerConfig::MaxAllowedDataBits' has a wrong offset!");
//(offsetof(FCharacterNetworkSerializationPackedBitsNetSerializerConfig, MaxAllowedObjectReferences) == 0x000004, "Member 'FCharacterNetworkSerializationPackedBitsNetSerializerConfig::MaxAllowedObjectReferences' has a wrong offset!");

// ScriptStruct Engine.ForceFeedbackChannelDetails
// 0x0090 (0x0090 - 0x0000)
struct FForceFeedbackChannelDetails final
{
public:
	uint8                                         bAffectsLeftLarge : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectsLeftSmall : 1;                             // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectsRightLarge : 1;                            // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectsRightSmall : 1;                            // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
};
//(alignof(FForceFeedbackChannelDetails) == 0x000008, "Wrong alignment on FForceFeedbackChannelDetails");
//(sizeof(FForceFeedbackChannelDetails) == 0x000090, "Wrong size on FForceFeedbackChannelDetails");
//(offsetof(FForceFeedbackChannelDetails, Curve) == 0x000008, "Member 'FForceFeedbackChannelDetails::Curve' has a wrong offset!");

// ScriptStruct Engine.ActiveForceFeedbackEffect
// 0x0078 (0x0078 - 0x0000)
struct FActiveForceFeedbackEffect final
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FInputDevicePropertyHandle>       ActiveDeviceProperties;                            // 0x0028(0x0050)(NativeAccessSpecifierPublic)
};
//(alignof(FActiveForceFeedbackEffect) == 0x000008, "Wrong alignment on FActiveForceFeedbackEffect");
//(sizeof(FActiveForceFeedbackEffect) == 0x000078, "Wrong size on FActiveForceFeedbackEffect");
//(offsetof(FActiveForceFeedbackEffect, ForceFeedbackEffect) == 0x000000, "Member 'FActiveForceFeedbackEffect::ForceFeedbackEffect' has a wrong offset!");
//(offsetof(FActiveForceFeedbackEffect, ActiveDeviceProperties) == 0x000028, "Member 'FActiveForceFeedbackEffect::ActiveDeviceProperties' has a wrong offset!");

// ScriptStruct Engine.ForceFeedbackEffectOverridenChannelDetails
// 0x0010 (0x0010 - 0x0000)
struct FForceFeedbackEffectOverridenChannelDetails final
{
public:
	TArray<struct FForceFeedbackChannelDetails>   ChannelDetails;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FForceFeedbackEffectOverridenChannelDetails) == 0x000008, "Wrong alignment on FForceFeedbackEffectOverridenChannelDetails");
//(sizeof(FForceFeedbackEffectOverridenChannelDetails) == 0x000010, "Wrong size on FForceFeedbackEffectOverridenChannelDetails");
//(offsetof(FForceFeedbackEffectOverridenChannelDetails, ChannelDetails) == 0x000000, "Member 'FForceFeedbackEffectOverridenChannelDetails::ChannelDetails' has a wrong offset!");

// ScriptStruct Engine.DeviceColorData
// 0x0008 (0x0008 - 0x0000)
struct FDeviceColorData final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetAfterCompletion;                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 LightColor;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDeviceColorData) == 0x000004, "Wrong alignment on FDeviceColorData");
//(sizeof(FDeviceColorData) == 0x000008, "Wrong size on FDeviceColorData");
//(offsetof(FDeviceColorData, bEnable) == 0x000000, "Member 'FDeviceColorData::bEnable' has a wrong offset!");
//(offsetof(FDeviceColorData, bResetAfterCompletion) == 0x000001, "Member 'FDeviceColorData::bResetAfterCompletion' has a wrong offset!");
//(offsetof(FDeviceColorData, LightColor) == 0x000004, "Member 'FDeviceColorData::LightColor' has a wrong offset!");

// ScriptStruct Engine.DeviceColorCurveData
// 0x0010 (0x0010 - 0x0000)
struct FDeviceColorCurveData final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetAfterCompletion;                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveLinearColor*                      DeviceColorCurve;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDeviceColorCurveData) == 0x000008, "Wrong alignment on FDeviceColorCurveData");
//(sizeof(FDeviceColorCurveData) == 0x000010, "Wrong size on FDeviceColorCurveData");
//(offsetof(FDeviceColorCurveData, bEnable) == 0x000000, "Member 'FDeviceColorCurveData::bEnable' has a wrong offset!");
//(offsetof(FDeviceColorCurveData, bResetAfterCompletion) == 0x000001, "Member 'FDeviceColorCurveData::bResetAfterCompletion' has a wrong offset!");
//(offsetof(FDeviceColorCurveData, DeviceColorCurve) == 0x000008, "Member 'FDeviceColorCurveData::DeviceColorCurve' has a wrong offset!");

// ScriptStruct Engine.DeviceTriggerBaseData
// 0x0002 (0x0002 - 0x0000)
struct FDeviceTriggerBaseData final
{
public:
	EInputDeviceTriggerMask                       AffectedTriggers;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetUponCompletion;                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDeviceTriggerBaseData) == 0x000001, "Wrong alignment on FDeviceTriggerBaseData");
//(sizeof(FDeviceTriggerBaseData) == 0x000002, "Wrong size on FDeviceTriggerBaseData");
//(offsetof(FDeviceTriggerBaseData, AffectedTriggers) == 0x000000, "Member 'FDeviceTriggerBaseData::AffectedTriggers' has a wrong offset!");
//(offsetof(FDeviceTriggerBaseData, bResetUponCompletion) == 0x000001, "Member 'FDeviceTriggerBaseData::bResetUponCompletion' has a wrong offset!");

// ScriptStruct Engine.DeviceTriggerFeedbackData
// 0x0010 (0x0010 - 0x0000)
struct FDeviceTriggerFeedbackData final
{
public:
	class UCurveFloat*                            FeedbackPositionCurve;                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FeedbackStrenghCurve;                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDeviceTriggerFeedbackData) == 0x000008, "Wrong alignment on FDeviceTriggerFeedbackData");
//(sizeof(FDeviceTriggerFeedbackData) == 0x000010, "Wrong size on FDeviceTriggerFeedbackData");
//(offsetof(FDeviceTriggerFeedbackData, FeedbackPositionCurve) == 0x000000, "Member 'FDeviceTriggerFeedbackData::FeedbackPositionCurve' has a wrong offset!");
//(offsetof(FDeviceTriggerFeedbackData, FeedbackStrenghCurve) == 0x000008, "Member 'FDeviceTriggerFeedbackData::FeedbackStrenghCurve' has a wrong offset!");

// ScriptStruct Engine.DeviceTriggerTriggerResistanceData
// 0x0010 (0x0010 - 0x0000)
struct FDeviceTriggerTriggerResistanceData final
{
public:
	int32                                         StartPosition;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartStrengh;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndPosition;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndStrengh;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDeviceTriggerTriggerResistanceData) == 0x000004, "Wrong alignment on FDeviceTriggerTriggerResistanceData");
//(sizeof(FDeviceTriggerTriggerResistanceData) == 0x000010, "Wrong size on FDeviceTriggerTriggerResistanceData");
//(offsetof(FDeviceTriggerTriggerResistanceData, StartPosition) == 0x000000, "Member 'FDeviceTriggerTriggerResistanceData::StartPosition' has a wrong offset!");
//(offsetof(FDeviceTriggerTriggerResistanceData, StartStrengh) == 0x000004, "Member 'FDeviceTriggerTriggerResistanceData::StartStrengh' has a wrong offset!");
//(offsetof(FDeviceTriggerTriggerResistanceData, EndPosition) == 0x000008, "Member 'FDeviceTriggerTriggerResistanceData::EndPosition' has a wrong offset!");
//(offsetof(FDeviceTriggerTriggerResistanceData, EndStrengh) == 0x00000C, "Member 'FDeviceTriggerTriggerResistanceData::EndStrengh' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshLODInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FSkeletalMeshLODInfo final
{
public:
	struct FPerPlatformFloat                      ScreenSize;                                        // 0x0000(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LODHysteresis;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 LODMaterialMap;                                    // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSkeletalMeshBuildSettings             BuildSettings;                                     // 0x0018(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSkeletalMeshOptimizationSettings      ReductionSettings;                                 // 0x0030(0x003C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneReference>                 BonesToRemove;                                     // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 BonesToPrioritize;                                 // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSectionReference>              SectionsToPrioritize;                              // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WeightOfPrioritization;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          BakePose;                                          // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BakePoseOverride;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SourceImportFilename;                              // 0x00B8(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkinCacheUsage                               SkinCacheUsage;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MorphTargetPositionErrorTolerance;                 // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasBeenSimplified : 1;                            // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasPerLODVertexColors : 1;                        // 0x00D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowCPUAccess : 1;                               // 0x00D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkeletalMeshVertexAttributeInfo> VertexAttributes;                                  // 0x00D8(0x0010)(Edit, EditFixedSize, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         bSupportUniformlyDistributedSampling : 1;          // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSkeletalMeshLODInfo) == 0x000008, "Wrong alignment on FSkeletalMeshLODInfo");
//(sizeof(FSkeletalMeshLODInfo) == 0x0000F0, "Wrong size on FSkeletalMeshLODInfo");
//(offsetof(FSkeletalMeshLODInfo, ScreenSize) == 0x000000, "Member 'FSkeletalMeshLODInfo::ScreenSize' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, LODHysteresis) == 0x000004, "Member 'FSkeletalMeshLODInfo::LODHysteresis' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, LODMaterialMap) == 0x000008, "Member 'FSkeletalMeshLODInfo::LODMaterialMap' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, BuildSettings) == 0x000018, "Member 'FSkeletalMeshLODInfo::BuildSettings' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, ReductionSettings) == 0x000030, "Member 'FSkeletalMeshLODInfo::ReductionSettings' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, BonesToRemove) == 0x000070, "Member 'FSkeletalMeshLODInfo::BonesToRemove' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, BonesToPrioritize) == 0x000080, "Member 'FSkeletalMeshLODInfo::BonesToPrioritize' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, SectionsToPrioritize) == 0x000090, "Member 'FSkeletalMeshLODInfo::SectionsToPrioritize' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, WeightOfPrioritization) == 0x0000A0, "Member 'FSkeletalMeshLODInfo::WeightOfPrioritization' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, BakePose) == 0x0000A8, "Member 'FSkeletalMeshLODInfo::BakePose' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, BakePoseOverride) == 0x0000B0, "Member 'FSkeletalMeshLODInfo::BakePoseOverride' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, SourceImportFilename) == 0x0000B8, "Member 'FSkeletalMeshLODInfo::SourceImportFilename' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, SkinCacheUsage) == 0x0000C8, "Member 'FSkeletalMeshLODInfo::SkinCacheUsage' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, MorphTargetPositionErrorTolerance) == 0x0000CC, "Member 'FSkeletalMeshLODInfo::MorphTargetPositionErrorTolerance' has a wrong offset!");
//(offsetof(FSkeletalMeshLODInfo, VertexAttributes) == 0x0000D8, "Member 'FSkeletalMeshLODInfo::VertexAttributes' has a wrong offset!");

// ScriptStruct Engine.AudioBasedVibrationData
// 0x0008 (0x0008 - 0x0000)
struct FAudioBasedVibrationData final
{
public:
	class USoundBase*                             Sound;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAudioBasedVibrationData) == 0x000008, "Wrong alignment on FAudioBasedVibrationData");
//(sizeof(FAudioBasedVibrationData) == 0x000008, "Wrong size on FAudioBasedVibrationData");
//(offsetof(FAudioBasedVibrationData, Sound) == 0x000000, "Member 'FAudioBasedVibrationData::Sound' has a wrong offset!");

// ScriptStruct Engine.ActivateDevicePropertyParams
// 0x000C (0x000C - 0x0000)
struct FActivateDevicePropertyParams final
{
public:
	struct FPlatformUserId                        UserId;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputDeviceId                         DeviceID;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLooping : 1;                                      // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreTimeDilation : 1;                           // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayWhilePaused : 1;                              // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FActivateDevicePropertyParams) == 0x000004, "Wrong alignment on FActivateDevicePropertyParams");
//(sizeof(FActivateDevicePropertyParams) == 0x00000C, "Wrong size on FActivateDevicePropertyParams");
//(offsetof(FActivateDevicePropertyParams, UserId) == 0x000000, "Member 'FActivateDevicePropertyParams::UserId' has a wrong offset!");
//(offsetof(FActivateDevicePropertyParams, DeviceID) == 0x000004, "Member 'FActivateDevicePropertyParams::DeviceID' has a wrong offset!");

// ScriptStruct Engine.ActiveDeviceProperty
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FActiveDeviceProperty final
{
public:
	TWeakObjectPtr<class UInputDeviceProperty>    Property;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FActiveDeviceProperty) == 0x000008, "Wrong alignment on FActiveDeviceProperty");
//(sizeof(FActiveDeviceProperty) == 0x000020, "Wrong size on FActiveDeviceProperty");
//(offsetof(FActiveDeviceProperty, Property) == 0x000000, "Member 'FActiveDeviceProperty::Property' has a wrong offset!");

// ScriptStruct Engine.RPCAnalyticsThreshold
// 0x0018 (0x0018 - 0x0000)
struct FRPCAnalyticsThreshold final
{
public:
	class FName                                   RPC;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountPerSec;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        TimePerSec;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRPCAnalyticsThreshold) == 0x000008, "Wrong alignment on FRPCAnalyticsThreshold");
//(sizeof(FRPCAnalyticsThreshold) == 0x000018, "Wrong size on FRPCAnalyticsThreshold");
//(offsetof(FRPCAnalyticsThreshold, RPC) == 0x000000, "Member 'FRPCAnalyticsThreshold::RPC' has a wrong offset!");
//(offsetof(FRPCAnalyticsThreshold, CountPerSec) == 0x00000C, "Member 'FRPCAnalyticsThreshold::CountPerSec' has a wrong offset!");
//(offsetof(FRPCAnalyticsThreshold, TimePerSec) == 0x000010, "Member 'FRPCAnalyticsThreshold::TimePerSec' has a wrong offset!");

// ScriptStruct Engine.RootMotionFinishVelocitySettings
// 0x0028 (0x0028 - 0x0000)
struct FRootMotionFinishVelocitySettings final
{
public:
	ERootMotionFinishVelocityMode                 Mode;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SetVelocity;                                       // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampVelocity;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRootMotionFinishVelocitySettings) == 0x000008, "Wrong alignment on FRootMotionFinishVelocitySettings");
//(sizeof(FRootMotionFinishVelocitySettings) == 0x000028, "Wrong size on FRootMotionFinishVelocitySettings");
//(offsetof(FRootMotionFinishVelocitySettings, Mode) == 0x000000, "Member 'FRootMotionFinishVelocitySettings::Mode' has a wrong offset!");
//(offsetof(FRootMotionFinishVelocitySettings, SetVelocity) == 0x000008, "Member 'FRootMotionFinishVelocitySettings::SetVelocity' has a wrong offset!");
//(offsetof(FRootMotionFinishVelocitySettings, ClampVelocity) == 0x000020, "Member 'FRootMotionFinishVelocitySettings::ClampVelocity' has a wrong offset!");

// ScriptStruct Engine.RootMotionSource
// 0x00F0 (0x00F0 - 0x0000)
struct FRootMotionSource
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        Priority;                                          // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        LocalID;                                           // 0x0012(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionAccumulateMode                     AccumulateMode;                                    // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InstanceName;                                      // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousTime;                                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoSmoothCorrectionDistance;                        // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRootMotionSourceStatus                Status;                                            // 0x0038(0x0001)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRootMotionSourceSettings              Settings;                                          // 0x0039(0x0001)(RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bInLocalSpace;                                     // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionMovementParams              RootMotionParams;                                  // 0x0040(0x0070)(RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	struct FRootMotionFinishVelocitySettings      FinishVelocityParams;                              // 0x00B0(0x0028)(RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 PredictionID;                                      // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldingTime;                                       // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRootMotionSource) == 0x000010, "Wrong alignment on FRootMotionSource");
//(sizeof(FRootMotionSource) == 0x0000F0, "Wrong size on FRootMotionSource");
//(offsetof(FRootMotionSource, Priority) == 0x000010, "Member 'FRootMotionSource::Priority' has a wrong offset!");
//(offsetof(FRootMotionSource, LocalID) == 0x000012, "Member 'FRootMotionSource::LocalID' has a wrong offset!");
//(offsetof(FRootMotionSource, AccumulateMode) == 0x000014, "Member 'FRootMotionSource::AccumulateMode' has a wrong offset!");
//(offsetof(FRootMotionSource, InstanceName) == 0x000018, "Member 'FRootMotionSource::InstanceName' has a wrong offset!");
//(offsetof(FRootMotionSource, StartTime) == 0x000024, "Member 'FRootMotionSource::StartTime' has a wrong offset!");
//(offsetof(FRootMotionSource, CurrentTime) == 0x000028, "Member 'FRootMotionSource::CurrentTime' has a wrong offset!");
//(offsetof(FRootMotionSource, PreviousTime) == 0x00002C, "Member 'FRootMotionSource::PreviousTime' has a wrong offset!");
//(offsetof(FRootMotionSource, Duration) == 0x000030, "Member 'FRootMotionSource::Duration' has a wrong offset!");
//(offsetof(FRootMotionSource, NoSmoothCorrectionDistance) == 0x000034, "Member 'FRootMotionSource::NoSmoothCorrectionDistance' has a wrong offset!");
//(offsetof(FRootMotionSource, Status) == 0x000038, "Member 'FRootMotionSource::Status' has a wrong offset!");
//(offsetof(FRootMotionSource, Settings) == 0x000039, "Member 'FRootMotionSource::Settings' has a wrong offset!");
//(offsetof(FRootMotionSource, bInLocalSpace) == 0x00003A, "Member 'FRootMotionSource::bInLocalSpace' has a wrong offset!");
//(offsetof(FRootMotionSource, RootMotionParams) == 0x000040, "Member 'FRootMotionSource::RootMotionParams' has a wrong offset!");
//(offsetof(FRootMotionSource, FinishVelocityParams) == 0x0000B0, "Member 'FRootMotionSource::FinishVelocityParams' has a wrong offset!");
//(offsetof(FRootMotionSource, PredictionID) == 0x0000D8, "Member 'FRootMotionSource::PredictionID' has a wrong offset!");
//(offsetof(FRootMotionSource, HoldingTime) == 0x0000E8, "Member 'FRootMotionSource::HoldingTime' has a wrong offset!");

// ScriptStruct Engine.RootMotionSource_ConstantForce
// 0x0020 (0x0110 - 0x00F0)
struct FRootMotionSource_ConstantForce : public FRootMotionSource
{
public:
	struct FVector                                Force;                                             // 0x00F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StrengthOverTime;                                  // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRootMotionSource_ConstantForce) == 0x000010, "Wrong alignment on FRootMotionSource_ConstantForce");
//(sizeof(FRootMotionSource_ConstantForce) == 0x000110, "Wrong size on FRootMotionSource_ConstantForce");
//(offsetof(FRootMotionSource_ConstantForce, Force) == 0x0000F0, "Member 'FRootMotionSource_ConstantForce::Force' has a wrong offset!");
//(offsetof(FRootMotionSource_ConstantForce, StrengthOverTime) == 0x000108, "Member 'FRootMotionSource_ConstantForce::StrengthOverTime' has a wrong offset!");

// ScriptStruct Engine.RootMotionSource_RadialForce
// 0x0060 (0x0150 - 0x00F0)
struct FRootMotionSource_RadialForce final : public FRootMotionSource
{
public:
	struct FVector                                Location;                                          // 0x00F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LocationActor;                                     // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPush;                                           // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoZForce;                                         // 0x0119(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrengthDistanceFalloff;                           // 0x0120(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StrengthOverTime;                                  // 0x0128(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFixedWorldDirection;                           // 0x0130(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FixedWorldDirection;                               // 0x0138(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
//(alignof(FRootMotionSource_RadialForce) == 0x000010, "Wrong alignment on FRootMotionSource_RadialForce");
//(sizeof(FRootMotionSource_RadialForce) == 0x000150, "Wrong size on FRootMotionSource_RadialForce");
//(offsetof(FRootMotionSource_RadialForce, Location) == 0x0000F0, "Member 'FRootMotionSource_RadialForce::Location' has a wrong offset!");
//(offsetof(FRootMotionSource_RadialForce, LocationActor) == 0x000108, "Member 'FRootMotionSource_RadialForce::LocationActor' has a wrong offset!");
//(offsetof(FRootMotionSource_RadialForce, Radius) == 0x000110, "Member 'FRootMotionSource_RadialForce::Radius' has a wrong offset!");
//(offsetof(FRootMotionSource_RadialForce, Strength) == 0x000114, "Member 'FRootMotionSource_RadialForce::Strength' has a wrong offset!");
//(offsetof(FRootMotionSource_RadialForce, bIsPush) == 0x000118, "Member 'FRootMotionSource_RadialForce::bIsPush' has a wrong offset!");
//(offsetof(FRootMotionSource_RadialForce, bNoZForce) == 0x000119, "Member 'FRootMotionSource_RadialForce::bNoZForce' has a wrong offset!");
//(offsetof(FRootMotionSource_RadialForce, StrengthDistanceFalloff) == 0x000120, "Member 'FRootMotionSource_RadialForce::StrengthDistanceFalloff' has a wrong offset!");
//(offsetof(FRootMotionSource_RadialForce, StrengthOverTime) == 0x000128, "Member 'FRootMotionSource_RadialForce::StrengthOverTime' has a wrong offset!");
//(offsetof(FRootMotionSource_RadialForce, bUseFixedWorldDirection) == 0x000130, "Member 'FRootMotionSource_RadialForce::bUseFixedWorldDirection' has a wrong offset!");
//(offsetof(FRootMotionSource_RadialForce, FixedWorldDirection) == 0x000138, "Member 'FRootMotionSource_RadialForce::FixedWorldDirection' has a wrong offset!");

// ScriptStruct Engine.RootMotionSource_MoveToForce
// 0x0040 (0x0130 - 0x00F0)
struct FRootMotionSource_MoveToForce : public FRootMotionSource
{
public:
	struct FVector                                StartLocation;                                     // 0x00F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0108(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictSpeedToExpected;                          // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0128(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRootMotionSource_MoveToForce) == 0x000010, "Wrong alignment on FRootMotionSource_MoveToForce");
//(sizeof(FRootMotionSource_MoveToForce) == 0x000130, "Wrong size on FRootMotionSource_MoveToForce");
//(offsetof(FRootMotionSource_MoveToForce, StartLocation) == 0x0000F0, "Member 'FRootMotionSource_MoveToForce::StartLocation' has a wrong offset!");
//(offsetof(FRootMotionSource_MoveToForce, TargetLocation) == 0x000108, "Member 'FRootMotionSource_MoveToForce::TargetLocation' has a wrong offset!");
//(offsetof(FRootMotionSource_MoveToForce, bRestrictSpeedToExpected) == 0x000120, "Member 'FRootMotionSource_MoveToForce::bRestrictSpeedToExpected' has a wrong offset!");
//(offsetof(FRootMotionSource_MoveToForce, PathOffsetCurve) == 0x000128, "Member 'FRootMotionSource_MoveToForce::PathOffsetCurve' has a wrong offset!");

// ScriptStruct Engine.RootMotionSource_MoveToDynamicForce
// 0x0060 (0x0150 - 0x00F0)
struct FRootMotionSource_MoveToDynamicForce final : public FRootMotionSource
{
public:
	struct FVector                                StartLocation;                                     // 0x00F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialTargetLocation;                             // 0x0108(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0120(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictSpeedToExpected;                          // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0140(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TimeMappingCurve;                                  // 0x0148(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRootMotionSource_MoveToDynamicForce) == 0x000010, "Wrong alignment on FRootMotionSource_MoveToDynamicForce");
//(sizeof(FRootMotionSource_MoveToDynamicForce) == 0x000150, "Wrong size on FRootMotionSource_MoveToDynamicForce");
//(offsetof(FRootMotionSource_MoveToDynamicForce, StartLocation) == 0x0000F0, "Member 'FRootMotionSource_MoveToDynamicForce::StartLocation' has a wrong offset!");
//(offsetof(FRootMotionSource_MoveToDynamicForce, InitialTargetLocation) == 0x000108, "Member 'FRootMotionSource_MoveToDynamicForce::InitialTargetLocation' has a wrong offset!");
//(offsetof(FRootMotionSource_MoveToDynamicForce, TargetLocation) == 0x000120, "Member 'FRootMotionSource_MoveToDynamicForce::TargetLocation' has a wrong offset!");
//(offsetof(FRootMotionSource_MoveToDynamicForce, bRestrictSpeedToExpected) == 0x000138, "Member 'FRootMotionSource_MoveToDynamicForce::bRestrictSpeedToExpected' has a wrong offset!");
//(offsetof(FRootMotionSource_MoveToDynamicForce, PathOffsetCurve) == 0x000140, "Member 'FRootMotionSource_MoveToDynamicForce::PathOffsetCurve' has a wrong offset!");
//(offsetof(FRootMotionSource_MoveToDynamicForce, TimeMappingCurve) == 0x000148, "Member 'FRootMotionSource_MoveToDynamicForce::TimeMappingCurve' has a wrong offset!");

// ScriptStruct Engine.RootMotionSource_JumpForce
// 0x0050 (0x0140 - 0x00F0)
struct FRootMotionSource_JumpForce final : public FRootMotionSource
{
public:
	struct FRotator                               Rotation;                                          // 0x00F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableTimeout;                                   // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0118(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TimeMappingCurve;                                  // 0x0120(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRootMotionSource_JumpForce) == 0x000010, "Wrong alignment on FRootMotionSource_JumpForce");
//(sizeof(FRootMotionSource_JumpForce) == 0x000140, "Wrong size on FRootMotionSource_JumpForce");
//(offsetof(FRootMotionSource_JumpForce, Rotation) == 0x0000F0, "Member 'FRootMotionSource_JumpForce::Rotation' has a wrong offset!");
//(offsetof(FRootMotionSource_JumpForce, Distance) == 0x000108, "Member 'FRootMotionSource_JumpForce::Distance' has a wrong offset!");
//(offsetof(FRootMotionSource_JumpForce, Height) == 0x00010C, "Member 'FRootMotionSource_JumpForce::Height' has a wrong offset!");
//(offsetof(FRootMotionSource_JumpForce, bDisableTimeout) == 0x000110, "Member 'FRootMotionSource_JumpForce::bDisableTimeout' has a wrong offset!");
//(offsetof(FRootMotionSource_JumpForce, PathOffsetCurve) == 0x000118, "Member 'FRootMotionSource_JumpForce::PathOffsetCurve' has a wrong offset!");
//(offsetof(FRootMotionSource_JumpForce, TimeMappingCurve) == 0x000120, "Member 'FRootMotionSource_JumpForce::TimeMappingCurve' has a wrong offset!");

// ScriptStruct Engine.ClusteredComponentData
// 0x0110 (0x0110 - 0x0000)
struct alignas(0x08) FClusteredComponentData final
{
public:
	uint8                                         Pad_0[0x100];                                      // 0x0000(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UClusterUnionReplicatedProxyComponent> ReplicatedProxyComponent;                          // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasReplicating;                                   // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPendingDeletion;                                  // 0x0109(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x6];                                      // 0x010A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FClusteredComponentData) == 0x000008, "Wrong alignment on FClusteredComponentData");
//(sizeof(FClusteredComponentData) == 0x000110, "Wrong size on FClusteredComponentData");
//(offsetof(FClusteredComponentData, ReplicatedProxyComponent) == 0x000100, "Member 'FClusteredComponentData::ReplicatedProxyComponent' has a wrong offset!");
//(offsetof(FClusteredComponentData, bWasReplicating) == 0x000108, "Member 'FClusteredComponentData::bWasReplicating' has a wrong offset!");
//(offsetof(FClusteredComponentData, bPendingDeletion) == 0x000109, "Member 'FClusteredComponentData::bPendingDeletion' has a wrong offset!");

// ScriptStruct Engine.RootMotionSourceNetworkStateGroup
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FRootMotionSourceNetworkStateGroup final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FRootMotionSourceNetworkStateGroup) == 0x000008, "Wrong alignment on FRootMotionSourceNetworkStateGroup");
//(sizeof(FRootMotionSourceNetworkStateGroup) == 0x000018, "Wrong size on FRootMotionSourceNetworkStateGroup");

// ScriptStruct Engine.RootMotionSourceGroupNetSerializerConfig
// 0x0000 (0x0001 - 0x0001)
struct FRootMotionSourceGroupNetSerializerConfig final : public FPolymorphicArrayStructNetSerializerConfig
{
};
//(alignof(FRootMotionSourceGroupNetSerializerConfig) == 0x000001, "Wrong alignment on FRootMotionSourceGroupNetSerializerConfig");
//(sizeof(FRootMotionSourceGroupNetSerializerConfig) == 0x000001, "Wrong size on FRootMotionSourceGroupNetSerializerConfig");

// ScriptStruct Engine.TouchInputControl
// 0x00A8 (0x00A8 - 0x0000)
struct FTouchInputControl final
{
public:
	bool                                          bTreatAsButton;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Image1;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Image2;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Center;                                            // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VisualSize;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ThumbSize;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InteractionSize;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InputScale;                                        // 0x0058(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   MainInputKey;                                      // 0x0068(0x0020)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   AltInputKey;                                       // 0x0088(0x0020)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTouchInputControl) == 0x000008, "Wrong alignment on FTouchInputControl");
//(sizeof(FTouchInputControl) == 0x0000A8, "Wrong size on FTouchInputControl");
//(offsetof(FTouchInputControl, bTreatAsButton) == 0x000000, "Member 'FTouchInputControl::bTreatAsButton' has a wrong offset!");
//(offsetof(FTouchInputControl, Image1) == 0x000008, "Member 'FTouchInputControl::Image1' has a wrong offset!");
//(offsetof(FTouchInputControl, Image2) == 0x000010, "Member 'FTouchInputControl::Image2' has a wrong offset!");
//(offsetof(FTouchInputControl, Center) == 0x000018, "Member 'FTouchInputControl::Center' has a wrong offset!");
//(offsetof(FTouchInputControl, VisualSize) == 0x000028, "Member 'FTouchInputControl::VisualSize' has a wrong offset!");
//(offsetof(FTouchInputControl, ThumbSize) == 0x000038, "Member 'FTouchInputControl::ThumbSize' has a wrong offset!");
//(offsetof(FTouchInputControl, InteractionSize) == 0x000048, "Member 'FTouchInputControl::InteractionSize' has a wrong offset!");
//(offsetof(FTouchInputControl, InputScale) == 0x000058, "Member 'FTouchInputControl::InputScale' has a wrong offset!");
//(offsetof(FTouchInputControl, MainInputKey) == 0x000068, "Member 'FTouchInputControl::MainInputKey' has a wrong offset!");
//(offsetof(FTouchInputControl, AltInputKey) == 0x000088, "Member 'FTouchInputControl::AltInputKey' has a wrong offset!");

// ScriptStruct Engine.UniqueNetIdReplNetSerializerConfig
// 0x0001 (0x0001 - 0x0000)
struct FUniqueNetIdReplNetSerializerConfig final : public FNetSerializerConfig
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FUniqueNetIdReplNetSerializerConfig) == 0x000001, "Wrong alignment on FUniqueNetIdReplNetSerializerConfig");
//(sizeof(FUniqueNetIdReplNetSerializerConfig) == 0x000001, "Wrong size on FUniqueNetIdReplNetSerializerConfig");

// ScriptStruct Engine.ClusterUnionParticleCandidateData
// 0x000C (0x000C - 0x0000)
struct FClusterUnionParticleCandidateData final
{
public:
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneID;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FClusterUnionParticleCandidateData) == 0x000004, "Wrong alignment on FClusterUnionParticleCandidateData");
//(sizeof(FClusterUnionParticleCandidateData) == 0x00000C, "Wrong size on FClusterUnionParticleCandidateData");
//(offsetof(FClusterUnionParticleCandidateData, Component) == 0x000000, "Member 'FClusterUnionParticleCandidateData::Component' has a wrong offset!");
//(offsetof(FClusterUnionParticleCandidateData, BoneID) == 0x000008, "Member 'FClusterUnionParticleCandidateData::BoneID' has a wrong offset!");

// ScriptStruct Engine.NetLevelVisibilityTransactionId
// 0x0004 (0x0004 - 0x0000)
struct FNetLevelVisibilityTransactionId final
{
public:
	uint32                                        Data;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FNetLevelVisibilityTransactionId) == 0x000004, "Wrong alignment on FNetLevelVisibilityTransactionId");
//(sizeof(FNetLevelVisibilityTransactionId) == 0x000004, "Wrong size on FNetLevelVisibilityTransactionId");
//(offsetof(FNetLevelVisibilityTransactionId, Data) == 0x000000, "Member 'FNetLevelVisibilityTransactionId::Data' has a wrong offset!");

// ScriptStruct Engine.UpdateLevelVisibilityLevelInfo
// 0x0020 (0x0020 - 0x0000)
struct FUpdateLevelVisibilityLevelInfo final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Filename;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNetLevelVisibilityTransactionId       VisibilityRequestId;                               // 0x0018(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bIsVisible : 1;                                    // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTryMakeVisible : 1;                               // 0x001C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkipCloseOnError : 1;                             // 0x001C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FUpdateLevelVisibilityLevelInfo) == 0x000004, "Wrong alignment on FUpdateLevelVisibilityLevelInfo");
//(sizeof(FUpdateLevelVisibilityLevelInfo) == 0x000020, "Wrong size on FUpdateLevelVisibilityLevelInfo");
//(offsetof(FUpdateLevelVisibilityLevelInfo, PackageName) == 0x000000, "Member 'FUpdateLevelVisibilityLevelInfo::PackageName' has a wrong offset!");
//(offsetof(FUpdateLevelVisibilityLevelInfo, Filename) == 0x00000C, "Member 'FUpdateLevelVisibilityLevelInfo::Filename' has a wrong offset!");
//(offsetof(FUpdateLevelVisibilityLevelInfo, VisibilityRequestId) == 0x000018, "Member 'FUpdateLevelVisibilityLevelInfo::VisibilityRequestId' has a wrong offset!");

// ScriptStruct Engine.HLODISMComponentDesc
// 0x0030 (0x0030 - 0x0000)
struct FHLODISMComponentDesc final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Instances;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCustomPrimitiveData>           InstancesCustomPrimitiveData;                      // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FHLODISMComponentDesc) == 0x000008, "Wrong alignment on FHLODISMComponentDesc");
//(sizeof(FHLODISMComponentDesc) == 0x000030, "Wrong size on FHLODISMComponentDesc");
//(offsetof(FHLODISMComponentDesc, StaticMesh) == 0x000000, "Member 'FHLODISMComponentDesc::StaticMesh' has a wrong offset!");
//(offsetof(FHLODISMComponentDesc, Material) == 0x000008, "Member 'FHLODISMComponentDesc::Material' has a wrong offset!");
//(offsetof(FHLODISMComponentDesc, Instances) == 0x000010, "Member 'FHLODISMComponentDesc::Instances' has a wrong offset!");
//(offsetof(FHLODISMComponentDesc, InstancesCustomPrimitiveData) == 0x000020, "Member 'FHLODISMComponentDesc::InstancesCustomPrimitiveData' has a wrong offset!");

// ScriptStruct Engine.MeshReductionSettings
// 0x002C (0x002C - 0x0000)
struct FMeshReductionSettings final
{
public:
	float                                         PercentTriangles;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxNumOfTriangles;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentVertices;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxNumOfVerts;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDeviation;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PixelError;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeldingThreshold;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HardAngleThreshold;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseLODModel;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshFeatureImportance                        SilhouetteImportance;                              // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshFeatureImportance                        TextureImportance;                                 // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshFeatureImportance                        ShadingImportance;                                 // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRecalculateNormals : 1;                           // 0x0027(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateUniqueLightmapUVs : 1;                    // 0x0027(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bKeepSymmetry : 1;                                 // 0x0027(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVisibilityAided : 1;                              // 0x0027(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCullOccluded : 1;                                 // 0x0027(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EStaticMeshReductionTerimationCriterion       TerminationCriterion;                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshFeatureImportance                        VisibilityAggressiveness;                          // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshFeatureImportance                        VertexColorImportance;                             // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FMeshReductionSettings) == 0x000004, "Wrong alignment on FMeshReductionSettings");
//(sizeof(FMeshReductionSettings) == 0x00002C, "Wrong size on FMeshReductionSettings");
//(offsetof(FMeshReductionSettings, PercentTriangles) == 0x000000, "Member 'FMeshReductionSettings::PercentTriangles' has a wrong offset!");
//(offsetof(FMeshReductionSettings, MaxNumOfTriangles) == 0x000004, "Member 'FMeshReductionSettings::MaxNumOfTriangles' has a wrong offset!");
//(offsetof(FMeshReductionSettings, PercentVertices) == 0x000008, "Member 'FMeshReductionSettings::PercentVertices' has a wrong offset!");
//(offsetof(FMeshReductionSettings, MaxNumOfVerts) == 0x00000C, "Member 'FMeshReductionSettings::MaxNumOfVerts' has a wrong offset!");
//(offsetof(FMeshReductionSettings, MaxDeviation) == 0x000010, "Member 'FMeshReductionSettings::MaxDeviation' has a wrong offset!");
//(offsetof(FMeshReductionSettings, PixelError) == 0x000014, "Member 'FMeshReductionSettings::PixelError' has a wrong offset!");
//(offsetof(FMeshReductionSettings, WeldingThreshold) == 0x000018, "Member 'FMeshReductionSettings::WeldingThreshold' has a wrong offset!");
//(offsetof(FMeshReductionSettings, HardAngleThreshold) == 0x00001C, "Member 'FMeshReductionSettings::HardAngleThreshold' has a wrong offset!");
//(offsetof(FMeshReductionSettings, BaseLODModel) == 0x000020, "Member 'FMeshReductionSettings::BaseLODModel' has a wrong offset!");
//(offsetof(FMeshReductionSettings, SilhouetteImportance) == 0x000024, "Member 'FMeshReductionSettings::SilhouetteImportance' has a wrong offset!");
//(offsetof(FMeshReductionSettings, TextureImportance) == 0x000025, "Member 'FMeshReductionSettings::TextureImportance' has a wrong offset!");
//(offsetof(FMeshReductionSettings, ShadingImportance) == 0x000026, "Member 'FMeshReductionSettings::ShadingImportance' has a wrong offset!");
//(offsetof(FMeshReductionSettings, TerminationCriterion) == 0x000028, "Member 'FMeshReductionSettings::TerminationCriterion' has a wrong offset!");
//(offsetof(FMeshReductionSettings, VisibilityAggressiveness) == 0x000029, "Member 'FMeshReductionSettings::VisibilityAggressiveness' has a wrong offset!");
//(offsetof(FMeshReductionSettings, VertexColorImportance) == 0x00002A, "Member 'FMeshReductionSettings::VertexColorImportance' has a wrong offset!");

// ScriptStruct Engine.StaticMeshSourceModel
// 0x0098 (0x0098 - 0x0000)
struct FStaticMeshSourceModel final
{
public:
	struct FMeshBuildSettings                     BuildSettings;                                     // 0x0000(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FMeshReductionSettings                 ReductionSettings;                                 // 0x0048(0x002C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint32                                        CacheMeshDescriptionTrianglesCount;                // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CacheMeshDescriptionVerticesCount;                 // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODDistance;                                       // 0x007C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerPlatformFloat                      ScreenSize;                                        // 0x0080(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerPlatformFloat                      Distance;                                          // 0x0084(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 SourceImportFilename;                              // 0x0088(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FStaticMeshSourceModel) == 0x000008, "Wrong alignment on FStaticMeshSourceModel");
//(sizeof(FStaticMeshSourceModel) == 0x000098, "Wrong size on FStaticMeshSourceModel");
//(offsetof(FStaticMeshSourceModel, BuildSettings) == 0x000000, "Member 'FStaticMeshSourceModel::BuildSettings' has a wrong offset!");
//(offsetof(FStaticMeshSourceModel, ReductionSettings) == 0x000048, "Member 'FStaticMeshSourceModel::ReductionSettings' has a wrong offset!");
//(offsetof(FStaticMeshSourceModel, CacheMeshDescriptionTrianglesCount) == 0x000074, "Member 'FStaticMeshSourceModel::CacheMeshDescriptionTrianglesCount' has a wrong offset!");
//(offsetof(FStaticMeshSourceModel, CacheMeshDescriptionVerticesCount) == 0x000078, "Member 'FStaticMeshSourceModel::CacheMeshDescriptionVerticesCount' has a wrong offset!");
//(offsetof(FStaticMeshSourceModel, LODDistance) == 0x00007C, "Member 'FStaticMeshSourceModel::LODDistance' has a wrong offset!");
//(offsetof(FStaticMeshSourceModel, ScreenSize) == 0x000080, "Member 'FStaticMeshSourceModel::ScreenSize' has a wrong offset!");
//(offsetof(FStaticMeshSourceModel, Distance) == 0x000084, "Member 'FStaticMeshSourceModel::Distance' has a wrong offset!");
//(offsetof(FStaticMeshSourceModel, SourceImportFilename) == 0x000088, "Member 'FStaticMeshSourceModel::SourceImportFilename' has a wrong offset!");

// ScriptStruct Engine.BlueprintInputDelegateBinding
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FBlueprintInputDelegateBinding
{
public:
	uint8                                         bConsumeInput : 1;                                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bExecuteWhenPaused : 1;                            // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideParentBinding : 1;                        // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBlueprintInputDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintInputDelegateBinding");
//(sizeof(FBlueprintInputDelegateBinding) == 0x000004, "Wrong size on FBlueprintInputDelegateBinding");

// ScriptStruct Engine.BlueprintInputActionDelegateBinding
// 0x001C (0x0020 - 0x0004)
struct FBlueprintInputActionDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	class FName                                   InputActionName;                                   // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   InputKeyEvent;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FunctionNameToBind;                                // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBlueprintInputActionDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintInputActionDelegateBinding");
//(sizeof(FBlueprintInputActionDelegateBinding) == 0x000020, "Wrong size on FBlueprintInputActionDelegateBinding");
//(offsetof(FBlueprintInputActionDelegateBinding, InputActionName) == 0x000004, "Member 'FBlueprintInputActionDelegateBinding::InputActionName' has a wrong offset!");
//(offsetof(FBlueprintInputActionDelegateBinding, InputKeyEvent) == 0x000010, "Member 'FBlueprintInputActionDelegateBinding::InputKeyEvent' has a wrong offset!");
//(offsetof(FBlueprintInputActionDelegateBinding, FunctionNameToBind) == 0x000014, "Member 'FBlueprintInputActionDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.EditorImportExportTestDefinition
// 0x0038 (0x0038 - 0x0000)
struct FEditorImportExportTestDefinition final
{
public:
	struct FFilePath                              ImportFilePath;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExportFileExtension;                               // 0x0010(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipExport;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FImportFactorySettingValues>    FactorySettings;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
//(alignof(FEditorImportExportTestDefinition) == 0x000008, "Wrong alignment on FEditorImportExportTestDefinition");
//(sizeof(FEditorImportExportTestDefinition) == 0x000038, "Wrong size on FEditorImportExportTestDefinition");
//(offsetof(FEditorImportExportTestDefinition, ImportFilePath) == 0x000000, "Member 'FEditorImportExportTestDefinition::ImportFilePath' has a wrong offset!");
//(offsetof(FEditorImportExportTestDefinition, ExportFileExtension) == 0x000010, "Member 'FEditorImportExportTestDefinition::ExportFileExtension' has a wrong offset!");
//(offsetof(FEditorImportExportTestDefinition, bSkipExport) == 0x000020, "Member 'FEditorImportExportTestDefinition::bSkipExport' has a wrong offset!");
//(offsetof(FEditorImportExportTestDefinition, FactorySettings) == 0x000028, "Member 'FEditorImportExportTestDefinition::FactorySettings' has a wrong offset!");

// ScriptStruct Engine.BlueprintInputAxisDelegateBinding
// 0x0018 (0x001C - 0x0004)
struct FBlueprintInputAxisDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	class FName                                   InputAxisName;                                     // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionNameToBind;                                // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBlueprintInputAxisDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintInputAxisDelegateBinding");
//(sizeof(FBlueprintInputAxisDelegateBinding) == 0x00001C, "Wrong size on FBlueprintInputAxisDelegateBinding");
//(offsetof(FBlueprintInputAxisDelegateBinding, InputAxisName) == 0x000004, "Member 'FBlueprintInputAxisDelegateBinding::InputAxisName' has a wrong offset!");
//(offsetof(FBlueprintInputAxisDelegateBinding, FunctionNameToBind) == 0x000010, "Member 'FBlueprintInputAxisDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.BlueprintInputAxisKeyDelegateBinding
// 0x0034 (0x0038 - 0x0004)
struct FBlueprintInputAxisKeyDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   AxisKey;                                           // 0x0008(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionNameToBind;                                // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBlueprintInputAxisKeyDelegateBinding) == 0x000008, "Wrong alignment on FBlueprintInputAxisKeyDelegateBinding");
//(sizeof(FBlueprintInputAxisKeyDelegateBinding) == 0x000038, "Wrong size on FBlueprintInputAxisKeyDelegateBinding");
//(offsetof(FBlueprintInputAxisKeyDelegateBinding, AxisKey) == 0x000008, "Member 'FBlueprintInputAxisKeyDelegateBinding::AxisKey' has a wrong offset!");
//(offsetof(FBlueprintInputAxisKeyDelegateBinding, FunctionNameToBind) == 0x000028, "Member 'FBlueprintInputAxisKeyDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.BlueprintInputKeyDelegateBinding
// 0x003C (0x0040 - 0x0004)
struct FBlueprintInputKeyDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputChord                            InputChord;                                        // 0x0008(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   InputKeyEvent;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FunctionNameToBind;                                // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBlueprintInputKeyDelegateBinding) == 0x000008, "Wrong alignment on FBlueprintInputKeyDelegateBinding");
//(sizeof(FBlueprintInputKeyDelegateBinding) == 0x000040, "Wrong size on FBlueprintInputKeyDelegateBinding");
//(offsetof(FBlueprintInputKeyDelegateBinding, InputChord) == 0x000008, "Member 'FBlueprintInputKeyDelegateBinding::InputChord' has a wrong offset!");
//(offsetof(FBlueprintInputKeyDelegateBinding, InputKeyEvent) == 0x000030, "Member 'FBlueprintInputKeyDelegateBinding::InputKeyEvent' has a wrong offset!");
//(offsetof(FBlueprintInputKeyDelegateBinding, FunctionNameToBind) == 0x000034, "Member 'FBlueprintInputKeyDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.BlueprintInputTouchDelegateBinding
// 0x0010 (0x0014 - 0x0004)
struct FBlueprintInputTouchDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	EInputEvent                                   InputKeyEvent;                                     // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FunctionNameToBind;                                // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBlueprintInputTouchDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintInputTouchDelegateBinding");
//(sizeof(FBlueprintInputTouchDelegateBinding) == 0x000014, "Wrong size on FBlueprintInputTouchDelegateBinding");
//(offsetof(FBlueprintInputTouchDelegateBinding, InputKeyEvent) == 0x000004, "Member 'FBlueprintInputTouchDelegateBinding::InputKeyEvent' has a wrong offset!");
//(offsetof(FBlueprintInputTouchDelegateBinding, FunctionNameToBind) == 0x000008, "Member 'FBlueprintInputTouchDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.CurveEdTab
// 0x0030 (0x0030 - 0x0000)
struct FCurveEdTab final
{
public:
	class FString                                 TabName;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCurveEdEntry>                  Curves;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ViewStartInput;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewEndInput;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewStartOutput;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewEndOutput;                                     // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCurveEdTab) == 0x000008, "Wrong alignment on FCurveEdTab");
//(sizeof(FCurveEdTab) == 0x000030, "Wrong size on FCurveEdTab");
//(offsetof(FCurveEdTab, TabName) == 0x000000, "Member 'FCurveEdTab::TabName' has a wrong offset!");
//(offsetof(FCurveEdTab, Curves) == 0x000010, "Member 'FCurveEdTab::Curves' has a wrong offset!");
//(offsetof(FCurveEdTab, ViewStartInput) == 0x000020, "Member 'FCurveEdTab::ViewStartInput' has a wrong offset!");
//(offsetof(FCurveEdTab, ViewEndInput) == 0x000024, "Member 'FCurveEdTab::ViewEndInput' has a wrong offset!");
//(offsetof(FCurveEdTab, ViewStartOutput) == 0x000028, "Member 'FCurveEdTab::ViewStartOutput' has a wrong offset!");
//(offsetof(FCurveEdTab, ViewEndOutput) == 0x00002C, "Member 'FCurveEdTab::ViewEndOutput' has a wrong offset!");

// ScriptStruct Engine.ISMComponentInstance
// 0x000C (0x000C - 0x0000)
struct FISMComponentInstance final
{
public:
	int32                                         ClientIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceIndex;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceSubIndex;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FISMComponentInstance) == 0x000004, "Wrong alignment on FISMComponentInstance");
//(sizeof(FISMComponentInstance) == 0x00000C, "Wrong size on FISMComponentInstance");
//(offsetof(FISMComponentInstance, ClientIndex) == 0x000000, "Member 'FISMComponentInstance::ClientIndex' has a wrong offset!");
//(offsetof(FISMComponentInstance, InstanceIndex) == 0x000004, "Member 'FISMComponentInstance::InstanceIndex' has a wrong offset!");
//(offsetof(FISMComponentInstance, InstanceSubIndex) == 0x000008, "Member 'FISMComponentInstance::InstanceSubIndex' has a wrong offset!");

// ScriptStruct Engine.ISMClientInstance
// 0x0010 (0x0010 - 0x0000)
struct FISMClientInstance final
{
public:
	TArray<int32>                                 ComponentIndices;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FISMClientInstance) == 0x000008, "Wrong alignment on FISMClientInstance");
//(sizeof(FISMClientInstance) == 0x000010, "Wrong size on FISMClientInstance");
//(offsetof(FISMClientInstance, ComponentIndices) == 0x000000, "Member 'FISMClientInstance::ComponentIndices' has a wrong offset!");

// ScriptStruct Engine.BuildPromotionImportWorkflowSettings
// 0x0150 (0x0150 - 0x0000)
struct FBuildPromotionImportWorkflowSettings final
{
public:
	struct FEditorImportWorkflowDefinition        Diffuse;                                           // 0x0000(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        Normal;                                            // 0x0020(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        StaticMesh;                                        // 0x0040(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        ReimportStaticMesh;                                // 0x0060(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        BlendShapeMesh;                                    // 0x0080(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        MorphMesh;                                         // 0x00A0(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        SkeletalMesh;                                      // 0x00C0(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        Animation;                                         // 0x00E0(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        Sound;                                             // 0x0100(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        SurroundSound;                                     // 0x0120(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<struct FEditorImportWorkflowDefinition> OtherAssetsToImport;                               // 0x0140(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
//(alignof(FBuildPromotionImportWorkflowSettings) == 0x000008, "Wrong alignment on FBuildPromotionImportWorkflowSettings");
//(sizeof(FBuildPromotionImportWorkflowSettings) == 0x000150, "Wrong size on FBuildPromotionImportWorkflowSettings");
//(offsetof(FBuildPromotionImportWorkflowSettings, Diffuse) == 0x000000, "Member 'FBuildPromotionImportWorkflowSettings::Diffuse' has a wrong offset!");
//(offsetof(FBuildPromotionImportWorkflowSettings, Normal) == 0x000020, "Member 'FBuildPromotionImportWorkflowSettings::Normal' has a wrong offset!");
//(offsetof(FBuildPromotionImportWorkflowSettings, StaticMesh) == 0x000040, "Member 'FBuildPromotionImportWorkflowSettings::StaticMesh' has a wrong offset!");
//(offsetof(FBuildPromotionImportWorkflowSettings, ReimportStaticMesh) == 0x000060, "Member 'FBuildPromotionImportWorkflowSettings::ReimportStaticMesh' has a wrong offset!");
//(offsetof(FBuildPromotionImportWorkflowSettings, BlendShapeMesh) == 0x000080, "Member 'FBuildPromotionImportWorkflowSettings::BlendShapeMesh' has a wrong offset!");
//(offsetof(FBuildPromotionImportWorkflowSettings, MorphMesh) == 0x0000A0, "Member 'FBuildPromotionImportWorkflowSettings::MorphMesh' has a wrong offset!");
//(offsetof(FBuildPromotionImportWorkflowSettings, SkeletalMesh) == 0x0000C0, "Member 'FBuildPromotionImportWorkflowSettings::SkeletalMesh' has a wrong offset!");
//(offsetof(FBuildPromotionImportWorkflowSettings, Animation) == 0x0000E0, "Member 'FBuildPromotionImportWorkflowSettings::Animation' has a wrong offset!");
//(offsetof(FBuildPromotionImportWorkflowSettings, Sound) == 0x000100, "Member 'FBuildPromotionImportWorkflowSettings::Sound' has a wrong offset!");
//(offsetof(FBuildPromotionImportWorkflowSettings, SurroundSound) == 0x000120, "Member 'FBuildPromotionImportWorkflowSettings::SurroundSound' has a wrong offset!");
//(offsetof(FBuildPromotionImportWorkflowSettings, OtherAssetsToImport) == 0x000140, "Member 'FBuildPromotionImportWorkflowSettings::OtherAssetsToImport' has a wrong offset!");

// ScriptStruct Engine.BuildPromotionTestSettings
// 0x01F0 (0x01F0 - 0x0000)
struct FBuildPromotionTestSettings final
{
public:
	struct FFilePath                              DefaultStaticMeshAsset;                            // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBuildPromotionImportWorkflowSettings  ImportWorkflow;                                    // 0x0010(0x0150)(Edit, NativeAccessSpecifierPublic)
	struct FBuildPromotionOpenAssetSettings       OpenAssets;                                        // 0x0160(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FBuildPromotionNewProjectSettings      NewProjectSettings;                                // 0x01C0(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FFilePath                              SourceControlMaterial;                             // 0x01E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FBuildPromotionTestSettings) == 0x000008, "Wrong alignment on FBuildPromotionTestSettings");
//(sizeof(FBuildPromotionTestSettings) == 0x0001F0, "Wrong size on FBuildPromotionTestSettings");
//(offsetof(FBuildPromotionTestSettings, DefaultStaticMeshAsset) == 0x000000, "Member 'FBuildPromotionTestSettings::DefaultStaticMeshAsset' has a wrong offset!");
//(offsetof(FBuildPromotionTestSettings, ImportWorkflow) == 0x000010, "Member 'FBuildPromotionTestSettings::ImportWorkflow' has a wrong offset!");
//(offsetof(FBuildPromotionTestSettings, OpenAssets) == 0x000160, "Member 'FBuildPromotionTestSettings::OpenAssets' has a wrong offset!");
//(offsetof(FBuildPromotionTestSettings, NewProjectSettings) == 0x0001C0, "Member 'FBuildPromotionTestSettings::NewProjectSettings' has a wrong offset!");
//(offsetof(FBuildPromotionTestSettings, SourceControlMaterial) == 0x0001E0, "Member 'FBuildPromotionTestSettings::SourceControlMaterial' has a wrong offset!");

// ScriptStruct Engine.ISMClientData
// 0x0010 (0x0010 - 0x0000)
struct FISMClientData final
{
public:
	TArray<struct FISMClientInstance>             Instances;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FISMClientData) == 0x000008, "Wrong alignment on FISMClientData");
//(sizeof(FISMClientData) == 0x000010, "Wrong size on FISMClientData");
//(offsetof(FISMClientData, Instances) == 0x000000, "Member 'FISMClientData::Instances' has a wrong offset!");

// ScriptStruct Engine.ISMComponentData
// 0x0001 (0x0001 - 0x0000)
struct FISMComponentData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FISMComponentData) == 0x000001, "Wrong alignment on FISMComponentData");
//(sizeof(FISMComponentData) == 0x000001, "Wrong size on FISMComponentData");

// ScriptStruct Engine.SlateModifierKeysState
// 0x0001 (0x0001 - 0x0000)
struct FSlateModifierKeysState final
{
public:
	uint8                                         ModifierKeysStateMask;                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSlateModifierKeysState) == 0x000001, "Wrong alignment on FSlateModifierKeysState");
//(sizeof(FSlateModifierKeysState) == 0x000001, "Wrong size on FSlateModifierKeysState");
//(offsetof(FSlateModifierKeysState, ModifierKeysStateMask) == 0x000000, "Member 'FSlateModifierKeysState::ModifierKeysStateMask' has a wrong offset!");

// ScriptStruct Engine.FloatSpringState
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FFloatSpringState final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FFloatSpringState) == 0x000004, "Wrong alignment on FFloatSpringState");
//(sizeof(FFloatSpringState) == 0x00000C, "Wrong size on FFloatSpringState");

// ScriptStruct Engine.VectorSpringState
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FVectorSpringState final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FVectorSpringState) == 0x000008, "Wrong alignment on FVectorSpringState");
//(sizeof(FVectorSpringState) == 0x000038, "Wrong size on FVectorSpringState");

// ScriptStruct Engine.QuaternionSpringState
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x10) FQuaternionSpringState final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FQuaternionSpringState) == 0x000010, "Wrong alignment on FQuaternionSpringState");
//(sizeof(FQuaternionSpringState) == 0x000040, "Wrong size on FQuaternionSpringState");

// ScriptStruct Engine.DrawToRenderTargetContext
// 0x0008 (0x0008 - 0x0000)
struct FDrawToRenderTargetContext final
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDrawToRenderTargetContext) == 0x000008, "Wrong alignment on FDrawToRenderTargetContext");
//(sizeof(FDrawToRenderTargetContext) == 0x000008, "Wrong size on FDrawToRenderTargetContext");
//(offsetof(FDrawToRenderTargetContext, RenderTarget) == 0x000000, "Member 'FDrawToRenderTargetContext::RenderTarget' has a wrong offset!");

// ScriptStruct Engine.ImportanceTexture
// 0x0050 (0x0050 - 0x0000)
struct FImportanceTexture final
{
public:
	struct FIntPoint                              Size;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumMips;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 MarginalCDF;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ConditionalCDF;                                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         TextureData;                                       // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UTexture2D>              Texture;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EImportanceWeight                             Weighting;                                         // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FImportanceTexture) == 0x000008, "Wrong alignment on FImportanceTexture");
//(sizeof(FImportanceTexture) == 0x000050, "Wrong size on FImportanceTexture");
//(offsetof(FImportanceTexture, Size) == 0x000000, "Member 'FImportanceTexture::Size' has a wrong offset!");
//(offsetof(FImportanceTexture, NumMips) == 0x000008, "Member 'FImportanceTexture::NumMips' has a wrong offset!");
//(offsetof(FImportanceTexture, MarginalCDF) == 0x000010, "Member 'FImportanceTexture::MarginalCDF' has a wrong offset!");
//(offsetof(FImportanceTexture, ConditionalCDF) == 0x000020, "Member 'FImportanceTexture::ConditionalCDF' has a wrong offset!");
//(offsetof(FImportanceTexture, TextureData) == 0x000030, "Member 'FImportanceTexture::TextureData' has a wrong offset!");
//(offsetof(FImportanceTexture, Texture) == 0x000040, "Member 'FImportanceTexture::Texture' has a wrong offset!");
//(offsetof(FImportanceTexture, Weighting) == 0x000048, "Member 'FImportanceTexture::Weighting' has a wrong offset!");

// ScriptStruct Engine.ActorFolderSet
// 0x0050 (0x0050 - 0x0000)
struct FActorFolderSet final
{
public:
	TSet<class UActorFolder*>                     ActorFolders;                                      // 0x0000(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
};
//(alignof(FActorFolderSet) == 0x000008, "Wrong alignment on FActorFolderSet");
//(sizeof(FActorFolderSet) == 0x000050, "Wrong size on FActorFolderSet");
//(offsetof(FActorFolderSet, ActorFolders) == 0x000000, "Member 'FActorFolderSet::ActorFolders' has a wrong offset!");

// ScriptStruct Engine.StreamableTextureInstance
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FStreamableTextureInstance
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStreamableTextureInstance) == 0x000008, "Wrong alignment on FStreamableTextureInstance");
//(sizeof(FStreamableTextureInstance) == 0x000048, "Wrong size on FStreamableTextureInstance");

// ScriptStruct Engine.DynamicTextureInstance
// 0x0010 (0x0058 - 0x0048)
struct FDynamicTextureInstance final : public FStreamableTextureInstance
{
public:
	class UTexture2D*                             Texture;                                           // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OriginalRadius;                                    // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDynamicTextureInstance) == 0x000008, "Wrong alignment on FDynamicTextureInstance");
//(sizeof(FDynamicTextureInstance) == 0x000058, "Wrong size on FDynamicTextureInstance");
//(offsetof(FDynamicTextureInstance, Texture) == 0x000048, "Member 'FDynamicTextureInstance::Texture' has a wrong offset!");
//(offsetof(FDynamicTextureInstance, bAttached) == 0x000050, "Member 'FDynamicTextureInstance::bAttached' has a wrong offset!");
//(offsetof(FDynamicTextureInstance, OriginalRadius) == 0x000054, "Member 'FDynamicTextureInstance::OriginalRadius' has a wrong offset!");

// ScriptStruct Engine.LevelSimplificationDetails
// 0x0158 (0x0158 - 0x0000)
struct FLevelSimplificationDetails final
{
public:
	bool                                          bCreatePackagePerAsset;                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetailsPercentage;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaterialProxySettings                 StaticMeshMaterialSettings;                        // 0x0008(0x00A0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideLandscapeExportLOD;                       // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LandscapeExportLOD;                                // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaterialProxySettings                 LandscapeMaterialSettings;                         // 0x00B0(0x00A0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBakeFoliageToLandscape;                           // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBakeGrassToLandscape;                             // 0x0151(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_152[0x6];                                      // 0x0152(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLevelSimplificationDetails) == 0x000008, "Wrong alignment on FLevelSimplificationDetails");
//(sizeof(FLevelSimplificationDetails) == 0x000158, "Wrong size on FLevelSimplificationDetails");
//(offsetof(FLevelSimplificationDetails, bCreatePackagePerAsset) == 0x000000, "Member 'FLevelSimplificationDetails::bCreatePackagePerAsset' has a wrong offset!");
//(offsetof(FLevelSimplificationDetails, DetailsPercentage) == 0x000004, "Member 'FLevelSimplificationDetails::DetailsPercentage' has a wrong offset!");
//(offsetof(FLevelSimplificationDetails, StaticMeshMaterialSettings) == 0x000008, "Member 'FLevelSimplificationDetails::StaticMeshMaterialSettings' has a wrong offset!");
//(offsetof(FLevelSimplificationDetails, bOverrideLandscapeExportLOD) == 0x0000A8, "Member 'FLevelSimplificationDetails::bOverrideLandscapeExportLOD' has a wrong offset!");
//(offsetof(FLevelSimplificationDetails, LandscapeExportLOD) == 0x0000AC, "Member 'FLevelSimplificationDetails::LandscapeExportLOD' has a wrong offset!");
//(offsetof(FLevelSimplificationDetails, LandscapeMaterialSettings) == 0x0000B0, "Member 'FLevelSimplificationDetails::LandscapeMaterialSettings' has a wrong offset!");
//(offsetof(FLevelSimplificationDetails, bBakeFoliageToLandscape) == 0x000150, "Member 'FLevelSimplificationDetails::bBakeFoliageToLandscape' has a wrong offset!");
//(offsetof(FLevelSimplificationDetails, bBakeGrassToLandscape) == 0x000151, "Member 'FLevelSimplificationDetails::bBakeGrassToLandscape' has a wrong offset!");

// ScriptStruct Engine.ReplicatedStaticActorDestructionInfo
// 0x0048 (0x0048 - 0x0000)
struct FReplicatedStaticActorDestructionInfo final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    ObjClass;                                          // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FReplicatedStaticActorDestructionInfo) == 0x000008, "Wrong alignment on FReplicatedStaticActorDestructionInfo");
//(sizeof(FReplicatedStaticActorDestructionInfo) == 0x000048, "Wrong size on FReplicatedStaticActorDestructionInfo");
//(offsetof(FReplicatedStaticActorDestructionInfo, ObjClass) == 0x000040, "Member 'FReplicatedStaticActorDestructionInfo::ObjClass' has a wrong offset!");

// ScriptStruct Engine.ClientReceiveData
// 0x0040 (0x0040 - 0x0000)
struct FClientReceiveData final
{
public:
	class APlayerController*                      LocalPC;                                           // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageType;                                       // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MessageIndex;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessageString;                                     // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           RelatedPlayerState_1;                              // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           RelatedPlayerState_2;                              // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalObject;                                    // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FClientReceiveData) == 0x000008, "Wrong alignment on FClientReceiveData");
//(sizeof(FClientReceiveData) == 0x000040, "Wrong size on FClientReceiveData");
//(offsetof(FClientReceiveData, LocalPC) == 0x000000, "Member 'FClientReceiveData::LocalPC' has a wrong offset!");
//(offsetof(FClientReceiveData, MessageType) == 0x000008, "Member 'FClientReceiveData::MessageType' has a wrong offset!");
//(offsetof(FClientReceiveData, MessageIndex) == 0x000014, "Member 'FClientReceiveData::MessageIndex' has a wrong offset!");
//(offsetof(FClientReceiveData, MessageString) == 0x000018, "Member 'FClientReceiveData::MessageString' has a wrong offset!");
//(offsetof(FClientReceiveData, RelatedPlayerState_1) == 0x000028, "Member 'FClientReceiveData::RelatedPlayerState_1' has a wrong offset!");
//(offsetof(FClientReceiveData, RelatedPlayerState_2) == 0x000030, "Member 'FClientReceiveData::RelatedPlayerState_2' has a wrong offset!");
//(offsetof(FClientReceiveData, OptionalObject) == 0x000038, "Member 'FClientReceiveData::OptionalObject' has a wrong offset!");

// ScriptStruct Engine.ParameterGroupData
// 0x0018 (0x0018 - 0x0000)
struct FParameterGroupData final
{
public:
	class FString                                 GroupName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupSortPriority;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FParameterGroupData) == 0x000008, "Wrong alignment on FParameterGroupData");
//(sizeof(FParameterGroupData) == 0x000018, "Wrong size on FParameterGroupData");
//(offsetof(FParameterGroupData, GroupName) == 0x000000, "Member 'FParameterGroupData::GroupName' has a wrong offset!");
//(offsetof(FParameterGroupData, GroupSortPriority) == 0x000010, "Member 'FParameterGroupData::GroupSortPriority' has a wrong offset!");

// ScriptStruct Engine.InputActionSpeechMapping
// 0x0018 (0x0018 - 0x0000)
struct FInputActionSpeechMapping final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SpeechKeyword;                                     // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
//(alignof(FInputActionSpeechMapping) == 0x000004, "Wrong alignment on FInputActionSpeechMapping");
//(sizeof(FInputActionSpeechMapping) == 0x000018, "Wrong size on FInputActionSpeechMapping");
//(offsetof(FInputActionSpeechMapping, ActionName) == 0x000000, "Member 'FInputActionSpeechMapping::ActionName' has a wrong offset!");
//(offsetof(FInputActionSpeechMapping, SpeechKeyword) == 0x00000C, "Member 'FInputActionSpeechMapping::SpeechKeyword' has a wrong offset!");

// ScriptStruct Engine.VirtualTextureSpacePoolConfig
// 0x0030 (0x0030 - 0x0000)
struct FVirtualTextureSpacePoolConfig final
{
public:
	int32                                         MinTileSize;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTileSize;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPixelFormat>                          Formats;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SizeInMegabyte;                                    // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableResidencyMipMapBias;                        // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSizeScale;                                   // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ScalabilityGroup;                                  // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinScaledSizeInMegabyte;                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxScaledSizeInMegabyte;                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FVirtualTextureSpacePoolConfig) == 0x000008, "Wrong alignment on FVirtualTextureSpacePoolConfig");
//(sizeof(FVirtualTextureSpacePoolConfig) == 0x000030, "Wrong size on FVirtualTextureSpacePoolConfig");
//(offsetof(FVirtualTextureSpacePoolConfig, MinTileSize) == 0x000000, "Member 'FVirtualTextureSpacePoolConfig::MinTileSize' has a wrong offset!");
//(offsetof(FVirtualTextureSpacePoolConfig, MaxTileSize) == 0x000004, "Member 'FVirtualTextureSpacePoolConfig::MaxTileSize' has a wrong offset!");
//(offsetof(FVirtualTextureSpacePoolConfig, Formats) == 0x000008, "Member 'FVirtualTextureSpacePoolConfig::Formats' has a wrong offset!");
//(offsetof(FVirtualTextureSpacePoolConfig, SizeInMegabyte) == 0x000018, "Member 'FVirtualTextureSpacePoolConfig::SizeInMegabyte' has a wrong offset!");
//(offsetof(FVirtualTextureSpacePoolConfig, bEnableResidencyMipMapBias) == 0x00001C, "Member 'FVirtualTextureSpacePoolConfig::bEnableResidencyMipMapBias' has a wrong offset!");
//(offsetof(FVirtualTextureSpacePoolConfig, bAllowSizeScale) == 0x00001D, "Member 'FVirtualTextureSpacePoolConfig::bAllowSizeScale' has a wrong offset!");
//(offsetof(FVirtualTextureSpacePoolConfig, ScalabilityGroup) == 0x000020, "Member 'FVirtualTextureSpacePoolConfig::ScalabilityGroup' has a wrong offset!");
//(offsetof(FVirtualTextureSpacePoolConfig, MinScaledSizeInMegabyte) == 0x000024, "Member 'FVirtualTextureSpacePoolConfig::MinScaledSizeInMegabyte' has a wrong offset!");
//(offsetof(FVirtualTextureSpacePoolConfig, MaxScaledSizeInMegabyte) == 0x000028, "Member 'FVirtualTextureSpacePoolConfig::MaxScaledSizeInMegabyte' has a wrong offset!");

// ScriptStruct Engine.ScalarParameterAtlasInstanceData
// 0x0068 (0x0068 - 0x0000)
struct FScalarParameterAtlasInstanceData final
{
public:
	bool                                          bIsUsedAsAtlasPosition;                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveLinearColor>       Curve;                                             // 0x0008(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveLinearColorAtlas>  Atlas;                                             // 0x0038(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FScalarParameterAtlasInstanceData) == 0x000008, "Wrong alignment on FScalarParameterAtlasInstanceData");
//(sizeof(FScalarParameterAtlasInstanceData) == 0x000068, "Wrong size on FScalarParameterAtlasInstanceData");
//(offsetof(FScalarParameterAtlasInstanceData, bIsUsedAsAtlasPosition) == 0x000000, "Member 'FScalarParameterAtlasInstanceData::bIsUsedAsAtlasPosition' has a wrong offset!");
//(offsetof(FScalarParameterAtlasInstanceData, Curve) == 0x000008, "Member 'FScalarParameterAtlasInstanceData::Curve' has a wrong offset!");
//(offsetof(FScalarParameterAtlasInstanceData, Atlas) == 0x000038, "Member 'FScalarParameterAtlasInstanceData::Atlas' has a wrong offset!");

// ScriptStruct Engine.LevelCollection
// 0x00B0 (0x00B0 - 0x0000)
struct FLevelCollection final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGameStateBase*                         GameState;                                         // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNetDriver*                             NetDriver;                                         // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDemoNetDriver*                         DemoNetDriver;                                     // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevel*                                 PersistentLevel;                                   // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class ULevel*>                           Levels;                                            // 0x0028(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PlayerController;                                  // 0x0090(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FLevelCollection) == 0x000008, "Wrong alignment on FLevelCollection");
//(sizeof(FLevelCollection) == 0x0000B0, "Wrong size on FLevelCollection");
//(offsetof(FLevelCollection, GameState) == 0x000008, "Member 'FLevelCollection::GameState' has a wrong offset!");
//(offsetof(FLevelCollection, NetDriver) == 0x000010, "Member 'FLevelCollection::NetDriver' has a wrong offset!");
//(offsetof(FLevelCollection, DemoNetDriver) == 0x000018, "Member 'FLevelCollection::DemoNetDriver' has a wrong offset!");
//(offsetof(FLevelCollection, PersistentLevel) == 0x000020, "Member 'FLevelCollection::PersistentLevel' has a wrong offset!");
//(offsetof(FLevelCollection, Levels) == 0x000028, "Member 'FLevelCollection::Levels' has a wrong offset!");
//(offsetof(FLevelCollection, PlayerController) == 0x000090, "Member 'FLevelCollection::PlayerController' has a wrong offset!");

// ScriptStruct Engine.TextureParameterValue
// 0x0030 (0x0030 - 0x0000)
struct FTextureParameterValue final
{
public:
	struct FMaterialParameterInfo                 ParameterInfo;                                     // 0x0000(0x0014)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               ParameterValue;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTextureParameterValue) == 0x000008, "Wrong alignment on FTextureParameterValue");
//(sizeof(FTextureParameterValue) == 0x000030, "Wrong size on FTextureParameterValue");
//(offsetof(FTextureParameterValue, ParameterInfo) == 0x000000, "Member 'FTextureParameterValue::ParameterInfo' has a wrong offset!");
//(offsetof(FTextureParameterValue, ParameterValue) == 0x000018, "Member 'FTextureParameterValue::ParameterValue' has a wrong offset!");
//(offsetof(FTextureParameterValue, ExpressionGUID) == 0x000020, "Member 'FTextureParameterValue::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.RuntimeVirtualTextureParameterValue
// 0x0030 (0x0030 - 0x0000)
struct FRuntimeVirtualTextureParameterValue final
{
public:
	struct FMaterialParameterInfo                 ParameterInfo;                                     // 0x0000(0x0014)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URuntimeVirtualTexture*                 ParameterValue;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FRuntimeVirtualTextureParameterValue) == 0x000008, "Wrong alignment on FRuntimeVirtualTextureParameterValue");
//(sizeof(FRuntimeVirtualTextureParameterValue) == 0x000030, "Wrong size on FRuntimeVirtualTextureParameterValue");
//(offsetof(FRuntimeVirtualTextureParameterValue, ParameterInfo) == 0x000000, "Member 'FRuntimeVirtualTextureParameterValue::ParameterInfo' has a wrong offset!");
//(offsetof(FRuntimeVirtualTextureParameterValue, ParameterValue) == 0x000018, "Member 'FRuntimeVirtualTextureParameterValue::ParameterValue' has a wrong offset!");
//(offsetof(FRuntimeVirtualTextureParameterValue, ExpressionGUID) == 0x000020, "Member 'FRuntimeVirtualTextureParameterValue::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.SparseVolumeTextureParameterValue
// 0x0030 (0x0030 - 0x0000)
struct FSparseVolumeTextureParameterValue final
{
public:
	struct FMaterialParameterInfo                 ParameterInfo;                                     // 0x0000(0x0014)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USparseVolumeTexture*                   ParameterValue;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSparseVolumeTextureParameterValue) == 0x000008, "Wrong alignment on FSparseVolumeTextureParameterValue");
//(sizeof(FSparseVolumeTextureParameterValue) == 0x000030, "Wrong size on FSparseVolumeTextureParameterValue");
//(offsetof(FSparseVolumeTextureParameterValue, ParameterInfo) == 0x000000, "Member 'FSparseVolumeTextureParameterValue::ParameterInfo' has a wrong offset!");
//(offsetof(FSparseVolumeTextureParameterValue, ParameterValue) == 0x000018, "Member 'FSparseVolumeTextureParameterValue::ParameterValue' has a wrong offset!");
//(offsetof(FSparseVolumeTextureParameterValue, ExpressionGUID) == 0x000020, "Member 'FSparseVolumeTextureParameterValue::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.FontParameterValue
// 0x0038 (0x0038 - 0x0000)
struct FFontParameterValue final
{
public:
	struct FMaterialParameterInfo                 ParameterInfo;                                     // 0x0000(0x0014)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  FontValue;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FontPage;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0024(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FFontParameterValue) == 0x000008, "Wrong alignment on FFontParameterValue");
//(sizeof(FFontParameterValue) == 0x000038, "Wrong size on FFontParameterValue");
//(offsetof(FFontParameterValue, ParameterInfo) == 0x000000, "Member 'FFontParameterValue::ParameterInfo' has a wrong offset!");
//(offsetof(FFontParameterValue, FontValue) == 0x000018, "Member 'FFontParameterValue::FontValue' has a wrong offset!");
//(offsetof(FFontParameterValue, FontPage) == 0x000020, "Member 'FFontParameterValue::FontPage' has a wrong offset!");
//(offsetof(FFontParameterValue, ExpressionGUID) == 0x000024, "Member 'FFontParameterValue::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.MaterialInstanceCachedData
// 0x0010 (0x0010 - 0x0000)
struct FMaterialInstanceCachedData final
{
public:
	TArray<int32>                                 ParentLayerIndexRemap;                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialInstanceCachedData) == 0x000008, "Wrong alignment on FMaterialInstanceCachedData");
//(sizeof(FMaterialInstanceCachedData) == 0x000010, "Wrong size on FMaterialInstanceCachedData");
//(offsetof(FMaterialInstanceCachedData, ParentLayerIndexRemap) == 0x000000, "Member 'FMaterialInstanceCachedData::ParentLayerIndexRemap' has a wrong offset!");

// ScriptStruct Engine.CollectionParameterBase
// 0x001C (0x001C - 0x0000)
struct FCollectionParameterBase
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ID;                                                // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCollectionParameterBase) == 0x000004, "Wrong alignment on FCollectionParameterBase");
//(sizeof(FCollectionParameterBase) == 0x00001C, "Wrong size on FCollectionParameterBase");
//(offsetof(FCollectionParameterBase, ParameterName) == 0x000000, "Member 'FCollectionParameterBase::ParameterName' has a wrong offset!");
//(offsetof(FCollectionParameterBase, ID) == 0x00000C, "Member 'FCollectionParameterBase::ID' has a wrong offset!");

// ScriptStruct Engine.CollectionScalarParameter
// 0x0004 (0x0020 - 0x001C)
struct FCollectionScalarParameter final : public FCollectionParameterBase
{
public:
	float                                         DefaultValue;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCollectionScalarParameter) == 0x000004, "Wrong alignment on FCollectionScalarParameter");
//(sizeof(FCollectionScalarParameter) == 0x000020, "Wrong size on FCollectionScalarParameter");
//(offsetof(FCollectionScalarParameter, DefaultValue) == 0x00001C, "Member 'FCollectionScalarParameter::DefaultValue' has a wrong offset!");

// ScriptStruct Engine.SoundNodeEditorData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSoundNodeEditorData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSoundNodeEditorData) == 0x000004, "Wrong alignment on FSoundNodeEditorData");
//(sizeof(FSoundNodeEditorData) == 0x000008, "Wrong size on FSoundNodeEditorData");

// ScriptStruct Engine.CollectionVectorParameter
// 0x0010 (0x002C - 0x001C)
struct FCollectionVectorParameter final : public FCollectionParameterBase
{
public:
	struct FLinearColor                           DefaultValue;                                      // 0x001C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FCollectionVectorParameter) == 0x000004, "Wrong alignment on FCollectionVectorParameter");
//(sizeof(FCollectionVectorParameter) == 0x00002C, "Wrong size on FCollectionVectorParameter");
//(offsetof(FCollectionVectorParameter, DefaultValue) == 0x00001C, "Member 'FCollectionVectorParameter::DefaultValue' has a wrong offset!");

// ScriptStruct Engine.MeshInstancingSettings
// 0x0018 (0x0018 - 0x0000)
struct FMeshInstancingSettings final
{
public:
	TSubclassOf<class AActor>                     ActorClassToUse;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceReplacementThreshold;                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipMeshesWithVertexColors;                       // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHLODVolumes;                                   // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UInstancedStaticMeshComponent> ISMComponentToUse;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMeshInstancingSettings) == 0x000008, "Wrong alignment on FMeshInstancingSettings");
//(sizeof(FMeshInstancingSettings) == 0x000018, "Wrong size on FMeshInstancingSettings");
//(offsetof(FMeshInstancingSettings, ActorClassToUse) == 0x000000, "Member 'FMeshInstancingSettings::ActorClassToUse' has a wrong offset!");
//(offsetof(FMeshInstancingSettings, InstanceReplacementThreshold) == 0x000008, "Member 'FMeshInstancingSettings::InstanceReplacementThreshold' has a wrong offset!");
//(offsetof(FMeshInstancingSettings, bSkipMeshesWithVertexColors) == 0x00000C, "Member 'FMeshInstancingSettings::bSkipMeshesWithVertexColors' has a wrong offset!");
//(offsetof(FMeshInstancingSettings, bUseHLODVolumes) == 0x00000D, "Member 'FMeshInstancingSettings::bUseHLODVolumes' has a wrong offset!");
//(offsetof(FMeshInstancingSettings, ISMComponentToUse) == 0x000010, "Member 'FMeshInstancingSettings::ISMComponentToUse' has a wrong offset!");

// ScriptStruct Engine.DistanceDatum
// 0x0014 (0x0014 - 0x0000)
struct FDistanceDatum final
{
public:
	float                                         FadeInDistanceStart;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDistanceEnd;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDistanceStart;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDistanceEnd;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FDistanceDatum) == 0x000004, "Wrong alignment on FDistanceDatum");
//(sizeof(FDistanceDatum) == 0x000014, "Wrong size on FDistanceDatum");
//(offsetof(FDistanceDatum, FadeInDistanceStart) == 0x000000, "Member 'FDistanceDatum::FadeInDistanceStart' has a wrong offset!");
//(offsetof(FDistanceDatum, FadeInDistanceEnd) == 0x000004, "Member 'FDistanceDatum::FadeInDistanceEnd' has a wrong offset!");
//(offsetof(FDistanceDatum, FadeOutDistanceStart) == 0x000008, "Member 'FDistanceDatum::FadeOutDistanceStart' has a wrong offset!");
//(offsetof(FDistanceDatum, FadeOutDistanceEnd) == 0x00000C, "Member 'FDistanceDatum::FadeOutDistanceEnd' has a wrong offset!");
//(offsetof(FDistanceDatum, Volume) == 0x000010, "Member 'FDistanceDatum::Volume' has a wrong offset!");

// ScriptStruct Engine.PacketSimulationSettings
// 0x0034 (0x0034 - 0x0000)
struct FPacketSimulationSettings final
{
public:
	int32                                         PktLoss;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktLossMaxSize;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktLossMinSize;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktOrder;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktDup;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktLag;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktLagVariance;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktLagMin;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktLagMax;                                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktIncomingLagMin;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktIncomingLagMax;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktIncomingLoss;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktJitter;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPacketSimulationSettings) == 0x000004, "Wrong alignment on FPacketSimulationSettings");
//(sizeof(FPacketSimulationSettings) == 0x000034, "Wrong size on FPacketSimulationSettings");
//(offsetof(FPacketSimulationSettings, PktLoss) == 0x000000, "Member 'FPacketSimulationSettings::PktLoss' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktLossMaxSize) == 0x000004, "Member 'FPacketSimulationSettings::PktLossMaxSize' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktLossMinSize) == 0x000008, "Member 'FPacketSimulationSettings::PktLossMinSize' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktOrder) == 0x00000C, "Member 'FPacketSimulationSettings::PktOrder' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktDup) == 0x000010, "Member 'FPacketSimulationSettings::PktDup' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktLag) == 0x000014, "Member 'FPacketSimulationSettings::PktLag' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktLagVariance) == 0x000018, "Member 'FPacketSimulationSettings::PktLagVariance' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktLagMin) == 0x00001C, "Member 'FPacketSimulationSettings::PktLagMin' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktLagMax) == 0x000020, "Member 'FPacketSimulationSettings::PktLagMax' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktIncomingLagMin) == 0x000024, "Member 'FPacketSimulationSettings::PktIncomingLagMin' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktIncomingLagMax) == 0x000028, "Member 'FPacketSimulationSettings::PktIncomingLagMax' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktIncomingLoss) == 0x00002C, "Member 'FPacketSimulationSettings::PktIncomingLoss' has a wrong offset!");
//(offsetof(FPacketSimulationSettings, PktJitter) == 0x000030, "Member 'FPacketSimulationSettings::PktJitter' has a wrong offset!");

// ScriptStruct Engine.NetDriverReplicationSystemConfig
// 0x000C (0x000C - 0x0000)
struct FNetDriverReplicationSystemConfig final
{
public:
	uint32                                        MaxReplicatedObjectCount;                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxDeltaCompressedObjectCount;                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxNetObjectGroupCount;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNetDriverReplicationSystemConfig) == 0x000004, "Wrong alignment on FNetDriverReplicationSystemConfig");
//(sizeof(FNetDriverReplicationSystemConfig) == 0x00000C, "Wrong size on FNetDriverReplicationSystemConfig");
//(offsetof(FNetDriverReplicationSystemConfig, MaxReplicatedObjectCount) == 0x000000, "Member 'FNetDriverReplicationSystemConfig::MaxReplicatedObjectCount' has a wrong offset!");
//(offsetof(FNetDriverReplicationSystemConfig, MaxDeltaCompressedObjectCount) == 0x000004, "Member 'FNetDriverReplicationSystemConfig::MaxDeltaCompressedObjectCount' has a wrong offset!");
//(offsetof(FNetDriverReplicationSystemConfig, MaxNetObjectGroupCount) == 0x000008, "Member 'FNetDriverReplicationSystemConfig::MaxNetObjectGroupCount' has a wrong offset!");

// ScriptStruct Engine.ChannelDefinition
// 0x0028 (0x0028 - 0x0000)
struct FChannelDefinition final
{
public:
	class FName                                   ChannelName;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClassName;                                         // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    ChannelClass;                                      // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StaticChannelIndex;                                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTickOnCreate : 1;                                 // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bServerOpen : 1;                                   // 0x0024(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientOpen : 1;                                   // 0x0024(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitialServer : 1;                                // 0x0024(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitialClient : 1;                                // 0x0024(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FChannelDefinition) == 0x000008, "Wrong alignment on FChannelDefinition");
//(sizeof(FChannelDefinition) == 0x000028, "Wrong size on FChannelDefinition");
//(offsetof(FChannelDefinition, ChannelName) == 0x000000, "Member 'FChannelDefinition::ChannelName' has a wrong offset!");
//(offsetof(FChannelDefinition, ClassName) == 0x00000C, "Member 'FChannelDefinition::ClassName' has a wrong offset!");
//(offsetof(FChannelDefinition, ChannelClass) == 0x000018, "Member 'FChannelDefinition::ChannelClass' has a wrong offset!");
//(offsetof(FChannelDefinition, StaticChannelIndex) == 0x000020, "Member 'FChannelDefinition::StaticChannelIndex' has a wrong offset!");

// ScriptStruct Engine.PooledReplicator
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FPooledReplicator final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPooledReplicator) == 0x000008, "Wrong alignment on FPooledReplicator");
//(sizeof(FPooledReplicator) == 0x000010, "Wrong size on FPooledReplicator");

// ScriptStruct Engine.MeshSectionInfoMap
// 0x0050 (0x0050 - 0x0000)
struct FMeshSectionInfoMap final
{
public:
	TMap<uint32, struct FMeshSectionInfo>         Map;                                               // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
//(alignof(FMeshSectionInfoMap) == 0x000008, "Wrong alignment on FMeshSectionInfoMap");
//(sizeof(FMeshSectionInfoMap) == 0x000050, "Wrong size on FMeshSectionInfoMap");
//(offsetof(FMeshSectionInfoMap, Map) == 0x000000, "Member 'FMeshSectionInfoMap::Map' has a wrong offset!");

// ScriptStruct Engine.NetworkEmulationProfileDescription
// 0x0020 (0x0020 - 0x0000)
struct FNetworkEmulationProfileDescription final
{
public:
	class FString                                 ProfileName;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ToolTip;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FNetworkEmulationProfileDescription) == 0x000008, "Wrong alignment on FNetworkEmulationProfileDescription");
//(sizeof(FNetworkEmulationProfileDescription) == 0x000020, "Wrong size on FNetworkEmulationProfileDescription");
//(offsetof(FNetworkEmulationProfileDescription, ProfileName) == 0x000000, "Member 'FNetworkEmulationProfileDescription::ProfileName' has a wrong offset!");
//(offsetof(FNetworkEmulationProfileDescription, ToolTip) == 0x000010, "Member 'FNetworkEmulationProfileDescription::ToolTip' has a wrong offset!");

// ScriptStruct Engine.ParticleSystemWorldManagerTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FParticleSystemWorldManagerTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FParticleSystemWorldManagerTickFunction) == 0x000008, "Wrong alignment on FParticleSystemWorldManagerTickFunction");
//(sizeof(FParticleSystemWorldManagerTickFunction) == 0x000038, "Wrong size on FParticleSystemWorldManagerTickFunction");

// ScriptStruct Engine.FreezablePerPlatformInt
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FFreezablePerPlatformInt final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FFreezablePerPlatformInt) == 0x000004, "Wrong alignment on FFreezablePerPlatformInt");
//(sizeof(FFreezablePerPlatformInt) == 0x000004, "Wrong size on FFreezablePerPlatformInt");

// ScriptStruct Engine.ClusterUnionReplicatedData
// 0x0002 (0x0002 - 0x0000)
struct FClusterUnionReplicatedData final
{
public:
	uint8                                         ObjectState;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnchored;                                       // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FClusterUnionReplicatedData) == 0x000001, "Wrong alignment on FClusterUnionReplicatedData");
//(sizeof(FClusterUnionReplicatedData) == 0x000002, "Wrong size on FClusterUnionReplicatedData");
//(offsetof(FClusterUnionReplicatedData, ObjectState) == 0x000000, "Member 'FClusterUnionReplicatedData::ObjectState' has a wrong offset!");
//(offsetof(FClusterUnionReplicatedData, bIsAnchored) == 0x000001, "Member 'FClusterUnionReplicatedData::bIsAnchored' has a wrong offset!");

// ScriptStruct Engine.ConstraintInstance
// 0x0248 (0x0280 - 0x0038)
struct FConstraintInstance final : public FConstraintInstanceBase
{
public:
	class FName                                   JointName;                                         // 0x0038(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintBone1;                                   // 0x0044(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintBone2;                                   // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Pos1;                                              // 0x0060(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PriAxis1;                                          // 0x0078(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecAxis1;                                          // 0x0090(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pos2;                                              // 0x00A8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PriAxis2;                                          // 0x00C0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecAxis2;                                          // 0x00D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AngularRotationOffset;                             // 0x00F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bScaleLinearLimits : 1;                            // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConstraintProfileProperties           ProfileInstance;                                   // 0x0110(0x0160)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FConstraintInstance) == 0x000008, "Wrong alignment on FConstraintInstance");
//(sizeof(FConstraintInstance) == 0x000280, "Wrong size on FConstraintInstance");
//(offsetof(FConstraintInstance, JointName) == 0x000038, "Member 'FConstraintInstance::JointName' has a wrong offset!");
//(offsetof(FConstraintInstance, ConstraintBone1) == 0x000044, "Member 'FConstraintInstance::ConstraintBone1' has a wrong offset!");
//(offsetof(FConstraintInstance, ConstraintBone2) == 0x000050, "Member 'FConstraintInstance::ConstraintBone2' has a wrong offset!");
//(offsetof(FConstraintInstance, Pos1) == 0x000060, "Member 'FConstraintInstance::Pos1' has a wrong offset!");
//(offsetof(FConstraintInstance, PriAxis1) == 0x000078, "Member 'FConstraintInstance::PriAxis1' has a wrong offset!");
//(offsetof(FConstraintInstance, SecAxis1) == 0x000090, "Member 'FConstraintInstance::SecAxis1' has a wrong offset!");
//(offsetof(FConstraintInstance, Pos2) == 0x0000A8, "Member 'FConstraintInstance::Pos2' has a wrong offset!");
//(offsetof(FConstraintInstance, PriAxis2) == 0x0000C0, "Member 'FConstraintInstance::PriAxis2' has a wrong offset!");
//(offsetof(FConstraintInstance, SecAxis2) == 0x0000D8, "Member 'FConstraintInstance::SecAxis2' has a wrong offset!");
//(offsetof(FConstraintInstance, AngularRotationOffset) == 0x0000F0, "Member 'FConstraintInstance::AngularRotationOffset' has a wrong offset!");
//(offsetof(FConstraintInstance, ProfileInstance) == 0x000110, "Member 'FConstraintInstance::ProfileInstance' has a wrong offset!");

// ScriptStruct Engine.PhysicsAssetSolverSettings
// 0x001C (0x001C - 0x0000)
struct FPhysicsAssetSolverSettings final
{
public:
	int32                                         PositionIterations;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VelocityIterations;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectionIterations;                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistance;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepenetrationVelocity;                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedTimeStep;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLinearJointSolver;                             // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FPhysicsAssetSolverSettings) == 0x000004, "Wrong alignment on FPhysicsAssetSolverSettings");
//(sizeof(FPhysicsAssetSolverSettings) == 0x00001C, "Wrong size on FPhysicsAssetSolverSettings");
//(offsetof(FPhysicsAssetSolverSettings, PositionIterations) == 0x000000, "Member 'FPhysicsAssetSolverSettings::PositionIterations' has a wrong offset!");
//(offsetof(FPhysicsAssetSolverSettings, VelocityIterations) == 0x000004, "Member 'FPhysicsAssetSolverSettings::VelocityIterations' has a wrong offset!");
//(offsetof(FPhysicsAssetSolverSettings, ProjectionIterations) == 0x000008, "Member 'FPhysicsAssetSolverSettings::ProjectionIterations' has a wrong offset!");
//(offsetof(FPhysicsAssetSolverSettings, CullDistance) == 0x00000C, "Member 'FPhysicsAssetSolverSettings::CullDistance' has a wrong offset!");
//(offsetof(FPhysicsAssetSolverSettings, MaxDepenetrationVelocity) == 0x000010, "Member 'FPhysicsAssetSolverSettings::MaxDepenetrationVelocity' has a wrong offset!");
//(offsetof(FPhysicsAssetSolverSettings, FixedTimeStep) == 0x000014, "Member 'FPhysicsAssetSolverSettings::FixedTimeStep' has a wrong offset!");
//(offsetof(FPhysicsAssetSolverSettings, bUseLinearJointSolver) == 0x000018, "Member 'FPhysicsAssetSolverSettings::bUseLinearJointSolver' has a wrong offset!");

// ScriptStruct Engine.PhysicalSurfaceName
// 0x0010 (0x0010 - 0x0000)
struct FPhysicalSurfaceName final
{
public:
	EPhysicalSurface                              Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FPhysicalSurfaceName) == 0x000004, "Wrong alignment on FPhysicalSurfaceName");
//(sizeof(FPhysicalSurfaceName) == 0x000010, "Wrong size on FPhysicalSurfaceName");
//(offsetof(FPhysicalSurfaceName, Type) == 0x000000, "Member 'FPhysicalSurfaceName::Type' has a wrong offset!");
//(offsetof(FPhysicalSurfaceName, Name) == 0x000004, "Member 'FPhysicalSurfaceName::Name' has a wrong offset!");

// ScriptStruct Engine.AsyncPhysicsTimestamp
// 0x0008 (0x0008 - 0x0000)
struct FAsyncPhysicsTimestamp final
{
public:
	int32                                         ServerFrame;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocalFrame;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FAsyncPhysicsTimestamp) == 0x000004, "Wrong alignment on FAsyncPhysicsTimestamp");
//(sizeof(FAsyncPhysicsTimestamp) == 0x000008, "Wrong size on FAsyncPhysicsTimestamp");
//(offsetof(FAsyncPhysicsTimestamp, ServerFrame) == 0x000000, "Member 'FAsyncPhysicsTimestamp::ServerFrame' has a wrong offset!");
//(offsetof(FAsyncPhysicsTimestamp, LocalFrame) == 0x000004, "Member 'FAsyncPhysicsTimestamp::LocalFrame' has a wrong offset!");

// ScriptStruct Engine.SpecularProfileStruct
// 0x0420 (0x0420 - 0x0000)
struct FSpecularProfileStruct final
{
public:
	ESpecularProfileFormat                        Format;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeCurveLinearColor               ViewColor;                                         // 0x0008(0x0208)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeCurveLinearColor               LightColor;                                        // 0x0210(0x0208)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSpecularProfileStruct) == 0x000008, "Wrong alignment on FSpecularProfileStruct");
//(sizeof(FSpecularProfileStruct) == 0x000420, "Wrong size on FSpecularProfileStruct");
//(offsetof(FSpecularProfileStruct, Format) == 0x000000, "Member 'FSpecularProfileStruct::Format' has a wrong offset!");
//(offsetof(FSpecularProfileStruct, ViewColor) == 0x000008, "Member 'FSpecularProfileStruct::ViewColor' has a wrong offset!");
//(offsetof(FSpecularProfileStruct, LightColor) == 0x000210, "Member 'FSpecularProfileStruct::LightColor' has a wrong offset!");
//(offsetof(FSpecularProfileStruct, Texture) == 0x000418, "Member 'FSpecularProfileStruct::Texture' has a wrong offset!");

// ScriptStruct Engine.BoneMirrorExport
// 0x001C (0x001C - 0x0000)
struct FBoneMirrorExport final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SourceBoneName;                                    // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         BoneFlipAxis;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FBoneMirrorExport) == 0x000004, "Wrong alignment on FBoneMirrorExport");
//(sizeof(FBoneMirrorExport) == 0x00001C, "Wrong size on FBoneMirrorExport");
//(offsetof(FBoneMirrorExport, BoneName) == 0x000000, "Member 'FBoneMirrorExport::BoneName' has a wrong offset!");
//(offsetof(FBoneMirrorExport, SourceBoneName) == 0x00000C, "Member 'FBoneMirrorExport::SourceBoneName' has a wrong offset!");
//(offsetof(FBoneMirrorExport, BoneFlipAxis) == 0x000018, "Member 'FBoneMirrorExport::BoneFlipAxis' has a wrong offset!");

// ScriptStruct Engine.SkelMeshMergeUVTransformMapping
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshMergeUVTransformMapping final
{
public:
	TArray<struct FSkelMeshMergeMeshUVTransforms> UVTransformsPerMesh;                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
//(alignof(FSkelMeshMergeUVTransformMapping) == 0x000008, "Wrong alignment on FSkelMeshMergeUVTransformMapping");
//(sizeof(FSkelMeshMergeUVTransformMapping) == 0x000010, "Wrong size on FSkelMeshMergeUVTransformMapping");
//(offsetof(FSkelMeshMergeUVTransformMapping, UVTransformsPerMesh) == 0x000000, "Member 'FSkelMeshMergeUVTransformMapping::UVTransformsPerMesh' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshSamplingInfo
// 0x0030 (0x0030 - 0x0000)
struct FSkeletalMeshSamplingInfo final
{
public:
	TArray<struct FSkeletalMeshSamplingRegion>    Regions;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSkeletalMeshSamplingBuiltData         BuiltData;                                         // 0x0010(0x0020)(NativeAccessSpecifierPrivate)
};
//(alignof(FSkeletalMeshSamplingInfo) == 0x000008, "Wrong alignment on FSkeletalMeshSamplingInfo");
//(sizeof(FSkeletalMeshSamplingInfo) == 0x000030, "Wrong size on FSkeletalMeshSamplingInfo");
//(offsetof(FSkeletalMeshSamplingInfo, Regions) == 0x000000, "Member 'FSkeletalMeshSamplingInfo::Regions' has a wrong offset!");
//(offsetof(FSkeletalMeshSamplingInfo, BuiltData) == 0x000010, "Member 'FSkeletalMeshSamplingInfo::BuiltData' has a wrong offset!");

// ScriptStruct Engine.SoundClassEditorData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSoundClassEditorData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSoundClassEditorData) == 0x000004, "Wrong alignment on FSoundClassEditorData");
//(sizeof(FSoundClassEditorData) == 0x000008, "Wrong size on FSoundClassEditorData");

// ScriptStruct Engine.SoundClassAdjuster
// 0x0020 (0x0020 - 0x0000)
struct FSoundClassAdjuster final
{
public:
	class USoundClass*                            SoundClassObject;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeAdjuster;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAdjuster;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowPassFilterFrequency;                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyToChildren : 1;                              // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VoiceCenterChannelVolumeAdjuster;                  // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSoundClassAdjuster) == 0x000008, "Wrong alignment on FSoundClassAdjuster");
//(sizeof(FSoundClassAdjuster) == 0x000020, "Wrong size on FSoundClassAdjuster");
//(offsetof(FSoundClassAdjuster, SoundClassObject) == 0x000000, "Member 'FSoundClassAdjuster::SoundClassObject' has a wrong offset!");
//(offsetof(FSoundClassAdjuster, VolumeAdjuster) == 0x000008, "Member 'FSoundClassAdjuster::VolumeAdjuster' has a wrong offset!");
//(offsetof(FSoundClassAdjuster, PitchAdjuster) == 0x00000C, "Member 'FSoundClassAdjuster::PitchAdjuster' has a wrong offset!");
//(offsetof(FSoundClassAdjuster, LowPassFilterFrequency) == 0x000010, "Member 'FSoundClassAdjuster::LowPassFilterFrequency' has a wrong offset!");
//(offsetof(FSoundClassAdjuster, VoiceCenterChannelVolumeAdjuster) == 0x000018, "Member 'FSoundClassAdjuster::VoiceCenterChannelVolumeAdjuster' has a wrong offset!");

// ScriptStruct Engine.SoundModulationDefaultRoutingSettings
// 0x0008 (0x0168 - 0x0160)
struct FSoundModulationDefaultRoutingSettings final : public FSoundModulationDefaultSettings
{
public:
	EModulationRouting                            VolumeRouting;                                     // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModulationRouting                            PitchRouting;                                      // 0x0161(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModulationRouting                            HighpassRouting;                                   // 0x0162(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModulationRouting                            LowpassRouting;                                    // 0x0163(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSoundModulationDefaultRoutingSettings) == 0x000008, "Wrong alignment on FSoundModulationDefaultRoutingSettings");
//(sizeof(FSoundModulationDefaultRoutingSettings) == 0x000168, "Wrong size on FSoundModulationDefaultRoutingSettings");
//(offsetof(FSoundModulationDefaultRoutingSettings, VolumeRouting) == 0x000160, "Member 'FSoundModulationDefaultRoutingSettings::VolumeRouting' has a wrong offset!");
//(offsetof(FSoundModulationDefaultRoutingSettings, PitchRouting) == 0x000161, "Member 'FSoundModulationDefaultRoutingSettings::PitchRouting' has a wrong offset!");
//(offsetof(FSoundModulationDefaultRoutingSettings, HighpassRouting) == 0x000162, "Member 'FSoundModulationDefaultRoutingSettings::HighpassRouting' has a wrong offset!");
//(offsetof(FSoundModulationDefaultRoutingSettings, LowpassRouting) == 0x000163, "Member 'FSoundModulationDefaultRoutingSettings::LowpassRouting' has a wrong offset!");

// ScriptStruct Engine.SoundSubmixSpectralAnalysisBandSettings
// 0x0010 (0x0010 - 0x0000)
struct FSoundSubmixSpectralAnalysisBandSettings final
{
public:
	float                                         BandFrequency;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackTimeMsec;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReleaseTimeMsec;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QFactor;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FSoundSubmixSpectralAnalysisBandSettings) == 0x000004, "Wrong alignment on FSoundSubmixSpectralAnalysisBandSettings");
//(sizeof(FSoundSubmixSpectralAnalysisBandSettings) == 0x000010, "Wrong size on FSoundSubmixSpectralAnalysisBandSettings");
//(offsetof(FSoundSubmixSpectralAnalysisBandSettings, BandFrequency) == 0x000000, "Member 'FSoundSubmixSpectralAnalysisBandSettings::BandFrequency' has a wrong offset!");
//(offsetof(FSoundSubmixSpectralAnalysisBandSettings, AttackTimeMsec) == 0x000004, "Member 'FSoundSubmixSpectralAnalysisBandSettings::AttackTimeMsec' has a wrong offset!");
//(offsetof(FSoundSubmixSpectralAnalysisBandSettings, ReleaseTimeMsec) == 0x000008, "Member 'FSoundSubmixSpectralAnalysisBandSettings::ReleaseTimeMsec' has a wrong offset!");
//(offsetof(FSoundSubmixSpectralAnalysisBandSettings, QFactor) == 0x00000C, "Member 'FSoundSubmixSpectralAnalysisBandSettings::QFactor' has a wrong offset!");

// ScriptStruct Engine.StaticMaterial
// 0x0038 (0x0038 - 0x0000)
struct FStaticMaterial final
{
public:
	class UMaterialInterface*                     MaterialInterface;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialSlotName;                                  // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ImportedMaterialSlotName;                          // 0x0014(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMeshUVChannelInfo                     UVChannelData;                                     // 0x0020(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStaticMaterial) == 0x000008, "Wrong alignment on FStaticMaterial");
//(sizeof(FStaticMaterial) == 0x000038, "Wrong size on FStaticMaterial");
//(offsetof(FStaticMaterial, MaterialInterface) == 0x000000, "Member 'FStaticMaterial::MaterialInterface' has a wrong offset!");
//(offsetof(FStaticMaterial, MaterialSlotName) == 0x000008, "Member 'FStaticMaterial::MaterialSlotName' has a wrong offset!");
//(offsetof(FStaticMaterial, ImportedMaterialSlotName) == 0x000014, "Member 'FStaticMaterial::ImportedMaterialSlotName' has a wrong offset!");
//(offsetof(FStaticMaterial, UVChannelData) == 0x000020, "Member 'FStaticMaterial::UVChannelData' has a wrong offset!");

// ScriptStruct Engine.StreamableTexture
// 0x0001 (0x0001 - 0x0000)
struct FStreamableTexture final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStreamableTexture) == 0x000001, "Wrong alignment on FStreamableTexture");
//(sizeof(FStreamableTexture) == 0x000001, "Wrong size on FStreamableTexture");

// ScriptStruct Engine.ExternalToolDefinition
// 0x0060 (0x0060 - 0x0000)
struct FExternalToolDefinition final
{
public:
	class FString                                 ToolName;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              ExecutablePath;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CommandLineOptions;                                // 0x0020(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDirectoryPath                         WorkingDirectory;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ScriptExtension;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDirectoryPath                         ScriptDirectory;                                   // 0x0050(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FExternalToolDefinition) == 0x000008, "Wrong alignment on FExternalToolDefinition");
//(sizeof(FExternalToolDefinition) == 0x000060, "Wrong size on FExternalToolDefinition");
//(offsetof(FExternalToolDefinition, ToolName) == 0x000000, "Member 'FExternalToolDefinition::ToolName' has a wrong offset!");
//(offsetof(FExternalToolDefinition, ExecutablePath) == 0x000010, "Member 'FExternalToolDefinition::ExecutablePath' has a wrong offset!");
//(offsetof(FExternalToolDefinition, CommandLineOptions) == 0x000020, "Member 'FExternalToolDefinition::CommandLineOptions' has a wrong offset!");
//(offsetof(FExternalToolDefinition, WorkingDirectory) == 0x000030, "Member 'FExternalToolDefinition::WorkingDirectory' has a wrong offset!");
//(offsetof(FExternalToolDefinition, ScriptExtension) == 0x000040, "Member 'FExternalToolDefinition::ScriptExtension' has a wrong offset!");
//(offsetof(FExternalToolDefinition, ScriptDirectory) == 0x000050, "Member 'FExternalToolDefinition::ScriptDirectory' has a wrong offset!");

// ScriptStruct Engine.MaterialEditorPromotionSettings
// 0x0030 (0x0030 - 0x0000)
struct FMaterialEditorPromotionSettings final
{
public:
	struct FFilePath                              DefaultMaterialAsset;                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              DefaultDiffuseTexture;                             // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              DefaultNormalTexture;                              // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FMaterialEditorPromotionSettings) == 0x000008, "Wrong alignment on FMaterialEditorPromotionSettings");
//(sizeof(FMaterialEditorPromotionSettings) == 0x000030, "Wrong size on FMaterialEditorPromotionSettings");
//(offsetof(FMaterialEditorPromotionSettings, DefaultMaterialAsset) == 0x000000, "Member 'FMaterialEditorPromotionSettings::DefaultMaterialAsset' has a wrong offset!");
//(offsetof(FMaterialEditorPromotionSettings, DefaultDiffuseTexture) == 0x000010, "Member 'FMaterialEditorPromotionSettings::DefaultDiffuseTexture' has a wrong offset!");
//(offsetof(FMaterialEditorPromotionSettings, DefaultNormalTexture) == 0x000020, "Member 'FMaterialEditorPromotionSettings::DefaultNormalTexture' has a wrong offset!");

// ScriptStruct Engine.ParticleEditorPromotionSettings
// 0x0010 (0x0010 - 0x0000)
struct FParticleEditorPromotionSettings final
{
public:
	struct FFilePath                              DefaultParticleAsset;                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FParticleEditorPromotionSettings) == 0x000008, "Wrong alignment on FParticleEditorPromotionSettings");
//(sizeof(FParticleEditorPromotionSettings) == 0x000010, "Wrong size on FParticleEditorPromotionSettings");
//(offsetof(FParticleEditorPromotionSettings, DefaultParticleAsset) == 0x000000, "Member 'FParticleEditorPromotionSettings::DefaultParticleAsset' has a wrong offset!");

// ScriptStruct Engine.TextureFormatSettings
// 0x0002 (0x0002 - 0x0000)
struct FTextureFormatSettings final
{
public:
	ETextureCompressionSettings                   CompressionSettings;                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CompressionNoAlpha : 1;                            // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         CompressionForceAlpha : 1;                         // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         CompressionNone : 1;                               // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         CompressionYCoCg : 1;                              // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SRGB : 1;                                          // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
//(alignof(FTextureFormatSettings) == 0x000001, "Wrong alignment on FTextureFormatSettings");
//(sizeof(FTextureFormatSettings) == 0x000002, "Wrong size on FTextureFormatSettings");
//(offsetof(FTextureFormatSettings, CompressionSettings) == 0x000000, "Member 'FTextureFormatSettings::CompressionSettings' has a wrong offset!");

// ScriptStruct Engine.TTVectorTrack
// 0x0008 (0x0030 - 0x0028)
struct FTTVectorTrack final : public FTTPropertyTrack
{
public:
	class UCurveVector*                           CurveVector;                                       // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FTTVectorTrack) == 0x000008, "Wrong alignment on FTTVectorTrack");
//(sizeof(FTTVectorTrack) == 0x000030, "Wrong size on FTTVectorTrack");
//(offsetof(FTTVectorTrack, CurveVector) == 0x000028, "Member 'FTTVectorTrack::CurveVector' has a wrong offset!");

// ScriptStruct Engine.AutoCompleteNode
// 0x0028 (0x0028 - 0x0000)
struct FAutoCompleteNode final
{
public:
	int32                                         IndexChar;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AutoCompleteListIndices;                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FAutoCompleteNode) == 0x000008, "Wrong alignment on FAutoCompleteNode");
//(sizeof(FAutoCompleteNode) == 0x000028, "Wrong size on FAutoCompleteNode");
//(offsetof(FAutoCompleteNode, IndexChar) == 0x000000, "Member 'FAutoCompleteNode::IndexChar' has a wrong offset!");
//(offsetof(FAutoCompleteNode, AutoCompleteListIndices) == 0x000008, "Member 'FAutoCompleteNode::AutoCompleteListIndices' has a wrong offset!");

// ScriptStruct Engine.InputActionKeyMapping
// 0x0030 (0x0030 - 0x0000)
struct FInputActionKeyMapping final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShift : 1;                                        // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCtrl : 1;                                         // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlt : 1;                                          // 0x000C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCmd : 1;                                          // 0x000C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   Key;                                               // 0x0010(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FInputActionKeyMapping) == 0x000008, "Wrong alignment on FInputActionKeyMapping");
//(sizeof(FInputActionKeyMapping) == 0x000030, "Wrong size on FInputActionKeyMapping");
//(offsetof(FInputActionKeyMapping, ActionName) == 0x000000, "Member 'FInputActionKeyMapping::ActionName' has a wrong offset!");
//(offsetof(FInputActionKeyMapping, Key) == 0x000010, "Member 'FInputActionKeyMapping::Key' has a wrong offset!");

// ScriptStruct Engine.VoiceSettings
// 0x0018 (0x0018 - 0x0000)
struct FVoiceSettings final
{
public:
	class USceneComponent*                        ComponentToAttachTo;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundEffectSourcePresetChain*          SourceEffectChain;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
//(alignof(FVoiceSettings) == 0x000008, "Wrong alignment on FVoiceSettings");
//(sizeof(FVoiceSettings) == 0x000018, "Wrong size on FVoiceSettings");
//(offsetof(FVoiceSettings, ComponentToAttachTo) == 0x000000, "Member 'FVoiceSettings::ComponentToAttachTo' has a wrong offset!");
//(offsetof(FVoiceSettings, AttenuationSettings) == 0x000008, "Member 'FVoiceSettings::AttenuationSettings' has a wrong offset!");
//(offsetof(FVoiceSettings, SourceEffectChain) == 0x000010, "Member 'FVoiceSettings::SourceEffectChain' has a wrong offset!");

// ScriptStruct Engine.StartPhysicsTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FStartPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FStartPhysicsTickFunction) == 0x000008, "Wrong alignment on FStartPhysicsTickFunction");
//(sizeof(FStartPhysicsTickFunction) == 0x000038, "Wrong size on FStartPhysicsTickFunction");

// ScriptStruct Engine.ActorDesc
// 0x00C8 (0x00C8 - 0x0000)
struct FActorDesc final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    NativeClass;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Class;                                             // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Label;                                             // 0x004C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x0058(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   RuntimeGrid;                                       // 0x0090(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpatiallyLoaded;                                // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActorIsEditorOnly;                                // 0x009D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActorPackage;                                      // 0x00A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorPath;                                         // 0x00AC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                DataLayerAssets;                                   // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
//(alignof(FActorDesc) == 0x000008, "Wrong alignment on FActorDesc");
//(sizeof(FActorDesc) == 0x0000C8, "Wrong size on FActorDesc");
//(offsetof(FActorDesc, Guid) == 0x000000, "Member 'FActorDesc::Guid' has a wrong offset!");
//(offsetof(FActorDesc, NativeClass) == 0x000010, "Member 'FActorDesc::NativeClass' has a wrong offset!");
//(offsetof(FActorDesc, Class) == 0x000018, "Member 'FActorDesc::Class' has a wrong offset!");
//(offsetof(FActorDesc, Name) == 0x000040, "Member 'FActorDesc::Name' has a wrong offset!");
//(offsetof(FActorDesc, Label) == 0x00004C, "Member 'FActorDesc::Label' has a wrong offset!");
//(offsetof(FActorDesc, Bounds) == 0x000058, "Member 'FActorDesc::Bounds' has a wrong offset!");
//(offsetof(FActorDesc, RuntimeGrid) == 0x000090, "Member 'FActorDesc::RuntimeGrid' has a wrong offset!");
//(offsetof(FActorDesc, bIsSpatiallyLoaded) == 0x00009C, "Member 'FActorDesc::bIsSpatiallyLoaded' has a wrong offset!");
//(offsetof(FActorDesc, bActorIsEditorOnly) == 0x00009D, "Member 'FActorDesc::bActorIsEditorOnly' has a wrong offset!");
//(offsetof(FActorDesc, ActorPackage) == 0x0000A0, "Member 'FActorDesc::ActorPackage' has a wrong offset!");
//(offsetof(FActorDesc, ActorPath) == 0x0000AC, "Member 'FActorDesc::ActorPath' has a wrong offset!");
//(offsetof(FActorDesc, DataLayerAssets) == 0x0000B8, "Member 'FActorDesc::DataLayerAssets' has a wrong offset!");

// ScriptStruct Engine.WorldPartitionDestructibleHLODDamagedActorState
// 0x0008 (0x0020 - 0x0018)
struct FWorldPartitionDestructibleHLODDamagedActorState final : public FFastArraySerializerItem
{
public:
	int32                                         ActorIndex;                                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ActorHealth;                                       // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FWorldPartitionDestructibleHLODDamagedActorState) == 0x000008, "Wrong alignment on FWorldPartitionDestructibleHLODDamagedActorState");
//(sizeof(FWorldPartitionDestructibleHLODDamagedActorState) == 0x000020, "Wrong size on FWorldPartitionDestructibleHLODDamagedActorState");
//(offsetof(FWorldPartitionDestructibleHLODDamagedActorState, ActorIndex) == 0x000018, "Member 'FWorldPartitionDestructibleHLODDamagedActorState::ActorIndex' has a wrong offset!");
//(offsetof(FWorldPartitionDestructibleHLODDamagedActorState, ActorHealth) == 0x00001C, "Member 'FWorldPartitionDestructibleHLODDamagedActorState::ActorHealth' has a wrong offset!");

// ScriptStruct Engine.WorldPartitionDestructibleHLODState
// 0x0040 (0x0150 - 0x0110)
struct FWorldPartitionDestructibleHLODState final : public FFastArraySerializer
{
public:
	TArray<struct FWorldPartitionDestructibleHLODDamagedActorState> DamagedActors;                                     // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UWorldPartitionDestructibleHLODComponent* OwnerComponent;                                    // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x28];                                     // 0x0128(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FWorldPartitionDestructibleHLODState) == 0x000008, "Wrong alignment on FWorldPartitionDestructibleHLODState");
//(sizeof(FWorldPartitionDestructibleHLODState) == 0x000150, "Wrong size on FWorldPartitionDestructibleHLODState");
//(offsetof(FWorldPartitionDestructibleHLODState, DamagedActors) == 0x000110, "Member 'FWorldPartitionDestructibleHLODState::DamagedActors' has a wrong offset!");
//(offsetof(FWorldPartitionDestructibleHLODState, OwnerComponent) == 0x000120, "Member 'FWorldPartitionDestructibleHLODState::OwnerComponent' has a wrong offset!");

// ScriptStruct Engine.WorldPartitionHLODDestructionTag
// 0x0010 (0x0010 - 0x0000)
struct FWorldPartitionHLODDestructionTag final
{
public:
	class UWorldPartitionDestructibleHLODComponent* HLODDestructionComponent;                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActorIndex;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FWorldPartitionHLODDestructionTag) == 0x000008, "Wrong alignment on FWorldPartitionHLODDestructionTag");
//(sizeof(FWorldPartitionHLODDestructionTag) == 0x000010, "Wrong size on FWorldPartitionHLODDestructionTag");
//(offsetof(FWorldPartitionHLODDestructionTag, HLODDestructionComponent) == 0x000000, "Member 'FWorldPartitionHLODDestructionTag::HLODDestructionComponent' has a wrong offset!");
//(offsetof(FWorldPartitionHLODDestructionTag, ActorIndex) == 0x000008, "Member 'FWorldPartitionHLODDestructionTag::ActorIndex' has a wrong offset!");

// ScriptStruct Engine.WorldPartitionRuntimeCellObjectMapping
// 0x0001 (0x0001 - 0x0000)
struct FWorldPartitionRuntimeCellObjectMapping final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FWorldPartitionRuntimeCellObjectMapping) == 0x000001, "Wrong alignment on FWorldPartitionRuntimeCellObjectMapping");
//(sizeof(FWorldPartitionRuntimeCellObjectMapping) == 0x000001, "Wrong size on FWorldPartitionRuntimeCellObjectMapping");

// ScriptStruct Engine.SpatialHashRuntimeGrid
// 0x0001 (0x0001 - 0x0000)
struct FSpatialHashRuntimeGrid final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FSpatialHashRuntimeGrid) == 0x000001, "Wrong alignment on FSpatialHashRuntimeGrid");
//(sizeof(FSpatialHashRuntimeGrid) == 0x000001, "Wrong size on FSpatialHashRuntimeGrid");

// ScriptStruct Engine.WorldPartitionStreamingQuerySource
// 0x0138 (0x0138 - 0x0000)
struct FWorldPartitionStreamingQuerySource final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGridLoadingRange;                              // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DataLayers;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDataLayersOnly;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpatialQuery;                                     // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x106];                                     // 0x0032(0x0106)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
//(alignof(FWorldPartitionStreamingQuerySource) == 0x000008, "Wrong alignment on FWorldPartitionStreamingQuerySource");
//(sizeof(FWorldPartitionStreamingQuerySource) == 0x000138, "Wrong size on FWorldPartitionStreamingQuerySource");
//(offsetof(FWorldPartitionStreamingQuerySource, Location) == 0x000000, "Member 'FWorldPartitionStreamingQuerySource::Location' has a wrong offset!");
//(offsetof(FWorldPartitionStreamingQuerySource, Radius) == 0x000018, "Member 'FWorldPartitionStreamingQuerySource::Radius' has a wrong offset!");
//(offsetof(FWorldPartitionStreamingQuerySource, bUseGridLoadingRange) == 0x00001C, "Member 'FWorldPartitionStreamingQuerySource::bUseGridLoadingRange' has a wrong offset!");
//(offsetof(FWorldPartitionStreamingQuerySource, DataLayers) == 0x000020, "Member 'FWorldPartitionStreamingQuerySource::DataLayers' has a wrong offset!");
//(offsetof(FWorldPartitionStreamingQuerySource, bDataLayersOnly) == 0x000030, "Member 'FWorldPartitionStreamingQuerySource::bDataLayersOnly' has a wrong offset!");
//(offsetof(FWorldPartitionStreamingQuerySource, bSpatialQuery) == 0x000031, "Member 'FWorldPartitionStreamingQuerySource::bSpatialQuery' has a wrong offset!");

}

