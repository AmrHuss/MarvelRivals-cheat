#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1041

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Hero_1041_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1041.Config_104101
// 0x0008 (0x00A0 - 0x0098)
class UConfig_104101 : public UMarvelAbilityConfig
{
public:
	EAutoAddAmmoTime                              AutoAddAmmoTime;                                   // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoAddAmmoAmount;                                 // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104101">();
	}
	static class UConfig_104101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104101>();
	}
};
static_assert(alignof(UConfig_104101) == 0x000008, "Wrong alignment on UConfig_104101");
static_assert(sizeof(UConfig_104101) == 0x0000A0, "Wrong size on UConfig_104101");
static_assert(offsetof(UConfig_104101, AutoAddAmmoTime) == 0x000098, "Member 'UConfig_104101::AutoAddAmmoTime' has a wrong offset!");
static_assert(offsetof(UConfig_104101, AutoAddAmmoAmount) == 0x00009C, "Member 'UConfig_104101::AutoAddAmmoAmount' has a wrong offset!");

// Class Hero_1041.AnimNotify_WS_WeaponQuickReload
// 0x0010 (0x0080 - 0x0070)
class UAnimNotify_WS_WeaponQuickReload final : public UAnimNotify_TriggerWeaponEvent
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponMaterialUpdateDuration;                      // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WS_WeaponQuickReload">();
	}
	static class UAnimNotify_WS_WeaponQuickReload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WS_WeaponQuickReload>();
	}
};
static_assert(alignof(UAnimNotify_WS_WeaponQuickReload) == 0x000008, "Wrong alignment on UAnimNotify_WS_WeaponQuickReload");
static_assert(sizeof(UAnimNotify_WS_WeaponQuickReload) == 0x000080, "Wrong size on UAnimNotify_WS_WeaponQuickReload");
static_assert(offsetof(UAnimNotify_WS_WeaponQuickReload, WeaponMaterialUpdateDuration) == 0x000078, "Member 'UAnimNotify_WS_WeaponQuickReload::WeaponMaterialUpdateDuration' has a wrong offset!");

// Class Hero_1041.Cue_Weapon_Loop_104121
// 0x0008 (0x1060 - 0x1058)
class ACue_Weapon_Loop_104121 : public AMarvelCueNotify_Weapon_Loop
{
public:
	int32                                         PassiveAbilityID;                                  // 0x1058(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105C[0x4];                                     // 0x105C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPassiveAmmoAdd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Weapon_Loop_104121">();
	}
	static class ACue_Weapon_Loop_104121* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Weapon_Loop_104121>();
	}
};
static_assert(alignof(ACue_Weapon_Loop_104121) == 0x000008, "Wrong alignment on ACue_Weapon_Loop_104121");
static_assert(sizeof(ACue_Weapon_Loop_104121) == 0x001060, "Wrong size on ACue_Weapon_Loop_104121");
static_assert(offsetof(ACue_Weapon_Loop_104121, PassiveAbilityID) == 0x001058, "Member 'ACue_Weapon_Loop_104121::PassiveAbilityID' has a wrong offset!");

// Class Hero_1041.Config_104131
// 0x0040 (0x0108 - 0x00C8)
class UConfig_104131 : public UMarvelAbilityConfig_LongPressTrigger
{
public:
	int32                                         SubTargetsMaxCount;                                // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetDistance;                                    // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DashEndLocationOffset;                             // 0x00D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileRecycleDelay;                            // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleOffsetLimit;                                  // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DizzyBuffTag;                                      // 0x00F0(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraInterp*                          PullingCameraInterp;                               // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104131">();
	}
	static class UConfig_104131* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104131>();
	}
};
static_assert(alignof(UConfig_104131) == 0x000008, "Wrong alignment on UConfig_104131");
static_assert(sizeof(UConfig_104131) == 0x000108, "Wrong size on UConfig_104131");
static_assert(offsetof(UConfig_104131, SubTargetsMaxCount) == 0x0000C8, "Member 'UConfig_104131::SubTargetsMaxCount' has a wrong offset!");
static_assert(offsetof(UConfig_104131, OffsetDistance) == 0x0000CC, "Member 'UConfig_104131::OffsetDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104131, DashEndLocationOffset) == 0x0000D0, "Member 'UConfig_104131::DashEndLocationOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104131, ProjectileRecycleDelay) == 0x0000E8, "Member 'UConfig_104131::ProjectileRecycleDelay' has a wrong offset!");
static_assert(offsetof(UConfig_104131, AngleOffsetLimit) == 0x0000EC, "Member 'UConfig_104131::AngleOffsetLimit' has a wrong offset!");
static_assert(offsetof(UConfig_104131, DizzyBuffTag) == 0x0000F0, "Member 'UConfig_104131::DizzyBuffTag' has a wrong offset!");
static_assert(offsetof(UConfig_104131, EndDistance) == 0x0000FC, "Member 'UConfig_104131::EndDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104131, PullingCameraInterp) == 0x000100, "Member 'UConfig_104131::PullingCameraInterp' has a wrong offset!");

// Class Hero_1041.Ability_104131
// 0x0060 (0x25C8 - 0x2568)
class UAbility_104131 : public UMarvelAbility_LongPressTrigger
{
public:
	class AMarvelAbilityTargetActor_Projectile*   BackWardProjectile;                                // 0x2568(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MissileRotator104131;                              // 0x2570(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  MainTarget;                                        // 0x2588(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          SubTargets;                                        // 0x2590(0x0010)(Net, ZeroConstructor, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         DragBuffId;                                        // 0x25A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DizzyBuffId;                                       // 0x25A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitGameplayTagRemoved*    WaitBuffRemoveTask;                                // 0x25A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_104131*                         Config_104131;                                     // 0x25B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAbility104131PullBackDispatcher;                 // 0x25B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddSubTarget(class AActor* Target);
	void ApplyDragBuff();
	class ACharacter* GetMainTarget();
	struct FRotator GetMissileRotator104131();
	TArray<TWeakObjectPtr<class AActor>> GetSubTargets();
	bool IsAbilityHit();
	bool IsMainTarget(const class AActor* CheckTarget);
	bool IsSubTarget(const class AActor* CheckTarget);
	void K2_EnterEndSection();
	void OnMainTargetDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnMainTargetHit();
	void OnRep_SubTargets();
	void OnTargetDizzyBuffRemoved();
	void OnWinterSoldierPortal(const struct FVector& LastPosition, const struct FVector& NewPosition);
	void RemoveSubTarget(class AActor* Target);
	void ResetSubTarget();
	void SetMainTarget(class AActor* Target);
	void SetMissileRotator104131();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104131">();
	}
	static class UAbility_104131* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104131>();
	}
};
static_assert(alignof(UAbility_104131) == 0x000008, "Wrong alignment on UAbility_104131");
static_assert(sizeof(UAbility_104131) == 0x0025C8, "Wrong size on UAbility_104131");
static_assert(offsetof(UAbility_104131, BackWardProjectile) == 0x002568, "Member 'UAbility_104131::BackWardProjectile' has a wrong offset!");
static_assert(offsetof(UAbility_104131, MissileRotator104131) == 0x002570, "Member 'UAbility_104131::MissileRotator104131' has a wrong offset!");
static_assert(offsetof(UAbility_104131, MainTarget) == 0x002588, "Member 'UAbility_104131::MainTarget' has a wrong offset!");
static_assert(offsetof(UAbility_104131, SubTargets) == 0x002590, "Member 'UAbility_104131::SubTargets' has a wrong offset!");
static_assert(offsetof(UAbility_104131, DragBuffId) == 0x0025A0, "Member 'UAbility_104131::DragBuffId' has a wrong offset!");
static_assert(offsetof(UAbility_104131, DizzyBuffId) == 0x0025A4, "Member 'UAbility_104131::DizzyBuffId' has a wrong offset!");
static_assert(offsetof(UAbility_104131, WaitBuffRemoveTask) == 0x0025A8, "Member 'UAbility_104131::WaitBuffRemoveTask' has a wrong offset!");
static_assert(offsetof(UAbility_104131, Config_104131) == 0x0025B0, "Member 'UAbility_104131::Config_104131' has a wrong offset!");
static_assert(offsetof(UAbility_104131, OnAbility104131PullBackDispatcher) == 0x0025B8, "Member 'UAbility_104131::OnAbility104131PullBackDispatcher' has a wrong offset!");

// Class Hero_1041.DragAbility_104131
// 0x0050 (0x1CF0 - 0x1CA0)
class UDragAbility_104131 : public UMarvelDragAbility
{
public:
	class ACharacter*                             DraggingCharacter;                                 // 0x1CA0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceOffset;                                    // 0x1CA8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CAC[0x4];                                     // 0x1CAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashEndLocationOffset;                             // 0x1CB0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawOffsetLimit;                                    // 0x1CC8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CCC[0x4];                                     // 0x1CCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               OriginRotator;                                     // 0x1CD0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         OriginYaw;                                         // 0x1CE8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CEC[0x4];                                     // 0x1CEC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCurrentLimitedYaw();
	struct FVector GetCurrentTargetLocation();
	float GetCurrentYaw();
	void OnActorHitDuringDash(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragAbility_104131">();
	}
	static class UDragAbility_104131* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragAbility_104131>();
	}
};
static_assert(alignof(UDragAbility_104131) == 0x000008, "Wrong alignment on UDragAbility_104131");
static_assert(sizeof(UDragAbility_104131) == 0x001CF0, "Wrong size on UDragAbility_104131");
static_assert(offsetof(UDragAbility_104131, DraggingCharacter) == 0x001CA0, "Member 'UDragAbility_104131::DraggingCharacter' has a wrong offset!");
static_assert(offsetof(UDragAbility_104131, DistanceOffset) == 0x001CA8, "Member 'UDragAbility_104131::DistanceOffset' has a wrong offset!");
static_assert(offsetof(UDragAbility_104131, DashEndLocationOffset) == 0x001CB0, "Member 'UDragAbility_104131::DashEndLocationOffset' has a wrong offset!");
static_assert(offsetof(UDragAbility_104131, YawOffsetLimit) == 0x001CC8, "Member 'UDragAbility_104131::YawOffsetLimit' has a wrong offset!");
static_assert(offsetof(UDragAbility_104131, OriginRotator) == 0x001CD0, "Member 'UDragAbility_104131::OriginRotator' has a wrong offset!");
static_assert(offsetof(UDragAbility_104131, OriginYaw) == 0x001CE8, "Member 'UDragAbility_104131::OriginYaw' has a wrong offset!");

// Class Hero_1041.Cue_Projectile_Loop_10413101
// 0x02D8 (0x1038 - 0x0D60)
class ACue_Projectile_Loop_10413101 final : public AMarvelCueNotify_Projectile
{
public:
	class UStaticMeshComponent*                   PrickleVineMeshComp;                               // 0x0D60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCableComponent*                  SubCableComp01;                                    // 0x0D68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCableComponent*                  SubCableComp02;                                    // 0x0D70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCableComponent*                  SubCableComp03;                                    // 0x0D78(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCableComponent*                  SubCableComp04;                                    // 0x0D80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCableComponent*                  SubCableComp05;                                    // 0x0D88(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMarvelCableComponent*>          Cables;                                            // 0x0D90(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HookComp01;                                        // 0x0DA0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HookComp02;                                        // 0x0DA8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HookComp03;                                        // 0x0DB0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HookComp04;                                        // 0x0DB8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HookComp05;                                        // 0x0DC0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         Hooks;                                             // 0x0DC8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 RiotMeshComp;                                      // 0x0DD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      RiotSpeedLineFXComponent;                          // 0x0DE0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayDeactivateSpeedlineFXTime;                    // 0x0DE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DEC[0x4];                                      // 0x0DEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedlineFXDissolveCurve;                          // 0x0DF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrickleVineGrowTime;                               // 0x0DF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrickleVineDissolveTime;                           // 0x0DFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrickleVineMeshLength;                             // 0x0E00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E04[0x4];                                      // 0x0E04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               PrickleVineMeshRotation;                           // 0x0E08(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         PrickleVineCurveWhenGrowing;                       // 0x0E20(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         PrickleVineCurveWhenDissolving;                    // 0x0E70(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FName                                   PrickleVineAttachSocketName;                       // 0x0EC0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ECC[0x4];                                      // 0x0ECC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   HideMaterialIndex;                                 // 0x0ED0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         SubCableLengthOffset;                              // 0x0F20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubCableEachSegmentLength;                         // 0x0F24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RiotRelativeRotator;                               // 0x0F28(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PrickleVineScaleDistanceCurve;                     // 0x0F40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SubCableMaterial;                                  // 0x0F48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubCableLength;                                    // 0x0F50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubCableNumSegments;                               // 0x0F54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubCableSolverIterations;                          // 0x0F58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubCableWidth;                                     // 0x0F5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         CharacterDragFX;                                   // 0x0F60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UFXSystemComponent*>        DragTargetFXComps;                                 // 0x0F68(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         PrickleVineRandRoll;                               // 0x0FB8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrickleVineGrowRange;                              // 0x0FBC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrickleVineGrowDelta;                              // 0x0FC0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrickleVineGrowLastDelta;                          // 0x0FC4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackVelocity;                                      // 0x0FC8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasSetDissolveTime;                               // 0x0FCC(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasEndAgentTask;                                  // 0x0FCD(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAbilityHit;                                     // 0x0FCE(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FCF[0x1];                                      // 0x0FCF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0FD0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelAbilityTargetActor_Projectile*   OwnerProjectile;                                   // 0x0FD8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbility_104131*                        OwnerAbility;                                      // 0x0FE0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelAbilityTargetActor_Projectile*   BackWardProjectile;                                // 0x0FE8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               OriginRotator;                                     // 0x0FF0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bStopUpdatePrickles;                               // 0x1008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1009[0x3];                                     // 0x1009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AbilityActivateTag;                                // 0x100C(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           HideAllPrickleVineTimer;                           // 0x1018(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedlineFXDissolveTimeCounter;                    // 0x1030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1034[0x4];                                     // 0x1034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideAllPrickleVineComponents();
	void HideAllSubPrickles();
	bool ShouldSetParameterWhenDissolving(class FName ParameterName);
	bool ShouldSetParameterWhenGrowing(class FName ParameterName);
	bool ShouldUpdateSubPrickles();
	void UpdatePrickleVineFX();
	void UpdateSubPrickles();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10413101">();
	}
	static class ACue_Projectile_Loop_10413101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10413101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10413101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10413101");
static_assert(sizeof(ACue_Projectile_Loop_10413101) == 0x001038, "Wrong size on ACue_Projectile_Loop_10413101");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineMeshComp) == 0x000D60, "Member 'ACue_Projectile_Loop_10413101::PrickleVineMeshComp' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableComp01) == 0x000D68, "Member 'ACue_Projectile_Loop_10413101::SubCableComp01' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableComp02) == 0x000D70, "Member 'ACue_Projectile_Loop_10413101::SubCableComp02' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableComp03) == 0x000D78, "Member 'ACue_Projectile_Loop_10413101::SubCableComp03' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableComp04) == 0x000D80, "Member 'ACue_Projectile_Loop_10413101::SubCableComp04' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableComp05) == 0x000D88, "Member 'ACue_Projectile_Loop_10413101::SubCableComp05' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, Cables) == 0x000D90, "Member 'ACue_Projectile_Loop_10413101::Cables' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HookComp01) == 0x000DA0, "Member 'ACue_Projectile_Loop_10413101::HookComp01' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HookComp02) == 0x000DA8, "Member 'ACue_Projectile_Loop_10413101::HookComp02' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HookComp03) == 0x000DB0, "Member 'ACue_Projectile_Loop_10413101::HookComp03' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HookComp04) == 0x000DB8, "Member 'ACue_Projectile_Loop_10413101::HookComp04' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HookComp05) == 0x000DC0, "Member 'ACue_Projectile_Loop_10413101::HookComp05' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, Hooks) == 0x000DC8, "Member 'ACue_Projectile_Loop_10413101::Hooks' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, RiotMeshComp) == 0x000DD8, "Member 'ACue_Projectile_Loop_10413101::RiotMeshComp' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, RiotSpeedLineFXComponent) == 0x000DE0, "Member 'ACue_Projectile_Loop_10413101::RiotSpeedLineFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, DelayDeactivateSpeedlineFXTime) == 0x000DE8, "Member 'ACue_Projectile_Loop_10413101::DelayDeactivateSpeedlineFXTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SpeedlineFXDissolveCurve) == 0x000DF0, "Member 'ACue_Projectile_Loop_10413101::SpeedlineFXDissolveCurve' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineGrowTime) == 0x000DF8, "Member 'ACue_Projectile_Loop_10413101::PrickleVineGrowTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineDissolveTime) == 0x000DFC, "Member 'ACue_Projectile_Loop_10413101::PrickleVineDissolveTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineMeshLength) == 0x000E00, "Member 'ACue_Projectile_Loop_10413101::PrickleVineMeshLength' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineMeshRotation) == 0x000E08, "Member 'ACue_Projectile_Loop_10413101::PrickleVineMeshRotation' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineCurveWhenGrowing) == 0x000E20, "Member 'ACue_Projectile_Loop_10413101::PrickleVineCurveWhenGrowing' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineCurveWhenDissolving) == 0x000E70, "Member 'ACue_Projectile_Loop_10413101::PrickleVineCurveWhenDissolving' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineAttachSocketName) == 0x000EC0, "Member 'ACue_Projectile_Loop_10413101::PrickleVineAttachSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HideMaterialIndex) == 0x000ED0, "Member 'ACue_Projectile_Loop_10413101::HideMaterialIndex' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableLengthOffset) == 0x000F20, "Member 'ACue_Projectile_Loop_10413101::SubCableLengthOffset' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableEachSegmentLength) == 0x000F24, "Member 'ACue_Projectile_Loop_10413101::SubCableEachSegmentLength' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, RiotRelativeRotator) == 0x000F28, "Member 'ACue_Projectile_Loop_10413101::RiotRelativeRotator' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineScaleDistanceCurve) == 0x000F40, "Member 'ACue_Projectile_Loop_10413101::PrickleVineScaleDistanceCurve' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableMaterial) == 0x000F48, "Member 'ACue_Projectile_Loop_10413101::SubCableMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableLength) == 0x000F50, "Member 'ACue_Projectile_Loop_10413101::SubCableLength' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableNumSegments) == 0x000F54, "Member 'ACue_Projectile_Loop_10413101::SubCableNumSegments' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableSolverIterations) == 0x000F58, "Member 'ACue_Projectile_Loop_10413101::SubCableSolverIterations' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableWidth) == 0x000F5C, "Member 'ACue_Projectile_Loop_10413101::SubCableWidth' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, CharacterDragFX) == 0x000F60, "Member 'ACue_Projectile_Loop_10413101::CharacterDragFX' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, DragTargetFXComps) == 0x000F68, "Member 'ACue_Projectile_Loop_10413101::DragTargetFXComps' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineRandRoll) == 0x000FB8, "Member 'ACue_Projectile_Loop_10413101::PrickleVineRandRoll' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineGrowRange) == 0x000FBC, "Member 'ACue_Projectile_Loop_10413101::PrickleVineGrowRange' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineGrowDelta) == 0x000FC0, "Member 'ACue_Projectile_Loop_10413101::PrickleVineGrowDelta' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineGrowLastDelta) == 0x000FC4, "Member 'ACue_Projectile_Loop_10413101::PrickleVineGrowLastDelta' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, BackVelocity) == 0x000FC8, "Member 'ACue_Projectile_Loop_10413101::BackVelocity' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, bHasSetDissolveTime) == 0x000FCC, "Member 'ACue_Projectile_Loop_10413101::bHasSetDissolveTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, bHasEndAgentTask) == 0x000FCD, "Member 'ACue_Projectile_Loop_10413101::bHasEndAgentTask' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, bIsAbilityHit) == 0x000FCE, "Member 'ACue_Projectile_Loop_10413101::bIsAbilityHit' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, OwnerCharacter) == 0x000FD0, "Member 'ACue_Projectile_Loop_10413101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, OwnerProjectile) == 0x000FD8, "Member 'ACue_Projectile_Loop_10413101::OwnerProjectile' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, OwnerAbility) == 0x000FE0, "Member 'ACue_Projectile_Loop_10413101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, BackWardProjectile) == 0x000FE8, "Member 'ACue_Projectile_Loop_10413101::BackWardProjectile' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, OriginRotator) == 0x000FF0, "Member 'ACue_Projectile_Loop_10413101::OriginRotator' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, bStopUpdatePrickles) == 0x001008, "Member 'ACue_Projectile_Loop_10413101::bStopUpdatePrickles' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, AbilityActivateTag) == 0x00100C, "Member 'ACue_Projectile_Loop_10413101::AbilityActivateTag' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HideAllPrickleVineTimer) == 0x001018, "Member 'ACue_Projectile_Loop_10413101::HideAllPrickleVineTimer' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SpeedlineFXDissolveTimeCounter) == 0x001030, "Member 'ACue_Projectile_Loop_10413101::SpeedlineFXDissolveTimeCounter' has a wrong offset!");

// Class Hero_1041.Cue_Ability_Loop_10413101
// 0x0068 (0x0E68 - 0x0E00)
class ACue_Ability_Loop_10413101 final : public AMarvelCueNotify_Ability
{
public:
	class AMarvelBaseCharacter*                   OwningCharacter;                                   // 0x0E00(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbility_104131*                        OwningAbility;                                     // 0x0E08(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraInterp*                          PullBackCameraInterp;                              // 0x0E10(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FSpringArmControlHandler> SpringArmHandlers;                                 // 0x0E18(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void OnAbilityStartPullBack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10413101">();
	}
	static class ACue_Ability_Loop_10413101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10413101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10413101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10413101");
static_assert(sizeof(ACue_Ability_Loop_10413101) == 0x000E68, "Wrong size on ACue_Ability_Loop_10413101");
static_assert(offsetof(ACue_Ability_Loop_10413101, OwningCharacter) == 0x000E00, "Member 'ACue_Ability_Loop_10413101::OwningCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10413101, OwningAbility) == 0x000E08, "Member 'ACue_Ability_Loop_10413101::OwningAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10413101, PullBackCameraInterp) == 0x000E10, "Member 'ACue_Ability_Loop_10413101::PullBackCameraInterp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10413101, SpringArmHandlers) == 0x000E18, "Member 'ACue_Ability_Loop_10413101::SpringArmHandlers' has a wrong offset!");

// Class Hero_1041.UIController_104131
// 0x0018 (0x0C70 - 0x0C58)
class UUIController_104131 : public UUIC_Ability
{
public:
	float                                         GatherWarningTime;                                 // 0x0C58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullDuration;                                      // 0x0C5C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPlayWarningAnim;                               // 0x0C60(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C61[0x7];                                      // 0x0C61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget_AbilityDuration*                DurationWidget;                                    // 0x0C68(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayWarningAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIController_104131">();
	}
	static class UUIController_104131* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIController_104131>();
	}
};
static_assert(alignof(UUIController_104131) == 0x000008, "Wrong alignment on UUIController_104131");
static_assert(sizeof(UUIController_104131) == 0x000C70, "Wrong size on UUIController_104131");
static_assert(offsetof(UUIController_104131, GatherWarningTime) == 0x000C58, "Member 'UUIController_104131::GatherWarningTime' has a wrong offset!");
static_assert(offsetof(UUIController_104131, FullDuration) == 0x000C5C, "Member 'UUIController_104131::FullDuration' has a wrong offset!");
static_assert(offsetof(UUIController_104131, bHasPlayWarningAnim) == 0x000C60, "Member 'UUIController_104131::bHasPlayWarningAnim' has a wrong offset!");
static_assert(offsetof(UUIController_104131, DurationWidget) == 0x000C68, "Member 'UUIController_104131::DurationWidget' has a wrong offset!");

// Class Hero_1041.Config_104141
// 0x0FB0 (0x1048 - 0x0098)
class UConfig_104141 final : public UMarvelAbilityConfig
{
public:
	bool                                          bNewCollideDown;                                   // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelApplyPinnedMotionConfig         NewCollideDownConfig;                              // 0x00A0(0x0160)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         GrabScopeID;                                       // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GrabCollideTag;                                    // 0x0204(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrabBuffID_CollideKonckDown;                       // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DashScopeID;                                       // 0x0214(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashDistance;                                      // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDashAbilityInfo                       DashInfo;                                          // 0x0220(0x0B70)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DashStopIfHasAnyTags;                              // 0x0D90(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector                                DashTraceOffset;                                   // 0x0DF8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MajorTargetBuffID;                                 // 0x0E10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E14[0x4];                                      // 0x0E14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelGameplayTagRequirements         MajorTargetRequirements;                           // 0x0E18(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         MinorTargetBuffID;                                 // 0x0EE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EEC[0x4];                                      // 0x0EEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelGameplayTagRequirements         MinorTargetRequirements;                           // 0x0EF0(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector                                PinnedTargetOffset;                                // 0x0FC0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  PinnedTargetGrantedTags;                           // 0x0FD8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EMovementMode                                 PinnedTargetMovementMode;                          // 0x1040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1041[0x7];                                     // 0x1041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104141">();
	}
	static class UConfig_104141* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104141>();
	}
};
static_assert(alignof(UConfig_104141) == 0x000008, "Wrong alignment on UConfig_104141");
static_assert(sizeof(UConfig_104141) == 0x001048, "Wrong size on UConfig_104141");
static_assert(offsetof(UConfig_104141, bNewCollideDown) == 0x000098, "Member 'UConfig_104141::bNewCollideDown' has a wrong offset!");
static_assert(offsetof(UConfig_104141, NewCollideDownConfig) == 0x0000A0, "Member 'UConfig_104141::NewCollideDownConfig' has a wrong offset!");
static_assert(offsetof(UConfig_104141, GrabScopeID) == 0x000200, "Member 'UConfig_104141::GrabScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_104141, GrabCollideTag) == 0x000204, "Member 'UConfig_104141::GrabCollideTag' has a wrong offset!");
static_assert(offsetof(UConfig_104141, GrabBuffID_CollideKonckDown) == 0x000210, "Member 'UConfig_104141::GrabBuffID_CollideKonckDown' has a wrong offset!");
static_assert(offsetof(UConfig_104141, DashScopeID) == 0x000214, "Member 'UConfig_104141::DashScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_104141, DashDistance) == 0x000218, "Member 'UConfig_104141::DashDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104141, DashInfo) == 0x000220, "Member 'UConfig_104141::DashInfo' has a wrong offset!");
static_assert(offsetof(UConfig_104141, DashStopIfHasAnyTags) == 0x000D90, "Member 'UConfig_104141::DashStopIfHasAnyTags' has a wrong offset!");
static_assert(offsetof(UConfig_104141, DashTraceOffset) == 0x000DF8, "Member 'UConfig_104141::DashTraceOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104141, MajorTargetBuffID) == 0x000E10, "Member 'UConfig_104141::MajorTargetBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104141, MajorTargetRequirements) == 0x000E18, "Member 'UConfig_104141::MajorTargetRequirements' has a wrong offset!");
static_assert(offsetof(UConfig_104141, MinorTargetBuffID) == 0x000EE8, "Member 'UConfig_104141::MinorTargetBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104141, MinorTargetRequirements) == 0x000EF0, "Member 'UConfig_104141::MinorTargetRequirements' has a wrong offset!");
static_assert(offsetof(UConfig_104141, PinnedTargetOffset) == 0x000FC0, "Member 'UConfig_104141::PinnedTargetOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104141, PinnedTargetGrantedTags) == 0x000FD8, "Member 'UConfig_104141::PinnedTargetGrantedTags' has a wrong offset!");
static_assert(offsetof(UConfig_104141, PinnedTargetMovementMode) == 0x001040, "Member 'UConfig_104141::PinnedTargetMovementMode' has a wrong offset!");

// Class Hero_1041.MarvelDragAbility_10414102
// 0x0028 (0x1CC8 - 0x1CA0)
class UMarvelDragAbility_10414102 : public UMarvelDragAbility
{
public:
	class UMarvelAbilityTask_Dash*                DashTask;                                          // 0x1CA0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ReplicatedTargetLocation;                          // 0x1CA8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_NetworkSyncPointWithPayload* NetSyncTask;                                       // 0x1CC0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyDash(const struct FVector& DragTargetLocation);
	void OnDashFinish(EDashStopReason Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelDragAbility_10414102">();
	}
	static class UMarvelDragAbility_10414102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelDragAbility_10414102>();
	}
};
static_assert(alignof(UMarvelDragAbility_10414102) == 0x000008, "Wrong alignment on UMarvelDragAbility_10414102");
static_assert(sizeof(UMarvelDragAbility_10414102) == 0x001CC8, "Wrong size on UMarvelDragAbility_10414102");
static_assert(offsetof(UMarvelDragAbility_10414102, DashTask) == 0x001CA0, "Member 'UMarvelDragAbility_10414102::DashTask' has a wrong offset!");
static_assert(offsetof(UMarvelDragAbility_10414102, ReplicatedTargetLocation) == 0x001CA8, "Member 'UMarvelDragAbility_10414102::ReplicatedTargetLocation' has a wrong offset!");
static_assert(offsetof(UMarvelDragAbility_10414102, NetSyncTask) == 0x001CC0, "Member 'UMarvelDragAbility_10414102::NetSyncTask' has a wrong offset!");

// Class Hero_1041.TraceComponent_10414101
// 0x0000 (0x16B0 - 0x16B0)
class UTraceComponent_10414101 final : public UMarvelAgentTraceComponent
{
public:
	class UConfig_104141*                         MyConfig;                                          // 0x16A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10414101">();
	}
	static class UTraceComponent_10414101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10414101>();
	}
};
static_assert(alignof(UTraceComponent_10414101) == 0x000010, "Wrong alignment on UTraceComponent_10414101");
static_assert(sizeof(UTraceComponent_10414101) == 0x0016B0, "Wrong size on UTraceComponent_10414101");
static_assert(offsetof(UTraceComponent_10414101, MyConfig) == 0x0016A8, "Member 'UTraceComponent_10414101::MyConfig' has a wrong offset!");

// Class Hero_1041.EffectiveComponent_10414101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10414101 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10414101">();
	}
	static class UEffectiveComponent_10414101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10414101>();
	}
};
static_assert(alignof(UEffectiveComponent_10414101) == 0x000010, "Wrong alignment on UEffectiveComponent_10414101");
static_assert(sizeof(UEffectiveComponent_10414101) == 0x001C00, "Wrong size on UEffectiveComponent_10414101");

// Class Hero_1041.EffectiveComponent_10414102
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10414102 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10414102">();
	}
	static class UEffectiveComponent_10414102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10414102>();
	}
};
static_assert(alignof(UEffectiveComponent_10414102) == 0x000010, "Wrong alignment on UEffectiveComponent_10414102");
static_assert(sizeof(UEffectiveComponent_10414102) == 0x001C00, "Wrong size on UEffectiveComponent_10414102");

// Class Hero_1041.Ability_104141
// 0x0270 (0x27C0 - 0x2550)
class UAbility_104141 : public UMarvelGameplayAbility
{
public:
	float                                         HasDashDistance;                                   // 0x2550(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityState_104141                          AbilityState;                                      // 0x2554(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2555[0x3];                                     // 0x2555(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashSourceLocation;                                // 0x2558(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DashTargetLocation;                                // 0x2570(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDashStageHit;                                  // 0x2588(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2589[0x3];                                     // 0x2589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  DashMajorTarget;                                   // 0x258C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2594[0x4];                                     // 0x2594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         DashMinorTargets;                                  // 0x2598(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UMarvelAgentTraceComponent*             DashTraceComponent;                                // 0x25A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         ApplyEffectToDashTargetsKey;                       // 0x25B0(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         DashMajorTargetPredictionKey;                      // 0x2650(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F0[0x8];                                     // 0x26F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_104141*                         MyConfig;                                          // 0x26F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_ApplyPinnedMotion*   ApplyPinnedMotionTask;                             // 0x2700(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2708[0x50];                                    // 0x2708(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_WaitTargetDataInDuration* WaitMajorTargetTask;                               // 0x2758(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitServerConfirm*   WaitServerConfirmTask;                             // 0x2760(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMontageEnded;                                     // 0x2768(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnablePin;                                        // 0x2769(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_276A[0x6];                                     // 0x276A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TWeakObjectPtr<class AActor>>            MoveIgnoreActors;                                  // 0x2770(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void OnAbilityStart();
	void OnAfterDashing(bool bAbilityEnd);
	void OnCharacterDashDistance(float InDistance);
	void OnClientReceivePinTaskReject();
	void OnHitMajorTarget(class AActor* Causer, class AActor* HitActor, struct FHitResult& Hit, bool bIsNetAuthority);
	void OnHitMinorTarget(class AActor* Causer, class AActor* HitActor, const struct FHitResult& Hit, bool bIsNetAuthority);
	void OnPinnedActorGameTagUpdate(const struct FGameplayTag& Tag, bool TagExists);
	void OnPinnedActorHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnPinnedActorLost();
	void OnPinnedTaskFinish(EDashStopReason Reason);
	void OnServerReceiveMajorTarget(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnServerWaitMajorTargetTimeout();
	void OnStartDashing();
	void OnStartPunching();
	void SetAbilityState(EAbilityState_104141 NewAbilityState);

	bool GetDashMajorTarget(class AActor** OutTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104141">();
	}
	static class UAbility_104141* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104141>();
	}
};
static_assert(alignof(UAbility_104141) == 0x000008, "Wrong alignment on UAbility_104141");
static_assert(sizeof(UAbility_104141) == 0x0027C0, "Wrong size on UAbility_104141");
static_assert(offsetof(UAbility_104141, HasDashDistance) == 0x002550, "Member 'UAbility_104141::HasDashDistance' has a wrong offset!");
static_assert(offsetof(UAbility_104141, AbilityState) == 0x002554, "Member 'UAbility_104141::AbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashSourceLocation) == 0x002558, "Member 'UAbility_104141::DashSourceLocation' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashTargetLocation) == 0x002570, "Member 'UAbility_104141::DashTargetLocation' has a wrong offset!");
static_assert(offsetof(UAbility_104141, bHasDashStageHit) == 0x002588, "Member 'UAbility_104141::bHasDashStageHit' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashMajorTarget) == 0x00258C, "Member 'UAbility_104141::DashMajorTarget' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashMinorTargets) == 0x002598, "Member 'UAbility_104141::DashMinorTargets' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashTraceComponent) == 0x0025A8, "Member 'UAbility_104141::DashTraceComponent' has a wrong offset!");
static_assert(offsetof(UAbility_104141, ApplyEffectToDashTargetsKey) == 0x0025B0, "Member 'UAbility_104141::ApplyEffectToDashTargetsKey' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashMajorTargetPredictionKey) == 0x002650, "Member 'UAbility_104141::DashMajorTargetPredictionKey' has a wrong offset!");
static_assert(offsetof(UAbility_104141, MyConfig) == 0x0026F8, "Member 'UAbility_104141::MyConfig' has a wrong offset!");
static_assert(offsetof(UAbility_104141, ApplyPinnedMotionTask) == 0x002700, "Member 'UAbility_104141::ApplyPinnedMotionTask' has a wrong offset!");
static_assert(offsetof(UAbility_104141, WaitMajorTargetTask) == 0x002758, "Member 'UAbility_104141::WaitMajorTargetTask' has a wrong offset!");
static_assert(offsetof(UAbility_104141, WaitServerConfirmTask) == 0x002760, "Member 'UAbility_104141::WaitServerConfirmTask' has a wrong offset!");
static_assert(offsetof(UAbility_104141, bMontageEnded) == 0x002768, "Member 'UAbility_104141::bMontageEnded' has a wrong offset!");
static_assert(offsetof(UAbility_104141, bEnablePin) == 0x002769, "Member 'UAbility_104141::bEnablePin' has a wrong offset!");
static_assert(offsetof(UAbility_104141, MoveIgnoreActors) == 0x002770, "Member 'UAbility_104141::MoveIgnoreActors' has a wrong offset!");

// Class Hero_1041.DashOnCharacterHitFilter_104141
// 0x0008 (0x0038 - 0x0030)
class UDashOnCharacterHitFilter_104141 final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DashOnCharacterHitFilter_104141">();
	}
	static class UDashOnCharacterHitFilter_104141* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDashOnCharacterHitFilter_104141>();
	}
};
static_assert(alignof(UDashOnCharacterHitFilter_104141) == 0x000008, "Wrong alignment on UDashOnCharacterHitFilter_104141");
static_assert(sizeof(UDashOnCharacterHitFilter_104141) == 0x000038, "Wrong size on UDashOnCharacterHitFilter_104141");

// Class Hero_1041.BuffAbility_10415101
// 0x0058 (0x1140 - 0x10E8)
class UBuffAbility_10415101 : public UMarvelEffectGameplayAbility
{
public:
	class UCurveFloat*                            SlowdownCurve;                                     // 0x10E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedBase;                                         // 0x10F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowDownTimeCNT;                                   // 0x10F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     SpeedAttribute;                                    // 0x10F8(0x0040)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTimeCurveValue;                                // 0x1138(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_113C[0x4];                                     // 0x113C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetChangeSlowDownValue(float DeltaTime);
	float GetCurveValue(float DeltaTime);
	void SetCurrentBuffSlowDownValue(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffAbility_10415101">();
	}
	static class UBuffAbility_10415101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffAbility_10415101>();
	}
};
static_assert(alignof(UBuffAbility_10415101) == 0x000008, "Wrong alignment on UBuffAbility_10415101");
static_assert(sizeof(UBuffAbility_10415101) == 0x001140, "Wrong size on UBuffAbility_10415101");
static_assert(offsetof(UBuffAbility_10415101, SlowdownCurve) == 0x0010E8, "Member 'UBuffAbility_10415101::SlowdownCurve' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10415101, SpeedBase) == 0x0010F0, "Member 'UBuffAbility_10415101::SpeedBase' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10415101, SlowDownTimeCNT) == 0x0010F4, "Member 'UBuffAbility_10415101::SlowDownTimeCNT' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10415101, SpeedAttribute) == 0x0010F8, "Member 'UBuffAbility_10415101::SpeedAttribute' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10415101, LastTimeCurveValue) == 0x001138, "Member 'UBuffAbility_10415101::LastTimeCurveValue' has a wrong offset!");

// Class Hero_1041.TraceComponent_10415101
// 0x0000 (0x16B0 - 0x16B0)
class UTraceComponent_10415101 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10415101">();
	}
	static class UTraceComponent_10415101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10415101>();
	}
};
static_assert(alignof(UTraceComponent_10415101) == 0x000010, "Wrong alignment on UTraceComponent_10415101");
static_assert(sizeof(UTraceComponent_10415101) == 0x0016B0, "Wrong size on UTraceComponent_10415101");

// Class Hero_1041.Cue_Projectile_Loop_10415101
// 0x0018 (0x0D78 - 0x0D60)
class ACue_Projectile_Loop_10415101 final : public AMarvelCueNotify_Projectile
{
public:
	class FName                                   SwitchParamName;                                   // 0x0D60(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6C[0x4];                                      // 0x0D6C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      TrajectoryNiagara;                                 // 0x0D70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10415101">();
	}
	static class ACue_Projectile_Loop_10415101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10415101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10415101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10415101");
static_assert(sizeof(ACue_Projectile_Loop_10415101) == 0x000D78, "Wrong size on ACue_Projectile_Loop_10415101");
static_assert(offsetof(ACue_Projectile_Loop_10415101, SwitchParamName) == 0x000D60, "Member 'ACue_Projectile_Loop_10415101::SwitchParamName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10415101, TrajectoryNiagara) == 0x000D70, "Member 'ACue_Projectile_Loop_10415101::TrajectoryNiagara' has a wrong offset!");

// Class Hero_1041.MarvelGameplayEffectDamage_10416101
// 0x0000 (0x16C8 - 0x16C8)
class UMarvelGameplayEffectDamage_10416101 final : public UMarvelGameplayEffectDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelGameplayEffectDamage_10416101">();
	}
	static class UMarvelGameplayEffectDamage_10416101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelGameplayEffectDamage_10416101>();
	}
};
static_assert(alignof(UMarvelGameplayEffectDamage_10416101) == 0x000008, "Wrong alignment on UMarvelGameplayEffectDamage_10416101");
static_assert(sizeof(UMarvelGameplayEffectDamage_10416101) == 0x0016C8, "Wrong size on UMarvelGameplayEffectDamage_10416101");

// Class Hero_1041.Ability_104161_Log
// 0x0030 (0x1118 - 0x10E8)
class UAbility_104161_Log final : public UMarvelEffectGameplayAbility
{
public:
	int32                                         ReleaseCount;                                      // 0x10E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10EC[0x4];                                     // 0x10EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_WaitAbilityActivate*       ActiveTask;                                        // 0x10F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentEnergy;                                     // 0x10F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10FC[0x4];                                     // 0x10FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PreviousEnergyRecord;                              // 0x1100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   SourceActor;                                       // 0x1110(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AccumulateCount(class UGameplayAbility* ActivatedAbility);
	void BattleLog();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104161_Log">();
	}
	static class UAbility_104161_Log* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104161_Log>();
	}
};
static_assert(alignof(UAbility_104161_Log) == 0x000008, "Wrong alignment on UAbility_104161_Log");
static_assert(sizeof(UAbility_104161_Log) == 0x001118, "Wrong size on UAbility_104161_Log");
static_assert(offsetof(UAbility_104161_Log, ReleaseCount) == 0x0010E8, "Member 'UAbility_104161_Log::ReleaseCount' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Log, ActiveTask) == 0x0010F0, "Member 'UAbility_104161_Log::ActiveTask' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Log, CurrentEnergy) == 0x0010F8, "Member 'UAbility_104161_Log::CurrentEnergy' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Log, PreviousEnergyRecord) == 0x001100, "Member 'UAbility_104161_Log::PreviousEnergyRecord' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Log, SourceActor) == 0x001110, "Member 'UAbility_104161_Log::SourceActor' has a wrong offset!");

// Class Hero_1041.Ability_104161_Delay_CheckKill
// 0x0028 (0x1110 - 0x10E8)
class UAbility_104161_Delay_CheckKill final : public UMarvelEffectGameplayAbility
{
public:
	class AActor*                                 TargetCheckActor;                                  // 0x10E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   SourceActor;                                       // 0x10F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104161*                         Config;                                            // 0x10F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedCheck;                                        // 0x1100(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1101[0xF];                                     // 0x1101(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ApplySlayDamageToTarget(float Value, class AMarvelBaseCharacter* Source, class AActor* Target, bool bIgnoreDamagePercent, class UMarvelAgentTraceComponent* TraceSource);
	static void CheckTargetStatusAfterDamage(class AMarvelBaseCharacter* Source, class AActor* Target);

	void CheckIfCanKill();
	void OnSourceActorDeath(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnSummonedDeath(class AActor* InActor);
	void OnTargetActorDeath(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104161_Delay_CheckKill">();
	}
	static class UAbility_104161_Delay_CheckKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104161_Delay_CheckKill>();
	}
};
static_assert(alignof(UAbility_104161_Delay_CheckKill) == 0x000008, "Wrong alignment on UAbility_104161_Delay_CheckKill");
static_assert(sizeof(UAbility_104161_Delay_CheckKill) == 0x001110, "Wrong size on UAbility_104161_Delay_CheckKill");
static_assert(offsetof(UAbility_104161_Delay_CheckKill, TargetCheckActor) == 0x0010E8, "Member 'UAbility_104161_Delay_CheckKill::TargetCheckActor' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Delay_CheckKill, SourceActor) == 0x0010F0, "Member 'UAbility_104161_Delay_CheckKill::SourceActor' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Delay_CheckKill, Config) == 0x0010F8, "Member 'UAbility_104161_Delay_CheckKill::Config' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Delay_CheckKill, bNeedCheck) == 0x001100, "Member 'UAbility_104161_Delay_CheckKill::bNeedCheck' has a wrong offset!");

// Class Hero_1041.Config_104161
// 0x1118 (0x11B0 - 0x0098)
class UConfig_104161 : public UMarvelAbilityConfig
{
public:
	bool                                          bUsePhysicKnockUp;                                 // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhysicForceMove                       PhysicKnockUp;                                     // 0x00A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocityZ;                                      // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindowTime;                                        // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             GroundTraceContext;                                // 0x0100(0x0F30)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         HoverTime;                                         // 0x1030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckAngle;                                  // 0x1034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckDistance;                               // 0x1038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KRatio;                                            // 0x103C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EarlyCheckKillScopeID;                             // 0x1040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckEnemyEarlyKill;                              // 0x1044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1045[0x3];                                     // 0x1045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               SummonedCharacterTagRequirement;                   // 0x1048(0x0118)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            RefreshAudioIDMap;                                 // 0x1160(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104161">();
	}
	static class UConfig_104161* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104161>();
	}
};
static_assert(alignof(UConfig_104161) == 0x000010, "Wrong alignment on UConfig_104161");
static_assert(sizeof(UConfig_104161) == 0x0011B0, "Wrong size on UConfig_104161");
static_assert(offsetof(UConfig_104161, bUsePhysicKnockUp) == 0x000098, "Member 'UConfig_104161::bUsePhysicKnockUp' has a wrong offset!");
static_assert(offsetof(UConfig_104161, PhysicKnockUp) == 0x0000A0, "Member 'UConfig_104161::PhysicKnockUp' has a wrong offset!");
static_assert(offsetof(UConfig_104161, MaxAcceleration) == 0x0000F0, "Member 'UConfig_104161::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UConfig_104161, MaxVelocityZ) == 0x0000F4, "Member 'UConfig_104161::MaxVelocityZ' has a wrong offset!");
static_assert(offsetof(UConfig_104161, WindowTime) == 0x0000F8, "Member 'UConfig_104161::WindowTime' has a wrong offset!");
static_assert(offsetof(UConfig_104161, GroundTraceContext) == 0x000100, "Member 'UConfig_104161::GroundTraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_104161, HoverTime) == 0x001030, "Member 'UConfig_104161::HoverTime' has a wrong offset!");
static_assert(offsetof(UConfig_104161, GroundCheckAngle) == 0x001034, "Member 'UConfig_104161::GroundCheckAngle' has a wrong offset!");
static_assert(offsetof(UConfig_104161, GroundCheckDistance) == 0x001038, "Member 'UConfig_104161::GroundCheckDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104161, KRatio) == 0x00103C, "Member 'UConfig_104161::KRatio' has a wrong offset!");
static_assert(offsetof(UConfig_104161, EarlyCheckKillScopeID) == 0x001040, "Member 'UConfig_104161::EarlyCheckKillScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_104161, bCheckEnemyEarlyKill) == 0x001044, "Member 'UConfig_104161::bCheckEnemyEarlyKill' has a wrong offset!");
static_assert(offsetof(UConfig_104161, SummonedCharacterTagRequirement) == 0x001048, "Member 'UConfig_104161::SummonedCharacterTagRequirement' has a wrong offset!");
static_assert(offsetof(UConfig_104161, RefreshAudioIDMap) == 0x001160, "Member 'UConfig_104161::RefreshAudioIDMap' has a wrong offset!");

// Class Hero_1041.Ability_104161
// 0x03B8 (0x2908 - 0x2550)
class UAbility_104161 : public UMarvelGameplayAbility
{
public:
	bool                                          bInPhysicKnockUp;                                  // 0x2550(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2551[0x3];                                     // 0x2551(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedAcceleration;                                // 0x2554(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UPrimitiveComponent>> BehitComponents;                                   // 0x2558(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UConfig_104161*                         Config;                                            // 0x2568(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   AbilityOwner;                                      // 0x2570(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCharacterMovementComponent*      OwnerMovementComp;                                 // 0x2578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESmashDownState                               SmashState;                                        // 0x2580(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterWindowState;                                 // 0x2581(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmashDownBegin;                                   // 0x2582(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterHover;                                       // 0x2583(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2584[0x4];                                     // 0x2584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashDirection;                                     // 0x2588(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimLocation;                                       // 0x25A0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedGravity;                                     // 0x25B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedAirControl;                                  // 0x25BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandleGravity;                                // 0x25C0(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalScopeLocation;                                // 0x25D8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalScopeNormal;                                  // 0x25F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         RPCKey;                                            // 0x2608(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         LaunchKey;                                         // 0x26A8(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         ResetKey;                                          // 0x2748(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x27E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F0[0x18];                                    // 0x27F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        LastTimeApplyRefreshBuffFrame;                     // 0x2808(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAOParamChanged;                                  // 0x2810(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2820[0x8];                                     // 0x2820(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashImpactPoint;                                   // 0x2828(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<TWeakObjectPtr<class AActor>>            CheckEarlyKillActorSet;                            // 0x2840(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bHasPreDeathCharacter;                             // 0x2890(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2891[0x3];                                     // 0x2891(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ContinuousKillCount;                               // 0x2894(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ContinuousKillCount_Actual;                        // 0x2898(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ContinuousRefreshCount;                            // 0x289C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A0[0x68];                                    // 0x28A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckIfHaveEarlyKillActor();
	struct FVector GetJumpInitialDirection(bool bIsUp);
	struct FVector GetSelectAimDirection(struct FMarvelAbilityTargetFilter& InFilter);
	void JumpStart();
	void K2_BeginHover();
	void K2_EnterWindowState();
	void K2_OnLaunchCharacterCallback();
	void K2_UpdateValidHitForUI(bool bValidHit);
	void LaunchUpEnded();
	void OnEarlyCheckKillCharacterPreDeath(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnRep_ContinuousKillCount();
	void OnRep_ContinuousKillCount_Actual();
	void OnRep_ContinuousRefreshCount();
	void OnServerReceiveLaunchVelocity(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnSlayCountDownTagUpdated(const struct FGameplayTag& TagUpdated, bool bTagExists);
	void ResetGravity();
	void SetHoverGravityScale(bool bSet);
	void TryEnterHover(float DeltaTime, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void TryEnterWindow(float DeltaTime, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void UpdateCheckEarlyKillActors(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104161">();
	}
	static class UAbility_104161* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104161>();
	}
};
static_assert(alignof(UAbility_104161) == 0x000008, "Wrong alignment on UAbility_104161");
static_assert(sizeof(UAbility_104161) == 0x002908, "Wrong size on UAbility_104161");
static_assert(offsetof(UAbility_104161, bInPhysicKnockUp) == 0x002550, "Member 'UAbility_104161::bInPhysicKnockUp' has a wrong offset!");
static_assert(offsetof(UAbility_104161, CachedAcceleration) == 0x002554, "Member 'UAbility_104161::CachedAcceleration' has a wrong offset!");
static_assert(offsetof(UAbility_104161, BehitComponents) == 0x002558, "Member 'UAbility_104161::BehitComponents' has a wrong offset!");
static_assert(offsetof(UAbility_104161, Config) == 0x002568, "Member 'UAbility_104161::Config' has a wrong offset!");
static_assert(offsetof(UAbility_104161, AbilityOwner) == 0x002570, "Member 'UAbility_104161::AbilityOwner' has a wrong offset!");
static_assert(offsetof(UAbility_104161, OwnerMovementComp) == 0x002578, "Member 'UAbility_104161::OwnerMovementComp' has a wrong offset!");
static_assert(offsetof(UAbility_104161, SmashState) == 0x002580, "Member 'UAbility_104161::SmashState' has a wrong offset!");
static_assert(offsetof(UAbility_104161, bEnterWindowState) == 0x002581, "Member 'UAbility_104161::bEnterWindowState' has a wrong offset!");
static_assert(offsetof(UAbility_104161, bSmashDownBegin) == 0x002582, "Member 'UAbility_104161::bSmashDownBegin' has a wrong offset!");
static_assert(offsetof(UAbility_104161, bEnterHover) == 0x002583, "Member 'UAbility_104161::bEnterHover' has a wrong offset!");
static_assert(offsetof(UAbility_104161, DashDirection) == 0x002588, "Member 'UAbility_104161::DashDirection' has a wrong offset!");
static_assert(offsetof(UAbility_104161, AimLocation) == 0x0025A0, "Member 'UAbility_104161::AimLocation' has a wrong offset!");
static_assert(offsetof(UAbility_104161, CachedGravity) == 0x0025B8, "Member 'UAbility_104161::CachedGravity' has a wrong offset!");
static_assert(offsetof(UAbility_104161, CachedAirControl) == 0x0025BC, "Member 'UAbility_104161::CachedAirControl' has a wrong offset!");
static_assert(offsetof(UAbility_104161, TimerHandleGravity) == 0x0025C0, "Member 'UAbility_104161::TimerHandleGravity' has a wrong offset!");
static_assert(offsetof(UAbility_104161, FinalScopeLocation) == 0x0025D8, "Member 'UAbility_104161::FinalScopeLocation' has a wrong offset!");
static_assert(offsetof(UAbility_104161, FinalScopeNormal) == 0x0025F0, "Member 'UAbility_104161::FinalScopeNormal' has a wrong offset!");
static_assert(offsetof(UAbility_104161, RPCKey) == 0x002608, "Member 'UAbility_104161::RPCKey' has a wrong offset!");
static_assert(offsetof(UAbility_104161, LaunchKey) == 0x0026A8, "Member 'UAbility_104161::LaunchKey' has a wrong offset!");
static_assert(offsetof(UAbility_104161, ResetKey) == 0x002748, "Member 'UAbility_104161::ResetKey' has a wrong offset!");
static_assert(offsetof(UAbility_104161, AbilitySystemComponent) == 0x0027E8, "Member 'UAbility_104161::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(UAbility_104161, LastTimeApplyRefreshBuffFrame) == 0x002808, "Member 'UAbility_104161::LastTimeApplyRefreshBuffFrame' has a wrong offset!");
static_assert(offsetof(UAbility_104161, OnAOParamChanged) == 0x002810, "Member 'UAbility_104161::OnAOParamChanged' has a wrong offset!");
static_assert(offsetof(UAbility_104161, DashImpactPoint) == 0x002828, "Member 'UAbility_104161::DashImpactPoint' has a wrong offset!");
static_assert(offsetof(UAbility_104161, CheckEarlyKillActorSet) == 0x002840, "Member 'UAbility_104161::CheckEarlyKillActorSet' has a wrong offset!");
static_assert(offsetof(UAbility_104161, bHasPreDeathCharacter) == 0x002890, "Member 'UAbility_104161::bHasPreDeathCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_104161, ContinuousKillCount) == 0x002894, "Member 'UAbility_104161::ContinuousKillCount' has a wrong offset!");
static_assert(offsetof(UAbility_104161, ContinuousKillCount_Actual) == 0x002898, "Member 'UAbility_104161::ContinuousKillCount_Actual' has a wrong offset!");
static_assert(offsetof(UAbility_104161, ContinuousRefreshCount) == 0x00289C, "Member 'UAbility_104161::ContinuousRefreshCount' has a wrong offset!");

// Class Hero_1041.EffectiveComponent_10416101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10416101 : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10416101">();
	}
	static class UEffectiveComponent_10416101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10416101>();
	}
};
static_assert(alignof(UEffectiveComponent_10416101) == 0x000010, "Wrong alignment on UEffectiveComponent_10416101");
static_assert(sizeof(UEffectiveComponent_10416101) == 0x001C00, "Wrong size on UEffectiveComponent_10416101");

// Class Hero_1041.EffectiveComponent_10416102
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10416102 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10416102">();
	}
	static class UEffectiveComponent_10416102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10416102>();
	}
};
static_assert(alignof(UEffectiveComponent_10416102) == 0x000010, "Wrong alignment on UEffectiveComponent_10416102");
static_assert(sizeof(UEffectiveComponent_10416102) == 0x001C00, "Wrong size on UEffectiveComponent_10416102");

// Class Hero_1041.Cue_Ability_Loop_10416102
// 0x0FD0 (0x1DD0 - 0x0E00)
class ACue_Ability_Loop_10416102 final : public AMarvelCueNotify_Ability
{
public:
	float                                         MaxDistToSmooth;                                   // 0x0E00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpMaxSpeed;                                      // 0x0E04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpMinSpeed;                                      // 0x0E08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateRate;                                        // 0x0E0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFindGroundParam                       GroundParam;                                       // 0x0E10(0x0F70)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAbility_104161*                        OwnerAbility;                                      // 0x1D80(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104161*                         AbilityConfig;                                     // 0x1D88(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x1D90(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastFXLocation;                                    // 0x1D98(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LastFXRotation;                                    // 0x1DB0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      FieldNiagara;                                      // 0x1DC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10416102">();
	}
	static class ACue_Ability_Loop_10416102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10416102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10416102) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10416102");
static_assert(sizeof(ACue_Ability_Loop_10416102) == 0x001DD0, "Wrong size on ACue_Ability_Loop_10416102");
static_assert(offsetof(ACue_Ability_Loop_10416102, MaxDistToSmooth) == 0x000E00, "Member 'ACue_Ability_Loop_10416102::MaxDistToSmooth' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, LerpMaxSpeed) == 0x000E04, "Member 'ACue_Ability_Loop_10416102::LerpMaxSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, LerpMinSpeed) == 0x000E08, "Member 'ACue_Ability_Loop_10416102::LerpMinSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, UpdateRate) == 0x000E0C, "Member 'ACue_Ability_Loop_10416102::UpdateRate' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, GroundParam) == 0x000E10, "Member 'ACue_Ability_Loop_10416102::GroundParam' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, OwnerAbility) == 0x001D80, "Member 'ACue_Ability_Loop_10416102::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, AbilityConfig) == 0x001D88, "Member 'ACue_Ability_Loop_10416102::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, OwnerChar) == 0x001D90, "Member 'ACue_Ability_Loop_10416102::OwnerChar' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, LastFXLocation) == 0x001D98, "Member 'ACue_Ability_Loop_10416102::LastFXLocation' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, LastFXRotation) == 0x001DB0, "Member 'ACue_Ability_Loop_10416102::LastFXRotation' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, FieldNiagara) == 0x001DC8, "Member 'ACue_Ability_Loop_10416102::FieldNiagara' has a wrong offset!");

// Class Hero_1041.Cue_Scope_Start_10416101
// 0x0018 (0x0380 - 0x0368)
class UCue_Scope_Start_10416101 final : public UMarvelCueNotify_Base
{
public:
	struct FVector                                ImpactNormal;                                      // 0x0368(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Start_10416101">();
	}
	static class UCue_Scope_Start_10416101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Scope_Start_10416101>();
	}
};
static_assert(alignof(UCue_Scope_Start_10416101) == 0x000008, "Wrong alignment on UCue_Scope_Start_10416101");
static_assert(sizeof(UCue_Scope_Start_10416101) == 0x000380, "Wrong size on UCue_Scope_Start_10416101");
static_assert(offsetof(UCue_Scope_Start_10416101, ImpactNormal) == 0x000368, "Member 'UCue_Scope_Start_10416101::ImpactNormal' has a wrong offset!");

// Class Hero_1041.EpicMomentAction_1041
// 0x0010 (0x0130 - 0x0120)
class UEpicMomentAction_1041 : public UEpicMomentBaseAction
{
public:
	struct FEpicMomentNodeInfo                    QKillConfig;                                       // 0x0120(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         QAbilityID;                                        // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1041">();
	}
	static class UEpicMomentAction_1041* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1041>();
	}
};
static_assert(alignof(UEpicMomentAction_1041) == 0x000008, "Wrong alignment on UEpicMomentAction_1041");
static_assert(sizeof(UEpicMomentAction_1041) == 0x000130, "Wrong size on UEpicMomentAction_1041");
static_assert(offsetof(UEpicMomentAction_1041, QKillConfig) == 0x000120, "Member 'UEpicMomentAction_1041::QKillConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1041, QAbilityID) == 0x00012C, "Member 'UEpicMomentAction_1041::QAbilityID' has a wrong offset!");

// Class Hero_1041.WinterSoldierAnimInstance
// 0x0040 (0x0940 - 0x0900)
class UWinterSoldierAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bTestUltimate;                                     // 0x0900(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_901[0x3];                                      // 0x0901(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimReloadConstraintCurveName;                     // 0x0904(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimReloadConstraintBlendAlpha;                    // 0x0910(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReloadAbilityTag;                                  // 0x0914(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimReloadConstraintCurveValue;                    // 0x0920(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseUltimateAOParam;                         // 0x0924(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_925[0x3];                                      // 0x0925(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UltimateAOPitch;                                   // 0x0928(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UltimateAOYaw;                                     // 0x092C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AWinterSoldierCharacter*                WinterSoldierCharacter;                            // 0x0930(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_938[0x8];                                      // 0x0938(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivateAbility(int32 InAbilityId);
	void OnEndAbility(int32 InAbilityId);
	void OnUltimateAOParamChanged(float InUltimateAOPitch, float InUltimateAOYaw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinterSoldierAnimInstance">();
	}
	static class UWinterSoldierAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinterSoldierAnimInstance>();
	}
};
static_assert(alignof(UWinterSoldierAnimInstance) == 0x000010, "Wrong alignment on UWinterSoldierAnimInstance");
static_assert(sizeof(UWinterSoldierAnimInstance) == 0x000940, "Wrong size on UWinterSoldierAnimInstance");
static_assert(offsetof(UWinterSoldierAnimInstance, bTestUltimate) == 0x000900, "Member 'UWinterSoldierAnimInstance::bTestUltimate' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, AnimReloadConstraintCurveName) == 0x000904, "Member 'UWinterSoldierAnimInstance::AnimReloadConstraintCurveName' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, AnimReloadConstraintBlendAlpha) == 0x000910, "Member 'UWinterSoldierAnimInstance::AnimReloadConstraintBlendAlpha' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, ReloadAbilityTag) == 0x000914, "Member 'UWinterSoldierAnimInstance::ReloadAbilityTag' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, AnimReloadConstraintCurveValue) == 0x000920, "Member 'UWinterSoldierAnimInstance::AnimReloadConstraintCurveValue' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, bShouldUseUltimateAOParam) == 0x000924, "Member 'UWinterSoldierAnimInstance::bShouldUseUltimateAOParam' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, UltimateAOPitch) == 0x000928, "Member 'UWinterSoldierAnimInstance::UltimateAOPitch' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, UltimateAOYaw) == 0x00092C, "Member 'UWinterSoldierAnimInstance::UltimateAOYaw' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, WinterSoldierCharacter) == 0x000930, "Member 'UWinterSoldierAnimInstance::WinterSoldierCharacter' has a wrong offset!");

// Class Hero_1041.WinterSoldierCharacter
// 0x0010 (0x17D0 - 0x17C0)
class AWinterSoldierCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bQuickReloading;                                   // 0x17B8(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B9[0x7];                                     // 0x17B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWinterSoldierMoveLogicBaseComponent*   WinterSoldierMoveLogic;                            // 0x17C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17C8[0x8];                                     // 0x17C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetQuickReloadingState(bool bInState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinterSoldierCharacter">();
	}
	static class AWinterSoldierCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWinterSoldierCharacter>();
	}
};
static_assert(alignof(AWinterSoldierCharacter) == 0x000010, "Wrong alignment on AWinterSoldierCharacter");
static_assert(sizeof(AWinterSoldierCharacter) == 0x0017D0, "Wrong size on AWinterSoldierCharacter");
static_assert(offsetof(AWinterSoldierCharacter, bQuickReloading) == 0x0017B8, "Member 'AWinterSoldierCharacter::bQuickReloading' has a wrong offset!");
static_assert(offsetof(AWinterSoldierCharacter, WinterSoldierMoveLogic) == 0x0017C0, "Member 'AWinterSoldierCharacter::WinterSoldierMoveLogic' has a wrong offset!");

// Class Hero_1041.WinterSoldierChildActor
// 0x0178 (0x0BB8 - 0x0A40)
class AWinterSoldierChildActor final : public AMarvelCharacterChildActor
{
public:
	TSet<int32>                                   OriginArmMaterialSet;                              // 0x0A40(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<int32>                                   UltimateArmMaterialSet;                            // 0x0A90(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<class FName>                             OriginArmMaterialSlotNameSet;                      // 0x0AE0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<class FName>                             UltimateArmMaterialSlotNameSet;                    // 0x0B30(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   OriginArmMaterialSlotNameSuffix;                   // 0x0B80(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UltimateArmMaterialSlotNameSuffix;                 // 0x0B8C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           UpdateArmMaterialTag;                              // 0x0B98(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA4[0x14];                                     // 0x0BA4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);
	void UpdateArmMaterial(bool bUltimate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinterSoldierChildActor">();
	}
	static class AWinterSoldierChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWinterSoldierChildActor>();
	}
};
static_assert(alignof(AWinterSoldierChildActor) == 0x000008, "Wrong alignment on AWinterSoldierChildActor");
static_assert(sizeof(AWinterSoldierChildActor) == 0x000BB8, "Wrong size on AWinterSoldierChildActor");
static_assert(offsetof(AWinterSoldierChildActor, OriginArmMaterialSet) == 0x000A40, "Member 'AWinterSoldierChildActor::OriginArmMaterialSet' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, UltimateArmMaterialSet) == 0x000A90, "Member 'AWinterSoldierChildActor::UltimateArmMaterialSet' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, OriginArmMaterialSlotNameSet) == 0x000AE0, "Member 'AWinterSoldierChildActor::OriginArmMaterialSlotNameSet' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, UltimateArmMaterialSlotNameSet) == 0x000B30, "Member 'AWinterSoldierChildActor::UltimateArmMaterialSlotNameSet' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, OriginArmMaterialSlotNameSuffix) == 0x000B80, "Member 'AWinterSoldierChildActor::OriginArmMaterialSlotNameSuffix' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, UltimateArmMaterialSlotNameSuffix) == 0x000B8C, "Member 'AWinterSoldierChildActor::UltimateArmMaterialSlotNameSuffix' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, UpdateArmMaterialTag) == 0x000B98, "Member 'AWinterSoldierChildActor::UpdateArmMaterialTag' has a wrong offset!");

// Class Hero_1041.WinterSoldierMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UWinterSoldierMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinterSoldierMoveLogicBaseComponent">();
	}
	static class UWinterSoldierMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinterSoldierMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UWinterSoldierMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UWinterSoldierMoveLogicBaseComponent");
static_assert(sizeof(UWinterSoldierMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UWinterSoldierMoveLogicBaseComponent");

// Class Hero_1041.WinterSoldierMovementComponent
// 0x0010 (0x1B00 - 0x1AF0)
class UWinterSoldierMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	class UConfig_104161*                         Config_104161;                                     // 0x1AF0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastSkipSmoothCorrectionTime;                      // 0x1AF8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AFC[0x4];                                     // 0x1AFC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinterSoldierMovementComponent">();
	}
	static class UWinterSoldierMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinterSoldierMovementComponent>();
	}
};
static_assert(alignof(UWinterSoldierMovementComponent) == 0x000010, "Wrong alignment on UWinterSoldierMovementComponent");
static_assert(sizeof(UWinterSoldierMovementComponent) == 0x001B00, "Wrong size on UWinterSoldierMovementComponent");
static_assert(offsetof(UWinterSoldierMovementComponent, Config_104161) == 0x001AF0, "Member 'UWinterSoldierMovementComponent::Config_104161' has a wrong offset!");
static_assert(offsetof(UWinterSoldierMovementComponent, LastSkipSmoothCorrectionTime) == 0x001AF8, "Member 'UWinterSoldierMovementComponent::LastSkipSmoothCorrectionTime' has a wrong offset!");

}

