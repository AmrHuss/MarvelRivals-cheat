#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1045

#include "Basic.hpp"

#include "Hero_1045_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DeclarativeUnreal_structs.hpp"


namespace SDK
{

// Class Hero_1045.Config_104521
// 0x00B0 (0x0148 - 0x0098)
class UConfig_104521 final : public UMarvelAbilityConfig
{
public:
	TArray<int32>                                 AbilityIdConfig;                                   // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         RecoveredEnergy;                                   // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecoveredEnergyAbilityID;                          // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTeamMember                            RecoveredEnergyHitEnemyType;                       // 0x00B0(0x0007)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          NedHeadshotToTrigger;                              // 0x00B7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BerserkSummonTriggersCues;                         // 0x00B8(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 BerserkBuffIDs;                                    // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 BerserkBuffSummonIDs;                              // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamMember                            BerserkHitEnemyType;                               // 0x0140(0x0007)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_147[0x1];                                      // 0x0147(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104521">();
	}
	static class UConfig_104521* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104521>();
	}
};
static_assert(alignof(UConfig_104521) == 0x000008, "Wrong alignment on UConfig_104521");
static_assert(sizeof(UConfig_104521) == 0x000148, "Wrong size on UConfig_104521");
static_assert(offsetof(UConfig_104521, AbilityIdConfig) == 0x000098, "Member 'UConfig_104521::AbilityIdConfig' has a wrong offset!");
static_assert(offsetof(UConfig_104521, RecoveredEnergy) == 0x0000A8, "Member 'UConfig_104521::RecoveredEnergy' has a wrong offset!");
static_assert(offsetof(UConfig_104521, RecoveredEnergyAbilityID) == 0x0000AC, "Member 'UConfig_104521::RecoveredEnergyAbilityID' has a wrong offset!");
static_assert(offsetof(UConfig_104521, RecoveredEnergyHitEnemyType) == 0x0000B0, "Member 'UConfig_104521::RecoveredEnergyHitEnemyType' has a wrong offset!");
static_assert(offsetof(UConfig_104521, NedHeadshotToTrigger) == 0x0000B7, "Member 'UConfig_104521::NedHeadshotToTrigger' has a wrong offset!");
static_assert(offsetof(UConfig_104521, BerserkSummonTriggersCues) == 0x0000B8, "Member 'UConfig_104521::BerserkSummonTriggersCues' has a wrong offset!");
static_assert(offsetof(UConfig_104521, BerserkBuffIDs) == 0x000120, "Member 'UConfig_104521::BerserkBuffIDs' has a wrong offset!");
static_assert(offsetof(UConfig_104521, BerserkBuffSummonIDs) == 0x000130, "Member 'UConfig_104521::BerserkBuffSummonIDs' has a wrong offset!");
static_assert(offsetof(UConfig_104521, BerserkHitEnemyType) == 0x000140, "Member 'UConfig_104521::BerserkHitEnemyType' has a wrong offset!");

// Class Hero_1045.Ability_104521
// 0x0008 (0x2560 - 0x2558)
class UAbility_104521 : public UAbility_108
{
public:
	uint8                                         Pad_2558[0x8];                                     // 0x2558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPostApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104521">();
	}
	static class UAbility_104521* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104521>();
	}
};
static_assert(alignof(UAbility_104521) == 0x000008, "Wrong alignment on UAbility_104521");
static_assert(sizeof(UAbility_104521) == 0x002560, "Wrong size on UAbility_104521");

// Class Hero_1045.TraceComponent_10453102
// 0x0000 (0x16B0 - 0x16B0)
class UTraceComponent_10453102 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10453102">();
	}
	static class UTraceComponent_10453102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10453102>();
	}
};
static_assert(alignof(UTraceComponent_10453102) == 0x000010, "Wrong alignment on UTraceComponent_10453102");
static_assert(sizeof(UTraceComponent_10453102) == 0x0016B0, "Wrong size on UTraceComponent_10453102");

// Class Hero_1045.Config_104531
// 0x0098 (0x0130 - 0x0098)
class UConfig_104531 final : public UMarvelAbilityConfig
{
public:
	bool                                          IsTriggeredOnActivation;                           // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTriggerOnHit;                                    // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTeamMember                            BerserkHitEnemyType;                               // 0x009A(0x0007)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BerserkSummonInstigatorCues;                       // 0x00A8(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 BerserkBuffIDs;                                    // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 BerserkBuffSummonIDs;                              // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104531">();
	}
	static class UConfig_104531* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104531>();
	}
};
static_assert(alignof(UConfig_104531) == 0x000008, "Wrong alignment on UConfig_104531");
static_assert(sizeof(UConfig_104531) == 0x000130, "Wrong size on UConfig_104531");
static_assert(offsetof(UConfig_104531, IsTriggeredOnActivation) == 0x000098, "Member 'UConfig_104531::IsTriggeredOnActivation' has a wrong offset!");
static_assert(offsetof(UConfig_104531, IsTriggerOnHit) == 0x000099, "Member 'UConfig_104531::IsTriggerOnHit' has a wrong offset!");
static_assert(offsetof(UConfig_104531, BerserkHitEnemyType) == 0x00009A, "Member 'UConfig_104531::BerserkHitEnemyType' has a wrong offset!");
static_assert(offsetof(UConfig_104531, BerserkSummonInstigatorCues) == 0x0000A8, "Member 'UConfig_104531::BerserkSummonInstigatorCues' has a wrong offset!");
static_assert(offsetof(UConfig_104531, BerserkBuffIDs) == 0x000110, "Member 'UConfig_104531::BerserkBuffIDs' has a wrong offset!");
static_assert(offsetof(UConfig_104531, BerserkBuffSummonIDs) == 0x000120, "Member 'UConfig_104531::BerserkBuffSummonIDs' has a wrong offset!");

// Class Hero_1045.Ability_104531
// 0x0008 (0x2560 - 0x2558)
class UAbility_104531 : public UAbility_108
{
public:
	uint8                                         Pad_2558[0x8];                                     // 0x2558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPostApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104531">();
	}
	static class UAbility_104531* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104531>();
	}
};
static_assert(alignof(UAbility_104531) == 0x000008, "Wrong alignment on UAbility_104531");
static_assert(sizeof(UAbility_104531) == 0x002560, "Wrong size on UAbility_104531");

// Class Hero_1045.Config_104543
// 0x00E0 (0x1180 - 0x10A0)
class UConfig_104543 final : public UConfig_AeroBase
{
public:
	struct FGameplayTagContainer                  FlyAbilityTag;                                     // 0x1098(0x0068)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GlideAbilityTag;                                   // 0x1100(0x000C)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110C[0x4];                                     // 0x110C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MoveAbilityTag;                                    // 0x1110(0x0068)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bConstantTurnOnGlide;                              // 0x1178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1179[0x7];                                     // 0x1179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104543">();
	}
	static class UConfig_104543* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104543>();
	}
};
static_assert(alignof(UConfig_104543) == 0x000010, "Wrong alignment on UConfig_104543");
static_assert(sizeof(UConfig_104543) == 0x001180, "Wrong size on UConfig_104543");
static_assert(offsetof(UConfig_104543, FlyAbilityTag) == 0x001098, "Member 'UConfig_104543::FlyAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_104543, GlideAbilityTag) == 0x001100, "Member 'UConfig_104543::GlideAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_104543, MoveAbilityTag) == 0x001110, "Member 'UConfig_104543::MoveAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_104543, bConstantTurnOnGlide) == 0x001178, "Member 'UConfig_104543::bConstantTurnOnGlide' has a wrong offset!");

// Class Hero_1045.Ability_104543
// 0x0060 (0x5AF0 - 0x5A90)
class UAbility_104543 : public UMarvelAeroBaseAbility
{
public:
	uint8                                         Pad_5A90[0x2C];                                    // 0x5A90(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FlyAbilityID;                                      // 0x5ABC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DescendAbilityID;                                  // 0x5AC0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanGlide;                                         // 0x5AC4(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlockMove;                                      // 0x5AC5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AC6[0x2];                                     // 0x5AC6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_104543*                         Config_104543;                                     // 0x5AC8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AD0[0x20];                                    // 0x5AD0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameTagUpdate(const struct FGameplayTag& Tag, bool TagExists);
	void OnMoveModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void SetCanGlide(bool bNewCanGlide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104543">();
	}
	static class UAbility_104543* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104543>();
	}
};
static_assert(alignof(UAbility_104543) == 0x000010, "Wrong alignment on UAbility_104543");
static_assert(sizeof(UAbility_104543) == 0x005AF0, "Wrong size on UAbility_104543");
static_assert(offsetof(UAbility_104543, FlyAbilityID) == 0x005ABC, "Member 'UAbility_104543::FlyAbilityID' has a wrong offset!");
static_assert(offsetof(UAbility_104543, DescendAbilityID) == 0x005AC0, "Member 'UAbility_104543::DescendAbilityID' has a wrong offset!");
static_assert(offsetof(UAbility_104543, bCanGlide) == 0x005AC4, "Member 'UAbility_104543::bCanGlide' has a wrong offset!");
static_assert(offsetof(UAbility_104543, bIsBlockMove) == 0x005AC5, "Member 'UAbility_104543::bIsBlockMove' has a wrong offset!");
static_assert(offsetof(UAbility_104543, Config_104543) == 0x005AC8, "Member 'UAbility_104543::Config_104543' has a wrong offset!");

// Class Hero_1045.Ability_104551
// 0x0000 (0x2558 - 0x2558)
class UAbility_104551 : public UAbility_108
{
public:
	void SetMaxSkillEnergyBaseValue(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104551">();
	}
	static class UAbility_104551* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104551>();
	}
};
static_assert(alignof(UAbility_104551) == 0x000008, "Wrong alignment on UAbility_104551");
static_assert(sizeof(UAbility_104551) == 0x002558, "Wrong size on UAbility_104551");

// Class Hero_1045.Summoned_10455101
// 0x01B0 (0x0FD0 - 0x0E20)
class ASummoned_10455101 : public ASummonedCharacterBase
{
public:
	FMulticastInlineDelegateProperty_             OnOctopusBusyStateChanged;                         // 0x0E20(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsOctopusBusy;                                    // 0x0E30(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E31[0x7];                                      // 0x0E31(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEquipComponent*                        EquipComponent;                                    // 0x0E38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipID;                                           // 0x0E40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E44[0x4];                                      // 0x0E44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentLookDir;                                    // 0x0E48(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             TransformAtSpawn;                                  // 0x0E60(0x0060)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastBusyTime;                                      // 0x0EC0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDuration;                                      // 0x0EC4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerUID;                                         // 0x0EC8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ECC[0x4];                                      // 0x0ECC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    CurrentTargetComponent;                            // 0x0ED0(0x0008)(BlueprintVisible, ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentTargetLocation;                             // 0x0ED8(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOctopusState                                 CurrentOctopusState;                               // 0x0EF0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOctopusState                                 LastOctopusState;                                  // 0x0EF1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF2[0x6];                                      // 0x0EF2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ValidPosRelativeLocation;                          // 0x0EF8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshHorizontalAngleVelocity;                       // 0x0F10(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalRotateInterpSpeed;                       // 0x0F14(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOUpdateVelocity;                                  // 0x0F18(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateDegreeThreshold;                             // 0x0F1C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTraceTime;                                    // 0x0F20(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F24[0x4];                                      // 0x0F24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BusyStateTag;                                      // 0x0F28(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BusyWindowTime;                                    // 0x0F38(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F3C[0x4];                                      // 0x0F3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 OctopusBuffs;                                      // 0x0F40(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AttackManageAbilityID;                             // 0x0F50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalAttackAbilityID;                             // 0x0F54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnhancedAttackAbilityID;                           // 0x0F58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x0F5C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5D[0x3];                                      // 0x0F5D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USpringArmComponent*                    SpringArmComponent;                                // 0x0F60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       CameraComponent;                                   // 0x0F68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CachedUpVector;                                    // 0x0F70(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreesBetweenMeshForwardAndLookDir;               // 0x0F88(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8C[0x4];                                      // 0x0F8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x0F90(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_FA0[0x30];                                     // 0x0FA0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ANamorCharacter* GetNamor();
	float GetPitchByLookVector(const struct FVector& LookVector);
	float GetRemainTime();
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);
	void OnRep_bIsOctopusBusy();
	void OnRep_CurrentLookDir();
	void OnRep_OnCurrentTargetChanged();
	void OnRep_OnOctopusStateChanged();
	void OnTagAdded(class FName TagName);
	void OnTakeDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void SetCachedUpVector(const struct FVector& InNormalVector);
	void SetCurrentOctopusState(EOctopusState NewOctopusState);
	void SetCurrentTargetComponentAndUpdateLookDir(class UPrimitiveComponent* NewTargetComponent);
	void SetCurrentTargetLocationAndForceNetUpdate(const struct FVector& NewTargetLocation);
	bool SetIsOctopusBusy(bool bInBusy);
	void UpdateLocalRotation(float DeltaSeconds);
	void UpdateLookRotation();

	struct FVector GetCurrentTargetLookDir() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10455101">();
	}
	static class ASummoned_10455101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10455101>();
	}
};
static_assert(alignof(ASummoned_10455101) == 0x000010, "Wrong alignment on ASummoned_10455101");
static_assert(sizeof(ASummoned_10455101) == 0x000FD0, "Wrong size on ASummoned_10455101");
static_assert(offsetof(ASummoned_10455101, OnOctopusBusyStateChanged) == 0x000E20, "Member 'ASummoned_10455101::OnOctopusBusyStateChanged' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, bIsOctopusBusy) == 0x000E30, "Member 'ASummoned_10455101::bIsOctopusBusy' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, EquipComponent) == 0x000E38, "Member 'ASummoned_10455101::EquipComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, EquipID) == 0x000E40, "Member 'ASummoned_10455101::EquipID' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CurrentLookDir) == 0x000E48, "Member 'ASummoned_10455101::CurrentLookDir' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, TransformAtSpawn) == 0x000E60, "Member 'ASummoned_10455101::TransformAtSpawn' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, LastBusyTime) == 0x000EC0, "Member 'ASummoned_10455101::LastBusyTime' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, FireDuration) == 0x000EC4, "Member 'ASummoned_10455101::FireDuration' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, PlayerUID) == 0x000EC8, "Member 'ASummoned_10455101::PlayerUID' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CurrentTargetComponent) == 0x000ED0, "Member 'ASummoned_10455101::CurrentTargetComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CurrentTargetLocation) == 0x000ED8, "Member 'ASummoned_10455101::CurrentTargetLocation' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CurrentOctopusState) == 0x000EF0, "Member 'ASummoned_10455101::CurrentOctopusState' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, LastOctopusState) == 0x000EF1, "Member 'ASummoned_10455101::LastOctopusState' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, ValidPosRelativeLocation) == 0x000EF8, "Member 'ASummoned_10455101::ValidPosRelativeLocation' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, MeshHorizontalAngleVelocity) == 0x000F10, "Member 'ASummoned_10455101::MeshHorizontalAngleVelocity' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, HorizontalRotateInterpSpeed) == 0x000F14, "Member 'ASummoned_10455101::HorizontalRotateInterpSpeed' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, AOUpdateVelocity) == 0x000F18, "Member 'ASummoned_10455101::AOUpdateVelocity' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, RotateDegreeThreshold) == 0x000F1C, "Member 'ASummoned_10455101::RotateDegreeThreshold' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, DelayTraceTime) == 0x000F20, "Member 'ASummoned_10455101::DelayTraceTime' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, BusyStateTag) == 0x000F28, "Member 'ASummoned_10455101::BusyStateTag' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, BusyWindowTime) == 0x000F38, "Member 'ASummoned_10455101::BusyWindowTime' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, OctopusBuffs) == 0x000F40, "Member 'ASummoned_10455101::OctopusBuffs' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, AttackManageAbilityID) == 0x000F50, "Member 'ASummoned_10455101::AttackManageAbilityID' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, NormalAttackAbilityID) == 0x000F54, "Member 'ASummoned_10455101::NormalAttackAbilityID' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, EnhancedAttackAbilityID) == 0x000F58, "Member 'ASummoned_10455101::EnhancedAttackAbilityID' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, bIsDead) == 0x000F5C, "Member 'ASummoned_10455101::bIsDead' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, SpringArmComponent) == 0x000F60, "Member 'ASummoned_10455101::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CameraComponent) == 0x000F68, "Member 'ASummoned_10455101::CameraComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CachedUpVector) == 0x000F70, "Member 'ASummoned_10455101::CachedUpVector' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, DegreesBetweenMeshForwardAndLookDir) == 0x000F88, "Member 'ASummoned_10455101::DegreesBetweenMeshForwardAndLookDir' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, DeclarePlayerViewSideHolder) == 0x000F90, "Member 'ASummoned_10455101::DeclarePlayerViewSideHolder' has a wrong offset!");

// Class Hero_1045.SummonedComp_10455101
// 0x0000 (0x0C90 - 0x0C90)
class USummonedComp_10455101 final : public UMarvelSummonedComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10455101">();
	}
	static class USummonedComp_10455101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10455101>();
	}
};
static_assert(alignof(USummonedComp_10455101) == 0x000010, "Wrong alignment on USummonedComp_10455101");
static_assert(sizeof(USummonedComp_10455101) == 0x000C90, "Wrong size on USummonedComp_10455101");

// Class Hero_1045.OctopusSummonedChildActor
// 0x0028 (0x0A68 - 0x0A40)
class AOctopusSummonedChildActor final : public AMarvelCharacterChildActor
{
public:
	uint8                                         Pad_A40[0x8];                                      // 0x0A40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentPlayingTurnMontage;                         // 0x0A48(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOctopusAnimData*                       OctopusAnimData;                                   // 0x0A50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceMontageRate;                            // 0x0A58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOYaw;                                             // 0x0A5C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOPitch;                                           // 0x0A60(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A64[0x4];                                      // 0x0A64(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsAttackDegreeValid(float InAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctopusSummonedChildActor">();
	}
	static class AOctopusSummonedChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctopusSummonedChildActor>();
	}
};
static_assert(alignof(AOctopusSummonedChildActor) == 0x000008, "Wrong alignment on AOctopusSummonedChildActor");
static_assert(sizeof(AOctopusSummonedChildActor) == 0x000A68, "Wrong size on AOctopusSummonedChildActor");
static_assert(offsetof(AOctopusSummonedChildActor, CurrentPlayingTurnMontage) == 0x000A48, "Member 'AOctopusSummonedChildActor::CurrentPlayingTurnMontage' has a wrong offset!");
static_assert(offsetof(AOctopusSummonedChildActor, OctopusAnimData) == 0x000A50, "Member 'AOctopusSummonedChildActor::OctopusAnimData' has a wrong offset!");
static_assert(offsetof(AOctopusSummonedChildActor, TurnInPlaceMontageRate) == 0x000A58, "Member 'AOctopusSummonedChildActor::TurnInPlaceMontageRate' has a wrong offset!");
static_assert(offsetof(AOctopusSummonedChildActor, AOYaw) == 0x000A5C, "Member 'AOctopusSummonedChildActor::AOYaw' has a wrong offset!");
static_assert(offsetof(AOctopusSummonedChildActor, AOPitch) == 0x000A60, "Member 'AOctopusSummonedChildActor::AOPitch' has a wrong offset!");

// Class Hero_1045.Projectile_10453102
// 0x0010 (0x2F70 - 0x2F60)
class AProjectile_10453102 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	bool                                          bShouldUsedForHitRate;                             // 0x2F60(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F61[0x7];                                     // 0x2F61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x2F68(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10453102">();
	}
	static class AProjectile_10453102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10453102>();
	}
};
static_assert(alignof(AProjectile_10453102) == 0x000010, "Wrong alignment on AProjectile_10453102");
static_assert(sizeof(AProjectile_10453102) == 0x002F70, "Wrong size on AProjectile_10453102");
static_assert(offsetof(AProjectile_10453102, bShouldUsedForHitRate) == 0x002F60, "Member 'AProjectile_10453102::bShouldUsedForHitRate' has a wrong offset!");
static_assert(offsetof(AProjectile_10453102, TargetActor) == 0x002F68, "Member 'AProjectile_10453102::TargetActor' has a wrong offset!");

// Class Hero_1045.Ability_104553
// 0x0000 (0x2558 - 0x2558)
class UAbility_104553 : public UAbility_108
{
public:
	bool IsOnCooldown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104553">();
	}
	static class UAbility_104553* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104553>();
	}
};
static_assert(alignof(UAbility_104553) == 0x000008, "Wrong alignment on UAbility_104553");
static_assert(sizeof(UAbility_104553) == 0x002558, "Wrong size on UAbility_104553");

// Class Hero_1045.InstantAmmo_104553
// 0x0000 (0x0D60 - 0x0D60)
class AInstantAmmo_104553 : public AInstantAmmo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InstantAmmo_104553">();
	}
	static class AInstantAmmo_104553* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInstantAmmo_104553>();
	}
};
static_assert(alignof(AInstantAmmo_104553) == 0x000008, "Wrong alignment on AInstantAmmo_104553");
static_assert(sizeof(AInstantAmmo_104553) == 0x000D60, "Wrong size on AInstantAmmo_104553");

// Class Hero_1045.Ability_104554
// 0x0020 (0x2570 - 0x2550)
class UAbility_104554 : public UMarvelGameplayAbility
{
public:
	class UPrimitiveComponent*                    TargetActorComponent;                              // 0x2550(0x0008)(BlueprintVisible, ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x2558(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector GetWaterTargetLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104554">();
	}
	static class UAbility_104554* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104554>();
	}
};
static_assert(alignof(UAbility_104554) == 0x000008, "Wrong alignment on UAbility_104554");
static_assert(sizeof(UAbility_104554) == 0x002570, "Wrong size on UAbility_104554");
static_assert(offsetof(UAbility_104554, TargetActorComponent) == 0x002550, "Member 'UAbility_104554::TargetActorComponent' has a wrong offset!");
static_assert(offsetof(UAbility_104554, TargetLocation) == 0x002558, "Member 'UAbility_104554::TargetLocation' has a wrong offset!");

// Class Hero_1045.Config_104561
// 0x0008 (0x00A0 - 0x0098)
class UConfig_104561 : public UMarvelAbilityConfig
{
public:
	float                                         WhaleFlyTime;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104561">();
	}
	static class UConfig_104561* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104561>();
	}
};
static_assert(alignof(UConfig_104561) == 0x000008, "Wrong alignment on UConfig_104561");
static_assert(sizeof(UConfig_104561) == 0x0000A0, "Wrong size on UConfig_104561");
static_assert(offsetof(UConfig_104561, WhaleFlyTime) == 0x000098, "Member 'UConfig_104561::WhaleFlyTime' has a wrong offset!");
static_assert(offsetof(UConfig_104561, MaxHeight) == 0x00009C, "Member 'UConfig_104561::MaxHeight' has a wrong offset!");

// Class Hero_1045.EpicMomentAction_1045
// 0x0000 (0x0120 - 0x0120)
class UEpicMomentAction_1045 final : public UEpicMomentBaseAction
{
public:
	void OnProjectileBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Projectile, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1045">();
	}
	static class UEpicMomentAction_1045* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1045>();
	}
};
static_assert(alignof(UEpicMomentAction_1045) == 0x000008, "Wrong alignment on UEpicMomentAction_1045");
static_assert(sizeof(UEpicMomentAction_1045) == 0x000120, "Wrong size on UEpicMomentAction_1045");

// Class Hero_1045.NamorAnimInstance
// 0x0010 (0x0910 - 0x0900)
class UNamorAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsLanding;                                        // 0x0900(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_901[0x3];                                      // 0x0901(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingForward;                                    // 0x0904(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingRight;                                      // 0x0908(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90C[0x4];                                      // 0x090C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorAnimInstance">();
	}
	static class UNamorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamorAnimInstance>();
	}
};
static_assert(alignof(UNamorAnimInstance) == 0x000010, "Wrong alignment on UNamorAnimInstance");
static_assert(sizeof(UNamorAnimInstance) == 0x000910, "Wrong size on UNamorAnimInstance");
static_assert(offsetof(UNamorAnimInstance, bIsLanding) == 0x000900, "Member 'UNamorAnimInstance::bIsLanding' has a wrong offset!");
static_assert(offsetof(UNamorAnimInstance, FallingForward) == 0x000904, "Member 'UNamorAnimInstance::FallingForward' has a wrong offset!");
static_assert(offsetof(UNamorAnimInstance, FallingRight) == 0x000908, "Member 'UNamorAnimInstance::FallingRight' has a wrong offset!");

// Class Hero_1045.NamorOctopusAnimInstance
// 0x0020 (0x0440 - 0x0420)
class UNamorOctopusAnimInstance final : public UAnimInstance
{
public:
	class UOctopusAnimData*                       OctopusAnimData;                                   // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   MontageAimOffsetBlendSpace;                        // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldUseMontageAO;                                // 0x0428(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x3];                                      // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Pitch;                                             // 0x042C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Yaw;                                               // 0x0430(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDead;                                           // 0x0434(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBornOver;                                         // 0x0435(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_436[0xA];                                      // 0x0436(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorOctopusAnimInstance">();
	}
	static class UNamorOctopusAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamorOctopusAnimInstance>();
	}
};
static_assert(alignof(UNamorOctopusAnimInstance) == 0x000010, "Wrong alignment on UNamorOctopusAnimInstance");
static_assert(sizeof(UNamorOctopusAnimInstance) == 0x000440, "Wrong size on UNamorOctopusAnimInstance");
static_assert(offsetof(UNamorOctopusAnimInstance, OctopusAnimData) == 0x000418, "Member 'UNamorOctopusAnimInstance::OctopusAnimData' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, MontageAimOffsetBlendSpace) == 0x000420, "Member 'UNamorOctopusAnimInstance::MontageAimOffsetBlendSpace' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, ShouldUseMontageAO) == 0x000428, "Member 'UNamorOctopusAnimInstance::ShouldUseMontageAO' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, Pitch) == 0x00042C, "Member 'UNamorOctopusAnimInstance::Pitch' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, Yaw) == 0x000430, "Member 'UNamorOctopusAnimInstance::Yaw' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, bIsDead) == 0x000434, "Member 'UNamorOctopusAnimInstance::bIsDead' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, bBornOver) == 0x000435, "Member 'UNamorOctopusAnimInstance::bBornOver' has a wrong offset!");

// Class Hero_1045.OctopusAnimData
// 0x0018 (0x0058 - 0x0040)
class UOctopusAnimData final : public UAnimationDataCollection
{
public:
	class UAnimMontage*                           Turn_L90_MT;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Turn_R90_MT;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BornAnimSequence;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctopusAnimData">();
	}
	static class UOctopusAnimData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOctopusAnimData>();
	}
};
static_assert(alignof(UOctopusAnimData) == 0x000008, "Wrong alignment on UOctopusAnimData");
static_assert(sizeof(UOctopusAnimData) == 0x000058, "Wrong size on UOctopusAnimData");
static_assert(offsetof(UOctopusAnimData, Turn_L90_MT) == 0x000040, "Member 'UOctopusAnimData::Turn_L90_MT' has a wrong offset!");
static_assert(offsetof(UOctopusAnimData, Turn_R90_MT) == 0x000048, "Member 'UOctopusAnimData::Turn_R90_MT' has a wrong offset!");
static_assert(offsetof(UOctopusAnimData, BornAnimSequence) == 0x000050, "Member 'UOctopusAnimData::BornAnimSequence' has a wrong offset!");

// Class Hero_1045.NamorCharacter
// 0x0030 (0x17F0 - 0x17C0)
class ANamorCharacter : public AMarvelBaseCharacter
{
public:
	FMulticastInlineDelegateProperty_             OnNamorOctopusNumChange;                           // 0x17B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CommandOctopusAttackDelegate;                      // 0x17C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CurrentNumOfLiveOctopus;                           // 0x17D8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17DC[0x4];                                     // 0x17DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNamorMoveLogicBaseComponent*           NamorMoveLogic;                                    // 0x17E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17E8[0x8];                                     // 0x17E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyBerserkBuff(const TArray<int32>& BerserkBuffIDs, const TArray<int32>& BerserkBuffSummonIDs, const struct FGameplayTagContainer& BerserkSummonTriggersCues, class UGameplayAbility* Ability);
	int32 ChangeNamorOctopusNum(int32 Delta);
	void OnRep_CurrentNumOfLiveOctopus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorCharacter">();
	}
	static class ANamorCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANamorCharacter>();
	}
};
static_assert(alignof(ANamorCharacter) == 0x000010, "Wrong alignment on ANamorCharacter");
static_assert(sizeof(ANamorCharacter) == 0x0017F0, "Wrong size on ANamorCharacter");
static_assert(offsetof(ANamorCharacter, OnNamorOctopusNumChange) == 0x0017B8, "Member 'ANamorCharacter::OnNamorOctopusNumChange' has a wrong offset!");
static_assert(offsetof(ANamorCharacter, CommandOctopusAttackDelegate) == 0x0017C8, "Member 'ANamorCharacter::CommandOctopusAttackDelegate' has a wrong offset!");
static_assert(offsetof(ANamorCharacter, CurrentNumOfLiveOctopus) == 0x0017D8, "Member 'ANamorCharacter::CurrentNumOfLiveOctopus' has a wrong offset!");
static_assert(offsetof(ANamorCharacter, NamorMoveLogic) == 0x0017E0, "Member 'ANamorCharacter::NamorMoveLogic' has a wrong offset!");

// Class Hero_1045.NamorChildActor
// 0x0008 (0x0A48 - 0x0A40)
class ANamorChildActor final : public AMarvelCharacterChildActor
{
public:
	class USkeletalMeshComponent*                 HornMesh;                                          // 0x0A40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorChildActor">();
	}
	static class ANamorChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANamorChildActor>();
	}
};
static_assert(alignof(ANamorChildActor) == 0x000008, "Wrong alignment on ANamorChildActor");
static_assert(sizeof(ANamorChildActor) == 0x000A48, "Wrong size on ANamorChildActor");
static_assert(offsetof(ANamorChildActor, HornMesh) == 0x000A40, "Member 'ANamorChildActor::HornMesh' has a wrong offset!");

// Class Hero_1045.NamorMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UNamorMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorMoveLogicBaseComponent">();
	}
	static class UNamorMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamorMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UNamorMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UNamorMoveLogicBaseComponent");
static_assert(sizeof(UNamorMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UNamorMoveLogicBaseComponent");

// Class Hero_1045.NamorMovementComponent
// 0x0000 (0x1AF0 - 0x1AF0)
class UNamorMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorMovementComponent">();
	}
	static class UNamorMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamorMovementComponent>();
	}
};
static_assert(alignof(UNamorMovementComponent) == 0x000010, "Wrong alignment on UNamorMovementComponent");
static_assert(sizeof(UNamorMovementComponent) == 0x001AF0, "Wrong size on UNamorMovementComponent");

// Class Hero_1045.TabData_1045
// 0x0000 (0x0050 - 0x0050)
class UTabData_1045 final : public UHeroTabDataBase
{
public:
	void OnSummonedBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Summoned, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1045">();
	}
	static class UTabData_1045* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1045>();
	}
};
static_assert(alignof(UTabData_1045) == 0x000008, "Wrong alignment on UTabData_1045");
static_assert(sizeof(UTabData_1045) == 0x000050, "Wrong size on UTabData_1045");

}

