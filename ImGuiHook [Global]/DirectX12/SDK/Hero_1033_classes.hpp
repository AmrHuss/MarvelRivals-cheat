#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1033

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Hero_1033_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Hero_1033.Cue_Projectile_10335202
// 0x0000 (0x0D60 - 0x0D60)
class ACue_Projectile_10335202 final : public AMarvelCueNotify_Projectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_10335202">();
	}
	static class ACue_Projectile_10335202* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_10335202>();
	}
};
static_assert(alignof(ACue_Projectile_10335202) == 0x000008, "Wrong alignment on ACue_Projectile_10335202");
static_assert(sizeof(ACue_Projectile_10335202) == 0x000D60, "Wrong size on ACue_Projectile_10335202");

// Class Hero_1033.Cue_Summoned_Loop_10335201
// 0x0000 (0x0E30 - 0x0E30)
class ACue_Summoned_Loop_10335201 final : public AMarvelCueNotify_Summoned
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoned_Loop_10335201">();
	}
	static class ACue_Summoned_Loop_10335201* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoned_Loop_10335201>();
	}
};
static_assert(alignof(ACue_Summoned_Loop_10335201) == 0x000008, "Wrong alignment on ACue_Summoned_Loop_10335201");
static_assert(sizeof(ACue_Summoned_Loop_10335201) == 0x000E30, "Wrong size on ACue_Summoned_Loop_10335201");

// Class Hero_1033.Ability_103302
// 0x0008 (0x2660 - 0x2658)
class UAbility_103302 : public UAbility_103
{
public:
	uint8                                         Pad_2658[0x8];                                     // 0x2658(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103302">();
	}
	static class UAbility_103302* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103302>();
	}
};
static_assert(alignof(UAbility_103302) == 0x000008, "Wrong alignment on UAbility_103302");
static_assert(sizeof(UAbility_103302) == 0x002660, "Wrong size on UAbility_103302");

// Class Hero_1033.Ability_103303
// 0x00D8 (0x2628 - 0x2550)
class UAbility_103303 : public UMarvelGameplayAbility
{
public:
	bool                                          bDebugAbility;                                     // 0x2550(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2551[0x3];                                     // 0x2551(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PendingWeaponEquipID;                              // 0x2554(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NextAbilityID;                                     // 0x2558(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AbilityWaitForActivate;                            // 0x255C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* AnimTask;                                          // 0x2560(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UEquipComponent>         EquipComp;                                         // 0x2568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitDelay*                 DelayTask;                                         // 0x2570(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_NetworkSyncPoint*          NetSyncTask;                                       // 0x2578(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2580[0xA8];                                    // 0x2580(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayEndAbility();
	void OnEndSync();
	void OnWeaponSwitchedReplicated(class AShootingWeapon* Weapon, const struct FMarvelEquipmentTable& WeaponInfo, bool bState);
	void SetNextAbilityID(int32 AbilityID);
	void SwitchWeapon(int32 NewWeaponIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103303">();
	}
	static class UAbility_103303* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103303>();
	}
};
static_assert(alignof(UAbility_103303) == 0x000008, "Wrong alignment on UAbility_103303");
static_assert(sizeof(UAbility_103303) == 0x002628, "Wrong size on UAbility_103303");
static_assert(offsetof(UAbility_103303, bDebugAbility) == 0x002550, "Member 'UAbility_103303::bDebugAbility' has a wrong offset!");
static_assert(offsetof(UAbility_103303, PendingWeaponEquipID) == 0x002554, "Member 'UAbility_103303::PendingWeaponEquipID' has a wrong offset!");
static_assert(offsetof(UAbility_103303, NextAbilityID) == 0x002558, "Member 'UAbility_103303::NextAbilityID' has a wrong offset!");
static_assert(offsetof(UAbility_103303, AbilityWaitForActivate) == 0x00255C, "Member 'UAbility_103303::AbilityWaitForActivate' has a wrong offset!");
static_assert(offsetof(UAbility_103303, AnimTask) == 0x002560, "Member 'UAbility_103303::AnimTask' has a wrong offset!");
static_assert(offsetof(UAbility_103303, EquipComp) == 0x002568, "Member 'UAbility_103303::EquipComp' has a wrong offset!");
static_assert(offsetof(UAbility_103303, DelayTask) == 0x002570, "Member 'UAbility_103303::DelayTask' has a wrong offset!");
static_assert(offsetof(UAbility_103303, NetSyncTask) == 0x002578, "Member 'UAbility_103303::NetSyncTask' has a wrong offset!");

// Class Hero_1033.MarvelAbilityConfig_AimDownSights
// 0x0408 (0x04A0 - 0x0098)
class UMarvelAbilityConfig_AimDownSights : public UMarvelAbilityConfig
{
public:
	int32                                         DecelerateBuffID;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraCorrParam                       CamCorrParam;                                      // 0x00A0(0x03B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FShootModeSensitivityParam             SensitivityParam;                                  // 0x0450(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsWaitStateChanged;                               // 0x0474(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_475[0x3];                                      // 0x0475(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStateChangedTaskParam                 TaskParam;                                         // 0x0478(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAbilityConfig_AimDownSights">();
	}
	static class UMarvelAbilityConfig_AimDownSights* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAbilityConfig_AimDownSights>();
	}
};
static_assert(alignof(UMarvelAbilityConfig_AimDownSights) == 0x000008, "Wrong alignment on UMarvelAbilityConfig_AimDownSights");
static_assert(sizeof(UMarvelAbilityConfig_AimDownSights) == 0x0004A0, "Wrong size on UMarvelAbilityConfig_AimDownSights");
static_assert(offsetof(UMarvelAbilityConfig_AimDownSights, DecelerateBuffID) == 0x000098, "Member 'UMarvelAbilityConfig_AimDownSights::DecelerateBuffID' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityConfig_AimDownSights, CamCorrParam) == 0x0000A0, "Member 'UMarvelAbilityConfig_AimDownSights::CamCorrParam' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityConfig_AimDownSights, SensitivityParam) == 0x000450, "Member 'UMarvelAbilityConfig_AimDownSights::SensitivityParam' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityConfig_AimDownSights, bIsWaitStateChanged) == 0x000474, "Member 'UMarvelAbilityConfig_AimDownSights::bIsWaitStateChanged' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityConfig_AimDownSights, TaskParam) == 0x000478, "Member 'UMarvelAbilityConfig_AimDownSights::TaskParam' has a wrong offset!");

// Class Hero_1033.MarvelAbility_AimDownSights
// 0x0068 (0x25B8 - 0x2550)
class UMarvelAbility_AimDownSights : public UMarvelGameplayAbility
{
public:
	bool                                          bIsAiming;                                         // 0x2550(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2551[0x7];                                     // 0x2551(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAimingStateChangeDispatcher;                     // 0x2558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCameraInterp*                          CameraInterpAsset;                                 // 0x2568(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityConfig_AimDownSights*     Config;                                            // 0x2570(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x2578(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2580[0x38];                                    // 0x2580(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAimingStateChange();
	void OnInputStateEnd(float StateIntervalTime);
	void OnRep_IsAiming();
	void SetAimingFOV(bool bInAiming);
	void SetAimingSensitivity();
	void SetAimingState(bool bNewState);
	void SetArmOffsetWithCorrection(bool bInAiming);
	void SetDecelerateBuffActive(bool bInAiming);
	void SetFppMode(bool bInAiming);
	void UpdateAimDownSightsSensitivity();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAbility_AimDownSights">();
	}
	static class UMarvelAbility_AimDownSights* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAbility_AimDownSights>();
	}
};
static_assert(alignof(UMarvelAbility_AimDownSights) == 0x000008, "Wrong alignment on UMarvelAbility_AimDownSights");
static_assert(sizeof(UMarvelAbility_AimDownSights) == 0x0025B8, "Wrong size on UMarvelAbility_AimDownSights");
static_assert(offsetof(UMarvelAbility_AimDownSights, bIsAiming) == 0x002550, "Member 'UMarvelAbility_AimDownSights::bIsAiming' has a wrong offset!");
static_assert(offsetof(UMarvelAbility_AimDownSights, OnAimingStateChangeDispatcher) == 0x002558, "Member 'UMarvelAbility_AimDownSights::OnAimingStateChangeDispatcher' has a wrong offset!");
static_assert(offsetof(UMarvelAbility_AimDownSights, CameraInterpAsset) == 0x002568, "Member 'UMarvelAbility_AimDownSights::CameraInterpAsset' has a wrong offset!");
static_assert(offsetof(UMarvelAbility_AimDownSights, Config) == 0x002570, "Member 'UMarvelAbility_AimDownSights::Config' has a wrong offset!");
static_assert(offsetof(UMarvelAbility_AimDownSights, OwnerChar) == 0x002578, "Member 'UMarvelAbility_AimDownSights::OwnerChar' has a wrong offset!");

// Class Hero_1033.Cue_Instant_HitImpact_10332201
// 0x0018 (0x0518 - 0x0500)
class UCue_Instant_HitImpact_10332201 final : public UMarvelCueNotify_InstantHitImpact
{
public:
	struct FVector                                RelativeBeamPosition;                              // 0x0500(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Instant_HitImpact_10332201">();
	}
	static class UCue_Instant_HitImpact_10332201* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Instant_HitImpact_10332201>();
	}
};
static_assert(alignof(UCue_Instant_HitImpact_10332201) == 0x000008, "Wrong alignment on UCue_Instant_HitImpact_10332201");
static_assert(sizeof(UCue_Instant_HitImpact_10332201) == 0x000518, "Wrong size on UCue_Instant_HitImpact_10332201");
static_assert(offsetof(UCue_Instant_HitImpact_10332201, RelativeBeamPosition) == 0x000500, "Member 'UCue_Instant_HitImpact_10332201::RelativeBeamPosition' has a wrong offset!");

// Class Hero_1033.MarvelCueNotify_TraceActor_10333101
// 0x0F60 (0x1C10 - 0x0CB0)
class AMarvelCueNotify_TraceActor_10333101 final : public AMarvelCueNotify_TraceActor
{
public:
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x0CB0(0x0F30)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComp;                                         // 0x1BE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalSize;                                         // 0x1BE8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DecalMaterialInstance;                             // 0x1C00(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C08[0x8];                                     // 0x1C08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelCueNotify_TraceActor_10333101">();
	}
	static class AMarvelCueNotify_TraceActor_10333101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelCueNotify_TraceActor_10333101>();
	}
};
static_assert(alignof(AMarvelCueNotify_TraceActor_10333101) == 0x000010, "Wrong alignment on AMarvelCueNotify_TraceActor_10333101");
static_assert(sizeof(AMarvelCueNotify_TraceActor_10333101) == 0x001C10, "Wrong size on AMarvelCueNotify_TraceActor_10333101");
static_assert(offsetof(AMarvelCueNotify_TraceActor_10333101, TraceContext) == 0x000CB0, "Member 'AMarvelCueNotify_TraceActor_10333101::TraceContext' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_TraceActor_10333101, DecalComp) == 0x001BE0, "Member 'AMarvelCueNotify_TraceActor_10333101::DecalComp' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_TraceActor_10333101, DecalSize) == 0x001BE8, "Member 'AMarvelCueNotify_TraceActor_10333101::DecalSize' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_TraceActor_10333101, DecalMaterialInstance) == 0x001C00, "Member 'AMarvelCueNotify_TraceActor_10333101::DecalMaterialInstance' has a wrong offset!");

// Class Hero_1033.Ability_103331
// 0x0010 (0x2560 - 0x2550)
class UAbility_103331 : public UMarvelGameplayAbility
{
public:
	TArray<class AActor*>                         HitActors;                                         // 0x2550(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void SaveHitActors(const TArray<struct FHitResult>& InHitResults);

	bool HasValidHitActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103331">();
	}
	static class UAbility_103331* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103331>();
	}
};
static_assert(alignof(UAbility_103331) == 0x000008, "Wrong alignment on UAbility_103331");
static_assert(sizeof(UAbility_103331) == 0x002560, "Wrong size on UAbility_103331");
static_assert(offsetof(UAbility_103331, HitActors) == 0x002550, "Member 'UAbility_103331::HitActors' has a wrong offset!");

// Class Hero_1033.Config_103331
// 0x0040 (0x00D8 - 0x0098)
class UConfig_103331 final : public UMarvelAbilityConfig
{
public:
	float                                         MaxTargetPitchAngle;                               // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValidPitchAngle;                                // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetDistance;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTargetHeight;                                   // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveAngel;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnlyPlatform;                                   // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DecalRotator;                                      // 0x00B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlacementCueTag;                                   // 0x00C8(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103331">();
	}
	static class UConfig_103331* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103331>();
	}
};
static_assert(alignof(UConfig_103331) == 0x000008, "Wrong alignment on UConfig_103331");
static_assert(sizeof(UConfig_103331) == 0x0000D8, "Wrong size on UConfig_103331");
static_assert(offsetof(UConfig_103331, MaxTargetPitchAngle) == 0x000098, "Member 'UConfig_103331::MaxTargetPitchAngle' has a wrong offset!");
static_assert(offsetof(UConfig_103331, MaxValidPitchAngle) == 0x00009C, "Member 'UConfig_103331::MaxValidPitchAngle' has a wrong offset!");
static_assert(offsetof(UConfig_103331, MaxTargetDistance) == 0x0000A0, "Member 'UConfig_103331::MaxTargetDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103331, MinTargetHeight) == 0x0000A4, "Member 'UConfig_103331::MinTargetHeight' has a wrong offset!");
static_assert(offsetof(UConfig_103331, AdditiveAngel) == 0x0000A8, "Member 'UConfig_103331::AdditiveAngel' has a wrong offset!");
static_assert(offsetof(UConfig_103331, bIsOnlyPlatform) == 0x0000AC, "Member 'UConfig_103331::bIsOnlyPlatform' has a wrong offset!");
static_assert(offsetof(UConfig_103331, DecalRotator) == 0x0000B0, "Member 'UConfig_103331::DecalRotator' has a wrong offset!");
static_assert(offsetof(UConfig_103331, PlacementCueTag) == 0x0000C8, "Member 'UConfig_103331::PlacementCueTag' has a wrong offset!");

// Class Hero_1033.AbilityTargetActor_PawnPlacement_103331
// 0x0030 (0x1730 - 0x1700)
class AAbilityTargetActor_PawnPlacement_103331 final : public AMarvelAbilityTargetActor_PawnPlacement
{
public:
	FMulticastInlineDelegateProperty_             OnPlacementTargetPositionUpdated;                  // 0x1700(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1710[0x20];                                    // 0x1710(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTargetActor_PawnPlacement_103331">();
	}
	static class AAbilityTargetActor_PawnPlacement_103331* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityTargetActor_PawnPlacement_103331>();
	}
};
static_assert(alignof(AAbilityTargetActor_PawnPlacement_103331) == 0x000010, "Wrong alignment on AAbilityTargetActor_PawnPlacement_103331");
static_assert(sizeof(AAbilityTargetActor_PawnPlacement_103331) == 0x001730, "Wrong size on AAbilityTargetActor_PawnPlacement_103331");
static_assert(offsetof(AAbilityTargetActor_PawnPlacement_103331, OnPlacementTargetPositionUpdated) == 0x001700, "Member 'AAbilityTargetActor_PawnPlacement_103331::OnPlacementTargetPositionUpdated' has a wrong offset!");

// Class Hero_1033.Ability_103332
// 0x0038 (0x2588 - 0x2550)
class UAbility_103332 : public UMarvelGameplayAbility
{
public:
	TArray<class AActor*>                         ValidActors;                                       // 0x2550(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 SelectedActor;                                     // 0x2560(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPortalSegments                        PortalSegments;                                    // 0x2568(0x0020)(Net, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void FilterValidHitResult(TArray<struct FHitResult>& InOutHitResults);
	void SetSelectedActor(class AActor* InSelectedActor, const struct FPortalSegments& InPortalSegments);

	class AActor* GetSelectedActor() const;
	TArray<class AActor*> GetValidActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103332">();
	}
	static class UAbility_103332* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103332>();
	}
};
static_assert(alignof(UAbility_103332) == 0x000008, "Wrong alignment on UAbility_103332");
static_assert(sizeof(UAbility_103332) == 0x002588, "Wrong size on UAbility_103332");
static_assert(offsetof(UAbility_103332, ValidActors) == 0x002550, "Member 'UAbility_103332::ValidActors' has a wrong offset!");
static_assert(offsetof(UAbility_103332, SelectedActor) == 0x002560, "Member 'UAbility_103332::SelectedActor' has a wrong offset!");
static_assert(offsetof(UAbility_103332, PortalSegments) == 0x002568, "Member 'UAbility_103332::PortalSegments' has a wrong offset!");

// Class Hero_1033.Config_103332
// 0x0008 (0x00A0 - 0x0098)
class UConfig_103332 final : public UMarvelAbilityConfig
{
public:
	float                                         ThreholdLandDistance;                              // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103332">();
	}
	static class UConfig_103332* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103332>();
	}
};
static_assert(alignof(UConfig_103332) == 0x000008, "Wrong alignment on UConfig_103332");
static_assert(sizeof(UConfig_103332) == 0x0000A0, "Wrong size on UConfig_103332");
static_assert(offsetof(UConfig_103332, ThreholdLandDistance) == 0x000098, "Member 'UConfig_103332::ThreholdLandDistance' has a wrong offset!");

// Class Hero_1033.Ability_103333
// 0x0C30 (0x3180 - 0x2550)
class UAbility_103333 : public UMarvelGameplayAbility
{
public:
	class AActor*                                 SelectedActor;                                     // 0x2550(0x0008)(BlueprintVisible, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SelectedActorChangedDelegate;                      // 0x2558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDashAbilityInfo                       DashInfo;                                          // 0x2568(0x0B70)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPredictionKey                         ClosedToCharacterKey;                              // 0x30D8(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3178[0x4];                                     // 0x3178(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToKickBeforeDashEnd;                           // 0x317C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClosedToTarget();
	void OnRep_SelectedActor(class AActor* OldActor);
	void PlayKickTimeline();
	void SelectedActorChangedDelegate__DelegateSignature(class AActor* OldActor, class AActor* NewActor);
	void StartCheckDashLeftTime();
	void StopCheckDashLeftTime();

	int32 GetDashTimelineIndex() const;
	int32 GetKickTimelineIndex() const;
	struct FPortalSegments GetPortalSegments() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103333">();
	}
	static class UAbility_103333* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103333>();
	}
};
static_assert(alignof(UAbility_103333) == 0x000008, "Wrong alignment on UAbility_103333");
static_assert(sizeof(UAbility_103333) == 0x003180, "Wrong size on UAbility_103333");
static_assert(offsetof(UAbility_103333, SelectedActor) == 0x002550, "Member 'UAbility_103333::SelectedActor' has a wrong offset!");
static_assert(offsetof(UAbility_103333, SelectedActorChangedDelegate) == 0x002558, "Member 'UAbility_103333::SelectedActorChangedDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_103333, DashInfo) == 0x002568, "Member 'UAbility_103333::DashInfo' has a wrong offset!");
static_assert(offsetof(UAbility_103333, ClosedToCharacterKey) == 0x0030D8, "Member 'UAbility_103333::ClosedToCharacterKey' has a wrong offset!");
static_assert(offsetof(UAbility_103333, TimeToKickBeforeDashEnd) == 0x00317C, "Member 'UAbility_103333::TimeToKickBeforeDashEnd' has a wrong offset!");

// Class Hero_1033.Cue_Ability_Loop_10333301
// 0x0078 (0x0E78 - 0x0E00)
class ACue_Ability_Loop_10333301 final : public AMarvelCueNotify_Ability
{
public:
	float                                         HookFlyDuration;                                   // 0x0E00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E04[0x24];                                     // 0x0E04(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   HookComponent;                                     // 0x0E28(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      NS_Cable;                                          // 0x0E30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         NS_CableHit;                                       // 0x0E38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbility_103333*                        OwnerAbility;                                      // 0x0E40(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ACharacter>              TargetCharacter;                                   // 0x0E48(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E50[0x28];                                     // 0x0E50(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleReceiveTargetCharacter(class AActor* OldActor, class AActor* NewActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10333301">();
	}
	static class ACue_Ability_Loop_10333301* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10333301>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10333301) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10333301");
static_assert(sizeof(ACue_Ability_Loop_10333301) == 0x000E78, "Wrong size on ACue_Ability_Loop_10333301");
static_assert(offsetof(ACue_Ability_Loop_10333301, HookFlyDuration) == 0x000E00, "Member 'ACue_Ability_Loop_10333301::HookFlyDuration' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10333301, HookComponent) == 0x000E28, "Member 'ACue_Ability_Loop_10333301::HookComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10333301, NS_Cable) == 0x000E30, "Member 'ACue_Ability_Loop_10333301::NS_Cable' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10333301, NS_CableHit) == 0x000E38, "Member 'ACue_Ability_Loop_10333301::NS_CableHit' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10333301, OwnerAbility) == 0x000E40, "Member 'ACue_Ability_Loop_10333301::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10333301, TargetCharacter) == 0x000E48, "Member 'ACue_Ability_Loop_10333301::TargetCharacter' has a wrong offset!");

// Class Hero_1033.CueDataProcessor_AttachBlackWidow_103333
// 0x0010 (0x00D0 - 0x00C0)
class UCueDataProcessor_AttachBlackWidow_103333 final : public UCueDataProcessor_AttachCharacter
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueDataProcessor_AttachBlackWidow_103333">();
	}
	static class UCueDataProcessor_AttachBlackWidow_103333* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCueDataProcessor_AttachBlackWidow_103333>();
	}
};
static_assert(alignof(UCueDataProcessor_AttachBlackWidow_103333) == 0x000008, "Wrong alignment on UCueDataProcessor_AttachBlackWidow_103333");
static_assert(sizeof(UCueDataProcessor_AttachBlackWidow_103333) == 0x0000D0, "Wrong size on UCueDataProcessor_AttachBlackWidow_103333");

// Class Hero_1033.Cue_Ability_Instant_10333301
// 0x0048 (0x02D0 - 0x0288)
class UCue_Ability_Instant_10333301 final : public UMarvelCueNotify_Static
{
public:
	struct FCueNiagaraInfo_Custom                 HitNiagaraInfo;                                    // 0x0288(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Instant_10333301">();
	}
	static class UCue_Ability_Instant_10333301* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Ability_Instant_10333301>();
	}
};
static_assert(alignof(UCue_Ability_Instant_10333301) == 0x000008, "Wrong alignment on UCue_Ability_Instant_10333301");
static_assert(sizeof(UCue_Ability_Instant_10333301) == 0x0002D0, "Wrong size on UCue_Ability_Instant_10333301");
static_assert(offsetof(UCue_Ability_Instant_10333301, HitNiagaraInfo) == 0x000288, "Member 'UCue_Ability_Instant_10333301::HitNiagaraInfo' has a wrong offset!");

// Class Hero_1033.Config_103341
// 0x0F78 (0x1010 - 0x0098)
class UConfig_103341 final : public UMarvelAbilityConfig
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFindGroundParam                       TargetPointTracingParam;                           // 0x00A0(0x0F70)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103341">();
	}
	static class UConfig_103341* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103341>();
	}
};
static_assert(alignof(UConfig_103341) == 0x000010, "Wrong alignment on UConfig_103341");
static_assert(sizeof(UConfig_103341) == 0x001010, "Wrong size on UConfig_103341");
static_assert(offsetof(UConfig_103341, TargetPointTracingParam) == 0x0000A0, "Member 'UConfig_103341::TargetPointTracingParam' has a wrong offset!");

// Class Hero_1033.Ability_103341
// 0x0000 (0x2550 - 0x2550)
class UAbility_103341 : public UMarvelGameplayAbility
{
public:
	bool IsMovingForward();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103341">();
	}
	static class UAbility_103341* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103341>();
	}
};
static_assert(alignof(UAbility_103341) == 0x000008, "Wrong alignment on UAbility_103341");
static_assert(sizeof(UAbility_103341) == 0x002550, "Wrong size on UAbility_103341");

// Class Hero_1033.CueProjectileLoop_1033_RopeHook
// 0x0020 (0x0D80 - 0x0D60)
class ACueProjectileLoop_1033_RopeHook : public AMarvelCueNotify_Projectile
{
public:
	float                                         CableLengthFactor;                                 // 0x0D60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RopeAttachedSocketName;                            // 0x0D64(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelCableComponent*                  Cable;                                             // 0x0D70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x0D78(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueProjectileLoop_1033_RopeHook">();
	}
	static class ACueProjectileLoop_1033_RopeHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueProjectileLoop_1033_RopeHook>();
	}
};
static_assert(alignof(ACueProjectileLoop_1033_RopeHook) == 0x000008, "Wrong alignment on ACueProjectileLoop_1033_RopeHook");
static_assert(sizeof(ACueProjectileLoop_1033_RopeHook) == 0x000D80, "Wrong size on ACueProjectileLoop_1033_RopeHook");
static_assert(offsetof(ACueProjectileLoop_1033_RopeHook, CableLengthFactor) == 0x000D60, "Member 'ACueProjectileLoop_1033_RopeHook::CableLengthFactor' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_1033_RopeHook, RopeAttachedSocketName) == 0x000D64, "Member 'ACueProjectileLoop_1033_RopeHook::RopeAttachedSocketName' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_1033_RopeHook, Cable) == 0x000D70, "Member 'ACueProjectileLoop_1033_RopeHook::Cable' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_1033_RopeHook, TargetMesh) == 0x000D78, "Member 'ACueProjectileLoop_1033_RopeHook::TargetMesh' has a wrong offset!");

// Class Hero_1033.Ability_103352
// 0x0010 (0x2560 - 0x2550)
class UAbility_103352 : public UMarvelGameplayAbility
{
public:
	bool                                          bIsAccumulating;                                   // 0x2550(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2551[0x3];                                     // 0x2551(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargeDuration;                                    // 0x2554(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2558[0x8];                                     // 0x2558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetChargeStrength() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103352">();
	}
	static class UAbility_103352* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103352>();
	}
};
static_assert(alignof(UAbility_103352) == 0x000008, "Wrong alignment on UAbility_103352");
static_assert(sizeof(UAbility_103352) == 0x002560, "Wrong size on UAbility_103352");
static_assert(offsetof(UAbility_103352, bIsAccumulating) == 0x002550, "Member 'UAbility_103352::bIsAccumulating' has a wrong offset!");
static_assert(offsetof(UAbility_103352, ChargeDuration) == 0x002554, "Member 'UAbility_103352::ChargeDuration' has a wrong offset!");

// Class Hero_1033.Config_103352
// 0x0028 (0x00C0 - 0x0098)
class UConfig_103352 : public UMarvelAbilityConfig
{
public:
	float                                         MinChargeDuration;                                 // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxChargeDuration;                                 // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RTPCName;                                          // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedClampMin;                                     // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedClampMax;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedClampMax;                                  // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103352">();
	}
	static class UConfig_103352* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103352>();
	}
};
static_assert(alignof(UConfig_103352) == 0x000008, "Wrong alignment on UConfig_103352");
static_assert(sizeof(UConfig_103352) == 0x0000C0, "Wrong size on UConfig_103352");
static_assert(offsetof(UConfig_103352, MinChargeDuration) == 0x000098, "Member 'UConfig_103352::MinChargeDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103352, MaxChargeDuration) == 0x00009C, "Member 'UConfig_103352::MaxChargeDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103352, RTPCName) == 0x0000A0, "Member 'UConfig_103352::RTPCName' has a wrong offset!");
static_assert(offsetof(UConfig_103352, SpeedClampMin) == 0x0000B0, "Member 'UConfig_103352::SpeedClampMin' has a wrong offset!");
static_assert(offsetof(UConfig_103352, MinSpeedClampMax) == 0x0000B4, "Member 'UConfig_103352::MinSpeedClampMax' has a wrong offset!");
static_assert(offsetof(UConfig_103352, MaxSpeedClampMax) == 0x0000B8, "Member 'UConfig_103352::MaxSpeedClampMax' has a wrong offset!");

// Class Hero_1033.Projectile_10335202
// 0x0010 (0x2F70 - 0x2F60)
class AProjectile_10335202 : public AMarvelAbilityTargetActor_Projectile
{
public:
	float                                         ChargeDuration;                                    // 0x2F60(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F64[0xC];                                     // 0x2F64(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10335202">();
	}
	static class AProjectile_10335202* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10335202>();
	}
};
static_assert(alignof(AProjectile_10335202) == 0x000010, "Wrong alignment on AProjectile_10335202");
static_assert(sizeof(AProjectile_10335202) == 0x002F70, "Wrong size on AProjectile_10335202");
static_assert(offsetof(AProjectile_10335202, ChargeDuration) == 0x002F60, "Member 'AProjectile_10335202::ChargeDuration' has a wrong offset!");

// Class Hero_1033.BlackWidowWeaponAnimInstance
// 0x0010 (0x0910 - 0x0900)
class UBlackWidowWeaponAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsAiming;                                         // 0x0900(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReloading;                                      // 0x0901(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_902[0x2];                                      // 0x0902(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StoragePercent;                                    // 0x0904(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateShoot;                                  // 0x0908(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateAim;                                    // 0x0909(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateAimLoop;                                // 0x090A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateStorage;                                // 0x090B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x090C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsViewingSelf;                                    // 0x090D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlackWidowElectronicState                    ElectronicState;                                   // 0x090E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlackWidow_103333_WeaponState                State_103333;                                      // 0x090F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetState_103333(EBlackWidow_103333_WeaponState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowWeaponAnimInstance">();
	}
	static class UBlackWidowWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowWeaponAnimInstance>();
	}
};
static_assert(alignof(UBlackWidowWeaponAnimInstance) == 0x000010, "Wrong alignment on UBlackWidowWeaponAnimInstance");
static_assert(sizeof(UBlackWidowWeaponAnimInstance) == 0x000910, "Wrong size on UBlackWidowWeaponAnimInstance");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsAiming) == 0x000900, "Member 'UBlackWidowWeaponAnimInstance::bIsAiming' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsReloading) == 0x000901, "Member 'UBlackWidowWeaponAnimInstance::bIsReloading' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, StoragePercent) == 0x000904, "Member 'UBlackWidowWeaponAnimInstance::StoragePercent' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsUltimateShoot) == 0x000908, "Member 'UBlackWidowWeaponAnimInstance::bIsUltimateShoot' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsUltimateAim) == 0x000909, "Member 'UBlackWidowWeaponAnimInstance::bIsUltimateAim' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsUltimateAimLoop) == 0x00090A, "Member 'UBlackWidowWeaponAnimInstance::bIsUltimateAimLoop' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsUltimateStorage) == 0x00090B, "Member 'UBlackWidowWeaponAnimInstance::bIsUltimateStorage' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsRunning) == 0x00090C, "Member 'UBlackWidowWeaponAnimInstance::bIsRunning' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsViewingSelf) == 0x00090D, "Member 'UBlackWidowWeaponAnimInstance::bIsViewingSelf' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, ElectronicState) == 0x00090E, "Member 'UBlackWidowWeaponAnimInstance::ElectronicState' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, State_103333) == 0x00090F, "Member 'UBlackWidowWeaponAnimInstance::State_103333' has a wrong offset!");

// Class Hero_1033.BlackWidowFPAnimInstance
// 0x0090 (0x0990 - 0x0900)
class UBlackWidowFPAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsScopeAiming;                                    // 0x0900(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAinFiring;                                      // 0x0901(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReloading;                                      // 0x0902(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x0903(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StoragePercent;                                    // 0x0904(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateShoot;                                  // 0x0908(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateAim;                                    // 0x0909(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateAimLoop;                                // 0x090A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateStorage;                                // 0x090B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlackWidowElectronicState                    ElectronicState;                                   // 0x090C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90D[0x3];                                      // 0x090D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               WeaponRotator;                                     // 0x0910(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_928[0x8];                                      // 0x0928(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LeftHandleTransform;                               // 0x0930(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowFPAnimInstance">();
	}
	static class UBlackWidowFPAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowFPAnimInstance>();
	}
};
static_assert(alignof(UBlackWidowFPAnimInstance) == 0x000010, "Wrong alignment on UBlackWidowFPAnimInstance");
static_assert(sizeof(UBlackWidowFPAnimInstance) == 0x000990, "Wrong size on UBlackWidowFPAnimInstance");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsScopeAiming) == 0x000900, "Member 'UBlackWidowFPAnimInstance::bIsScopeAiming' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsAinFiring) == 0x000901, "Member 'UBlackWidowFPAnimInstance::bIsAinFiring' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsReloading) == 0x000902, "Member 'UBlackWidowFPAnimInstance::bIsReloading' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsRunning) == 0x000903, "Member 'UBlackWidowFPAnimInstance::bIsRunning' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, StoragePercent) == 0x000904, "Member 'UBlackWidowFPAnimInstance::StoragePercent' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsUltimateShoot) == 0x000908, "Member 'UBlackWidowFPAnimInstance::bIsUltimateShoot' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsUltimateAim) == 0x000909, "Member 'UBlackWidowFPAnimInstance::bIsUltimateAim' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsUltimateAimLoop) == 0x00090A, "Member 'UBlackWidowFPAnimInstance::bIsUltimateAimLoop' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsUltimateStorage) == 0x00090B, "Member 'UBlackWidowFPAnimInstance::bIsUltimateStorage' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, ElectronicState) == 0x00090C, "Member 'UBlackWidowFPAnimInstance::ElectronicState' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, WeaponRotator) == 0x000910, "Member 'UBlackWidowFPAnimInstance::WeaponRotator' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, LeftHandleTransform) == 0x000930, "Member 'UBlackWidowFPAnimInstance::LeftHandleTransform' has a wrong offset!");

// Class Hero_1033.BlackWidowAnimInstance
// 0x00E0 (0x09E0 - 0x0900)
class UBlackWidowAnimInstance final : public UMarvelAnimInstance
{
public:
	float                                         JumpDirectionInterpSpeed;                          // 0x0900(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_904[0xC];                                      // 0x0904(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  LeftHandAdditiveRotation;                          // 0x0910(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AimingStateTags;                                   // 0x0930(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         AimOffsetDataIndex;                                // 0x0998(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HitAnimIndex;                                      // 0x099C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingEnhancedJump;                                // 0x09A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A1[0x3];                                      // 0x09A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElectronicStrength;                                // 0x09A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpDirection;                                     // 0x09A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintDirection;                                   // 0x09AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintWithRifle;                                  // 0x09B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinalLeftHandIKEnabled;                           // 0x09B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bElectronicState_None;                             // 0x09B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bElectronicState_Storage;                          // 0x09B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bElectronicState_Fire;                             // 0x09B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWeaponModeWithRifle;                              // 0x09B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRunState_SprintToNormal;                          // 0x09B6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRunState_SprintStartConduit;                      // 0x09B7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B8[0x4];                                      // 0x09B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAnimInstance>           AbilityAnimInstance;                               // 0x09BC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C4[0xC];                                      // 0x09C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class ABlackWidowCharacter*                   BlackWidowCharacter;                               // 0x09D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9D8[0x8];                                      // 0x09D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowAnimInstance">();
	}
	static class UBlackWidowAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowAnimInstance>();
	}
};
static_assert(alignof(UBlackWidowAnimInstance) == 0x000010, "Wrong alignment on UBlackWidowAnimInstance");
static_assert(sizeof(UBlackWidowAnimInstance) == 0x0009E0, "Wrong size on UBlackWidowAnimInstance");
static_assert(offsetof(UBlackWidowAnimInstance, JumpDirectionInterpSpeed) == 0x000900, "Member 'UBlackWidowAnimInstance::JumpDirectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, LeftHandAdditiveRotation) == 0x000910, "Member 'UBlackWidowAnimInstance::LeftHandAdditiveRotation' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, AimingStateTags) == 0x000930, "Member 'UBlackWidowAnimInstance::AimingStateTags' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, AimOffsetDataIndex) == 0x000998, "Member 'UBlackWidowAnimInstance::AimOffsetDataIndex' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, HitAnimIndex) == 0x00099C, "Member 'UBlackWidowAnimInstance::HitAnimIndex' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bUsingEnhancedJump) == 0x0009A0, "Member 'UBlackWidowAnimInstance::bUsingEnhancedJump' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, ElectronicStrength) == 0x0009A4, "Member 'UBlackWidowAnimInstance::ElectronicStrength' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, JumpDirection) == 0x0009A8, "Member 'UBlackWidowAnimInstance::JumpDirection' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, SprintDirection) == 0x0009AC, "Member 'UBlackWidowAnimInstance::SprintDirection' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bSprintWithRifle) == 0x0009B0, "Member 'UBlackWidowAnimInstance::bSprintWithRifle' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bFinalLeftHandIKEnabled) == 0x0009B1, "Member 'UBlackWidowAnimInstance::bFinalLeftHandIKEnabled' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bElectronicState_None) == 0x0009B2, "Member 'UBlackWidowAnimInstance::bElectronicState_None' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bElectronicState_Storage) == 0x0009B3, "Member 'UBlackWidowAnimInstance::bElectronicState_Storage' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bElectronicState_Fire) == 0x0009B4, "Member 'UBlackWidowAnimInstance::bElectronicState_Fire' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bWeaponModeWithRifle) == 0x0009B5, "Member 'UBlackWidowAnimInstance::bWeaponModeWithRifle' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bRunState_SprintToNormal) == 0x0009B6, "Member 'UBlackWidowAnimInstance::bRunState_SprintToNormal' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bRunState_SprintStartConduit) == 0x0009B7, "Member 'UBlackWidowAnimInstance::bRunState_SprintStartConduit' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, AbilityAnimInstance) == 0x0009BC, "Member 'UBlackWidowAnimInstance::AbilityAnimInstance' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, BlackWidowCharacter) == 0x0009D0, "Member 'UBlackWidowAnimInstance::BlackWidowCharacter' has a wrong offset!");

// Class Hero_1033.BlackWidowCharacter
// 0x0050 (0x1810 - 0x17C0)
class ABlackWidowCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bIsFiring;                                         // 0x17B8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReloading;                                      // 0x17B9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateAiming;                                 // 0x17BA(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17BB[0x5];                                     // 0x17BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               WeaponRotator;                                     // 0x17C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WeaponRotationRate;                                // 0x17D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponRotationInterpSpeed;                         // 0x17DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponMoveRotationMaxVec;                          // 0x17E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponMoveRotationMinVec;                          // 0x17E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlackWidowElectronicStateChanged;                // 0x17E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBlackWidowMoveLogicBaseComponent*      BlackWidowMoveLogic;                               // 0x17F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElectronicStrength;                                // 0x1800(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBlackWidowElectronicState                    ElectronicState;                                   // 0x1804(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOpenMirrorShootReady;                             // 0x1805(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsScopeAiming;                                    // 0x1806(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAimFiring;                                      // 0x1807(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEnhancedJump;                                  // 0x1808(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBlackWidow_RunState                          RunState;                                          // 0x1809(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180A[0x2];                                     // 0x180A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargeDuration;                                    // 0x180C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsViewingSelfInFirstPerspective();
	void OnRep_ElectronicState(EBlackWidowElectronicState OldState);
	void SetAimFiringState(bool bSetState);
	void SetAimingState(bool bSetState);
	void SetAimReloadingState(bool bSetState);
	void SetBlackWidowRunState(EBlackWidow_RunState InRunState);
	void SetElectronicState(EBlackWidowElectronicState ElecState);
	void SetElectronicStrength(float InStrength);
	void SetFiringingState(bool bSetState);
	void SetOpenMirrorShootReady(bool bSetState);
	void SetUltimateAimingState(bool bSetState);
	void SetUseEnhancedJump(bool bUse);

	EBlackWidowWeaponMode GetCurrentWeaponMode() const;
	EBlackWidowElectronicState GetElectronicState() const;
	float GetElectronicStrength() const;
	bool GetOpenMirrorShootReady() const;
	bool IsSwitchingToSniperRifle() const;
	bool IsSwitchingToStick() const;
	bool IsUsingSniperRifle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowCharacter">();
	}
	static class ABlackWidowCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlackWidowCharacter>();
	}
};
static_assert(alignof(ABlackWidowCharacter) == 0x000010, "Wrong alignment on ABlackWidowCharacter");
static_assert(sizeof(ABlackWidowCharacter) == 0x001810, "Wrong size on ABlackWidowCharacter");
static_assert(offsetof(ABlackWidowCharacter, bIsFiring) == 0x0017B8, "Member 'ABlackWidowCharacter::bIsFiring' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bIsReloading) == 0x0017B9, "Member 'ABlackWidowCharacter::bIsReloading' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bIsUltimateAiming) == 0x0017BA, "Member 'ABlackWidowCharacter::bIsUltimateAiming' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, WeaponRotator) == 0x0017C0, "Member 'ABlackWidowCharacter::WeaponRotator' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, WeaponRotationRate) == 0x0017D8, "Member 'ABlackWidowCharacter::WeaponRotationRate' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, WeaponRotationInterpSpeed) == 0x0017DC, "Member 'ABlackWidowCharacter::WeaponRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, WeaponMoveRotationMaxVec) == 0x0017E0, "Member 'ABlackWidowCharacter::WeaponMoveRotationMaxVec' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, WeaponMoveRotationMinVec) == 0x0017E4, "Member 'ABlackWidowCharacter::WeaponMoveRotationMinVec' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, OnBlackWidowElectronicStateChanged) == 0x0017E8, "Member 'ABlackWidowCharacter::OnBlackWidowElectronicStateChanged' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, BlackWidowMoveLogic) == 0x0017F8, "Member 'ABlackWidowCharacter::BlackWidowMoveLogic' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, ElectronicStrength) == 0x001800, "Member 'ABlackWidowCharacter::ElectronicStrength' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, ElectronicState) == 0x001804, "Member 'ABlackWidowCharacter::ElectronicState' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bOpenMirrorShootReady) == 0x001805, "Member 'ABlackWidowCharacter::bOpenMirrorShootReady' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bIsScopeAiming) == 0x001806, "Member 'ABlackWidowCharacter::bIsScopeAiming' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bIsAimFiring) == 0x001807, "Member 'ABlackWidowCharacter::bIsAimFiring' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bUseEnhancedJump) == 0x001808, "Member 'ABlackWidowCharacter::bUseEnhancedJump' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, RunState) == 0x001809, "Member 'ABlackWidowCharacter::RunState' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, ChargeDuration) == 0x00180C, "Member 'ABlackWidowCharacter::ChargeDuration' has a wrong offset!");

// Class Hero_1033.ShootingLogic_103321
// 0x0000 (0x0D68 - 0x0D68)
class UShootingLogic_103321 final : public UShootingLogic_Instant
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShootingLogic_103321">();
	}
	static class UShootingLogic_103321* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShootingLogic_103321>();
	}
};
static_assert(alignof(UShootingLogic_103321) == 0x000008, "Wrong alignment on UShootingLogic_103321");
static_assert(sizeof(UShootingLogic_103321) == 0x000D68, "Wrong size on UShootingLogic_103321");

// Class Hero_1033.CueWeaponLoop_103301
// 0x0000 (0x1058 - 0x1058)
class ACueWeaponLoop_103301 final : public AMarvelCueNotify_Weapon_Loop
{
public:
	class USkeletalMeshComponent* GetWeaponMesh1P();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueWeaponLoop_103301">();
	}
	static class ACueWeaponLoop_103301* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueWeaponLoop_103301>();
	}
};
static_assert(alignof(ACueWeaponLoop_103301) == 0x000008, "Wrong alignment on ACueWeaponLoop_103301");
static_assert(sizeof(ACueWeaponLoop_103301) == 0x001058, "Wrong size on ACueWeaponLoop_103301");

// Class Hero_1033.BlackWidowMoveLogicBaseComponent
// 0x0010 (0x0400 - 0x03F0)
class UBlackWidowMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	struct FGameplayTag                           FallingTag;                                        // 0x03F0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowMoveLogicBaseComponent">();
	}
	static class UBlackWidowMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UBlackWidowMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UBlackWidowMoveLogicBaseComponent");
static_assert(sizeof(UBlackWidowMoveLogicBaseComponent) == 0x000400, "Wrong size on UBlackWidowMoveLogicBaseComponent");
static_assert(offsetof(UBlackWidowMoveLogicBaseComponent, FallingTag) == 0x0003F0, "Member 'UBlackWidowMoveLogicBaseComponent::FallingTag' has a wrong offset!");

// Class Hero_1033.BlackWidowMovementComponent
// 0x0010 (0x1B00 - 0x1AF0)
class UBlackWidowMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	float                                         CustomGravityScale;                                // 0x1AF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomGravity;                                 // 0x1AF4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF5[0xB];                                     // 0x1AF5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowMovementComponent">();
	}
	static class UBlackWidowMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowMovementComponent>();
	}
};
static_assert(alignof(UBlackWidowMovementComponent) == 0x000010, "Wrong alignment on UBlackWidowMovementComponent");
static_assert(sizeof(UBlackWidowMovementComponent) == 0x001B00, "Wrong size on UBlackWidowMovementComponent");
static_assert(offsetof(UBlackWidowMovementComponent, CustomGravityScale) == 0x001AF0, "Member 'UBlackWidowMovementComponent::CustomGravityScale' has a wrong offset!");
static_assert(offsetof(UBlackWidowMovementComponent, bUseCustomGravity) == 0x001AF4, "Member 'UBlackWidowMovementComponent::bUseCustomGravity' has a wrong offset!");

// Class Hero_1033.BlackWidowSniperGun
// 0x0020 (0x0C90 - 0x0C70)
class ABlackWidowSniperGun : public AShootingWeapon
{
public:
	uint8                                         Pad_C70[0x8];                                      // 0x0C70(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   CachedBindedRebornCharacter;                       // 0x0C78(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBulletLoadedInfo_1033                 BulletLoadedInfo;                                  // 0x0C80(0x0010)(BlueprintVisible, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnOwnerCharacterRespawned(class AActor* TargetActor, const struct FCharacterRebornParam& RebornParam);
	void OnRep_BulletLoaded();
	void SetBulletLoaded(bool bLoaded);

	float GetPullBulletDuration() const;
	bool IsBulletLoaded() const;
	bool ShouldPassPullBulletSafeCheck(float Tolerance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowSniperGun">();
	}
	static class ABlackWidowSniperGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlackWidowSniperGun>();
	}
};
static_assert(alignof(ABlackWidowSniperGun) == 0x000008, "Wrong alignment on ABlackWidowSniperGun");
static_assert(sizeof(ABlackWidowSniperGun) == 0x000C90, "Wrong size on ABlackWidowSniperGun");
static_assert(offsetof(ABlackWidowSniperGun, CachedBindedRebornCharacter) == 0x000C78, "Member 'ABlackWidowSniperGun::CachedBindedRebornCharacter' has a wrong offset!");
static_assert(offsetof(ABlackWidowSniperGun, BulletLoadedInfo) == 0x000C80, "Member 'ABlackWidowSniperGun::BulletLoadedInfo' has a wrong offset!");

// Class Hero_1033.BlackWidowStickMeshComponent
// 0x0010 (0x16B0 - 0x16A0)
class UBlackWidowStickMeshComponent final : public USkeletalMeshComponent
{
public:
	bool                                          bHiddenWhile_103333;                               // 0x16A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16A1[0xF];                                     // 0x16A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHiddenWhile_103333(bool bInHiddenWhile_103333);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowStickMeshComponent">();
	}
	static class UBlackWidowStickMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowStickMeshComponent>();
	}
};
static_assert(alignof(UBlackWidowStickMeshComponent) == 0x000010, "Wrong alignment on UBlackWidowStickMeshComponent");
static_assert(sizeof(UBlackWidowStickMeshComponent) == 0x0016B0, "Wrong size on UBlackWidowStickMeshComponent");
static_assert(offsetof(UBlackWidowStickMeshComponent, bHiddenWhile_103333) == 0x0016A0, "Member 'UBlackWidowStickMeshComponent::bHiddenWhile_103333' has a wrong offset!");

// Class Hero_1033.EpicMomentAction_1033
// 0x0018 (0x0138 - 0x0120)
class UEpicMomentAction_1033 final : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnProjectileBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Projectile, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnSummonerBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Summoned, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnSummonerEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1033">();
	}
	static class UEpicMomentAction_1033* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1033>();
	}
};
static_assert(alignof(UEpicMomentAction_1033) == 0x000008, "Wrong alignment on UEpicMomentAction_1033");
static_assert(sizeof(UEpicMomentAction_1033) == 0x000138, "Wrong size on UEpicMomentAction_1033");

}

